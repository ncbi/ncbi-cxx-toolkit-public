-- C++ libs ------ Properties--property pUsingCPlusPlus : trueproperty pProjectFileExtension : ".mcp"property pCPlusPlusExtension : ".cpp"-- Whether to recreate existing project files.property pAlwaysCreateProjects : false-- Which targets to create.-- If these are changed you must recreate the project files.  There is no direct effect on building.property pCreateBlueTargets : true -- 'Blue' was codename for System 7, here it means pre-Carbon.property pCreateCarbonTargets : trueproperty pCreateDebugTargets : trueproperty pCreateProfiledTargets : falseproperty pCreateOptimizedTargets : true-- Whether to create projects in the specified category.property pCreateObjectLibs : true (* whether to create/compile object libraries *)property pCreateSocketLibs : true (* whether to create/compile socket libs *)-- Whether to compile everything.property pShouldBuild : trueproperty pDirsToCreate : {{relPath:"compilers:mac_prj", name:"lib"}}property pDebugPrefix : "debug.pfx"property pReleasePrefix : "release.pfx"property pLinkExecutables : false---- Global variables--global NCBICPPglobal SOURCEFILESglobal INCLUDEFILESglobal LIBRARIESglobal BINARIESglobal gCDistribPresentglobal gCDistribRoot---- Routines specific to this project--on SimpleProjectData(projName, features, section, fileList)		if (count characters of projName) > 18 then		set projName to characters 1 through 18 of projName as string	end if		tell application "CodeWarrior IDE"				if features does not contain "C" and features does not contain "C++" then			error "Project " & projName & "'s default language (a feature) must be C or C++."		end if		set myFeatures to features		--copy "BNDL" to end of myFeatures		set myPath to section & ":"		return {name:projName, features:myFeatures, rsrcs:{}, settings:Â			{Prefix File:"", ppcProject:{}}, projLibs:{}, sysPaths:{}, fileData:Â			{{projPath:myPath, fileList:fileList}}}			end tellend SimpleProjectDataon AddSimpleProject(projName, features, section, fileList)		AddProject(SimpleProjectData(projName, features, section, fileList))	end AddSimpleProjecton ObjectData(objName)		set projName to "object_" & objName	set projPath to "objects:" & objName	set projFiles to {objName & "__", objName & "___"}		return SimpleProjectData(projName, {"C++"}, projPath, projFiles)	end ObjectDataon AddObject(projName)		AddProject(ObjectData(projName))	end AddObjecton DataPlusSysPaths(dataRec, newSysPaths)		repeat with i in newSysPaths		copy i to end of sysPaths of dataRec	end repeat	return dataRec	end DataPlusSysPathson SetProjectData()		if pCreateSocketLibs then		AddSimpleProject("mitsock", {"C"}, "connect:mitsock", Â			{"OTSocketInternal", "OTErrno", "OTSockets", "OTidle", "OTNetdbServices", "OTnetdb"})				set myFiles to {"email_diag_handler.cpp", "ncbi_ansi_ext.c", "ncbi_buffer.c", "ncbi_conn_stream.cpp", Â			"ncbi_conn_streambuf.cpp", "ncbi_connection.c", "ncbi_connector.c", "ncbi_connutil.c", Â			"ncbi_core.c", "ncbi_core_cxx.cpp", "ncbi_file_connector.c", "ncbi_heapmgr.c", "ncbi_host_info.c", Â			"ncbi_http_connector.c", "ncbi_memory_connector.c", "ncbi_priv.c", "ncbi_sendmail.c", Â			"ncbi_server_info.c", "ncbi_service.c", "ncbi_service_connector.c", "ncbi_dispd.c", Â			"ncbi_lbsmd_stub.c", "ncbi_socket.c", "ncbi_socket_connector.c", "ncbi_util.c", "threaded_server.cpp"}				AddProject(SimpleProjectData("connect", {"C++"}, "connect", myFiles))		AddSimpleProject("conntest", {"C"}, "connect:test", {"ncbi_conntest"})			end if		AddSimpleProject("corelib", {"C++"}, "corelib", Â		{"ddumpable", "ncbiapp", "ncbiargs", "ncbicntr_workshop", "ncbidiag", "ncbidbg", "ncbienv", "ncbiexpt", "ncbifile", "ncbiobj", "ncbireg", Â			"ncbistd", "ncbistre", "ncbithr", "ncbitime", "ncbimtx", "ncbi_safe_static", "ncbi_system", Â			"ncbi_os_mac", "version"})		AddSimpleProject("cgi", {"C++"}, "cgi", {"cgi_run", "cgictx", "ncbicgir", "cgiapp", "ncbicgi", "ncbires"})		AddSimpleProject("dbapi", {"C++"}, "dbapi", Â		{"active_obj", "rsmeta_impl", "conn_impl", "array", "driver_mgr", "stmt_impl", "cstmt_impl", Â			"ds_impl", "variant", "blobstream", "cursor_impl", "rs_impl", "bytestreambuf", "dbapi"})		--AddSimpleProject("dbapi_driver", {"C++"}, "dbapi:driver", Â	--	{"driver_mgr", "interfaces", "numeric_convert", "public", "exception", "memory_store", "parameters", Â	--		"types", "handle_stack", "pointer_pot"})		AddSimpleProject("util", {"C++"}, "util", Â		{"bytesrc", "strbuffer", "checksum", "ddump_viewer", "itree", "stream_utils", "thread_pool", "utf8", "random_gen", "smalldns", "strsearch"})		AddSimpleProject("pbacktest", {"C++"}, "util:test", {"pbacktest"})			AddSimpleProject("serial", {"C++"}, "serial", Â		{"asntypes", "autoptrinfo", "choice", "choiceptr", "classinfo", "classinfob", "continfo", "delaybuf", "enumerated", "exception", Â			"hookdata", "item", "iterator", "member", "memberid", "memberlist", "objcopy", "object", "objectinfo", "objectio", "objectiter", Â			"objhook", "objistr", "objistrasn", "objistrasnb", "objistrxml", "objlist", "objostr", "objostrasn", "objostrasnb", "objostrxml", Â			"objstack", "objstrb", "ptrinfo", "rtti", "serial", "serialasn", "serializable", "serialobject", "stdtypes", "stltypes", Â			"typeinfo", "typemap", "typeref", "variant"})		AddSimpleProject("html", {"C++"}, "html", Â		{"commentdiag", "html", "jsmenu", "nodemap", "pager", "components", "htmlhelper", "node", "page", "selection"})		if pCreateObjectLibs then				AddSimpleProject("object_asn2asn", {"C++"}, "objects:asn2asn", {"asn2asn"})				AddObject("access")		AddObject("biblio")		AddObject("cdd")		AddObject("cn3d")		AddObject("docsum")		AddObject("entrez2")		AddObject("entrezgene")		AddObject("featdef")		AddObject("gbseq")		AddObject("general")		AddObject("id1")		AddObject("medlars")		AddObject("medline")		AddObject("mim")		AddObject("mla")				AddObject("mmdb1")		AddObject("mmdb2")		AddObject("mmdb3")		AddObject("ncbimime")		AddObject("objprt")		AddObject("proj")		AddObject("pub")		AddObject("pubmed")		AddSimpleProject("object_seq", {"C++"}, "objects:seq", {"seq__", "seq___", "gencode", "seqport_util"})		AddObject("seqalign")		AddObject("seqblock")		AddObject("seqcode")		AddObject("seqfeat")		AddObject("seqloc")		AddObject("seqres")		AddObject("seqset")		AddObject("submit")		AddSimpleProject("taxon1", {"C++"}, "objects:taxon1", {"taxon1__", "taxon1___", "taxon1", "cache", "utils", "ctreecont"})		AddObject("tinyseq")				AddSimpleProject("object_objmgr", {"C++"}, "objects:objmgr", Â			{"align_ci", "data_source", "handle_range_map", "seq_id_mapper", "annot_ci", "desc_ci", "object_manager", "seq_map", Â				"annot_object", "feat_ci", "reader", "seq_vector", "annot_types_ci", "gbload_util", "reader_id1", "seqdesc_ci", Â				"bioseq_handle", "gbloader", "reader_pubseq", "seqmatch_info", "bioseq_info", "graph_ci", "scope", "strstreambuf", Â				"data_loader", "handle_range", "seq_id_handle", "tse_info", "seq_map_ci", "seq_map_ext"})						AddSimpleProject("xobjutil", {"C++"}, "objects:util", {"feature", "seqtitle", "gbqual", "sequence", "genbank", "weight"})		AddSimpleProject("validatr", {"C++"}, "objects:validator", Â			{"utilities", "validator", "validatorp", "validerror_align", "validerror_annot", "validerror_bioseq", Â				"validerror_bioseqset", "validerror_desc", "validerror_descr", "validerror_feat", "validerror_graph"})			end if		--AddSimpleProject("xctools", {"C++"}, "ctools", {"asn_connection.c", "ctools"})	--AddSimpleProject("xans", {"C++"}, "ctools:asn", {"asnio", "asnwrite"})		-- old script code below	--if gCDistribPresent then	--	set myFiles to {"ctools.cpp", "asn_connection"}	--	AddProject(DataPlusSysPaths(SimpleProjectData("xctools", {"C"}, "ctools", myFiles), Â	--		{CToolkitRoot() & "include:", CToolkitRoot() & "ctools:", Â	--			CToolkitRoot() & "corelib:", CToolkitRoot() & "asnlib:"}))	--end if		--set myFiles to {"asnio", "asnwrite"}	--AddProject(DataPlusSysPaths(SimpleProjectData("xasn", {"C++"}, "ctools:asn", myFiles), Â	--	{CToolkitRoot() & "include:", CToolkitRoot() & "ctools:", Â	--		CToolkitRoot() & "corelib:", CToolkitRoot() & "asnlib:"})	end SetProjectDataon CopyHeaders()	tell application "Finder"				set confFolder to folder "compilers" of folder (my ModuleRoot())		set prefixFolder to folder "mac_prj" of confFolder				my UpdateRenameHeader("ncbiconf.mac", confFolder, "ncbiconf.h", "")				my UpdateHeader("debug.pfx", prefixFolder)		my UpdateHeader("release.pfx", prefixFolder)		my UpdateHeader("Carbon-debug.pfx", prefixFolder)		my UpdateHeader("Carbon-release.pfx", prefixFolder)			end tellend CopyHeaders---- Global variables--global gStartupDiskglobal gHomeDirglobal gDevDirglobal gMWrootglobal gMWCWfolderglobal gMacLibsglobal gStubLibsglobal gPPCLibsglobal gMSLPPCLibsglobal modRootglobal gDistribRootglobal gAccessRootglobal gProjectsDirglobal gSourceDirglobal gIncludeDirglobal gLibsDirglobal gRsrcsDirglobal gOutputDirglobal gSourcePathglobal gIncludePathglobal gLibsPathglobal gRsrcsPathglobal gProjectDataon AddProject(projData)		copy projData to end of gProjectData	end AddProjecton ResolveAlias(pathname)	tell application "Finder"		--if the last character of pathname is ":" then error "Don't use a trailing colon with ResolveAlias."		if exists folder pathname then return pathname & ":"		if exists alias file pathname then return the original item of alias file pathname as string		error "The folder (or alias) '" & pathname & "' doesn't exist."	end tellend ResolveAliason IsOSX()	tell application "Finder"				set vers to the version as text				if second character of vers is equal to "." then			set vers to "0" & vers		end if				return vers > 10 or vers = 10			end tellend IsOSXon HomeDir()	tell application "Finder"				if my IsOSX() then			-- return the home as string			set hm to home as string			set wd to words of hm			set rs to rest of wd			set text item delimiters of AppleScript to ":"			set nw to (rs as string) & ":"			set text item delimiters of AppleScript to ""			return nw		else			return gStartupDisk		end if			end tellend HomeDiron CToolkitRoot()		try		set modRoot to ResolveAlias(gMWroot & "ncbi")	on error		try			set modRoot to ResolveAlias(gStartupDisk & gHomeDir & "ncbi")		end try	end try		return modRoot	end CToolkitRooton CPlusPlusToolkitRoot()		try		set modRoot to ResolveAlias(gMWroot & "cxx")	on error		try			set modRoot to ResolveAlias(gStartupDisk & gHomeDir & "cxx")		end try	end try		return modRoot	end CPlusPlusToolkitRooton ModuleRoot()		if pUsingCPlusPlus then		return CPlusPlusToolkitRoot()	else		return CToolkitRoot()	end if	end ModuleRooton AccessRoot()	if my IsOSX() then		set wd to words of gDistribRoot		set rs to rest of wd		set text item delimiters of AppleScript to ":"		set nw to (rs as string) & ":"		set text item delimiters of AppleScript to ""		return nw	else		return gDistribRoot	end ifend AccessRooton MWRootDir()		set mwRoot to ""	set mwLocations to {gStartupDisk, gStartupDisk & "Applications:", gStartupDisk & "Applications (Mac OS 9):", Â		gStartupDisk & gHomeDir, gStartupDisk & gHomeDir & "Applications:", gStartupDisk & gHomeDir & "Applications (Mac OS 9):"}	repeat with mwVersion from 8 to 9		set dirName to "Metrowerks CodeWarrior " & mwVersion & ".0"		repeat with mwLoc in mwLocations			try				set mwRoot to ResolveAlias(mwLoc & dirName)				return mwRoot			end try		end repeat	end repeat		error "Can't find the Metrowerks CodeWarrior folder."	end MWRootDiron SetGlobals()	tell application "Finder"				set gProjectData to {}				set gStartupDisk to startup disk as string		set gHomeDir to my HomeDir()		set gMWroot to my MWRootDir()		set gMWCWfolder to gMWroot & "Metrowerks CodeWarrior:"		set gMacLibs to gMWCWfolder & "MacOS Support:Universal:Libraries:"		set gStubLibs to gMacLibs & "StubLibraries:"		set gPPCLibs to gMacLibs & "PPCLibraries:"		set gMSLPPCLibs to gMWCWfolder & "MSL:MSL_C:MSL_MacOS:Lib:PPC:"				set gDistribRoot to my ModuleRoot()		set gAccessRoot to my AccessRoot()				set gIncludeDir to gDistribRoot & "include:"		set gIncludePath to gAccessRoot & "include:"		if pUsingCPlusPlus then			set gSourceDir to gDistribRoot & "src:"			set gLibsDir to gDistribRoot & "compilers:mac_prj:lib:"			set gOutputDir to gDistribRoot & "compilers:mac_prj:bin:"			set gProjectsDir to gOutputDir			set gRsrcsDir to gDistribRoot & "compilers:mac_prj:"			set gSourcePath to gAccessRoot & "src:"			set gLibsPath to gAccessRoot & "compilers:mac_prj:lib:"			set gOutputPath to gAccessRoot & "compilers:mac_prj:bin:"			set gProjectsPath to gOutputDir			set gRsrcsPath to gAccessRoot & "compilers:mac_prj:"		else			set gSourceDir to gDistribRoot			set gLibsDir to gDistribRoot & "lib:"			set gOutputDir to gDistribRoot & "build:"			set gRsrcsDir to gDistribRoot & "link:macmet:"			set gSourcePath to gAccessRoot			set gLibsPath to gAccessRoot & "lib:"			set gOutputPath to gAccessRoot & "build:"			set gRsrcsPath to gAccessRoot & "link:macmet:"		end if				set gCDistribRoot to my CToolkitRoot()		set gCDistribPresent to (gCDistribRoot is not "")				if pLinkExecutables then			set gProjectsDir to gOutputDir		else			set gProjectsDir to gLibsDir		end if			end tellend SetGlobalson HeaderExists(header, headerDir)	tell application "Finder"				if headerDir is "" then set headerDir to folder gIncludeDir		return exists file header of headerDir			end tellend HeaderExistson IsOlderThan(fileA, fileB)	tell application "Finder"				return (the modification date of fileA < the modification date of fileB)			end tellend IsOlderThanon UpdateRenameHeader(canonicalName, canonicalDir, dotHName, dotHDir)	tell application "Finder"				set needRename to (dotHName is not "")		if not needRename then set dotHName to canonicalName		if dotHDir is "" then set dotHDir to folder gIncludeDir				-- This file is only present if the script was interrupted.		if needRename and my HeaderExists(canonicalName, dotHDir) then			delete file canonicalName of dotHDir		end if				-- The native config file.		-- If it's missing, assume this is a prepared distribution and the header is already up-to-date.		if not my HeaderExists(canonicalName, canonicalDir) then return		set canonicalFile to file canonicalName of canonicalDir				set needCopy to true		if my HeaderExists(dotHName, dotHDir) then			set dotHFile to file dotHName of dotHDir			if my IsOlderThan(dotHFile, canonicalFile) then				delete dotHFile			else				set needCopy to false			end if		end if				if needCopy then			duplicate canonicalFile to dotHDir			if needRename then set name of file canonicalName of dotHDir to dotHName		end if			end tellend UpdateRenameHeaderon UpdateHeader(headerName, headerDir)		UpdateRenameHeader(headerName, headerDir, "", "")	end UpdateHeaderon SetDebugSettings(shouldDebug, shouldProfile)	tell application "CodeWarrior IDE"				if shouldDebug then			(* ===== Panel PPC Global Optimizer =====  *)			Set Preferences of panel "PPC Global Optimizer" to Â				{Optimize For:code_Speed, Level:0}			(* ===== Panel PPC Linker ===== *)			Set Preferences of panel "PPC Linker" to Â				{Generate SYM File:true Â					, Suppress Warnings:false}			(* ===== Panel C/C++ Language =====  *)			Set Preferences of panel "C/C++ Compiler" to Â				{Inlining:inline_none Â					, AutoInlining:false}		else			(* ==== optimized/release settings ==== *)			(* ===== Panel PPC Global Optimizer =====  *)			Set Preferences of panel "PPC Global Optimizer" to Â				{Optimize For:code_Speed, Level:4}			(* ===== Panel PPC Linker ===== *)			Set Preferences of panel "PPC Linker" to Â				{Generate SYM File:false Â					, Suppress Warnings:true}			(* ===== Panel C/C++ Language =====  *)			Set Preferences of panel "C/C++ Compiler" to Â				{Inlining:inline_smart Â					, AutoInlining:true}		end if				if shouldProfile then			(* ===== Panel PPC Processor ===== *)			Set Preferences of panel "PPC CodeGen" to Â				{Use Profiler:true}		else			(* ===== Panel PPC Processor ===== *)			Set Preferences of panel "PPC CodeGen" to Â				{Use Profiler:false}		end if			end tellend SetDebugSettingson SetPreferences()	tell application "CodeWarrior IDE"				(* ===== Section "Target" ===== *)				-- Panel "Target Settings"		Set Preferences of panel "Target Settings" to {Linker:"MacOS PPC Linker"}				-- Panel "PPC Target"		if pLinkExecutables then			Set Preferences of panel "PPC Project" to Â				{Project Type:standard application, SIZE Flags:22720, File Creator:"NCBI", File Type:"APPL", Preferred Heap Size:9000, Min Heap Size:5000, Stack Size:64}		else			Set Preferences of panel "PPC Project" to {Project Type:library}		end if		(* ===== Section "Language Settings" ===== *)				-- Panel "C/C++ Language"		Set Preferences of panel "C/C++ Compiler" to Â			{Activate CPlusPlus:false Â				, ARM Conformance:false Â				, Exception Handling:true Â				, RTTI:true Â				, Pool Strings:true Â				, Dont Reuse Strings:false Â				, Require Function Prototypes:true Â				, ANSI Strict:false Â				, ANSI Keywords Only:false Â				, Expand Trigraph Sequences:false Â				, MPW Newlines:false Â				, MPW Pointer Type Rules:false Â				, Enums Always Ints:false}				-- Panel "C/C++ Warnings"		Set Preferences of panel "C/C++ Warnings" to Â			{Treat Warnings As Errors:false Â				, Illegal Pragmas:true Â				, Empty Declarations:true Â				, Possible Errors:true Â				, Unused Variables:true Â				, Unused Arguments:false Â				, Extra Commas:true Â				, Extended Error Checking:true Â				, Hidden Virtual Functions:true Â				, Implicit Arithmetic Conversions:false Â				, NonInlined Functions:false Â				, Inconsistent Class Struct:true}				(* ===== Section "Code Generation" ===== *)				-- Panel "PPC Processor"		Set Preferences of panel "PPC CodeGen" to Â			{Struct Alignment:Align_PPC Â				, Make Strings ReadOnly:true Â				, Store Data in TOC:true Â				, Use FMADD Instructions:false Â				, Use Profiler:false Â				, Traceback Tables:TB_Inline Â				, Schedule:false Â				, Peephole Optimizer:true}				(* ===== Section "Linker" ===== *)				-- Panel "PPC Linker"		Set Preferences of panel "PPC Linker" to Â			{Generate SYM File:true Â				, Full Path In SYM:true Â				, Generate Link Map:false Â				, Link Mode:fast Â				, Initialization Name:Â				"", Main Name:Â				"__start", Termination Name:""} Â						-- Panel "PPC PEF"		Set Preferences of panel "PPC PEF" to Â			{Export Symbols:none Â				, Old Definition:0 Â				, Old Implementation:0 Â				, Current Version:0 Â				, Code Sorting:nosort Â				, Share Data Section:false Â				, Expand Uninitialized Data:false Â				, Fragment Name:""}				(* ===== Section "Debugger" ===== *)				-- Panel "Debugger Settings"		Set Preferences of panel "Debugger Target" to Â			{Log System Messages:false}				my SetPaths1()			end tellend SetPreferenceson SetPaths1()	tell application "CodeWarrior IDE"				(* ===== Panel Access Paths ===== *)		-- We need to be able to move the default system compiler folder to the end of the list		-- because certain files like "all.h" and "all" are defined by both Metrowerks and NCBI.		-- We want to find the NCBI "all.h" first.		Set Preferences of panel "Access Paths" to {System Paths:{}} -- This removes the compiler default folder				Set Preferences of panel "Access Paths" to {Always Full Search:true, Convert Paths:true}			end tellend SetPaths1on SetPaths2()	tell application "CodeWarrior IDE"				-- Add recursive include dir AFTER source dirs to avoid major performance hit		set pathsToAdd to {}		-- gDistribRoot & "link:macmet:", 		repeat with i in {gAccessRoot, gLibsPath, gIncludePath}			copy {name:i, recursive:false, origin:absolute} to end of pathsToAdd		end repeat		if not pUsingCPlusPlus then			copy {name:gAccessRoot & "link:macmet:", recursive:true, origin:absolute} to end of pathsToAdd		end if		Set Preferences of panel "Access Paths" to {User Paths:pathsToAdd}				set pathsToAdd to {{name:gIncludePath, recursive:true, origin:absolute}}		if not pUsingCPlusPlus then			copy {name:gAccessRoot, recursive:true, origin:absolute} to end of pathsToAdd		end if				-- After we have added all paths, reinsert compiler default at end of list		set dirsToAdd to {Â			":MacOS Support:", Â			":MSL:"}				repeat with i in dirsToAdd			copy {name:i, recursive:true, origin:shell relative} to end of pathsToAdd		end repeat		Set Preferences of panel "Access Paths" to {System Paths:pathsToAdd}			end tellend SetPaths2on AddFeatures(features, flags)	tell application "CodeWarrior IDE"				if features contains "BNDL" then			Set Preferences of panel "Output Flags" to {Has Bundle:true}		end if				if features contains "sockets" and flags does not contain "Carbon" then			set libsToAdd to {Â				gStubLibs & "ThreadsLib", Â				gStubLibs & "OpenTransportLib", Â				gStubLibs & "OpenTptInternetLib", Â				gStubLibs & "InternetConfigLib", Â				gPPCLibs & "OpenTptInetPPC.o", Â				gPPCLibs & "OpenTransportAppPPC.o"}						Add Files libsToAdd					end if			end tellend AddFeatureson SetupTarget(proj, flags)	tell application "CodeWarrior IDE"				-- initialize variables		set projRsrcs to {}		set projFeatures to {}		set sysPaths to {}				-- Grab the fields of our project record and store them in local variables.		set projName to proj's name		set projSettings to proj's settings		try			set projFeatures to proj's features		end try		try			set sysPaths to proj's sysPaths		end try		try			set projRsrcs to proj's rsrcs		end try		set projLibs to proj's projLibs		set projFileData to proj's fileData				-- Figure out what our output file and input libraries will be named.		if flags contains "Carbon" then			set targetAPI to "C2"		else			set targetAPI to "Mac"		end if		if flags contains "debug" then			set targetDebug to "dbg"		else			if flags contains "profile" then				set targetDebug to "prf"			else				set targetDebug to ""			end if		end if		set targetName to projName & " " & targetAPI		set libNameSuffix to "-" & targetAPI		if targetDebug is not "" then			set targetName to targetName & " " & targetDebug			set libNameSuffix to libNameSuffix & "-" & targetDebug		end if		if pLinkExecutables then			set targetFilename to targetName		else			set targetFilename to projName & libNameSuffix & ".lib"		end if				-- Make the new target, and set the current target to be it.		make new target at project document 1 with properties {name:targetName}		set the current target of project document 1 to the result				-- Set default settings.  do this BEFORE setting per-project settings!		my SetPreferences()				-- Set the name of the output file (the application)		Set Preferences of panel "PPC Project" to {File Name:targetFilename}				-- If we have any per-project override settings, set them.		if (count ppcProject of projSettings) > 0 then			Set Preferences of panel "PPC Project" to ppcProject of projSettings		end if		--Set Preferences of panel "Access Paths" to {User Paths:{{name:NCBISOURCE & projPath, origin:absolute}}}		my SetPaths2()				-- Add per-project system paths.		set pathsToAdd to {}		repeat with i in sysPaths			copy {name:i, recursive:true, origin:absolute} to end of pathsToAdd		end repeat		if (count pathsToAdd) > 0 then Â			Set Preferences of panel "Access Paths" to {System Paths:pathsToAdd}				-- Now add C toolkit for headers, not for sources.		if pUsingCPlusPlus then			if gCDistribPresent then				copy {name:gCDistribRoot, recursive:true, origin:absolute} to end of pathsToAdd			end if		end if				-- Set the appropriate prefix file.		set prefixFile to Prefix File of projSettings		if prefixFile is "" then			if flags contains "debug" then				set prefixFile to pDebugPrefix			else				set prefixFile to pReleasePrefix			end if		end if		if flags contains "Carbon" then			if prefixFile is "" then				set prefixFile to "CarbonPrefix.h"			else				set prefixFile to "Carbon-" & prefixFile			end if		end if		Set Preferences of panel "C/C++ Compiler" to {Prefix File:prefixFile}				-- Are we assuming a .c or a .cpp extension?		if projFeatures contains "C++" then			set fileExtension to pCPlusPlusExtension		else			set fileExtension to ".c"		end if				-- Add source files.		repeat with group in projFileData			set projPath to projPath of group			Set Preferences of panel "Access Paths" to Â				{User Paths:{{name:gSourcePath & projPath, origin:absolute}}}			set fileList to group's fileList			set filesToAdd to {}			repeat with i in fileList				if i does not contain "." then set i to i & fileExtension				copy gSourceDir & projPath & i to end of filesToAdd			end repeat			Add Files filesToAdd		end repeat				if flags contains "debug" or flags contains "profile" then			set the debug of every target file of target (count targets of project document 1) Â				of project document 1 to true			if flags contains "profile" then				my SetDebugSettings(true, true)			else				my SetDebugSettings(true, false)			end if		else			my SetDebugSettings(false, false)		end if				-- Add appropriate system libraries.		if pLinkExecutables then			if flags contains "Carbon" then				if flags contains "profile" then					my AddCarbonLibs(true)				else					my AddCarbonLibs(false)				end if			else				if flags contains "profile" then					my AddBlueLibs(true)				else					my AddBlueLibs(false)				end if			end if		end if		my AddFeatures(projFeatures, flags)				set filesToAdd to {}				-- Add user libraries.		if projFeatures contains "sockets" then			if projLibs does not contain "mitsock" then				copy "mitsock" to beginning of projLibs			end if		end if		repeat with i in projLibs			copy gLibsDir & i & libNameSuffix & ".lib" to end of filesToAdd		end repeat				-- Add resources.		repeat with i in projRsrcs			copy gRsrcsDir & i to end of filesToAdd		end repeat				Add Files filesToAdd				Reset File Paths			end tellend SetupTargeton CreateFolders()	tell application "Finder"				repeat with i in pDirsToCreate			set pth to relPath of i			if pth is not "" then set pth to pth & ":"			if not (exists folder (gDistribRoot & pth & i's name)) then				make new folder at folder (gDistribRoot & pth) with properties {name:i's name}			end if		end repeat			end tellend CreateFolderson CreateProject(proj)	tell application "CodeWarrior IDE"				-- This statement doesn't work, because AppleScript is broken.		if proj is {} then return				try			get proj's name		on error			return		end try				set projFilename to proj's name & pProjectFileExtension		set projPathname to gProjectsDir & projFilename		if pAlwaysCreateProjects or not (exists file projPathname of application "Finder") then						try				close (the first project document whose name is projFilename)			end try						Create Project {projPathname}						if pCreateBlueTargets and pCreateDebugTargets then				my SetupTarget(proj, "Blue debug")			end if						if pCreateBlueTargets and pCreateProfiledTargets then				my SetupTarget(proj, "Blue profile")			end if						if pCreateBlueTargets and pCreateOptimizedTargets then				my SetupTarget(proj, "Blue")			end if						if pCreateCarbonTargets and pCreateDebugTargets then				my SetupTarget(proj, "Carbon debug")			end if						if pCreateCarbonTargets and pCreateProfiledTargets then				my SetupTarget(proj, "Carbon profile")			end if						if pCreateCarbonTargets and pCreateOptimizedTargets then				my SetupTarget(proj, "Carbon")			end if						set the current target of project document 1 to target 1 of project document 1						Close Project					end if			end tellend CreateProjecton CreateAllProjects()		repeat with proj in gProjectData		CreateProject(proj)	end repeat	end CreateAllProjectson BuildProject(projName)	tell application "CodeWarrior IDE"		open (gProjectsDir & projName & pProjectFileExtension)		repeat with i from 2 to (count targets of project document 1)			set the current target of project document 1 to target i of project document 1			Make Project			-- If there were compiler warnings, then a compiler window will be in front.			-- For whatever reason, this causes the next "set the current target..." to fail.			-- An easy way to make the window go away without having to know if it's there or not 			-- is to build again, which, because everything is already compiled, finishes instantly			-- and produces no warnings.			--Make Project			-- An even better way is to check for the window and close it.			if the name of window 1 is "Errors & Warnings" then				close first window -- "close window 1" becomes "Close Window 1" (different event)			end if		end repeat		set the current target of project document 1 to target 1 of project document 1		Close Project	end tellend BuildProjecton BuildAllProjects()		repeat with proj in gProjectData		try			set projName to proj's name		on error			set projName to ""		end try		-- This statement doesn't work, because AppleScript is broken.		if proj is not {} then			if projName is not "" then				BuildProject(projName)			end if		end if	end repeat	end BuildAllProjectson SignalCompletion()		beep	end SignalCompletionwith timeout of 60000 seconds		SetGlobals()		SetProjectData()		CreateFolders()	CopyHeaders()		tell application "CodeWarrior IDE" to activate		CreateAllProjects()		if pShouldBuild then		BuildAllProjects()	end if		SignalCompletion()	end timeout