<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Database Access - SQL, Berkley DB - The NCBI C++ Toolkit Book [Internet] - NCBI</title><meta name="description" content="A comprehensive manual on the NCBI C++ toolkit, including its design and development framework, a C++ library reference, software examples and demos, FAQs and release notes." /><meta name="robots" content="index,nofollow,noarchive" /><meta name="page_id" content="ch_dbapi" /><meta name="page_type" content="chapter" /><meta name="ncbipopper" content="triggerPosition:'bottom left',destPosition:'top left',openEvent:'click',closeEvent:'click'" /><script type="text/javascript" src="js/jig/1.7/js/jig.min.js"></script><script type="text/javascript" src="js/toolkitSymbolSearch.js"></script><link type="text/css" rel="stylesheet" href="css/ptbooks.css" /><link type="text/css" rel="stylesheet" href="css/toolkit.css" /></head><body><div class="grid no_max_width"><div class="col twelve_col nomargin shadow"><div class="content"><div class="col eight_col"><div class="nvgtn"><a href="#__nav_cntnt" class="jig-ncbipopper">Contents ▾</a><div style="display:none;width:700px;height:500px;overflow:auto;" id="__nav_cntnt"><a class="right" href="toc.html">Table of Contents Page</a><ul class="simple-list"><li class="half_rhythm"><a href="toolkit.fm.html">Book Information</a></li><li class="half_rhythm"><a href="part1.html">Part 1. Overview</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_intro.html">1. Introduction to the C++ Toolkit</a></li><li class="half_rhythm"><a href="ch_start.html">2. Getting Started</a></li></ul></li><li class="half_rhythm"><a href="part2.html">Part 2. Development Framework</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_getcode_svn.html">3. Retrieve the Source Code (FTP and Subversion)</a></li><li class="half_rhythm"><a href="ch_config.html">4. Configure, Build, and Use the Toolkit</a></li><li class="half_rhythm"><a href="ch_build.html">5. Working with Makefiles</a></li><li class="half_rhythm"><a href="ch_proj.html">6. Project Creation and Management</a></li><li class="half_rhythm"><a href="ch_style.html">7. Programming Policies and Guidelines</a></li></ul></li><li class="half_rhythm"><a href="part3.html">Part 3. C++ Toolkit Library Reference</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_core.html">8. Portability, Core Functionality and Application Framework</a></li><li class="half_rhythm"><a href="ch_conn.html">9. Networking and IPC</a></li><li class="half_rhythm"><a href="ch_dbapi.html">10. Database Access - SQL, Berkley DB</a></li><li class="half_rhythm"><a href="ch_cgi.html">11. CGI and Fast-CGI </a></li><li class="half_rhythm"><a href="ch_html.html">12. HTML</a></li><li class="half_rhythm"><a href="ch_ser.html">13. Data Serialization (ASN.1, XML)</a></li><li class="half_rhythm"><a href="ch_datamod.html">14. Biological Sequence Data Model</a></li><li class="half_rhythm"><a href="ch_objmgr.html">15. Biological Object Manager</a></li><li class="half_rhythm"><a href="ch_blast.html">16. BLAST API</a></li><li class="half_rhythm"><a href="ch_dataaccess.html">17. Access to NCBI data</a></li><li class="half_rhythm"><a href="ch_algoalign.html">18. Biological Sequence Alignment</a></li><li class="half_rhythm"><a href="ch_gui.html">19. GUI and Graphics</a></li><li class="half_rhythm"><a href="ch_boost.html">20. Using the Boost Unit Test Framework</a></li></ul></li><li class="half_rhythm"><a href="part4.html">Part 4. Wrappers for 3rd-Party Packages</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_xmlwrapp.html">21. XmlWrapp (XML parsing and handling, XSLT, XPath)</a></li></ul></li><li class="half_rhythm"><a href="part5.html">Part 5. Software</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_debug.html">22. Debugging, Exceptions, and Error Handling</a></li><li class="half_rhythm"><a href="ch_grid.html">23. Distributed Computing</a></li><li class="half_rhythm"><a href="ch_app.html">24. Applications</a></li><li class="half_rhythm"><a href="ch_demo.html">25. Examples and Demos</a></li><li class="half_rhythm"><a href="ch_res.html">26. C Toolkit Resources for C++ Toolkit Users</a></li></ul></li><li class="half_rhythm"><a href="part6.html">Part 6. Help and Support</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_browse.html">27. NCBI C++ Toolkit Source Browser</a></li><li class="half_rhythm"><a href="ch_devtools.html">28. Software Development Tools</a></li><li class="half_rhythm"><a href="ch_xmlauthor.html">29. XML Authoring using Word</a></li><li class="half_rhythm"><a href="ch_faq.html">30. FAQs, Useful Documentation Links, and Mailing Lists</a></li></ul></li><li class="half_rhythm"><a href="part7.html">Part 7. Library and Applications Configuration</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_libconfig.html">31. Library Configuration</a></li></ul></li><li class="half_rhythm"><a href="part8.html">Release Notes</a><ul class="simple-list"><li class="half_rhythm"><a href="release_notes.html">Release Notes (Version 9, May 2012)</a></li><li class="half_rhythm"><a href="release_notes_7-05_2011.html">Release Notes (Version 7, May 2011)</a></li><li class="half_rhythm"><a href="release_notes_06_29_2010.html">Release Notes (June, 2010)</a></li><li class="half_rhythm"><a href="release_notes_05_15_2009.html">Release Notes (May, 2009)</a></li><li class="half_rhythm"><a href="release_notes_12_24_2008.html">Release Notes (December, 2008)</a></li><li class="half_rhythm"><a href="release_notes_12_31_2008.html">Release Notes (March, 2008)</a></li><li class="half_rhythm"><a href="release_notes_08_27_2007.html">Release Notes (August, 2007)</a></li><li class="half_rhythm"><a href="release_notes_03_12_2007.html">Release Notes (March, 2007)</a></li><li class="half_rhythm"><a href="release_notes_08_14_2006.html">Release Notes (August, 2006)</a></li><li class="half_rhythm"><a href="release_notes_04_30_2006.html">Release Notes (April 30, 2006)</a></li><li class="half_rhythm"><a href="release_notes_12_31_2005.html">Release Notes (December 31, 2005)</a></li><li class="half_rhythm"><a href="release_notes_10_03_2005.html">Release Notes (August, 2005)</a></li><li class="half_rhythm"><a href="release_notes_05_05_2005.html">Release Notes (April, 2005)</a></li><li class="half_rhythm"><a href="release_notes_03_09_2005.html">Release Notes (February, 2005)</a></li><li class="half_rhythm"><a href="release_notes_11_22_2004.html">Release Notes (November 22, 2004)</a></li><li class="half_rhythm"><a href="release_notes_10_2_2004.html">Release Notes (October 2, 2004)</a></li><li class="half_rhythm"><a href="release_notes_7_8_2004.html">Release Notes (July 8, 2004)</a></li><li class="half_rhythm"><a href="release_notes_april_16_2004.html">Release Notes (April 16, 2004)</a></li><li class="half_rhythm"><a href="release_notes_12_08_2003.html">Release Notes (December 8, 2003)</a></li><li class="half_rhythm"><a href="release_notes_08_01_2003.html">Release Notes (August 1, 2003)</a></li></ul></li><li class="half_rhythm"><a href="app1.appendix1.html">Appendix - Books and Styles</a></li></ul></div><div class="pagination"><a class="pagelink active prev" title="Previous page" href="ch_conn.html">&lt; Prev</a><a class="pagelink active next" title="Next page" href="ch_cgi.html">Next &gt;</a></div></div><div class="meta_content"><h1><span class="label">10</span><span class="title">Database Access - SQL, Berkley DB</span></h1><p class="small">Last Update: August 31, 2012.</p></div><div class="body_content"><div class="sec"><h2><span class="title">Overview</span></h2><p>The overview for this chapter consists of the following topics:</p><ul><li><p>Introduction</p></li><li><p>Chapter Outline</p></li></ul><div class="sec"><h3><span class="title">Introduction</span></h3><p>Database Access [Library dbapi: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/dbapi">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi">src</a>]</p><p>The DBAPI library provides the underlying <a href="ch_dbapi.html#ch_dbapi.dbapi_user_layer">user-layer</a> and <a href="ch_dbapi.html#ch_dbapi.dbapi_driver_ref">driver</a> API for the NCBI database connectivity project. The project's goal is to provide access to various relational database management systems (RDBMS) with a single uniform user interface. Consult the detailed documentation for details of the <a href="ch_dbapi.html#ch_dbapi.dbapi_drivers">supported DBAPI drivers</a>.</p><p>The BDB library is part of the NCBI C++ Toolkit and serves as a high-level interface to the Berkeley DB. The primary purpose of the library is to provide tools for work with flatfile, federated databases. The BDB library incorporates a number of Berkeley DB services; for a detailed understanding of how it works, study the original Berkeley DB documentation from <a href="http://www.oracle.com/database/berkeley-db/db/">http://www.oracle.com/database/berkeley-db/db/</a>. The BDB library is compatible with Berkeley DB v. 4.1 and higher. The BDB library, as it is right now, is architecturally different from the dbapi library and does not follow its design. The BDB is intended for use by software developers who need small-footprint, high-performance database capabilities with zero administration. The database in this case becomes tightly integrated with the application code.</p></div><div class="sec"><h3><span class="title">Chapter Outline</span></h3><p>The following is an outline of the topics presented in this chapter:</p><ul><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_overview">DBAPI Overview</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Security">Security</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Simple_Database_Access_via_C">Simple Database Access via C++</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Database_loadbalanci">Database Load-Balancing (DBLB)</a></p><ul><li><p><a href="ch_dbapi.html#ch_dbapi.Getting_started">Setting up Load-Balancing of Database Servers</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Using_Database_LoadBalancing_fr">Using Database Load-Balancing from C++</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Database_Access_via_Python_and">Load-Balanced Database Access via Python and Perl</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Advantages_of_using_">Advantages of using DBLB</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.HOW_IT_WORKS_by_defa">How it works (by default)</a></p></li></ul></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_user_layer">NCBI DBAPI User-Layer Reference</a></p><ul><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_obj_hierarchy">Object Hierarchy</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_includes">Includes</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_objects">Objects</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_obj_lifecycle">Object Life Cycle</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_variant">CVariant Type</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_choose_driver">Choosing the Driver</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_src_cnxns">Data Source and Connections</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_main_loop">Main Loop</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_io_params">Input and Output Parameters</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_stored_procs">Stored Procedures</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_cursors">Cursors</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_wwblobs">Working with BLOBs</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_blobs">Updating BLOBs Using Cursors</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_bulk_insert">Using Bulk Insert</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_diag">Diagnostic Messages</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_trace">Trace Output</a></p></li></ul></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_driver_ref">NCBI DBAPI Driver Reference</a></p><ul><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_drvr_overview">Overview</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_drvr_arch">The driver architecture</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_sample_prog">Sample program</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_errors">Error handling</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_context">Driver context and connections</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_drvr_mgr">Driver Manager</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_txt_img">Text and Image Data Handling</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_results">Results loop</a></p></li></ul></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_drivers">Supported DBAPI drivers</a></p><ul><li><p><a href="ch_dbapi.html#ch_dbapi.free_tds64">FreeTDS (TDS ver. 7.0)</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_drvs_ctlib">Sybase CTLIB</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_drvs_dblib">Sybase DBLIB</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_drvrs_odbc">ODBC</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.mysql_driver">MySQL Driver</a></p></li></ul></li></ul><p>dbapi [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/dbapi">include/dbapi</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi">src/dbapi</a>]</p><p><a href="ch_dbapi.html#ch_dbapi.dbapi_driver_ref">driver</a> [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/dbapi/driver">include/dbapi/driver</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/driver">src/dbapi/driver</a>]</p><ul><li><p><a href="ch_dbapi.html#ch_dbapi.Major_Features_of_th">Major Features of the BDB Library</a></p></li></ul></div></div><div class="sec" id="ch_dbapi.dbapi_overview"><h2><span class="title">DBAPI Overview</span></h2><p>DBAPI is a consistent, object-oriented programming interface to multiple back-end databases. It encapsulates leading relational database vendors' APIs and is universal for all applications regardless of which database is used. It frees developers from dealing with the low-level details of a particular database vendor's API, allowing them to concentrate on domain-specific issues and build appropriate data models. It allows developers to write programs that are reusable with many different types of relational databases and to drill down to the native database APIs for added control when needed.</p><p>DBAPI has open SQL interface. It takes advantage of database-specific features to maximize performance and allows tight control over statements and their binding and execution semantics.</p><p>DBAPI has "Native" Access Modules for Sybase, Microsoft SQL Server, SQLITE, and ODBC. It provides native, high-performance implementations for supported vendor databases. It allows porting to other databases with minimal code changes.</p><p>DBAPI is split into low-layer and user-layer.</p><p>In addition, a simplified C++ API (<a href="ch_dbapi.html#ch_dbapi.Simple_Database_Access_via_C">SDBAPI</a>) layer is provided for cases where the full DBAPI feature set is not required.</p><p>See the <a href="ch_libconfig.html#ch_libconfig.DBAPI">DBAPI configuration parameters reference</a> for details on configuring the DBAPI library.</p><p>See the DBAPI sample programs for example code:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/dbapi/">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/dbapi/</a></p></li></ul></div><div class="sec" id="ch_dbapi.Security"><h2><span class="title">Security</span></h2><p>Much has been written about networked database security - in particular, SQL injection. Please see the common resources for more information.</p><p>When using DBAPI or SDBAPI, the two most important rules for protecting against SQL injection are:</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">Never construct a SQL statement from user-supplied input if the same functionality can be achieved by passing the user input to stored procedures or parameterized SQL.</p></dd><dt>2</dt><dd><p class="no_top_margin">If constructing a SQL statement from user-supplied input cannot be avoided, then you MUST sanitize the user input.</p></dd></dl><p>The following sample programs illustrates how to protect against SQL injection for basic SQL statements using SDBAPI and DBAPI:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/sdbapi/sdbapi_simple.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/sdbapi/sdbapi_simple.cpp</a></p></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/dbapi/dbapi_simple.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/dbapi/dbapi_simple.cpp</a></p></li></ul><p>See the <a href="http://www.ncbi.nlm.nih.gov/books/NBK7177/#ch_faq.Security">Security FAQ</a> for more information.</p></div><div class="sec" id="ch_dbapi.Simple_Database_Access_via_C"><h2><span class="title">Simple Database Access via C++</span></h2><p>This section shows how to execute a simple static SQL query using the simplified database API (SDBAPI). Note that database load-balancing is performed automatically and transparenty when using SDBAPI.</p><p>C++ source files using SDBAPI should contain:</p><pre><span class="nctnt-pre ncbi-code">#include &lt;dbapi/simple/sdbapi.hpp&gt;</span></pre><p>Application makefiles should contain:</p><pre>LIB  = $(SDBAPI_LIB) xconnect xutil xncbi<br />LIBS = $(SDBAPI_LIBS) $(NETWORK_LIBS) $(DL_LIBS) $(ORIG_LIBS)</pre><p>This example connects to a load-balanced service:</p><pre><span class="nctnt-pre ncbi-code">CDatabase db("dbapi://" + my_username + ":" + my_password +<br />             "@" + my_servicename + "/" + my_dbname);<br />db.Connect();<br />CQuery query = db.NewQuery();<br />query.SetSql("select title from Journal");<br />query.Execute();<br />ITERATE(CQuery, it, query.MultiSet()) {<br />    string col1 = it[1].AsString(); // Note: uses 1-based index !<br />    NcbiCout &lt;&lt; col1 &lt;&lt; NcbiEndl;<br />}</span></pre><p><span class="nctnt highlight">Note:</span> SDBAPI always uses load balancing - you don't have to call <span class="nctnt ncbi-func">DBLB_INSTALL_DEFAULT()</span>.</p><p>See the SDBAPI sample programs for more example code:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/sdbapi/">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/sdbapi/</a></p></li></ul></div><div class="sec" id="ch_dbapi.Database_loadbalanci"><h2><span class="title">Database Load-Balancing (DBLB)</span></h2><div class="sec" id="ch_dbapi.Getting_started"><h3><span class="title">Setting up Load-Balancing of Database Servers</span></h3><p>For the following to be clear, it is important to distinguish between a database name, an underlying (actual) server name (e.g. MSSQL17), which hosts a variety of databases, a database server alias, and a service name. A server alias may be moved to a different underlying server. The server alias is often used with sqsh, and the GUI tools, such as SQL Management studio. The service name is used by the load-balancer to look up the underlying server to use, and is the name that should be used by an application. The server aliases and service names often share a common prefix and would look similar, and in fact for reasons presented below, there should be at least one server alias that is identical to the service name.</p><p>The following steps must be done prior to database load-balancing:</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">Ask the DBAs to add your service name (e.g. YOURSERVICE) to the load-balancer configuration database. Typically, the names are clear, for example, there are server aliases YOURSERVICE1, and YOURSERVICE2 that already exist, and databases that have “YOURSERVICE” as an embedded string, but if not, the databases providing the service and the server aliases involved should be given. Note that if databases are moved to different underlying servers, both the server aliases, and the load-balancer configuration which points to those servers are both moved, synchronously.</p></dd><dt>2</dt><dd><p class="no_top_margin">Tell the DBAs which of the server aliases point to the server that should be used, if the load-balancer is unavailable, as the DBAPI will look for a server alias with the same name as the service, in that case.</p></dd><dt>3</dt><dd><p class="no_top_margin">The DBAs will also ask for a DNS name to match the service name as a backup connection method, should everything else fail.</p></dd></dl></div><div class="sec" id="ch_dbapi.Using_Database_LoadBalancing_fr"><h3><span class="title">Using Database Load-Balancing from C++</span></h3><p>For simplest access, see the section on <a href="ch_dbapi.html#ch_dbapi.Simple_Database_Access_via_C">using SDBAPI</a> above. SDBAPI uses the database load-balancing by default.</p><p>If more flexibility is required, and you want to activate the database load-balancing for the more general NCBI DBAPI:</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">Before the very first DBAPI connection attempt, call:<br /><br /><span class="nctnt ncbi-code">#include &lt;dbapi/driver/dbapi_svc_mapper.hpp&gt;</span><br /><span class="nctnt ncbi-code">DBLB_INSTALL_DEFAULT();</span><br /></p></dd><dt>2</dt><dd><p class="no_top_margin">Link <span class="nctnt ncbi-lib">'$(XCONNEXT)'</span> and <span class="nctnt ncbi-lib">'xconnect'</span> libraries to your application.</p></dd></dl><p>If steps (1) and (2) above are done then the DBAPI connection methods (such as <span class="nctnt ncbi-func">Connect()</span> or <span class="nctnt ncbi-func">ConnectValidated()</span>) will attempt to resolve the passed server name as a load-balanced service name.</p><p><span class="nctnt highlight">Note:</span> If steps (1) and (2) above are not done, or if DBLB library is not available (such as in the publicly distributed code base), or if the passed server name cannot be resolved as a load-balanced service name, then the regular database server name resolution will be used – i.e. the passed name will first be interpreted as a server alias (using the "interfaces" file), and if that fails, it will be interpreted as a DNS name. Note however that by default if the service name resolves (exists), then the regular database server name resolution will not be used as a fallback, even if DBAPI can't connect (for whatever reason) to the servers that the service resolves to.</p><p>Example:</p><pre><span class="nctnt-pre ncbi-code">#include &lt;dbapi/driver/dbapi_svc_mapper.hpp&gt;<br /><br />DBLB_INSTALL_DEFAULT();<br />IDataSource* ds = dm.CreateDs("ftds");<br />IConnection* conn = ds-&gt;CreateConnection();<br /><br />// (Use of validator here is optional but generally encouraged.)<br />CTrivialConnValidator my_validator(my_databasename);<br /><br />conn-&gt;ConnectValidated(my_validator, my_username, my_password, my_servicename);</span></pre></div><div class="sec" id="ch_dbapi.Database_Access_via_Python_and"><h3><span class="title">Load-Balanced Database Access via Python and Perl</span></h3><p>Load-balanced database access can be achieved from scripts by using the utility <span class="nctnt ncbi-app">ncbi_dblb</span>, which is located under <span class="nctnt ncbi-path">/opt/machine/lbsm/bin</span>:</p><p>Here are some sample scripts that demonstrate using <span class="nctnt ncbi-app">ncbi_dblb</span> to retrieve the server name for a given load-balanced name:</p><p>From Python:</p><pre><span class="nctnt-pre ncbi-code">#!/usr/bin/env python<br /><br />import subprocess, sys<br /><br />if len(sys.argv) &gt; 1:<br />    # Use the -q option to fetch only the server name.<br />    cmd = ['/opt/machine/lbsm/bin/ncbi_dblb', '-q', sys.argv[1]]<br />    srv = subprocess.Popen(cmd, stdout=subprocess.PIPE).communicate()[0].strip()<br />    # Do whatever is needed with the server name...<br />    print 'Server: "' + srv + '"'</span></pre><p>From Perl:</p><pre><span class="nctnt-pre ncbi-code">#!/usr/bin/env perl -w<br /><br />use strict;<br /><br />if (@ARGV) {<br />    # Use the -q option to fetch only the server name.<br />    my $cmd = '/opt/machine/lbsm/bin/ncbi_dblb -q ' . $ARGV[0];<br />    my $srv = `$cmd`; chomp($srv);<br />    # Do whatever is needed with the server name...<br />    print 'Server: "' . $srv . '"'<br />}</span></pre></div><div class="sec" id="ch_dbapi.Advantages_of_using_"><h3><span class="title">Advantages of using DBLB</span></h3><div class="sec" id="ch_dbapi.C_Specific"><h4><span class="title">C++ Specific</span></h4><ul><li><p>A database-level verification mechanism.</p></li><li><p>Latch onto the same database server for the life of your process. It's often useful to avoid possible inter-server data discrepancy. The "latch-on" mechanism can be relaxed or turned off if needed.</p></li><li><p>Automatic connection retries. If a connection to the selected server cannot be established, the API will try again with other servers (unless it is against the chosen "latch-on" strategy).</p></li><li><p>The default connection strategy is *configurable*. You can change its parameters using a configuration file, environment variables, and/or programmatically. You can also configure locally for your application ad-hoc mappings to the database servers (this is usually not recommended but can come in handy in emergency cases or for debugging).</p></li><li><p>If needed, you can implement your own customized mapper. Components of the default connection strategy can be used separately, or in combination with each other and with the user-created strategies, if necessary.</p></li></ul></div><div class="sec" id="ch_dbapi.General"><h4><span class="title">General</span></h4><ul><li><p>Connecting to the database servers by server name and/or "interfaces" file based aliases still works the same as it used to.</p></li><li><p>Automatic avoidance of unresponsive database servers. This prevents your application from hanging for up to 30 seconds on the network timeout.</p></li><li><p>Independence from the database "interfaces" file. A centrally maintained service directory is used instead, which is accessible locally and/or via network. It also dynamically checks database servers' availability and excludes unresponsive servers.</p></li></ul></div></div><div class="sec" id="ch_dbapi.HOW_IT_WORKS_by_defa"><h3><span class="title">How it works (by default)</span></h3><p>The following steps are performed each time a request is made to establish a load-balanced connection to a named database service:</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">The requests will first go through the DBLB mechanism that tries to match the requested service name against the services known to the NCBI <a href="ch_app.html#ch_app.Load_Balancing">Load Balancer</a> and/or those described in the application's configuration file.</p></dd><dt>2</dt><dd><p class="no_top_margin">If the requested service name is unknown to the load balancer then this name will be used "as is".</p></dd><dt>3</dt><dd><p class="no_top_margin">However, if this service name is known to the DBLB then the DBLB will try to establish a connection to the database server that it deems the most suitable. If the service is handled by the NCBI load-balancer, then the unresponsive servers will be weeded out, and a load on the machines that run the servers may be taken into account too.</p></dd><dt>4</dt><dd><p class="no_top_margin"><span class="nctnt highlight">C++ only:</span> If the connection cannot be established, then DBLB will automatically retry the connection, now using another suitable database server.</p></dd><dt>5</dt><dd><p class="no_top_margin">This procedure may be repeated several times, during which there will be only one attempt to connect to each database.</p></dd><dt>6</dt><dd><p class="no_top_margin"><span class="nctnt highlight">C++ only:</span> Once a database connection is successfully established it will be "latched-on". This means that when you will try to connect to the same service or alias within the same application again then you will be connected to the same database server (this can be relaxed or turned off completely).</p></dd><dt>7</dt><dd><p class="no_top_margin">For example, you can connect to the "PMC" service which is currently mapped to two servers. The server names are provided dynamically by the NCBI load-balancer, so you never have to change your configuration or recompile your application if either a service configuration or an "interfaces" file get changed.</p></dd><dt>8</dt><dd><p class="no_top_margin"><span class="nctnt highlight">C++ only:</span> If <span class="nctnt ncbi-func">ConnectValidated()</span> is used to connect to a database, then requests to establish database connections will first go through the server-level load-balancing mechanism. On successful login to server, the database connection will be validated against the validator. If the validator does not "approve" the connection, then DBAPI will automatically close this connection and repeat this login/validate attempt with the next server, and so on, until a "good" (successful login + successful validation) connection is found. If you want to validate a connection against more than one validator/database, then you can combine validators. Class <span class="nctnt ncbi-class">CConnValidatorCoR</span> was developed to allow combining of other validators into a chain.</p></dd></dl></div></div><div class="sec" id="ch_dbapi.dbapi_user_layer"><h2><span class="title">NCBI DBAPI User-Layer Reference</span></h2><div class="sec" id="ch_dbapi.dbapi_obj_hierarchy"><h3><span class="title">Object hierarchy</span></h3><p>See <a href="ch_dbapi.html#ch_dbapi.F1">Figure 1</a>.</p><div class="figure" id="ch_dbapi.F1"><div class="graphic"><img src="img/dbapi_user.gif" alt="Figure 1. Object Hierarchy" /></div><div class="caption"><p>Figure 1. Object Hierarchy</p></div></div></div><div class="sec" id="ch_dbapi.dbapi_includes"><h3><span class="title">Includes</span></h3><p>For most purposes it is sufficient to include one file in the user source file: <span class="nctnt ncbi-path">dbapi.hpp</span>.</p><pre><span class="nctnt-pre ncbi-code">#include &lt;dbapi/dbapi.hpp&gt;</span></pre><p>For static linkage the following include file is also necessary:</p><pre><span class="nctnt-pre ncbi-code">#include &lt;dbapi/driver/drivers.hpp&gt;</span></pre></div><div class="sec" id="ch_dbapi.dbapi_objects"><h3><span class="title">Objects</span></h3><p>All objects are returned as pointers to their respective interfaces. The null (0) value is valid, meaning that no object was returned.</p></div><div class="sec" id="ch_dbapi.dbapi_obj_lifecycle"><h3><span class="title">Object Life Cycle</span></h3><p>In general, any child object is valid only in the scope of its parent object. This is because most of the objects share the same internal structures. There is no need to delete every object explicitly, as all created objects will be deleted upon program exit. Specifically, all objects are derived from the static <span class="nctnt ncbi-class">CDriverManager</span> object, and will be destroyed when <span class="nctnt ncbi-class">CDriverManager</span> is destroyed. It is possible to delete any object from the framework and it is deleted along with all derived objects. For example, when an <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIConnection.html">IConnection</a> object is deleted, all derived <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIStatement.html">IStatement</a>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classICallableStatement.html">ICallableStatement</a> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIResultSet.html">IResultSet</a> objects will be deleted too. If the number of the objects (for instance <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIResultSet.html">IResultSet</a>) is very high, it is recommended to delete them explicitly or enclose in the <span class="nctnt ncbi-type">auto_ptr&lt;...&gt;</span> template. For each object a <span class="nctnt ncbi-func">Close()</span> method is provided. It disposes of internal resources, required for the proper library cleanup, but leaves the framework intact. After calling <span class="nctnt ncbi-func">Close()</span> the object becomes invalid. This method may be necessary when the database cleanup and framework cleanup are performed in different places of the code.</p></div><div class="sec" id="ch_dbapi.dbapi_variant"><h3><span class="title">CVariant Type</span></h3><p>The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a> type is used to represent any database data type (except BLOBs). It is an object, not a pointer, so it behaves like a primitive C++ type. Basic comparison operators are supported (==, !=, &lt; ) for identical internal types. If types are not identical, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariantException.html">CVariantException</a> is thrown. <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a> has a set of getters to extract a value of a particular type, e.g. <span class="nctnt ncbi-func">GetInt4()</span>, <span class="nctnt ncbi-func">GetByte()</span>,<span class="nctnt ncbi-func"> GetString()</span>, etc. If <span class="nctnt ncbi-func">GetString()</span> is called for a different type, like <span class="nctnt ncbi-type">DateTime</span> or <span class="nctnt ncbi-type">integer</span> it tries to convert it to a string. If it doesn't succeed, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariantException.html">CVariantException</a> is thrown. There is a set of factory methods (static functions) for creating <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a> objects of a particular type, such as <span class="nctnt ncbi-func">CVariant::BigInt()</span>, <span class="nctnt ncbi-func">CVariant::SmallDateTime()</span>, <span class="nctnt ncbi-func">CVariant::VarBinary()</span> etc. For more details please see the comments in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/dbapi/variant.hpp">variant.hpp</a> file.</p><p>Related sample code:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_object.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_object.cpp</a></p></li></ul></div><div class="sec" id="ch_dbapi.dbapi_choose_driver"><h3><span class="title">Choosing the Driver</span></h3><p>There are several drivers for working with different SQL servers on different platforms. The ones presently implemented are "<span class="nctnt ncbi-lib">ctlib</span>" (Sybase), "<span class="nctnt ncbi-lib">dblib</span>"(MS SQL, Sybase), "<span class="nctnt ncbi-lib">ftds</span>" (MS SQL, Sybase, cross platform). For static linkage these drivers should be registered manually; for dynamic linkage this is not necessary. The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDriverManager.html">CDriverManager</a> object maintains all registered drivers.</p><pre><span class="nctnt-pre ncbi-code">DBAPI_RegisterDriver_CTLIB();<br />DBAPI_RegisterDriver_DBLIB();</span></pre><p>Related sample code:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_context.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_context.cpp</a></p></li></ul></div><div class="sec" id="ch_dbapi.dbapi_src_cnxns"><h3><span class="title">Data Source and Connections</span></h3><p>The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIDataSource.html">IDataSource</a> interface defines the database platform. To create an object implementing this interface, use the method <span class="nctnt ncbi-func">CreateDs(const string&amp; driver)</span>. An <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIDataSource.html">IDataSource</a> can create objects represented by an <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIConnection.html">IConnection</a> interface, which is responsible for the connection to the database. It is highly recommended to specify the database name as an argument to the <span class="nctnt ncbi-func">CreateConnection()</span> method, or use the <span class="nctnt ncbi-func">SetDatabase()</span> method of a <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCConnection.html">CConnection</a> object instead of using a regular SQL statement. In the latter case, the library won't be able to track the current database.</p><pre><span class="nctnt-pre ncbi-code">IDataSource *ds = dm.CreateDs("ctlib");<br />IConnection *conn = ds-&gt;CreateConnection();<br />conn-&gt;Connect("user", "password", "server", "database");<br />IStatement *stmt = conn-&gt;CreateStatement();</span></pre><p>Every additional call to <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIConnection.html">IConnection</a><span class="nctnt ncbi-func">::CreateStatement()</span> results in cloning the connection for each statement. These connections inherit the same default database, which was specified in the <span class="nctnt ncbi-func">Connect()</span> or <span class="nctnt ncbi-func">SetDatabase()</span> method. Thus if the default database was changed by calling <span class="nctnt ncbi-func">SetDatabase()</span>, all subsequent cloned connections created by <span class="nctnt ncbi-func">CreateStatement()</span> will inherit this particular default database.</p><p>Related sample code:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/dbapi/dbapi_simple.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/dbapi/dbapi_simple.cpp</a></p></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_connection.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_connection.cpp</a></p></li></ul></div><div class="sec" id="ch_dbapi.dbapi_main_loop"><h3><span class="title">Main Loop</span></h3><p>The library simulates the main result-retrieving loop of the Sybase client library by using the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIStatement.html">IStatement</a><span class="nctnt ncbi-func">::HasMoreResults()</span> method:</p><pre><span class="nctnt-pre ncbi-code">stmt-&gt;Execute("select * from MyTable");<br />while( stmt-&gt;HasMoreResults() ) {<br />    if( stmt-&gt;HasRows() ) {<br />        IResultSet *rs = stmt-&gt;GetResultset();<br /><br />        // Retrieve results, if any<br /><br />        while( rs-&gt;Next() ) {<br />            int col1 = rs-&gt;GetVariant(1).GetInt4();<br />            ...<br />        }<br />    }<br />}</span></pre><p>This method should be called until it returns <span class="nctnt ncbi-monospace">false</span>, which means that no more results are available. It returns as soon as a result is ready. The type of the result can be obtained by calling the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIResultSet.html">IResultSet</a><span class="nctnt ncbi-func">::GetResultType()</span> method. Supported result types are <span class="nctnt ncbi-var">eDB_RowResult, eDB_ParamResult, eDB_ComputeResult, eDB_StatusResult, eDB_CursorResult</span>. The method <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIStatement.html">IStatement</a><span class="nctnt ncbi-func">::GetRowCount()</span> returns the number of updated or deleted rows.</p><p>The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIStatement.html">IStatement</a><span class="nctnt ncbi-func">::ExecuteUpdate()</span> method is used for SQL statements that do not return rows:</p><pre><span class="nctnt-pre ncbi-code">stmt-&gt;ExecuteUpdate("update...");<br />int rows = stmt-&gt;GetRowCount();</span></pre><p>The method <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIStatement.html">IStatement</a><span class="nctnt ncbi-func">::GetResultSet()</span> returns an <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIResultSet.html">IResultSet</a> object. The method <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIResultSet.html">IResultSet</a><span class="nctnt ncbi-func">::Next()</span> actually does the fetching, so it should be always called first. It returns <span class="nctnt ncbi-monospace">false</span> when no more fetch data is available. All column data, except Image and Text is represented by a single <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a> object. The method <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIResultSet.html">IResultSet</a><span class="nctnt ncbi-func">::GetVariant()</span> takes one parameter, the column number. Column numbers start with 1.</p><p>Related sample code:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/dbapi/dbapi_simple.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/dbapi/dbapi_simple.cpp</a></p></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_stmt.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_stmt.cpp</a></p></li></ul></div><div class="sec" id="ch_dbapi.dbapi_io_params"><h3><span class="title">Input and Output Parameters</span></h3><p>The method <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classICallableStatement.html">ICallableStatement</a><span class="nctnt ncbi-func">::SetParam(const CVariant&amp; v, const string&amp; name)</span> is used to pass parameters to stored procedures and dynamic SQL statements. To ensure the correct parameter type it is recommended to use <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a> type factories (static methods) to create a <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a> of the required internal type. There is no internal representation for the BIT parameter type, please use TinyInt of Int types with 0 for <span class="nctnt ncbi-monospace">false</span> and 1 for <span class="nctnt ncbi-monospace">true</span> respectively. Here are a few examples: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a><span class="nctnt ncbi-func">::Int4(Int4 *p)</span>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a><span class="nctnt ncbi-func">::TinyInt(UInt1 *p)</span>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a><span class="nctnt ncbi-func">::VarChar(const char *p, size_t len )</span> etc.</p><p>There are also corresponding constructors, like <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a><span class="nctnt ncbi-func">::CVariant(Int4 v)</span>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a><span class="nctnt ncbi-func">::CVariant(const string&amp; s)</span>, ..., but the user must ensure the proper type conversion in the arguments, and not all internal types can be created using constructors.</p><p>Output parameters are set by the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classICallableStatement.html">ICallableStatement</a><span class="nctnt ncbi-func">::SetOutputParam(const CVariant&amp; v, const string&amp; name)</span> method, where the first argument is a null <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a> of a particular type, e.g. <span class="nctnt ncbi-code">SetOutputParam(CVariant(eDB_SmallInt),"@arg")</span>.</p><p>Related sample code:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/dbapi/dbapi_simple.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/dbapi/dbapi_simple.cpp</a></p></li></ul></div><div class="sec" id="ch_dbapi.dbapi_stored_procs"><h3><span class="title">Stored Procedures</span></h3><p>The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classICallableStatement.html">ICallableStatement</a> object is used for calling stored procedures. First get the object itself by calling <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIConnection.html">IConnection</a><span class="nctnt ncbi-func">::PrepareCall()</span>. Then set any parameters. If the parameter name is empty, the calls to <span class="nctnt ncbi-func">SetParam()</span> should be in the exact order of the actual parameters. Retrieve all results in the main loop. Get the status of the stored procedure using the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classICallableStatement.html">ICallableStatement</a><span class="nctnt ncbi-func">::GetReturnStatus()</span> method.</p><pre><span class="nctnt-pre ncbi-code">ICallableStatement *cstmt = conn-&gt;PrepareCall("ProcName");<br />Uint1 byte = 1;<br />cstmt-&gt;SetParam(CVariant("test"), "@test_input");<br />cstmt-&gt;SetParam(CVariant::TinyInt(&amp;byte), "@byte");<br />cstmt-&gt;SetOutputParam(CVariant(eDB_Int), "@result");<br />cstmt-&gt;Execute();<br />while(cstmt-&gt;HasMoreResults()) {<br />    if( cstmt-&gt;HasRows() ) {<br />        IResultSet *rs = cstmt-&gt;GetResultSet();<br />        switch( rs-&gt;GetResultType() ) {<br />            case eDB_RowResult:<br />                while(rs-&gt;Next()) {<br /><br />                // retrieve row results<br /><br />                }<br />                break;<br />            case eDB_ParamResult:<br />                while(rs-&gt;Next()) {<br /><br />                // Retrieve parameter row<br /><br />                }<br />                break;<br />        }<br />    }<br />}<br /><br />// Get status<br />int status = cstmt-&gt;GetReturnStatus();</span></pre><p>It is also possible to use <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIStatement.html">IStatement</a> interface to call stored procedures using standard SQL language call. The difference from <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classICallableStatement.html">ICallableStatement</a> is that there is no <span class="nctnt ncbi-func">SetOutputParam()</span> call. The output parameter is passed with a regular <span class="nctnt ncbi-func">SetParam()</span> call having a <i>non-null </i><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a> argument. There is no <span class="nctnt ncbi-func">GetReturnStatus()</span> call in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIStatement.html">IStatement</a>, so use the result type filter to get it - although note that result sets with type <span class="nctnt ncbi-monospace">eDB_StatusResult</span> are not always guaranteed to be returned when using the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIStatement.html">IStatement</a> interface.</p><pre><span class="nctnt-pre ncbi-code">sql = "exec SampleProc @id, @f, @o output";<br />stmt-&gt;SetParam(CVariant(5), "@id");<br />stmt-&gt;SetParam(CVariant::Float(&amp;f), "@f");<br />stmt-&gt;SetParam(CVariant(5), "@o");<br />stmt-&gt;Execute(sql);<br />while(stmt-&gt;HasMoreResults()) {<br />    IResultSet *rs = stmt-&gt;GetResultSet();<br /><br />    if( rs == 0 )<br />        continue;<br /><br />    switch( rs-&gt;GetResultType() ) {<br />    case eDB_ParamResult:<br />        while( rs-&gt;Next() ) {<br />            NcbiCout &lt;&lt; "Output param: "<br />                     &lt;&lt; rs-&gt;GetVariant(1).GetInt4()<br />                     &lt;&lt; NcbiEndl;<br />        }<br />        break;<br />    case eDB_StatusResult:<br />        while( rs-&gt;Next() ) {<br />            NcbiCout &lt;&lt; "Return status: "<br />                     &lt;&lt; rs-&gt;GetVariant(1).GetInt4()<br />                     &lt;&lt; NcbiEndl;<br />        }<br />        break;<br />    case eDB_RowResult:<br />        while( rs-&gt;Next() ) {<br />            if( rs-&gt;GetVariant(1).GetInt4() == 2121 ) {<br />                NcbiCout &lt;&lt; rs-&gt;GetVariant(2).GetString() &lt;&lt; "|"<br />                         &lt;&lt; rs-&gt;GetVariant(3).GetString() &lt;&lt; "|"<br />                         &lt;&lt; rs-&gt;GetVariant(4).GetString() &lt;&lt; "|"<br />                         &lt;&lt; rs-&gt;GetVariant(5).GetString() &lt;&lt; "|"<br />                         &lt;&lt; rs-&gt;GetVariant(6).GetString() &lt;&lt; "|"<br />                         &lt;&lt; rs-&gt;GetVariant(7).GetString() &lt;&lt; "|"<br />                         &lt;&lt; NcbiEndl;<br />            } else {<br />                NcbiCout &lt;&lt; rs-&gt;GetVariant(1).GetInt4() &lt;&lt; "|"<br />                         &lt;&lt; rs-&gt;GetVariant(2).GetFloat() &lt;&lt; "|"<br />                         &lt;&lt; rs-&gt;GetVariant("date_val").GetString() &lt;&lt; "|"<br />                         &lt;&lt; NcbiEndl;<br />            }<br />        }<br />        break;<br />    }<br />}<br />stmt-&gt;ClearParamList();</span></pre><p>Related sample code:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/dbapi/dbapi_simple.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/dbapi/dbapi_simple.cpp</a></p></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_proc.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_proc.cpp</a></p></li></ul></div><div class="sec" id="ch_dbapi.dbapi_cursors"><h3><span class="title">Cursors</span></h3><p>The library currently supports basic cursor features such as setting parameters and cursor update and delete operations.</p><pre><span class="nctnt-pre ncbi-code">ICursor *cur = conn-&gt;CreateCursor("table_cur",<br />                                  "select ... for update of ...");<br />IResultSet *rs = cur-&gt;Open();<br />while(rs-&gt;Next()) {<br />    cur-&gt;Update(table, sql_statement_for_update);<br />}<br />cur-&gt;Close();</span></pre><p>Related sample code:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_cursor.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_cursor.cpp</a></p></li></ul></div><div class="sec" id="ch_dbapi.dbapi_wwblobs"><h3><span class="title">Working with BLOBs</span></h3><p>Due to the possibly very large size, reading and writing BLOBs requires special treatment. During the fetch the contents of the whole column must be read before advancing to the next one. That's why the columns of type IMAGE and TEXT are not bound to the corresponding variables in the resultset and all subsequent columns are not bound either. So it is recommended to put the BLOB columns at the end of the column list. There are several ways to read BLOBs, using <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIResultSet.html">IResultSet</a><span class="nctnt ncbi-func">::Read()</span>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIResultSet.html">IResultSet</a><span class="nctnt ncbi-func">::GetBlobIStream()</span>, and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIResultSet.html">IResultSet</a><span class="nctnt ncbi-func">::GetBlobReader()</span> methods. The first is the most efficient; it reads data into a supplied buffer until it returns 0 bytes read. The next call will read from the next column. The second method implements the STL istream interface. After each successful column read you should get another istream for the next column. The third implements the C++ Toolkit <span class="nctnt ncbi-func">IReader</span> interface. If the data size is small and double buffering is not a performance issue, the BLOB columns can be bound to <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a> variables by calling <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIResultSet.html">IResultSet</a><span class="nctnt ncbi-func">::BindBlobToVariant(true)</span>. In this case the data should be read using <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a><span class="nctnt ncbi-func">::Read()</span> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a><span class="nctnt ncbi-func">::GetBlobSize()</span>. To write BLOBs there are also several options. To pass a BLOB as a SQL parameter you should store it in a <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a> using <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a><span class="nctnt ncbi-func">::Append()</span> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a><span class="nctnt ncbi-func">::Truncate()</span> methods. To store a BLOB in the database you should initialize this column first by writing a zero value (<span class="nctnt ncbi-var">0x0</span>) for an IMAGE type or a space value (<span class="nctnt ncbi-monospace">' '</span>) for a TEXT type. After that you can open a regular <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIResultSet.html">IResultSet</a> or <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classICursor.html">ICursor</a> and for each required row update the BLOB using <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIResultSet.html">IResultSet</a><span class="nctnt ncbi-func">::GetBlobOStream()</span>. NOTE: this call opens an additional connection to the database.</p><p>Related sample code:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_lob.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_lob.cpp</a></p></li></ul></div><div class="sec" id="ch_dbapi.dbapi_blobs"><h3><span class="title">Updating BLOBs Using Cursors</span></h3><p>It is recommended to update BLOBs using cursors, because no additional connections are opened and this is the only way to work with ODBC drivers.</p><pre><span class="nctnt-pre ncbi-code">ICursor *blobCur = conn-&gt;CreateCursor("test",<br />             "select id, blob from BlobSample for update of blob");<br />IResultSet *blobRs = blobCur-&gt;Open();<br />while(blobRs-&gt;Next()) {<br />    ostream&amp; out = blobCur-&gt;GetBlobOStream(2, blob.size());<br />    out.write(buf, blob.size());<br />    out.flush();<br />}</span></pre><p>Note that <span class="nctnt ncbi-func">GetBlobOStream()</span> takes the column number as the first argument and this call is invalid until the cursor is open.</p></div><div class="sec" id="ch_dbapi.dbapi_bulk_insert"><h3><span class="title">Using Bulk Insert</span></h3><p>Bulk insert is useful when it is necessary to insert big amounts of data. The <span class="nctnt ncbi-func">IConnection::CreateBulkInsert()</span> takes two parameters, the table name and number of columns. The <span class="nctnt ncbi-func">CVariant::Truncate(size_t len)</span> method truncates the internal buffer of CDB_Text and CDB_Image object from the end of the buffer. If no parameter specified, it erases the whole buffer.</p><pre><span class="nctnt-pre ncbi-code">NcbiCout &lt;&lt; "Initializing BlobSample table..." &lt;&lt; NcbiEndl;<br />string im = ......;<br />IBulkInsert *bi = conn-&gt;CreateBulkInsert("BlobSample", 2);<br />CVariant col1 = CVariant(eDB_Int);<br />CVariant col2 = CVariant(eDB_Text);<br />bi-&gt;Bind(1, &amp;col1);<br />bi-&gt;Bind(2, &amp;col2);<br />for(int i = 0; i &lt; ROWCOUNT; ++i ) {<br />    string im = "BLOB data " + NStr::IntToString(i);<br />    col1 = i;<br />    col2.Truncate();<br />    col2.Append(im.c_str(), im.size());<br />    bi-&gt;AddRow();<br />}<br />bi-&gt;Complete();<br /></span></pre><p>Related sample code:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_bcp.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_bcp.cpp</a></p></li></ul></div><div class="sec" id="ch_dbapi.dbapi_diag"><h3><span class="title">Diagnostic Messages</span></h3><p>The DBAPI library is integrated with the C++ Toolkit diagnostic and tracing facility. By default all client and server messages are handled by the Toolkit's standard message handler. However it is possible to redirect the DBAPI-specific messages to a single <span class="nctnt ncbi-class">CDB_MultiEx</span> object and retrieve them later at any time. There are two types of redirection, per data source and per connection. The redirection from a data source is enabled by calling <span class="nctnt ncbi-func">IDataSource::SetLogStream(0)</span>. After the call all client- and context-specific messages will be stored in the <span class="nctnt ncbi-func">IDataSource</span> object. The <span class="nctnt ncbi-func">IDataSource::GetErrorInfo()</span> method will return the string representation of all accumulated messages and clean up the storage. The <span class="nctnt ncbi-func">IDataSource::GetErrorAsEx()</span> will return a pointer to the underlying <span class="nctnt ncbi-class">CDB_MultiEx</span> object. Retrieving information and cleaning up is left to the developer. Do NOT delete this object. The connection-specific redirection is controlled by calling <span class="nctnt ncbi-func">IConnection::MsgToEx(boolean enable)</span> method. This redirection is useful; for instance, to temporarily disable default messages from the database server. The <span class="nctnt ncbi-func">IConnection::GetErrorInfo()</span> and <span class="nctnt ncbi-func">IConnection::GetErrorAsEx()</span> methods work in the same manner as for the <span class="nctnt ncbi-func">IDataSource</span></p><p>Related sample code:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_msg.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_msg.cpp</a></p></li></ul></div><div class="sec" id="ch_dbapi.dbapi_trace"><h3><span class="title">Trace Output</span></h3><p>The DBAPI library uses the Toolkit-wide DIAG_TRACE environment variable to do the debug output. To enable it set it to any value. If you have any problems with the DBAPI please include the trace output into your email.</p></div></div><div class="sec" id="ch_dbapi.dbapi_driver_ref"><h2><span class="title">NCBI DBAPI Driver Reference</span></h2><p>(Low-level access to the various RDBMSs.)</p><ul><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_driver_ref">NCBI DBAPI Driver Reference</a></p><ul><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_drvr_overview">Overview</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_drvr_arch">The driver architecture</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_sample_prog">Sample program</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_errors">Error handling</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_context">Driver context and connections</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_drvr_mgr">Driver Manager</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_txt_img">Text and Image Data Handling</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_results">Results loop</a></p></li></ul></li></ul><div class="sec" id="ch_dbapi.dbapi_drvr_overview"><h3><span class="title">Overview</span></h3><p>The NCBI DBAPI driver library describes and implements a set of objects needed to provide a uniform low-level access to the various relational database management systems (RDBMS). The basic driver functionality is the same as in most other RDBMS client APIs. It allows opening a connection to a server, executing a command (query) on this connection and getting the results back. The main advantage of using the driver is that you don't have to change your own upper-level code if you need to move from one RDBMS client API to another.</p><p>The driver can use two different methods to access the particular RDBMS. If the RDBMS provides a client library for the given computer system (e.g. Sun/Solaris), then the driver uses that library. If no such client library exists, then the driver connects to an RDBMS through a special gateway server which is running on a computer system where such a library does exist.</p></div><div class="sec" id="ch_dbapi.dbapi_drvr_arch"><h3><span class="title">The driver architecture</span></h3><p>There are two major groups of the driver's objects: the RDBMS-independent objects, and the objects which are specific to a particular RDBMS. The only RDBMS-specific object which user should be aware of is a "Driver Context". The "Driver Context" is effectively a "Connection" factory. The only way to make a connection to the server is to call the <span class="nctnt ncbi-func">Connect()</span> method of a "Driver Context" object. So, before doing anything with an RDBMS, you need to create at least one driver context object. All driver contexts implement the same interface defined in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classI__DriverContext.html">I_DriverContext</a> class. If you are working on a library which could be used with more than one RDBMS, the driver context should not be created by the library. Instead, the library API should include a pointer to <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=I_DriverContext&amp;d=C">I_DriverContext</a> so an existing driver context can be passed in.</p><p>There is no "real" factory for driver contexts because it's not always possible to statically link the RDBMS libraries from different vendors into the same binary. Most of them are written in C and name collisions do exist. The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=C_DriverMgr&amp;d=C">Driver Manager</a> helps to overcome this problem. It allows creating a mixture of statically linked and dynamically loaded drivers and using them together in one executable.</p><p>The driver context creates the connection which is RDBMS-specific, but before returning it to the caller it puts it into an RDBMS-independent "envelope", <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Connection.html">CDB_Connection</a>. The same is true for the commands and for the results - the user gets the pointer to the RDBMS-independent "envelope object" instead of the real one. It is the caller's responsibility to delete those objects. The life spans of the real object and the envelope object are not necessarily the same.</p><p>Once you have the connection object, you could use it as a factory for the different types of commands. The command object in turn serves as a factory for the results. The connection is always single threaded, that means that you have to execute the commands and process their results sequentially one by one. If you need to execute the several commands in parallel, you can do it using multiple connections.</p><p>Another important part of the driver is error and message handling. There are two different mechanisms implemented. The first one is exceptions. All exceptions which could be thrown by the driver are inherited from the single base class <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Exception.html">CDB_Exception</a>. Drivers use the exception mechanism whenever possible, but in many cases the underlying client library uses callbacks or handlers to report error messages rather than throwing exceptions. The driver supplies a handler's stack mechanism to manage these cases.</p><p>To send and to receive the data through the driver you have to use the driver provided datatypes. The collection of the datatypes includes: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__TinyInt.html">one</a>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__SmallInt.html">two</a>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Int.html">four</a> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__BigInt.html">eight</a> byte integers; <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Float.html">float</a> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Double.html">double</a>; <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Numeric.html">numeric</a>; <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Char.html">char</a>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__VarChar.html">varchar</a>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Binary.html">binary</a>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__VarBinary.html">varbinary</a>; <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__DateTime.html">datetime</a> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__SmallDateTime.html">smalldatetime</a>; <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Text.html">text</a> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Image.html">image</a>. All datatypes are derived from a single base class <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Object.html">CDB_Object</a>.</p></div><div class="sec" id="ch_dbapi.dbapi_sample_prog"><h3><span class="title">Sample program</span></h3><p>This program opens one connection to the server and selects the database names and the date when each database was created (assuming that table "sysdatabases" does exist). In this example the string "XXX" should be replaced with the real driver name.</p><pre><span class="nctnt-pre ncbi-code">#include &lt;iostream&gt;<br />#include &lt;dbapi/driver/public.hpp&gt;<br />#include &lt;dbapi/driver/exception.hpp&gt;<br />/* Here, XXXlib has to be replaced with the real name, e.g. "ctlib" */<br />#include &lt;dbapi/driver/XXXlib/interfaces.hpp&gt;<br />USING_NCBI_SCOPE;<br />int main()<br />{<br />    try { // to be sure that we are catching all driver related exceptions<br />        // We need to create a driver context first<br />        // In real program we have to replace CXXXContext with something real<br />        CXXXContext my_context;<br />        // connecting to server "MyServer"<br />        // with user name "my_user_name" and password "my_password"<br />        CDB_Connection* con = my_context.Connect("MyServer", "my_user_name",<br />                                                 "my_password", 0);<br />        // Preparing a SQL query<br />        CDB_LangCmd* lcmd =<br />            con-&gt;LangCmd("select name, crdate from sysdatabases");<br />        // Sending this query to a server<br />        lcmd-&gt;Send();<br />        CDB_Char dbname(64);<br />        CDB_DateTime crdate;<br />        // the result loop<br />        while(lcmd-&gt;HasMoreResults()) {<br />            CDB_Result* r= lcmd-&gt;Result();<br />            // skip all but row result<br />            if (r == 0  ||  r-&gt;ResultType() != eDB_RowResult) {<br />                delete r;<br />                continue;<br />            }<br />            // printing the names of selected columns<br />            NcbiCout &lt;&lt; r-&gt;ItemName(0) &lt;&lt; " \t\t\t"<br />                     &lt;&lt; r-&gt;ItemName(1) &lt;&lt; NcbiEndl;<br />            // fetching the rows<br />            while ( r-&gt;Fetch() ) {<br />                r-&gt;GetItem(&amp;dbname); // get the database name<br />                r-&gt;GetItem(&amp;crdate); // get the creation date<br />                NcbiCout &lt;&lt; dbname.Value() &lt;&lt; ' '<br />                         &lt;&lt; crdate.Value().AsString("M/D/Y h:m")<br />                         &lt;&lt; NcbiEndl;<br />            }<br />            delete r; // we don't need this result anymore<br />        }<br />        delete lcmd; // delete the command<br />        delete con;  // delete the connection<br />    }<br />    catch (CDB_Exception&amp; e) { // printing the error messages<br />        CDB_UserHandler_Stream myExHandler(&amp;cerr);<br />        myExHandler.HandleIt(&amp;e);<br />    }<br />}</span></pre></div><div class="sec" id="ch_dbapi.dbapi_errors"><h3><span class="title">Error handling</span></h3><p>Error handling is almost always a pain when you are working with an RDBMS because different systems implement different approaches. Depending on the system, you can get error messages through return codes, callbacks, handlers, and/or exceptions. These messages could have different formats. It could be just an integer (error code), a structure, or a set of callback's arguments. The NCBI DBAPI driver intercepts all those error messages in all different formats and converts them into various types of objects derived from <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Exception.html">CDB_Exception</a>.</p><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Exception.html">CDB_Exception</a> provides the following methods for all exceptions:</p><ul><li><p><span class="nctnt ncbi-func">GetDBErrCode()</span> - returns the integer code for this message (assigned by SQL server).</p></li><li><p><span class="nctnt ncbi-func">SeverityString(void)</span> - returns the severity string of this message (assigned by SQL server).</p></li><li><p><span class="nctnt ncbi-func">GetErrCodeString()</span> - returns the name for this error code (e.g. "eSQL").</p></li><li><p><span class="nctnt ncbi-func">Type()</span> - returns the type value for this exception type (e.g. eSQL).</p></li><li><p><span class="nctnt ncbi-func">TypeString()</span> - returns the type string for this exception type (e.g. "eSQL"). This is a pass-through to <span class="nctnt ncbi-func">CException::GetType()</span>.</p></li><li><p><span class="nctnt ncbi-func">ErrCode()</span> - alias for <span class="nctnt ncbi-func">GetDBErrCode()</span>.</p></li><li><p><span class="nctnt ncbi-func">Message()</span> - returns the error message itself. This is a pass-through to <span class="nctnt ncbi-func">CException::GetMsg()</span>.</p></li><li><p><span class="nctnt ncbi-func">OriginatedFrom()</span> - returns the SQL server name. This is a pass-through to <span class="nctnt ncbi-func">CException::GetModule()</span>.</p></li><li><p><span class="nctnt ncbi-func">SetServerName()</span> - sets the SQL server name.</p></li><li><p><span class="nctnt ncbi-func">GetServerName()</span> - returns the SQL server name.</p></li><li><p><span class="nctnt ncbi-func">SetUserName()</span> - sets the SQL user name.</p></li><li><p><span class="nctnt ncbi-func">GetUserName()</span> - returns the SQL user name.</p></li><li><p><span class="nctnt ncbi-func">SetExtraMsg()</span> - sets extra message text to be included in the message output.</p></li><li><p><span class="nctnt ncbi-func">GetExtraMsg()</span> - gets the extra message text.</p></li><li><p><span class="nctnt ncbi-func">SetSybaseSeverity()</span> - sets the severity value for a Sybase exception - <span class="nctnt highlight">N.B.</span> Sybase severity values can be provided for Sybase/FreeTDS ctlib/dblib drivers only.</p></li><li><p><span class="nctnt ncbi-func">GetSybaseSeverity()</span> - gets the severity value for a Sybase exception - <span class="nctnt highlight">N.B.</span> Sybase severity values can be provided by Sybase/FreeTDS ctlib/dblib drivers only.</p></li><li><p><span class="nctnt ncbi-func">ReportExtra()</span> - outputs any extra text to the supplied stream.</p></li><li><p><span class="nctnt ncbi-func">Clone()</span> - creates a new exception based on this one.</p></li></ul><p><span class="nctnt highlight">N.B.</span> The following <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Exception.html">CDB_Exception</a> methods are deprecated:</p><ul><li><p><span class="nctnt ncbi-func">Severity()</span> - returns the severity value of this message (assigned by SQL server).</p></li><li><p><span class="nctnt ncbi-func">SeverityString(EDB_Severity sev)</span> - returns the severity string of this message (assigned by SQL server).</p></li></ul><p>The DBAPI driver may throw any of the following types derived from <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Exception.html">CDB_Exception</a>:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__SQLEx.html">CDB_SQLEx</a> This type is used if an error message has come from a SQL server and indicates an error in a SQL query. It could be a wrong table or column name or a SQL syntax error. This type provides the additional methods:</p><ul><li><p><span class="nctnt ncbi-func">BatchLine()</span> - returns the line number in the SQL batch that generated the error.</p></li><li><p><span class="nctnt ncbi-func">SqlState()</span> - returns a byte string describing an error (it's not useful most of the time).</p></li></ul></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__RPCEx.html">CDB_RPCEx</a> An error message has come while executing an RPC or stored procedure. This type provides the additional methods:</p><ul><li><p><span class="nctnt ncbi-func">ProcName()</span> - returns the procedure name where the exception originated.</p></li><li><p><span class="nctnt ncbi-func">ProcLine()</span> - returns the line number within the procedure where the exception originated.</p></li></ul></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__DeadlockEx.html">CDB_DeadlockEx</a> An error message has come as a result of a deadlock.</p></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__DSEx.html">CDB_DSEx</a> An error has come from an RDBMS and is not related to a SQL query or RPC.</p></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__TimeoutEx.html">CDB_TimeoutEx</a> An error message has come due to a timeout.</p></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__ClientEx.html">CDB_ClientEx</a> An error message has come from the client side.</p></li></ul><p>Drivers use two ways to deliver an error message object to an application. If it is possible to throw an exception, then the driver throws the error message object. If not, then the driver calls the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__UserHandler.html">user's error handler</a> with a pointer to the error message object as an argument. It's not always convenient to process all types of error messages in one error handler. Some users may want to use a special error message handler inside some function or block and a default error handler outside. To accommodate these cases the driver provides a <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CDBHandlerStack&amp;d=C">handler stack mechanism</a>. The top handler in the stack gets the error message object first. If it knows how to deal with this message, then it processes the message and returns <span class="nctnt ncbi-monospace">true</span>. If handler wants to pass this message to the other handlers, then it returns <span class="nctnt ncbi-monospace">false</span>. So, the driver pushes the error message object through the stack until it gets <span class="nctnt ncbi-monospace">true</span> from the handler. The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__UserHandler__Stream.html">default driver's error handler</a>, which just prints the error message to <span class="nctnt ncbi-var">stderr</span>, is always on the bottom of the stack.</p><p>Another tool which users may want to use for error handling is the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__MultiEx.html">CDB_MultiEx</a> object. This tool allows collecting multiple <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Exception.html">CDB_Exception</a> objects into one container and then throwing the container as one exception object.</p></div><div class="sec" id="ch_dbapi.dbapi_context"><h3><span class="title">Driver context and connections</span></h3><p>Every program which is going to work with an NCBI DBAPI driver should create at least one Driver Context object first. The main purpose of this object is to be a Connection factory, but it's a good idea to customize this object prior to opening a connection. The first step is to setup two message handler stacks. The first one is for error messages which are not bound to some particular connection or could occur inside the <span class="nctnt ncbi-func">Connect()</span> method. Use <span class="nctnt ncbi-func">PushCntxMsgHandler()</span> to populate it. The other stack serves as an initial message handler stack for all connections which will be derived from this context. Use <span class="nctnt ncbi-func">PushDefConnMsgHandler()</span> method to populate this stack. The second step of customization is setting timeouts. The <span class="nctnt ncbi-func">SetLoginTimeout()</span> and <span class="nctnt ncbi-func">SetTimeout()</span> methods do the job. If you are going to work with text or image objects in your program, you need to call <span class="nctnt ncbi-func">SetMaxTextImageSize()</span> to define the maximum size for such objects. Objects which exceed this limit could be truncated.</p><pre><span class="nctnt-pre ncbi-code">class CMyHandlerForConnectionBoundErrors : public CDB_UserHandler<br />{<br />    virtual bool HandleIt(CDB_Exception* ex);<br />    ...<br />};<br />class CMyHandlerForOtherErrors : public CDB_UserHandler<br />{<br />    virtual bool HandleIt(CDB_Exception* ex);<br />    ...<br />};<br />...<br />int main()<br />{<br />    CMyHandlerForConnectionBoundErrors conn_handler;<br />    CMyHandlerForOtherErrors           other_handler;<br />    ...<br />    try { // to be sure that we are catching all driver related exceptions<br />        // We need to create a driver context first<br />        // In real program we have to replace CXXXContext with something real<br />        CXXXContext my_context;<br />        my_context.PushCntxMsgHandler(&amp;other_handler);<br />        my_context.PushDefConnMsgHandler(&amp;conn_handler);<br />        // set timeouts (in seconds) and size limits (in bytes):<br />        my_context.SetLoginTimeout(10); // for logins<br />        my_context.SetTimeout(15);      // for client/server communications<br />        my_context.SetMaxTextImageSize(0x7FFFFFFF); // text/image size limit<br />        ...<br />        CDB_Connection* my_con =<br />            my_context.Connect("MyServer", "my_user_name", "my_password",<br />                               I_DriverContext::fBcpIn);<br />        ...<br />    }<br />    catch (CDB_Exception&amp; e) {<br />        other_handler.HandleIt(&amp;e);<br />    }<br />}</span></pre><p>The only way to get a connection to a server in an NCBI DBAPI driver is through a <span class="nctnt ncbi-func">Connect()</span> method in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classI__DriverContext.html">driver context</a>. The first three arguments: server name, user name and password are obvious. Values for <span class="nctnt ncbi-var">mode</span> are constructed by a bitwise-inclusive-OR of flags defined in EConnectionMode. If <span class="nctnt ncbi-var">reusable</span> is <span class="nctnt ncbi-monospace">false</span>, then driver creates a new connection which will be destroyed as soon as user delete the correspondent <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CDB_Connection&amp;d=C">CDB_Connection</a> (the <span class="nctnt ncbi-var">pool_name</span> is ignored in this case).</p><p>Opening a connection to a server is an expensive operation. If program opens and closes connections to the same server multiple times it worth calling the <span class="nctnt ncbi-func">Connect()</span> method with <span class="nctnt ncbi-var">reusable</span> set to <span class="nctnt ncbi-monospace">true</span>. In this case driver does not close the connection when the correspondent CDB_Connection is deleted, but keeps it around in a "recycle bin". Every time an application calls the <span class="nctnt ncbi-func">Connect()</span> method with <span class="nctnt ncbi-var">reusable</span> set to <span class="nctnt ncbi-monospace">true</span>, driver tries to satisfy the request from a "recycle bin" first and opens a new connection only if necessary.</p><p>The <span class="nctnt ncbi-var">pool_name</span> argument is just an arbitrary string. An application could use this argument to assign a name to one or more connections (to create a connection pool) or to invoke a connection by name from this pool.</p><pre><span class="nctnt-pre ncbi-code">...<br />// Create a pool of four connections (two to one server and two to another)<br />// with the default database "DatabaseA"<br />CDB_Connection* con[4];<br />int i;<br />for (i = 4;  i--; ) {<br />    con[i]= my_context.Connect((i%2 == 0) ? "MyServer1" : "MyServer2",<br />                               "my_user_name", "my_password", 0, true,<br />                               "ConnectionPoolA");<br />    CDB_LangCmd* lcmd= con[i]-&gt;LangCmd("use DatabaseA");<br />    lcmd-&gt;Send();<br />    while(lcmd-&gt;HasMoreResults()) {<br />        CDB_Result* r = lcmd-&gt;Result();<br />        delete r;<br />    }<br />    delete lcmd;<br />}<br />// return all connections to a "recycle bin"<br />for(i= 0; i &lt; 4; delete con_array[i++]);<br />...<br />// in some other part of the program<br />// we want to get a connection from "ConnectionPoolA"<br />// but we don't want driver to open a new connection if pool is empty<br />try {<br />    CDB_Connection* my_con= my_context.Connect("", "", "", 0, true,<br />                                               "ConnectionPoolA");<br />    // Note that server name, user name and password are empty<br />    ...<br />}<br />catch (CDB_Exception&amp; e) {<br />    // the pool is empty<br />    ...<br />}</span></pre><p>An application could combine in one pool the connections to the different servers. This mechanism could also be used to group together the connections with some particular settings (default database, transaction isolation level, etc.).</p></div><div class="sec" id="ch_dbapi.dbapi_drvr_mgr"><h3><span class="title">Driver Manager</span></h3><p>It's not always known which NCBI DBAPI driver will be used by a particular program. Sometimes you want a driver to be a parameter in your program. Sometimes you need to use two different drivers in one binary but can not link them statically because of name collisions. Sometimes you just need the driver contexts factory. The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=C_DriverMgr&amp;d=C">Driver Manager</a> is intended to solve these problems.</p><p>Let's rewrite our <a href="ch_dbapi.html#ch_dbapi.dbapi_sample_prog">Sample program</a> using the <span class="nctnt ncbi-monospace">Driver Manager</span>. The original text was.</p><pre><span class="nctnt-pre ncbi-code">#include &lt;iostream&gt;<br />#include &lt;dbapi/driver/public.hpp&gt;<br />#include &lt;dbapi/driver/exception.hpp&gt;<br />/* Here, XXXlib has to be replaced with the real name, e.g. "ctlib" */<br />#include &lt;dbapi/driver/XXXlib/interfaces.hpp&gt;<br />USING_NCBI_SCOPE;<br />int main()<br />{<br />    try { // to be sure that we are catching all driver related exceptions<br />        // We need to create a driver context first<br />        // In real program we have to replace CXXXContext with something real<br />        CXXXContext my_context;<br />        // connecting to server "MyServer"<br />        // with user name "my_user_name" and password "my_password"<br />        CDB_Connection* con = my_context.Connect("MyServer", "my_user_name",<br />                                                 "my_password", 0);<br />        ...</span></pre><p>If we use the <span class="nctnt ncbi-monospace">Driver Manager</span> we could allow the driver name to be a program argument.</p><pre><span class="nctnt-pre ncbi-code">#include &lt;iostream&gt;<br />#include &lt;dbapi/driver/public.hpp&gt;<br />#include &lt;dbapi/driver/exception.hpp&gt;<br />#include &lt;dbapi/driver/driver_mgr.hpp&gt; // this is a new header<br />USING_NCBI_SCOPE;<br />int main(int argc, const char* argv[])<br />{<br />    try { // to be sure that we are catching all driver related exceptions<br />        C_DriverMgr drv_mgr;<br />        // We need to create a driver context first<br />        I_DriverContext* my_context= drv_mgr.GetDriverContext(<br />                                        (argc &gt; 1)? argv[1] : "ctlib");<br />        // connecting to server "MyServer"<br />        // with user name "my_user_name" and password "my_password"<br />        CDB_Connection* con = my_context-&gt;Connect("MyServer", "my_user_name",<br />                                                 "my_password", 0);<br />        ...</span></pre><p>This fragment creates an instance of the <span class="nctnt ncbi-monospace">Driver Manager</span>, dynamically loads the driver's library, implicitly registers this driver, creates the driver context and makes a connection to a server. If you don't want to load some drivers dynamically for any reason, but want to use the <span class="nctnt ncbi-monospace">Driver Manager</span> as a driver contexts factory, then you need to statically link your program with those libraries and explicitly register those using functions from <span class="nctnt ncbi-path">dbapi/driver/drivers.hpp</span> header.</p></div><div class="sec" id="ch_dbapi.dbapi_txt_img"><h3><span class="title">Text and Image Data Handling</span></h3><p><span class="nctnt ncbi-type">text</span> and <span class="nctnt ncbi-type">image</span> are SQL datatypes and can hold up to 2Gb of data. Because they could be huge, the RDBMS keeps these values separately from the other data in the table. In most cases the table itself keeps just a special pointer to a text/image value and the actual value is stored separately. This creates some difficulties for text/image data handling.</p><p>When you retrieve a large text/image value, you often prefer to "stream" it into your program and process it chunk by chunk rather than get it as one piece. Some RDBMS clients allow to stream the text/image values only if a corresponding column is the only column in a select statement.</p><p>Let's suppose that you have a table T (i_val int, t_val text) and you need to select all i_val, t_val where i_val &gt; 0. The simplest way is to use a query:</p><pre><span class="nctnt-pre ncbi-code">select i_val, t_val from T where i_val &gt; 0</span></pre><p>But it could be expensive. Because two columns are selected, some clients will put the whole row in a buffer prior to giving access to it to the user. The better way to do this is to use two selects:</p><pre><span class="nctnt-pre ncbi-code">select i_val from T where i_val &gt; 0<br />select t_val from T where i_val &gt; 0</span></pre><p>Looks ugly, but could save you a lot of memory.</p><p>Updating and inserting the text/image data is also not a straightforward process. For small texts and images it is possible to use just SQL <span class="nctnt ncbi-code">insert</span> and <span class="nctnt ncbi-code">update</span> statements, but it will be inefficient (if possible at all) for the large ones. The better way to insert and update text and image columns is to use the <span class="nctnt ncbi-func">SendData()</span> method of the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CDB_Connection&amp;d=C">CDB_Connection</a> object or to use the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CDB_SendDataCmd&amp;d=C">CDB_SendDataCmd</a> object.</p><p>The recommended algorithm for inserting text/image data is:</p><ul><li><p>Use a SQL <span class="nctnt ncbi-code">insert</span> statement to insert a new row into the table. Use a space value (<span class="nctnt ncbi-monospace">' '</span>) for each text column and a zero value (<span class="nctnt ncbi-monospace">0x0</span>) for each image column you are going to populate. Use <span class="nctnt ncbi-var">NULL</span> only if the value will remain <span class="nctnt ncbi-var">NULL</span>.</p></li><li><p>Use a SQL <span class="nctnt ncbi-code">select</span> statement to select all text/image columns from this row.</p></li><li><p>Fetch the row result and get an <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classI__ITDescriptor.html">I_ITDescriptor</a> for each column.</p></li><li><p>Finish the results loop.</p></li><li><p>Use the <span class="nctnt ncbi-func">SendData()</span> method or <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__SendDataCmd.html">CDB_SendDataCmd</a> object to populate the columns.</p></li></ul><p><span class="nctnt highlight">Example</span></p><p>Let's suppose that we want to insert a new row into table T as described above.</p><pre><span class="nctnt-pre ncbi-code">CDB_Connection* con;<br />...<br />// preparing the query<br />CDB_LangCmd* lcmd= con-&gt;LangCmd("insert T (i_val, t_val) values(100, ' ')\n");<br />lcmd-&gt;More("select t_val from T where i_val = 100");<br />// Sending this query to a server<br />lcmd-&gt;Send();<br />I_ITDescriptor* my_descr;<br />// the result loop<br />while(lcmd-&gt;HasMoreResults()) {<br />    CDB_Result* r= lcmd-&gt;Result();<br />    // skip all but row result<br />    if (r == 0  ||  r-&gt;ResultType() != eDB_RowResult) {<br />        delete r;<br />        continue;<br />    }<br />    // fetching the row<br />    while(r-&gt;Fetch()) {<br />        // read 0 bytes from the text (some clients need this trick)<br />        r-&gt;ReadItem(0, 0);<br />        my_deskr = r-&gt;GetImageOrTextDescriptor();<br />    }<br />    delete r; // we don't need this result anymore<br />}<br />delete lcmd; // delete the command<br />CDB_Text my_text;<br />my_text.Append("This is a text I want to insert");<br />//sending the text<br />con-&gt;SendData(my_descr, my_text);<br />delete my_descr; // we don't need this descriptor anymore<br />...</span></pre><p>The recommended algorithm for updating the text/image data is:</p><ul><li><p>Use a SQL <span class="nctnt ncbi-code">update</span> statement to replace the current value with a space value (<span class="nctnt ncbi-monospace">' '</span>) for a text column and a zero value (<span class="nctnt ncbi-monospace">0x0</span>) for an image column.</p></li><li><p>Use a SQL <span class="nctnt ncbi-code">select</span> statement to select all text/image columns you want to update in this row.</p></li><li><p>Fetch the row result and get an <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classI__ITDescriptor.html">I_ITDescriptor</a> for each column.</p></li><li><p>Finish the results loop.</p></li><li><p>Use the <span class="nctnt ncbi-func">SendData()</span> method or the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__SendDataCmd.html">CDB_SendDataCmd</a> object to populate the columns.</p></li></ul><p><span class="nctnt highlight">Example</span></p><pre><span class="nctnt-pre ncbi-code">CDB_Connection* con;<br />...<br />// preparing the query<br />CDB_LangCmd* lcmd= con-&gt;LangCmd("update T set t_val= ' ' where i_val =  100");<br />lcmd-&gt;More("select t_val from T where i_val = 100");<br />// Sending this query to a server<br />lcmd-&gt;Send();<br />I_ITDescriptor* my_descr;<br />// the result loop<br />while(lcmd-&gt;HasMoreResults()) {<br />    CDB_Result* r= lcmd-&gt;Result();<br />    // skip all but row result<br />    if (r == 0  ||  r-&gt;ResultType() != eDB_RowResult) {<br />        delete r;<br />        continue;<br />    }<br />    // fetching the row<br />    while(r-&gt;Fetch()) {<br />        // read 0 bytes from the text (some clients need this trick)<br />        r-&gt;ReadItem(0, 0);<br />        my_deskr = r-&gt;GetImageOrTextDescriptor();<br />    }<br />    delete r; // we don't need this result anymore<br />}<br />delete lcmd; // delete the command<br />CDB_Text my_text;<br />my_text.Append("This is a text I want to see as an update");<br />//sending the text<br />con-&gt;SendData(my_descr, my_text);<br />delete my_descr; // we don't need this descriptor anymore<br />...</span></pre></div><div class="sec" id="ch_dbapi.dbapi_results"><h3><span class="title">Results loop</span></h3><p>Each connection in the NCBI DBAPI driver is always single threaded. Therefore, applications have to retrieve all the results from a current command prior to executing a new one. Not all results are meaningful (i.e. an RPC always returns a status result regardless of whether or not a procedure has a return statement), but all results need to be retrieved. The following loop is recommended for retrieving results from all types of commands:</p><pre><span class="nctnt-pre ncbi-code">CDB_XXXCmd* cmd; // XXX could be Lang, RPC, etc.<br />...<br />while (cmd-&gt;HasMoreResults()) {<br />        // HasMoreResults() method returns true        // if the Result() method needs to be called.<br />        // It doesn't guarantee that Result() will return not NULL result<br />   CDB_Result* res = cmd-&gt;Result();<br />   if (res == 0)<br />       continue; // a NULL res doesn't mean that there is no more results<br />   switch(res-&gt;ResultType()) {<br />      case eDB_RowResult: // row result<br />          while(res-&gt;Fetch()) {<br />             ...<br />          }<br />          break;<br />      case eDB_ParamResult: // Output parameters<br />          while(res-&gt;Fetch()) {<br />             ...<br />          }<br />          break;<br />      case eDB_ComputeResult: // Compute result<br />          while(res-&gt;Fetch()) {<br />             ...<br />          }<br />          break;<br />      case eDB_StatusResult: // Status result<br />          while(res-&gt;Fetch()) {<br />             ...<br />          }<br />          break;<br />      case eDB_CursorResult: // Cursor result<br />          while(res-&gt;Fetch()) {<br />             ...<br />          }<br />          break;<br />   }<br />   delete res;<br />}</span></pre><p>If you don't want to process some particular type of result, just skip the <span class="nctnt ncbi-code">while (res-&gt;Fetch()){...}</span> in the corresponding <span class="nctnt ncbi-code">case</span>.</p></div></div><div class="sec" id="ch_dbapi.dbapi_drivers"><h2><span class="title">Supported DBAPI drivers</span></h2><ul><li><p><a href="ch_dbapi.html#ch_dbapi.free_tds64">FreeTDS (TDS ver. 7.0)</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_drvs_ctlib">Sybase CTLIB</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_drvs_dblib">Sybase DBLIB</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_drvrs_odbc">ODBC</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.mysql_driver">MySQL Driver</a></p></li></ul><div class="sec" id="ch_dbapi.free_tds64"><h3><span class="title">FreeTDS (TDS ver. 7.0)</span></h3><p>This driver is the most recommended, built-in, and portable.</p><ul><li><p>Registration function (for the manual, static registration) <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=DBAPI_RegisterDriver_FTDS&amp;d=f">DBAPI_RegisterDriver_FTDS()</a></p></li><li><p>Driver default name (for the run-time loading from a DLL) <span class="nctnt ncbi-lib">"ftds"</span>.</p></li><li><p>Driver library <span class="nctnt ncbi-lib">ncbi_xdbapi_ftds</span></p></li><li><p><span class="nctnt ncbi-monospace">FreeTDS</span> libraries and headers used by the driver <a href="ch_config.html#ch_config.ch_configlocalizatio">$(FTDS_LIBS)</a> <a href="ch_config.html#ch_config.ch_configlocalizatio">$(FTDS_INCLUDE)</a></p></li><li><p><span class="nctnt ncbi-monospace">FreeTDS</span>-specific driver context attributes "version", default = <span class="nctnt ncbi-monospace">&lt;DBVERSION_UNKNOWN&gt;</span> (also allowed: <span class="nctnt ncbi-monospace">"42"</span>, <span class="nctnt ncbi-monospace">"46"</span>, "70", "100")</p></li><li><p>FreeTDS works on UNIX and Windows platforms.</p></li><li><p>This driver supports Windows Domain Authentication using protocol NTLMv2, which is a default authentication protocol for Windows at NCBI.</p></li><li><p>This driver supports TDS protocol version auto-detection. TDS protocol version cannot be detected when connecting against Sybase Open Server.</p></li><li><p>Caveats</p></li></ul><p>Default version of the TDS protocol (&lt;DBVERSION_UNKNOWN&gt;) will work with MS SQL Server and Sybase SQL Server. If you want to work with Sybase Open server you should use TDS protocol version 4.6 or 5.0. This can be done either by using a driver parameter "version" equal either to "46" or to "50" or by setting an environment variable TDSVER either to "46" or to "50".</p><p>Although a slightly modified version of FreeTDS is now part of the C++ Toolkit, it retains its own license: the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/driver/ftds64/freetds/COPYING.LIB">GNU Library General Public License</a>.</p><p>TDS protocol version 4.2 should not be used with MS SQL server</p></div><div class="sec" id="ch_dbapi.dbapi_drvs_ctlib"><h3><span class="title">Sybase CTLIB</span></h3><ul><li><p>Registration function (for the manual, static registration) <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=DBAPI_RegisterDriver_CTLIB&amp;d=f">DBAPI_RegisterDriver_CTLIB()</a></p></li><li><p>Driver default name (for the run-time loading from a DLL) <span class="nctnt ncbi-monospace">"ctlib"</span></p></li><li><p>Driver library <span class="nctnt ncbi-lib">ncbi_xdbapi_ctlib</span></p></li><li><p><span class="nctnt ncbi-monospace">Sybase CTLIB</span> libraries and headers used by the driver (UNIX) <a href="ch_config.html#ch_config.ch_configlocalizatio">$(SYBASE_LIBS)</a> <a href="ch_config.html#ch_config.ch_configlocalizatio">$(SYBASE_INCLUDE)</a></p></li><li><p><span class="nctnt ncbi-monospace">Sybase CTLIB</span> libraries and headers used by the driver (MS Windows). You will need the Sybase OpenClient package installed on your PC. In MSVC++, set the "C/C++ / General / Additional Include Directories" and "Linker / General / Additional Library Directories" properties to the Sybase OpenClient headers and libraries (for example "C:\Sybase\include" and "C:\Sybase\lib" respectively). Also set the "Linker / Input / Additional Dependencies" property to include the needed Sybase OpenClient libraries: LIBCT.LIB LIBCS.LIB LIBBLK.LIB. To run the application, you must set environment variable <span class="nctnt ncbi-monospace">%SYBASE%</span> to the Sybase OpenClient root directory (e.g. "C:\Sybase"), and also to have your "interfaces" file there, in INI/sql.ini. In NCBI, we have the Sybase OpenClient libs installed in <span class="nctnt ncbi-path">\\snowman\win-coremake\Lib\ThirdParty\sybase</span>.</p></li><li><p>CTLIB-specific header (contains <span class="nctnt ncbi-monospace">non-portable</span> extensions) <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/dbapi/driver/ctlib/interfaces.hpp">dbapi/driver/ctlib/interfaces.hpp</a></p></li><li><p>CTLIB-specific driver context attributes "reuse_context" (default value is <span class="nctnt ncbi-monospace">"true"</span>), "version" (default value is <span class="nctnt ncbi-monospace">"125"</span>, also allowed <span class="nctnt ncbi-monospace">"100"</span> and <span class="nctnt ncbi-monospace">"110"</span>)</p></li><li><p>Caveats</p></li></ul><p>Cannot communicate with MS SQL server using any TDS version.</p></div><div class="sec" id="ch_dbapi.dbapi_drvs_dblib"><h3><span class="title">Sybase DBLIB</span></h3><ul><li><p>Registration function (for the manual, static registration) <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=DBAPI_RegisterDriver_DBLIB&amp;d=f">DBAPI_RegisterDriver_DBLIB()</a></p></li><li><p>Driver default name (for the run-time loading from a DLL) <span class="nctnt ncbi-monospace">"dblib"</span></p></li><li><p>Driver library <span class="nctnt ncbi-lib">dbapi_driver_dblib</span></p></li><li><p><span class="nctnt ncbi-monospace">Sybase DBLIB</span> libraries and headers used by the driver (UNIX) <a href="ch_config.html#ch_config.ch_configlocalizatio">$(SYBASE_DBLIBS)</a> <a href="ch_config.html#ch_config.ch_configlocalizatio">$(SYBASE_INCLUDE)</a></p></li><li><p><span class="nctnt ncbi-monospace">Sybase DBLIB</span> libraries and headers used by the driver (MS Windows) Libraries: LIBSYBDB.LIB. See Sybase OpenClient installation and usage instructions in the <a href="ch_dbapi.html#ch_dbapi.dbapi_drvs_ctlib">Sybase CTLIB</a> section (just above).</p></li><li><p>DBLIB-specific header (contains <span class="nctnt ncbi-monospace">non-portable</span> extensions) <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/dbapi/driver/dblib/interfaces.hpp">dbapi/driver/dblib/interfaces.hpp</a></p></li><li><p>DBLIB-specific driver context attributes "version" (default value is <span class="nctnt ncbi-monospace">"46"</span>, also allowed <span class="nctnt ncbi-monospace">"100"</span>)</p></li><li><p>Caveats</p></li></ul><p>Text/image operations fail when working with MS SQL server, because MS SQL server sends text/image length in the reverse byte order, and this cannot be fixed (as it was fixed for <a href="ch_dbapi.html#ch_dbapi.free_tds64">FreeTDS</a> ) as we do not have access to the DBLIB source code.</p><p>DB Library version level <span class="nctnt ncbi-monospace">"100"</span> is recommended for communication with Sybase server 12.5, because the default version level (<span class="nctnt ncbi-monospace">"46"</span>) is not working correctly with this server.</p></div><div class="sec" id="ch_dbapi.dbapi_drvrs_odbc"><h3><span class="title">ODBC</span></h3><ul><li><p>Registration function (for the manual, static registration) <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=DBAPI_RegisterDriver_ODBC&amp;d=f">DBAPI_RegisterDriver_ODBC()</a></p></li><li><p>Driver default name (for the run-time loading from a DLL) <span class="nctnt ncbi-monospace">"odbc"</span></p></li><li><p>Driver library <span class="nctnt ncbi-lib">dbapi_driver_odbc</span></p></li><li><p><span class="nctnt ncbi-monospace">ODBC</span> libraries and headers used by the driver (MS Windows) <span class="nctnt ncbi-lib">ODBC32.LIB ODBCCP32.LIB ODBCBCP.LIB</span></p></li><li><p><span class="nctnt ncbi-monospace">ODBC</span> libraries and headers used by the driver (UNIX) <a href="ch_config.html#ch_config.ch_configlocalizatio">$(ODBC_LIBS)</a><a href="ch_config.html#ch_config.ch_configlocalizatio">$(ODBC_INCLUDE)</a></p></li><li><p><span class="nctnt ncbi-monospace">ODBC</span>-specific header (contains <span class="nctnt ncbi-monospace">non-portable</span> extensions) <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/dbapi/driver/odbc/interfaces.hpp">dbapi/driver/odbc/interfaces.hpp</a></p></li><li><p><span class="nctnt ncbi-monospace">ODBC</span>-specific driver context attributes "version" (default value is <span class="nctnt ncbi-monospace">"3"</span>, also allowed <span class="nctnt ncbi-monospace">"2"</span>), "use_dsn" (default value is <span class="nctnt ncbi-monospace">false</span>, if you have set this attribute to <span class="nctnt ncbi-monospace">true</span>, you need to define your <span class="nctnt ncbi-monospace">data source</span> using <span class="nctnt ncbi-monospace">"Control Panel"/"Administrative Tools"/"Data Sources (ODBC)"</span>)</p></li><li><p>Caveats</p></li></ul><p>The <span class="nctnt ncbi-func">CDB_Result::GetImageOrTextDescriptor()</span> does not work for ODBC driver. You need to use <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CDB_ITDescriptor&amp;d=C">CDB_ITDescriptor</a> instead. The other way to deal with <span class="nctnt ncbi-type">texts/images</span> in ODBC is through the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CDB_CursorCmd&amp;d=C">CDB_CursorCmd</a> methods: <span class="nctnt ncbi-func">UpdateTextImage</span> and <span class="nctnt ncbi-func">SendDataCmd</span>.</p><p>On most NCBI PCs, there is an old header <span class="nctnt ncbi-path">odbcss.h</span> (from 4/24/1998) installed. The symptom is that although everything compiles just fine, however in the linking stage there are dozens of unresolved symbol errors for ODBC functions. Ask "pc.systems" to fix this for your PC.</p><p>On UNIX, it's only known to work with Merant's implementation of ODBC, and it has not been thoroughly tested or widely used, so surprises are possible.</p></div><div class="sec" id="ch_dbapi.mysql_driver"><h3><span class="title">MySQL Driver</span></h3><p>There is a direct (without ODBC) MySQL driver in the NCBI C++ Toolkit DBAPI. However, the driver implements a very minimal functionality and does not support the following:</p><ul><li><p>Working with images by chunks (images can be accessed as string fields though)</p></li><li><p>RPC</p></li><li><p>BCP</p></li><li><p>SendData functionality</p></li><li><p>Connection pools</p></li><li><p>Parameter binding</p></li><li><p>Canceling results</p></li><li><p>ReadItem</p></li><li><p>IsAlive</p></li><li><p>Refresh functions</p></li><li><p>Setting timeouts</p></li></ul></div></div><div class="sec" id="ch_dbapi.Major_Features_of_th"><h2><span class="title">Major Features of the BDB Library</span></h2><p>The BDB library provides tools for the development of specialized data storage in applications not having access to a centralized RDBMS.</p><ul><li><p><b>C++ wrapper on top of Berkeley DB.</b> The BDB library takes care of many of the ultra low-level details for C programmers using the Berkeley DB. The BDB implements B-Tree file access (both keyed and sequential), environments, cursors, and transactions.</p></li><li><p><b>Error checking.</b> All error codes coming from the Berkeley DB are analyzed and processed in a manner common to all other components of the C++ Toolkit. When an error situation is detected, the BDB library sends an exception that is reported by the diagnostic services and can be handled by the calling application, similar to any other Toolkit exception.</p></li><li><p><b>Support for relational table structure and different data types.</b> The Berkeley DB itself is “type agnostic” and provides no means to manipulate data types. But for many cases, clear data type support can save a lot of work. The Toolkit implements all major scalar data types so it can be used like a regular database.</p></li><li><p><b>Cross platform compatibility.</b> The BDB databases can be transferred across platforms without reconverting the data. The BDB tracks the fact that the database was created as big-endian or little-endian and does the conversion transparently when the database migrates.</p></li><li><p><b>Easy BLOBs.</b> The BDB library supports keyed BLOB storage. BLOBs can be streamed to and from the database. A set of additional interfaces has been written to simplify the BLOB access in comparison with the original Berkeley DB C library.</p></li><li><p><b>Disk-based cache interface.</b> The BDB library implements a cache disk cache service used by other Toolkit components to minimize client-server traffic and to store parts of the data locally. Different cache management and data expiration policies have been put in place.</p></li><li><p><b>Database maps.</b> The BDB library includes template classes similar to STL map and multimap but persistently stores the map content in the Berkeley DB files.</p></li><li><p><b>Simple queries.</b> The BDB library includes implementation of a simple query language to search records in flat files.</p></li></ul></div></div></div><div class="col four_col last"><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>In this page</h3></div></div><div class="portlet_content"><ul><li><a href="#ch_dbapi.dbapi_overview">DBAPI Overview</a></li><li><a href="#ch_dbapi.Security">Security</a></li><li><a href="#ch_dbapi.Simple_Database_Access_via_C">Simple Database Access via C++</a></li><li><a href="#ch_dbapi.Database_loadbalanci">Database Load-Balancing (DBLB)</a></li><li><a href="#ch_dbapi.dbapi_user_layer">NCBI DBAPI User-Layer Reference</a></li><li><a href="#ch_dbapi.dbapi_driver_ref">NCBI DBAPI Driver Reference</a></li><li><a href="#ch_dbapi.dbapi_drivers">Supported DBAPI drivers</a></li><li><a href="#ch_dbapi.Major_Features_of_th">Major Features of the BDB Library</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Download</h3></div></div><div class="portlet_content"><ul><li><a href="pdf/ch_dbapi.pdf">PDF version of this page</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Search</h3></div></div><div class="portlet_content"><form name="frmSymbolSearch" onsubmit="return SymbolSearch('toolkit')" action="/" id="frmSymbolSearch"><table><tbody><tr align="center" valign="middle"><td colspan="2" nowrap="nowrap"><input name="__symbol" size="22" style="vertical-align:                                          middle;" onkeypress="SymbolSearchKeyPress('toolkit',event)" type="text" />   <input value="Search" style="vertical-align: middle;" onclick="javasrcipt:SymbolSearch('toolkit');" type="button" /></td></tr><tr class="internal-only"><th style="text-align:left">Public</th><th style="text-align:left">Internal</th></tr><tr><td><input id="pToolkitAll" name="__symboloc" type="radio" checked="checked" /><span title="Search in the C/C++ source code and in this Book">All</span></td><td class="internal-only"><input id="iToolkitAll" name="__symboloc" type="radio" /><span title="Search in the C/C++ source code,  this Book, and Wiki">All</span></td></tr><tr><td><input id="pLXR" name="__symboloc" type="radio" /><span title="Search the symbol in the source code using LINUX Cross-Reference browser">LXR</span></td><td class="internal-only"><input id="iLXR" name="__symboloc" type="radio" /><span title="Search the symbol in the source code using LINUX Cross-Reference browser">LXR</span></td></tr><tr><td><input id="pLib" name="__symboloc" type="radio" /><span title="Locate the Toolkit library(es) where the symbol is defined">Library</span></td><td class="internal-only"><input id="iLib" name="__symboloc" type="radio" /><span title="Locate the Toolkit library(es) where the symbol is defined">Library</span></td></tr></tbody></table></form></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Source Browsers</h3></div></div><div class="portlet_content"><ul><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">LXR</a></li><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">Doxygen</a></li><li class="internal-only">LXR: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">public</a> / <a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lxr/ident">internal</a></li><li class="internal-only">Doxygen: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml">public</a> / <a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml">internal</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>SVN Source Repository</h3></div></div><div class="portlet_content"><ul><li><a href="http://www.ncbi.nlm.nih.gov/bookshelf/br.fcgi?book=toolkit&amp;part=ch_getcode_svn#ch_getcode_svn.code_retrieval">Server</a></li><li><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/c++">Web
                            (dev)</a></li><li><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/internal/c++">Web
                            (extra)</a></li><li><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/production/components">Web (prod)</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Resources</h3></div></div><div class="portlet_content"><ul><li class="internal-only"><a href="http://intranet.ncbi.nlm.nih.gov/wiki-private/CxxToolkit">Wiki</a></li><li class="internal-only"><a href="http://jira/browse/CXX">JIRA</a></li><li class="internal-only"><a href="http://intranet/ieb/ToolBox/STAT/test_stat/test_stat_ext.cgi"><span title="View results of testsuite runs on the automatic C++ Toolkit builds">Testsuite</span></a></li><li><a href="release_notes.html">Release Notes</a></li><li><a href="ch_getcode_svn.html#ch_getcode_svn.ftp_download">Download</a></li><li><a href="pdf/TOC.pdf">PDF of the book</a></li><li><a href="ch_style.html">Coding Style</a></li><li><a href="ch_faq.html#ch_faq.mailing_lists">Mailing Lists</a></li><li><a href="mailto:CPP-CORE@NCBI.NLM.NIH.GOV"><span title="Contact C++ Toolkit group">Help and Support</span></a></li></ul></div></div></div></div></div></div></body></html>
