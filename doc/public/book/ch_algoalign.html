<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Biological Sequence Alignment - The NCBI C++ Toolkit Book [Internet] - NCBI</title><meta name="description" content="A comprehensive manual on the NCBI C++ toolkit, including its design and development framework, a C++ library reference, software examples and demos, FAQs and release notes." /><meta name="robots" content="index,nofollow,noarchive" /><meta name="page_id" content="ch_algoalign" /><meta name="page_type" content="chapter" /><meta name="ncbipopper" content="triggerPosition:'bottom left',destPosition:'top left',openEvent:'click',closeEvent:'click'" /><script type="text/javascript" src="js/jig/1.7/js/jig.min.js"></script><script type="text/javascript" src="js/toolkitSymbolSearch.js"></script><link type="text/css" rel="stylesheet" href="css/ptbooks.css" /><link type="text/css" rel="stylesheet" href="css/toolkit.css" /></head><body><div class="grid no_max_width"><div class="col twelve_col nomargin shadow"><div class="content"><div class="col eight_col"><div class="nvgtn"><a href="#__nav_cntnt" class="jig-ncbipopper">Contents ▾</a><div style="display:none;width:700px;height:500px;overflow:auto;" id="__nav_cntnt"><a class="right" href="toc.html">Table of Contents Page</a><ul class="simple-list"><li class="half_rhythm"><a href="toolkit.fm.html">Book Information</a></li><li class="half_rhythm"><a href="part1.html">Part 1. Overview</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_intro.html">1. Introduction to the C++ Toolkit</a></li><li class="half_rhythm"><a href="ch_start.html">2. Getting Started</a></li></ul></li><li class="half_rhythm"><a href="part2.html">Part 2. Development Framework</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_getcode_svn.html">3. Retrieve the Source Code (FTP and Subversion)</a></li><li class="half_rhythm"><a href="ch_config.html">4. Configure, Build, and Use the Toolkit</a></li><li class="half_rhythm"><a href="ch_build.html">5. Working with Makefiles</a></li><li class="half_rhythm"><a href="ch_proj.html">6. Project Creation and Management</a></li><li class="half_rhythm"><a href="ch_style.html">7. Programming Policies and Guidelines</a></li></ul></li><li class="half_rhythm"><a href="part3.html">Part 3. C++ Toolkit Library Reference</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_core.html">8. Portability, Core Functionality and Application Framework</a></li><li class="half_rhythm"><a href="ch_conn.html">9. Networking and IPC</a></li><li class="half_rhythm"><a href="ch_dbapi.html">10. Database Access - SQL, Berkley DB</a></li><li class="half_rhythm"><a href="ch_cgi.html">11. CGI and Fast-CGI </a></li><li class="half_rhythm"><a href="ch_html.html">12. HTML</a></li><li class="half_rhythm"><a href="ch_ser.html">13. Data Serialization (ASN.1, XML)</a></li><li class="half_rhythm"><a href="ch_datamod.html">14. Biological Sequence Data Model</a></li><li class="half_rhythm"><a href="ch_objmgr.html">15. Biological Object Manager</a></li><li class="half_rhythm"><a href="ch_blast.html">16. BLAST API</a></li><li class="half_rhythm"><a href="ch_dataaccess.html">17. Access to NCBI data</a></li><li class="half_rhythm"><a href="ch_algoalign.html">18. Biological Sequence Alignment</a></li><li class="half_rhythm"><a href="ch_gui.html">19. GUI and Graphics</a></li><li class="half_rhythm"><a href="ch_boost.html">20. Using the Boost Unit Test Framework</a></li></ul></li><li class="half_rhythm"><a href="part4.html">Part 4. Wrappers for 3rd-Party Packages</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_xmlwrapp.html">21. XmlWrapp (XML parsing and handling, XSLT, XPath)</a></li></ul></li><li class="half_rhythm"><a href="part5.html">Part 5. Software</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_debug.html">22. Debugging, Exceptions, and Error Handling</a></li><li class="half_rhythm"><a href="ch_grid.html">23. Distributed Computing</a></li><li class="half_rhythm"><a href="ch_app.html">24. Applications</a></li><li class="half_rhythm"><a href="ch_demo.html">25. Examples and Demos</a></li><li class="half_rhythm"><a href="ch_res.html">26. C Toolkit Resources for C++ Toolkit Users</a></li></ul></li><li class="half_rhythm"><a href="part6.html">Part 6. Help and Support</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_browse.html">27. NCBI C++ Toolkit Source Browser</a></li><li class="half_rhythm"><a href="ch_devtools.html">28. Software Development Tools</a></li><li class="half_rhythm"><a href="ch_xmlauthor.html">29. XML Authoring using Word</a></li><li class="half_rhythm"><a href="ch_faq.html">30. FAQs, Useful Documentation Links, and Mailing Lists</a></li></ul></li><li class="half_rhythm"><a href="part7.html">Part 7. Library and Applications Configuration</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_libconfig.html">31. Library Configuration</a></li></ul></li><li class="half_rhythm"><a href="part8.html">Release Notes</a><ul class="simple-list"><li class="half_rhythm"><a href="release_notes.html">Release Notes (Version 9, May 2012)</a></li><li class="half_rhythm"><a href="release_notes_7-05_2011.html">Release Notes (Version 7, May 2011)</a></li><li class="half_rhythm"><a href="release_notes_06_29_2010.html">Release Notes (June, 2010)</a></li><li class="half_rhythm"><a href="release_notes_05_15_2009.html">Release Notes (May, 2009)</a></li><li class="half_rhythm"><a href="release_notes_12_24_2008.html">Release Notes (December, 2008)</a></li><li class="half_rhythm"><a href="release_notes_12_31_2008.html">Release Notes (March, 2008)</a></li><li class="half_rhythm"><a href="release_notes_08_27_2007.html">Release Notes (August, 2007)</a></li><li class="half_rhythm"><a href="release_notes_03_12_2007.html">Release Notes (March, 2007)</a></li><li class="half_rhythm"><a href="release_notes_08_14_2006.html">Release Notes (August, 2006)</a></li><li class="half_rhythm"><a href="release_notes_04_30_2006.html">Release Notes (April 30, 2006)</a></li><li class="half_rhythm"><a href="release_notes_12_31_2005.html">Release Notes (December 31, 2005)</a></li><li class="half_rhythm"><a href="release_notes_10_03_2005.html">Release Notes (August, 2005)</a></li><li class="half_rhythm"><a href="release_notes_05_05_2005.html">Release Notes (April, 2005)</a></li><li class="half_rhythm"><a href="release_notes_03_09_2005.html">Release Notes (February, 2005)</a></li><li class="half_rhythm"><a href="release_notes_11_22_2004.html">Release Notes (November 22, 2004)</a></li><li class="half_rhythm"><a href="release_notes_10_2_2004.html">Release Notes (October 2, 2004)</a></li><li class="half_rhythm"><a href="release_notes_7_8_2004.html">Release Notes (July 8, 2004)</a></li><li class="half_rhythm"><a href="release_notes_april_16_2004.html">Release Notes (April 16, 2004)</a></li><li class="half_rhythm"><a href="release_notes_12_08_2003.html">Release Notes (December 8, 2003)</a></li><li class="half_rhythm"><a href="release_notes_08_01_2003.html">Release Notes (August 1, 2003)</a></li></ul></li><li class="half_rhythm"><a href="app1.appendix1.html">Appendix - Books and Styles</a></li></ul></div><div class="pagination"><a class="pagelink active prev" title="Previous page" href="ch_dataaccess.html">&lt; Prev</a><a class="pagelink active next" title="Next page" href="ch_gui.html">Next &gt;</a></div></div><div class="meta_content"><h1><span class="label">18</span><span class="title">Biological Sequence Alignment</span></h1><p class="small">Last Update: November 1, 2012.</p></div><div class="body_content"><div class="sec"><h2><span class="title">The Global Alignment Library [<span class="nctnt ncbi-path">xalgoalign</span>:<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/algo/align">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/algo/align">src</a>]</span></h2><p>The overview for this chapter consists of the following topics:</p><ul><li><p><a href="#ch_algoalign.intro">Introduction</a></p></li><li><p><a href="#ch_algoalign.outline">Chapter Outline</a></p></li></ul><div class="sec"><h3><span class="title">Introduction</span></h3><p>The library contains C++ classes encapsulating global pairwise alignment algorithms frequently used in computational biology.</p><ul><li><p><span class="nctnt ncbi-class">CNWAligner</span> is the base class for the global alignment algorithm classes. The class provides an implementation of the generic Needleman-Wunsch for computing global alignments of nucleotide and amino acid sequences. The implementation uses an affine scoring scheme. An optional end-space free variant is supported, which is useful in applications where one sequence is expected to align in the interior of the other sequence, or the suffix of one string to align with a prefix of the other.<br />The classical Needleman-Wunsch algorithm is known to have memory and CPU requirements of the order of the sequence lengths' product. If consistent partial alignments are available, the problem is split into smaller subproblems taking fewer operations and less space to complete. <span class="nctnt ncbi-class">CNWAligner</span> provides a way to specify such partial alignments (ungapped).</p></li><li><p><span class="nctnt ncbi-class">CBandAligner</span> encapsulates the banded variant of the global alignment algorithm which is applicable when the number of differences in the target alignment is limited ('the band width'). The computational cost of the algorithm is of the order of the band width multiplied by the length of the query sequence.</p></li><li><p><span class="nctnt ncbi-class">CMMAligner</span> follows Hirschberg's divide-and-conquer approach under which the amount of space required to align two sequences globally becomes a linear function of the sequences' lengths. Although the latter is achieved at a cost of up to twice longer running time, a multithreaded version of the algorithm can run even faster than the classical Needleman-Wunsch algorithm in a multiple-CPU environment.</p></li><li><p><span class="nctnt ncbi-class">CSplicedAligner</span> is an abstract base for algorithms computing cDNA-to-genome, or spliced alignments. Spliced alignment algorithms specifically account for splice signals in their dynamic programming recurrences resulting in better alignments for these particular but very important types of sequences.</p></li></ul></div><div class="sec"><h3><span class="title">Chapter Outline</span></h3><p>The following is an outline of the chapter topics:</p><ul><li><p><a href="ch_algoalign.html#ch_algoalign.generic_global_alignment">Computing pairwise global sequence alignments</a></p><ul><li><p><a href="ch_algoalign.html#ch_algoalign.initialization">Initialization</a></p></li><li><p><a href="ch_algoalign.html#ch_algoalign.setup">Parameters of alignment</a></p></li><li><p><a href="ch_algoalign.html#ch_algoalign.computing">Computing</a></p></li><li><p><a href="ch_algoalign.html#ch_algoalign.transcript">Alignment transcript</a></p></li></ul></li><li><p><a href="ch_algoalign.html#ch_algoalign.Computing_multiple_s">Computing multiple sequence alignments</a></p></li><li><p><a href="ch_algoalign.html#ch_algoalign.divide_and_conquer">Aligning sequences in linear space</a></p><ul><li><p><a href="ch_algoalign.html#ch_algoalign.idea">The idea of the algorithm</a></p></li><li><p><a href="ch_algoalign.html#ch_algoalign.mm_implementation">Implementation</a></p></li></ul></li><li><p><a href="ch_algoalign.html#ch_algoalign.spliced_alignment">Computing spliced sequences alignments</a></p><ul><li><p><a href="ch_algoalign.html#ch_algoalign.uk_formulation">The problem</a></p></li><li><p><a href="ch_algoalign.html#ch_algoalign.uk_implementation">Implementation</a></p></li></ul></li><li><p><a href="ch_algoalign.html#ch_algoalign.formatter">Formatting computed alignments</a></p><ul><li><p><a href="ch_algoalign.html#ch_algoalign.nw_formatter">Formatter object</a></p></li></ul></li></ul></div><p><b>Demo Cases</b> [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/app/nw_aligner">src/app/nw_aligner</a>] [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/app/splign/">src/app/splign/</a>]</p></div><div class="sec" id="ch_algoalign.generic_global_alignment"><h2><span class="title">Computing pairwise global sequence alignments</span></h2><p>Generic <b>pairwise</b> global alignment functionality is provided by <span class="nctnt ncbi-class">CNWAligner</span>.</p><p><span class="nctnt highlight">NOTE: </span><span class="nctnt ncbi-class">CNWAligner</span> is not a multiple sequence aligner. An example of using <span class="nctnt ncbi-class">CNWAligner</span> can be seen <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/app/nw_aligner">here</a>.</p><p>This functionality is discussed in the following topics:</p><ul><li><p><a href="ch_algoalign.html#ch_algoalign.initialization">Initialization</a></p></li><li><p><a href="ch_algoalign.html#ch_algoalign.setup">Parameters of alignment</a></p></li><li><p><a href="ch_algoalign.html#ch_algoalign.computing">Computing</a></p></li><li><p><a href="ch_algoalign.html#ch_algoalign.transcript">Alignment transcript</a></p></li></ul><div class="sec" id="ch_algoalign.initialization"><h3><span class="title">Initialization</span></h3><p>Two constructors are provided to initialize the aligner:</p><pre><span class="nctnt-pre ncbi-code">CNWAligner(const char* seq1, size_t len1,<br />           const char* seq2, size_t len2,<br />           const SNCBIPackedScoreMatrix* scoremat = 0);<br />CNWAligner(void);</span></pre><p>The first constructor allows specification of the sequences and the score matrix at the time of the object's construction. Note that the sequences must be in the proper strands, because the aligners do not build reverse complementaries. The last parameter must be a pointer to a properly initialized <span class="nctnt ncbi-class">SNCBIPackedScoreMatrix</span> object or zero. If it is a valid pointer, then the sequences are verified against the alphabet contained in the <span class="nctnt ncbi-class">SNCBIPackedScoreMatrix</span> object, and its score matrix is further used in dynamic programming recurrences. Otherwise, sequences are verified against the IUPACna alphabet, and match/mismatch scores are used to fill in the score matrix.</p><p>The default constructor is provided to support reuse of an aligner object when many sequence pairs share the same type and alignment parameters. In this case, the following two functions must be called before computing the first alignment to load the score matrix and the sequences:</p><pre><span class="nctnt-pre ncbi-code">void SetScoreMatrix(const SNCBIPackedScoreMatrix* scoremat = 0);<br />void SetSequences(const char* seq1, size_t len1,<br />                  const char* seq2, size_t len2,<br />                  bool verify = true);</span></pre><p>where the meaning of <span class="nctnt ncbi-var">scoremat</span> is the same as above.</p></div><div class="sec" id="ch_algoalign.setup"><h3><span class="title">Parameters of alignment</span></h3><p><span class="nctnt ncbi-class">CNWAligner</span> realizes the affine gap penalty model, which means that every gap of length L (with the possible exception of end gaps) contributes Wg+L*Ws to the total alignment score, where Wg is a cost to open the gap and Ws is a cost to extend the gap by one basepair. These two parameters are always in effect when computing sequence alignments and can be set with:</p><pre><span class="nctnt-pre ncbi-code">void SetWg(TScore value); // set gap opening score<br />void SetWs(TScore value); // set gap extension score</span></pre><p>To indicate penalties, both gap opening and gap extension scores are assigned with negative values.</p><p>Many applications (such as the shotgun sequence assembly) benefit from a possibility to avoid penalizing end gaps of alignment, because the relevant sequence's ends may not be expected to align. <span class="nctnt ncbi-class">CNWAligner</span> supports this through a built-in end-space free variant controlled with a single function:</p><pre><span class="nctnt-pre ncbi-code">void SetEndSpaceFree(bool Left1, bool Right1, bool Left2, bool Right2);</span></pre><p>The first two arguments control the left and the right ends of the first sequence. The other two control the second sequence's ends. True value means that end spaces will not be penalized. Although an arbitrary combination of end-space free flags can be specified, judgment should be used to get plausible alignments.</p><p>The following two functions are only meaningful when aligning nucleotide sequences:</p><pre><span class="nctnt-pre ncbi-code">void SetWm(TScore value); // set match score<br />void SetWms(TScore value); // set mismatch score</span></pre><p>The first function sets a bonus associated with every matching pair of nucleotides. The second function assigns a penalty for every mismatching aligned pair of nucleotides. It is important that values set with these two functions will only take effect after <span class="nctnt ncbi-func">SetScoreMatrix()</span> is called (with a zero pointer, which is the default).</p><p>One thing that could limit the scope of global alignment applications is that the classical algorithm takes quadratic space and time to evaluate the alignment. One wayto deal with it is to use the linear-space algorithm encapuslated in <span class="nctnt ncbi-class">CMMAligner</span>. However, when some pattern of alignment is known or desired, it is worthwhile to explicitly specify "mile posts" through which the alignment should pass. Long high-scoring pairs with 100% identity (no gaps or mismatches) are typically good candidates for them. From the algorithmic point of view, the pattern splits the dynamic programming table into smaller parts, thus alleviating space and CPU requirements. The following function is provided to let the aligner know about such guiding constraints:</p><pre><span class="nctnt-pre ncbi-code">void SetPattern(const vector&lt;size_t&gt;&amp; pattern);</span></pre><p>Pattern is a vector of hits specified by their zero-based coordinates, as in the following example:</p><pre><span class="nctnt-pre ncbi-code">// the last parameter omitted to indicate nucl sequences<br />CNWAligner aligner (seq1, len1, seq2, len2);<br />// we want coordinates [99,119] and [129,159] on seq1 be aligned<br />// with [1099,1119] and [10099,10129] on seq2.<br />const size_t hits [] = { 99, 119, 1099, 1119, 129, 159, 10099, 10129 };<br />vector&lt;size_t&gt; pattern ( hits, hits + sizeof(hits)/sizeof(hits[0]) );<br />aligner.SetPattern(pattern);</span></pre></div><div class="sec" id="ch_algoalign.computing"><h3><span class="title">Computing</span></h3><p>To start computations, call <span class="nctnt ncbi-func">Run()</span>, which returns the overall alignment score having aligned the sequences. Score is a scalar value associated with the alignment and depends on the parameters of the alignment. The global alignment algorithms align two sequences so that the score is the maximum over all possible alignments.</p></div><div class="sec" id="ch_algoalign.transcript"><h3><span class="title">Alignment transcript</span></h3><p>The immediate output of the global alignment algorithms is a transcript.The transcript serves as a basic representation of alignments and is simply a string of elementary commands transforming the first sequence into the second one on a per-character basis. These commands (transcript characters) are (M)atch, (R)eplace, (I)nsert, and (D)elete. For example, the alignment</p><pre>TTC-ATCTCTAAATCTCTCTCATATATATCG<br />||| ||||||     |||| || ||| ||||<br />TTCGATCTCT-----TCTC-CAGATAAATCG</pre><p>has a transcript:</p><pre>MMMIMMMMMMDDDDDMMMMDMMRMMMRMMMM</pre><p>Several functions are available to retrieve and analyze the transcript:</p><pre><span class="nctnt-pre ncbi-code">// raw transcript<br />const vector&lt;ETranscriptSymbol&gt;* GetTranscript(void) const<br />{<br />    return &amp;m_Transcript;<br />}<br />// converted transcript vector<br />void GetTranscriptString(vector&lt;char&gt;* out) const;<br />// transcript parsers<br />size_t        GetLeftSeg(size_t* q0, size_t* q1,<br />                         size_t* s0, size_t* s1,<br />                         size_t min_size) const;<br />size_t        GetRightSeg(size_t* q0, size_t* q1,<br />                          size_t* s0, size_t* s1,<br />                          size_t min_size) const;<br />size_t        GetLongestSeg(size_t* q0, size_t* q1,<br />                            size_t* s0, size_t* s1) const;</span></pre><p>The last three functions search for a continuous segment of matching characters and return it in sequence coordinates through <span class="nctnt ncbi-var">q0</span>, <span class="nctnt ncbi-var">q1</span>, <span class="nctnt ncbi-var">s0</span>, <span class="nctnt ncbi-var">s1</span>.</p><p>The alignment transcript is a simple yet complete representation of alignments that can be used to evaluate virtually every characteristic or detail of any particular alignment. Some of them, such as the percent identity or the number of gaps or mismatches, could be easily restored from the transcript alone, whereas others, such as the scores for protein alignments, would require availability of the original sequences.</p></div></div><div class="sec" id="ch_algoalign.Computing_multiple_s"><h2><span class="title">Computing multiple sequence alignments</span></h2><p>COBALT (COnstraint Based ALignment Tool) is an experimental multiple alignment algorithm whose basic idea was to leverage resources at NCBI, then build up a set of pairwise constraints, then perform a fairly standard iterative multiple alignment process (with many tweaks driven by various benchmarks). A precompiled binary, with the data files needed to run it, is available at</p><p><a href="ftp://ftp.ncbi.nlm.nih.gov/pub/agarwala/cobalt">ftp://ftp.ncbi.nlm.nih.gov/pub/agarwala/cobalt/</a></p><p>The work is being done on an improved COBALT tool.</p><p>The paper reference for this algorithm is</p><p><i>J.S. Papadopoulos, R. Agarwala, "COBALT: Constraint-Based Alignment Tool for Multiple Protein Sequences". Bioinformatics, May 2007</i></p></div><div class="sec" id="ch_algoalign.divide_and_conquer"><h2><span class="title">Aligning sequences in linear space</span></h2><p><span class="nctnt ncbi-class">CMMAligner</span> is an interface to a linear space variant of the global alignment algorithm. This functionality is discussed in the following topics:</p><ul><li><p><a href="ch_algoalign.html#ch_algoalign.idea">The idea of the algorithm</a></p></li><li><p><a href="ch_algoalign.html#ch_algoalign.mm_implementation">Implementation</a></p></li></ul><div class="sec" id="ch_algoalign.idea"><h3><span class="title">The idea of the algorithm</span></h3><p>That the classical global alignment algorithm requires quadratic space could be a serious restriction in sequence alignment. One way to deal with it is to use alignment patterns. Another approach was first introduced by Hirschberg and became known as a divide-and-conquer strategy. At a coarse level, it suggests computing of scores for partial alignments starting from two opposite corners of the dynamic programming matrix while keeping only those located in the middle rows or columns. After the analysis of the adjacent scores, it is possible to determine cells on those lines through which the global alignment's back-trace path will go. This approach reduces space to linear while only doubling the worst-case time bound. For details see, for example, Dan Gusfield's "Algorithms on Strings, Trees and Sequences".</p></div><div class="sec" id="ch_algoalign.mm_implementation"><h3><span class="title">Implementation</span></h3><p><span class="nctnt ncbi-class">CMMAligner</span> inherits its public interface from <span class="nctnt ncbi-class">CNWAligner</span>. The only additional method allows us to toggle multiple-threaded versions of the algorithm.</p><p>The divide-and-conquer strategy suggests natural parallelization, where blocks of the dynamic programming matrix are evaluated simultaneously. A theoretical acceleration limit imposed by the current implementation is 0.5. To use multiple-threaded versions, call <span class="nctnt ncbi-func">EnableMultipleThreads()</span>. The number of simultaneously running threads will not exceed the number of CPUs installed on your system.</p><p>When comparing alignments produced with the linear-space version with those produced by <span class="nctnt ncbi-class">CNWAligner</span>, be ready to find many of them similar, although not exactly the same. This is normal, because several optimal alignments may exist for each pair of sequences.</p></div></div><div class="sec" id="ch_algoalign.spliced_alignment"><h2><span class="title">Computing spliced sequences alignments</span></h2><p>This functionality is discussed in the following topics:</p><ul><li><p><a href="ch_algoalign.html#ch_algoalign.uk_formulation">The problem</a></p></li><li><p><a href="ch_algoalign.html#ch_algoalign.uk_implementation">Implementation</a></p></li></ul><div class="sec" id="ch_algoalign.uk_formulation"><h3><span class="title">The problem</span></h3><p>The spliced sequence alignment arises as an attempt to address the problem of eukaryotic gene structure recognition. Tools based on spliced alignments exploit the idea of comparing genomic sequences to their transcribed and spliced products, such as mRNA, cDNA, or EST sequences. The final objective for all splice alignment algorithms is to come up with a combination of segments on the genomic sequence that:</p><ul><li><p>makes up a sequence very similar to the spliced product, when the segments are concatenated; and</p></li><li><p>satisfies certain statistically determined conditions, such as consensus splice sites and lengths of introns.</p></li></ul><p>According to the classical eukaryotic transcription and splicing mechanism, pieces of genomic sequence do not get shuffled. Therefore, one way of revealing the original exons could be to align the spliced product with its parent gene globally. However, because of the specificity of the process in which the spliced product is constructed, the generic global alignment with the affine penalty model may not be enough. To address this accurately, dynamic programming recurrences should specifically account for introns and splice signals.</p><p>Algorithms described in this chapter exploit this idea and address a refined splice alignment problem presuming that:</p><ul><li><p>the genomic sequence contains only one location from which the spliced product could have originated;</p></li><li><p>the spliced product and the genomic sequence are in the plus strand; and</p></li><li><p>the poly(A) tail and any other chunks of the product not created through the splicing were cut off, although a moderate level of sequencing errors on genomic, spliced, or both sequences is allowed.</p></li></ul><p>In other words, the library classes provide basic splice alignment algorithms to be used in more sophisticated applications. One real-life application, Splign, can be found under demo cases for the library.</p></div><div class="sec" id="ch_algoalign.uk_implementation"><h3><span class="title">Implementation</span></h3><p>There is a small hierarchy of three classes involved in spliced alignment facilitating a quality/performance trade-off in the case of distorted sequences:</p><ul><li><p><span class="nctnt ncbi-class">CSplicedAligner</span> - abstract base for spliced aligners.</p></li><li><p><span class="nctnt ncbi-class">CSplicedAligner16</span> - accounts for the three conventional splices (GT/AG, GC/AG, AT/AC) and a generic splice; uses 2 bytes per back-trace matrix cell. Use this class with high-quality genomic sequences.</p></li><li><p><span class="nctnt ncbi-class">CSplicedAligner32</span> - accounts for the three conventionals and splices that could be produced by damaging bases of any conventional; uses 4 bytes per back-trace matrix cell. Use this class with distorted genomic sequences.</p></li></ul><p>The abstract base class for spliced aligners, <span class="nctnt ncbi-class">CNWSplicedAligner</span>, inherites an interface from its parent, <span class="nctnt ncbi-class">CNWAligner</span>, adding support for two new parameters: intron penalty and minimal intron size (the default is 50).</p><p>All classes assume that the spliced sequence is the first of the two input sequences passed. By default, the classes do not penalize gaps at the ends of the spliced sequence. The default intron penalties are chosen so that the 16-bit version is able able to pick out short exons, whereas the 32-bit version is generally more conservative.</p><p>As with the generic global alignment, the immediate output of the algorithms is the alignment transcript. For the sake of spliced alignments, the transcript's alphabet is augmented to accommodate introns as a special sequence-editing operation.</p></div></div><div class="sec" id="ch_algoalign.formatter"><h2><span class="title">Formatting computed alignments</span></h2><p>This functionality is discussed in the following topics:</p><ul><li><p><a href="ch_algoalign.html#ch_algoalign.nw_formatter">Formatter object</a></p></li></ul><div class="sec" id="ch_algoalign.nw_formatter"><h3><span class="title">Formatter object</span></h3><p><span class="nctnt ncbi-class">CNWFormatter</span> is a single place where all different alignment representations are created. The only argument to its constructor is the aligner object that actually was or will be used to align the sequences.</p><p>The alignment must be computed before formatting. If the formatter is unable to find the computed alignment in the aligner that was referenced to the constructor, an exception will be thrown.</p><p>To format the alignment as a <span class="nctnt ncbi-class">CSeq_align</span> structure, call</p><pre><span class="nctnt-pre ncbi-code">void AsSeqAlign(CSeq_align* output) const;</span></pre><p>To format it as text, call</p><pre><span class="nctnt-pre ncbi-code">void AsText(string* output, ETextFormatType type, size_t line_width = 100)</span></pre><p>Supported text formats and their <span class="nctnt ncbi-class">ETextFormatType</span> constants are:</p><ul><li><p>Type 1 (<span class="nctnt ncbi-var">eFormatType1</span>):<br />TTC-ATCTCTAAATCTCTCTCATATATATCG<br />TTCGATCTCT-----TCTC-CAGATAAATCG<br />                      ^   ^    </p></li><li><p>Type 2 (<span class="nctnt ncbi-var">eFormatType2</span>):<br />TTC-ATCTCTAAATCTCTCTCATATATATCG<br />||| ||||||     |||| || ||| ||||<br />TTCGATCTCT-----TCTC-CAGATAAATCG</p></li><li><p>Gapped FastA (<span class="nctnt ncbi-var">eFormatFastA</span>):<br />&gt;SEQ1<br />TTC-ATCTCTAAATCTCTCTCATATATATCG<br />&gt;SEQ2<br />TTCGATCTCT-----TCTC-CAGATAAATCG</p></li><li><p>Table of exons (<span class="nctnt ncbi-var">eFormatExonTable</span>) - spliced alignments only. The exons are listed from left to right in tab-separated columns. The columns represent sequence IDs, alignment lengths, percent identity, coordinates on the query (spliced) and the subject sequences, and a short annotation including splice signals.</p></li><li><p>Extended table of exons (<span class="nctnt ncbi-var">eFormatExonTableEx</span>) - spliced alignments only. In addition to the nine columns, the full alignment transcript is listed for every exon.</p></li><li><p>ASN.1 (<span class="nctnt ncbi-var">eFormatASN</span>)</p></li></ul></div></div></div></div><div class="col four_col last"><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>In this page</h3></div></div><div class="portlet_content"><ul><li><a href="#ch_algoalign.generic_global_alignment">Computing pairwise global sequence alignments</a></li><li><a href="#ch_algoalign.Computing_multiple_s">Computing multiple sequence alignments</a></li><li><a href="#ch_algoalign.divide_and_conquer">Aligning sequences in linear space</a></li><li><a href="#ch_algoalign.spliced_alignment">Computing spliced sequences alignments</a></li><li><a href="#ch_algoalign.formatter">Formatting computed alignments</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Download</h3></div></div><div class="portlet_content"><ul><li><a href="pdf/ch_algoalign.pdf">PDF version of this page</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Search</h3></div></div><div class="portlet_content"><form name="frmSymbolSearch" onsubmit="return SymbolSearch('toolkit')" action="/" id="frmSymbolSearch"><table><tbody><tr align="center" valign="middle"><td colspan="2" nowrap="nowrap"><input name="__symbol" size="22" style="vertical-align:                                          middle;" onkeypress="SymbolSearchKeyPress('toolkit',event)" type="text" />   <input value="Search" style="vertical-align: middle;" onclick="javasrcipt:SymbolSearch('toolkit');" type="button" /></td></tr><tr class="internal-only"><th style="text-align:left">Public</th><th style="text-align:left">Internal</th></tr><tr><td><input id="pToolkitAll" name="__symboloc" type="radio" checked="checked" /><span title="Search in the C/C++ source code and in this Book">All</span></td><td class="internal-only"><input id="iToolkitAll" name="__symboloc" type="radio" /><span title="Search in the C/C++ source code,  this Book, and Wiki">All</span></td></tr><tr><td><input id="pLXR" name="__symboloc" type="radio" /><span title="Search the symbol in the source code using LINUX Cross-Reference browser">LXR</span></td><td class="internal-only"><input id="iLXR" name="__symboloc" type="radio" /><span title="Search the symbol in the source code using LINUX Cross-Reference browser">LXR</span></td></tr><tr><td><input id="pLib" name="__symboloc" type="radio" /><span title="Locate the Toolkit library(es) where the symbol is defined">Library</span></td><td class="internal-only"><input id="iLib" name="__symboloc" type="radio" /><span title="Locate the Toolkit library(es) where the symbol is defined">Library</span></td></tr></tbody></table></form></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Source Browsers</h3></div></div><div class="portlet_content"><ul><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">LXR</a></li><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">Doxygen</a></li><li class="internal-only">LXR: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">public</a> / <a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lxr/ident">internal</a></li><li class="internal-only">Doxygen: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml">public</a> / <a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml">internal</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>SVN Source Repository</h3></div></div><div class="portlet_content"><ul><li><a href="http://www.ncbi.nlm.nih.gov/bookshelf/br.fcgi?book=toolkit&amp;part=ch_getcode_svn#ch_getcode_svn.code_retrieval">Server</a></li><li><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/c++">Web
                            (dev)</a></li><li><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/internal/c++">Web
                            (extra)</a></li><li><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/production/components">Web (prod)</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Resources</h3></div></div><div class="portlet_content"><ul><li class="internal-only"><a href="http://intranet.ncbi.nlm.nih.gov/wiki-private/CxxToolkit">Wiki</a></li><li class="internal-only"><a href="http://jira/browse/CXX">JIRA</a></li><li class="internal-only"><a href="http://intranet/ieb/ToolBox/STAT/test_stat/test_stat_ext.cgi"><span title="View results of testsuite runs on the automatic C++ Toolkit builds">Testsuite</span></a></li><li><a href="release_notes.html">Release Notes</a></li><li><a href="ch_getcode_svn.html#ch_getcode_svn.ftp_download">Download</a></li><li><a href="pdf/TOC.pdf">PDF of the book</a></li><li><a href="ch_style.html">Coding Style</a></li><li><a href="ch_faq.html#ch_faq.mailing_lists">Mailing Lists</a></li><li><a href="mailto:CPP-CORE@NCBI.NLM.NIH.GOV"><span title="Contact C++ Toolkit group">Help and Support</span></a></li></ul></div></div></div></div></div></div></body></html>
