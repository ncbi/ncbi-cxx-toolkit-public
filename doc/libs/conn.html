<!--#set var="TITLE" value="Connection Library" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->

<h1>Connection Library (<tt>connect</tt>)</h1>

<font size=1><u><b>Note</b></u>: Due to security issues, not all links in the public version
of this file could be accessible by outside NCBI users. Unrestricted version of this document is available to
inside NCBI users at:
<a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/libs/conn.html">http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/libs/conn.html</a>.
</font>

<h2>Contents</h2>

<ol>
<ul>
    <li> <a href="#ref_Overview">Overview</a>
    <li> <a href="#ref_Connections">Connections</a>: notion of connection; different types of connections that library provides;
	programming API.
    <ul> 
	<li> <a href="#ref_SocketConnector">Socket Connector</a>
	<li> <a href="#ref_FileConnector">File Connector</a>
	<li> <a href="#ref_HTTPConnector">HTTP Connector</a>
	<li> <a href="#ref_ServiceConnector">Service Connector</a>
    </ul>
    <li> <a href="#ref_CxxConnectionStreams">C++ Connection Streams</a> built on top of connection objects.
    <li> <a href="#ref_ServiceAPI">Service mapping API</a>: description of service name resolution API.
</ul>
</ol>

<p>
<hr>

<a name="ref_Overview"></a><h2>Overview</h2>

NCBI C++ platform-independent
connection library (<a href="../lxr/source/src/connect"><i><b>src/connect</b></i></a>
and <a href="../lxr/source/include/connect"><i><b>include/connect</b></i></a>)
consists of 2 parts:
<ol>
<li> Lower-level library written in C (also used as a replacement of existing
connection library in the NCBI C Toolkit);
<li> Upper-level library written in C++ and using C++ streams.
</ol>
<p>
Functionality of the library includes:
<ul>
	<li> <tt>SOCK</tt> interface (sockets), which works
			interchangeable on most UNIX flavors, MS-Windows, and Mac;
	<li> <tt>SERV</tt> interface, which provides mapping of symbolic service names into
			server addresses;
	<li> <tt>CONN</tt> interface, which allows to
			create a <i>connection</i>, the special object capable to
			do <tt>read</tt>, <tt>write</tt> etc. I/O operations;
	<li> C++ streams built on top of <tt>CONN</tt> interface.
</ul>
<p>
<u>Note</u>:
The most lower-level <tt>SOCK</tt> interface is not covered in this document.
Well-commented API can be found in
<a href="../lxr/source/include/connect/ncbi_socket.h"><i><b>connect/ncbi_socket.h</b></i></a>.

<p>
<hr>


<a name="ref_Connections"></a><h2>Connections</h2>

There are 3 simple types of connections: <i>socket</i>, <i>file</i> and
<i>http</i>; and one hybrid type, <i>service</i> connection.

<p>
A connection is created with a call to <a href="../lxr/ident?i=CONN_Create"><i><b>CONN_Create()</b></i></a>,
declared in <a href="../lxr/source/include/connect/ncbi_connection.h"><i><b>connect/ncbi_connection.h</b></i></a>,
and returned by a pointer to <i><b>CONN</b></i> passed as a second argument:
<pre>
CONN conn;          /* connection handle */
EIO_Status status = CONN_Create(connector, &conn);
</pre>
The first argument of this function is a handle of a so-called <i>connector</i>,
a special object implementing functionality of the connection being built.
Above, for each type of connection there is a special connector in the
library. For each connector, one or more "constructors" defined, each
returning the connector's handle. Connectors' constructors are defined in individual
header files, like <a href="../lxr/source/include/connect/ncbi_socket_connector.h"><i><b>connect/ncbi_socket_connector.h</b></i></a>,
<a href="../lxr/source/include/connect/ncbi_http_connector.h"><i><b>connect/ncbi_http_connector.h</b></i></a>,
<a href="../lxr/source/include/connect/ncbi_service_connector.h"><i><b>connect/ncbi_service_connector.h</b></i></a> etc.
<b><i>CONN_Create()</i></b> <a href="#CONN_SetTimeout">resets</a> all timeouts to the default value <tt>CONN_DEFAULT_TIMEOUT</tt>.

<p>
After successful creation with <i><b>CONN_Create()</b></i>, the following
calls from <tt>CONN</tt> API
<a href="../lxr/source/include/connect/ncbi_connection.h"><i><b>connect/ncbi_connection.h</b></i></a>become available.
All calls (except <a href="#CONN_GetTimeout"><i><b>CONN_GetTimeout()</b></i></a> and <a href="#CONN_GetType"><i><b>CONN_GetType()</b></i></a>)
return I/O completion status of type <a href="../lxr/ident?i=EIO_Status"><i><b>EIO_Status</b></i></a>.
Normal completion has code <i><b>eIO_Success</b></i>.
<ul>

<li> <a name="CONN_Read"></a><a href="../lxr/ident?i=CONN_Read"><i><b>CONN_Read</i></b></a>&nbsp;<tt>(CONN conn, void* buf, size_t bufsize, size_t* n_read, EIO_ReadMethod how);</tt><br>
Read or peek data, depending on read method <tt>how</tt>, up to <tt>bufsize</tt> bytes from connection to specified buffer
<tt>buf</tt>, return (via pointer argument <tt>n_read</tt>) the number of actually read bytes. The last argument
<tt>how</tt> can be one of the following:
<ul>
<li><a href="../lxr/ident?i=EIO_ReadMethod"><i><b>eIO_Plain</b></i></a> - to read data in a regular way, that is extracting data from the connection,
<li><i><b>eIO_Peek</b></i> - to peek data from the connection, i.e. the next read operation will see the data again,
<li><i><b>eIO_Persist</b></i> - to read exactly (not less than) <tt>bufsize</tt> bytes or until an error condition occurs.
</ul>
Return value other than <i><b>eIO_Success</b></i> means trouble.
Specifically, return value <i><b>eIO_Timeout</b></i> indicates that the operation could not
be completed within the preset amount of time; but some data may, however,
be available in the buffer (e.g. in case of persistent reading, with <i><b>eIO_Persist</b></i>), and this is actually true for any return code.

<li> <a href="../lxr/ident?i=CONN_Write"><i><b>CONN_Write</b></i></a>&nbsp;<tt>(CONN conn, const void* buf, size_t bufsize, size_t* n_written);</tt><br>
Write the specified number of bytes <tt>bufsize</tt> from the buffer <tt>buf</tt> to the connection. Return (via <tt>n_written</tt>)
the number of actually written data, and completion code as a return value.

<li> <a href="../lxr/ident?i=CONN_Flush"><i><b>CONN_Flush</b></i></a>&nbsp;<tt>(CONN conn);</tt><br>
Flush internal output queue, if this is supported by the current connection type.

<li> <a name="CONN_SetTimeout"></a><a href="../lxr/ident?i=CONN_SetTimeout"><i><b>CONN_SetTimeout</b></i></a>&nbsp;<tt>(CONN conn, EIO_Event action, const STimeout* timeout);</tt><br>
Set the timeout on the specified I/O action, <a href="../lxr/ident?i=EIO_Event"><i><b>eIO_Read</b></i></a>, <i><b>eIO_Write</b></i>,
<i><b>eIO_ReadWrite</b></i>, <i><b>eIO_Open</b></i>, and <i><b>eIO_Close</b></i>. The latter 2 actions are
used in a phase of opening and closing the link, respectively: if connection
cannot be established (closed) within the specified period, <i><b>eIO_Timeout</b></i> would result.
<i><b>eIO_Timeout</b></i> would result if reading/writing could not
be completed within specified time range, correspondingly. A timeout can be passed as
the <tt>NULL</tt>-pointer. This special case denotes an infinite value for that timeout.
Also, a special value <tt>CONN_DEFAULT_TIMEOUT</tt> may be used for any timeout.
This value specifies the timeout set by default for the current connection type.

<li> <a name="CONN_GetTimeout"></a><a href="../lxr/ident?i=CONN_GetTimeout"><i><b>CONN_GetTimeout</b></i></a>&nbsp;<tt>(CONN conn, EIO_Event action);</tt><br>
Obtain (via return value of type <b><i>const <a href="../lxr/ident?i=STimeout">STimeout</a>*</i></b>)
timeouts set by <a href="#CONN_SetTimeout"><i><b>CONN_SetTimeout()</b></i></a> routine, or active by default
(i.e. special value <tt>CONN_DEFAULT_TIMEOUT</tt>).
<br>
<u>Caution</u>: Returned pointer valid only for the time the connection
handle is valid, i.e. up to a call to <a href="#CONN_Close"><i><b>CONN_Close()</b></i></a>.

<li> <a name="CONN_ReInit"></a><a href="../lxr/ident?i=CONN_ReInit"><i><b>CONN_ReInit</b></i></a>&nbsp;<tt>(CONN conn, CONNECTOR replacement);</tt><br>
This function allows to clear current contents of a
connection, and "immerse" a new connector into it.
Previous connector (if any) is closed first (if open),
then gets destroyed, and thus must not be referenced again in the program.
As a special case, new connector can be
the same connector, which is currently active within the connection. It this case, the connector is not destroyed,
instead it will be effectively re-opened. If connector passed as <tt>NULL</tt>, then the <tt>conn</tt> handle is kept
existing but unusable (the old connector closed and destroyed), and can be <i><b>CONN_ReInit()</b></i>ed later.
None of the timeouts are touched by this call.

<li> <a href="../lxr/ident?i=CONN_Wait"><i><b>CONN_Wait</b></i></a>&nbsp;<tt>(CONN conn, EIO_Event event, const STimeout* timeout);</tt><br>
Suspend the program until connection is ready to perform reading (<tt>event</tt> = <i><b>eIO_Read</b></i>) or writing
(<tt>event</tt> = <i><b>eIO_Write</b></i>), or until timeout (if non-<tt>NULL</tt>) expired. If timeout is passed as <tt>NULL</tt>, then
the wait time is infinite.

<li> <a href="../lxr/ident?i=CONN_Status"><i><b>CONN_Status</b></i></a>&nbsp;<tt>(CONN conn, EIO_Event direction);</tt><br>
Provide the information about recent low-level data exchange in the link.
Operation direction has to be specified as either <i><b>eIO_Read</b></i> or <i><b>eIO_Write</b></i>.
The necessity of this call arises from the fact that
sometimes return value of a <tt>CONN</tt> API function does not really tell that the
problem has been detected: suppose, the user peeks data in a 100-byte buffer and gets 10 bytes.
Return status <i><b>eIO_Success</b></i> signals that those 10 bytes were found
in the connection okay. But how to know whether the end-of-file condition
occurred during last operation? It is where <i><b>CONN_Status()</b></i> comes
handy. When inquired about read operation, return value <i><b>eIO_Closed</b></i> denotes that
<tt>EOF</tt> was actually hit while making the peek, and those 10 bytes are in fact the only data
left untaken, no more are expected to come.

<li> <a name="CONN_Close"></a><a href="../lxr/ident?i=CONN_Close"><i><b>CONN_Close</b></i></a>&nbsp;<tt>(CONN conn);</tt><br>
Close the connection by closing the link (if open), deleting underlying
connector(s) (if any) and the connection itself. Regardless of the return status (which may indicate certain problems),
the connection handle becomes invalid and cannot be used in the program again.

<li> <a name="CONN_GetType"></a><a href="../lxr/ident?i=CONN_GetType"><i><b>CONN_GetType</b></i></a>&nbsp;<tt>(CONN conn);</tt><br>
Return character string (0-terminated), verbally representing the current
connection type, like <tt>"HTTP"</tt>, <tt>"SOCKET"</tt>, <tt>"SERVICE/HTTP"</tt> etc. Unknown connection
type gets returned as <tt>NULL</tt>.

<li> <a href="../lxr/ident?i=CONN_SetCallback"><i><b>CONN_SetCallback</b></i></a>&nbsp;<tt>(CONN conn, ECONN_Callback
type, const SCONN_Callback* new_cb, SCONN_Callback* old_cb);</tt><br>
Set user callback function to be called upon an event specified by
callback <tt>type</tt>. The old callback (if any) gets returned via
passed pointer <tt>old_cb</tt> (if not <tt>NULL</tt>). Callback
structure <a href="../lxr/ident?i=SCONN_Callback"><b><i>SCONN_Callback</b></i></a>
has the following fields: callback function <tt>func</tt> and
<tt>void* data</tt>. Callback function <tt>func</tt> should have the
following prototype:
<ul><tt>
  typedef void (*FConnCallback)(CONN conn, ECONN_Callback type, void* data);
</tt></ul>
When called, both <tt>type</tt> of callback and <tt>data</tt> pointer
are supplied. The only callback type defined as of writing of
this note is <a href="../lxr/ident?i=ECONN_Callback"><b><i>eCONN_OnClose</i></b></a>.
Callback function is always called prior to the event to happed, e.g. close callback is
called when the connection is about to close.
</ul>

<u>Note</u>: There is no means to "open" a connection: it is done
automatically when actually needed, and in most cases at
the first I/O operation.
But forming of actual link between source and destination
can be postponed even longer. These details are hidden and made transparent to
the connection's user. The connection is seen as a two-way communication channel,
which is clear to use right away after a call to <i><b>CONN_Create()</b></i>.
<p>
<u>Note</u>: If for some reason <i><b>CONN_Create()</b></i> failed to create
a connection (return code differs from <i><b>eIO_Success</b></i>), then the
connector, which was passed to this function, is left intact; that is, its
handle can be used again.
Otherwise, if connection is created successfully, the passed
connector handle becomes invalid, and cannot be used anywhere else throughout
the program (with one, however, exception: it may be used as a replacing connector in a call to
<a href="#CONN_ReInit"><i><b>CONN_ReInit()</b></i></a> for the same connection).
<p>
<u>Note</u>: There are no public connectors' "destructors". Connector successfully put into connection
is deleted automatically along with that connection by <i><b>CONN_Close()</b></i>,
or explicitly with a call to <i><b>CONN_ReInit()</b></i> provided that replacing connector is
<tt>NULL</tt> or different from the original.

<p>
<hr>


<a name="ref_SocketConnector"></a><h3>Socket connector</h3>

Constructors are defined in:
<pre>
#include &lt;<a href="../lxr/source/include/connect/ncbi_socket_connector.h">connect/ncbi_socket_connector.h</a>&gt;
</pre>

<p>
Socket connection based on the socket connector brings almost direct
access to the <a href="../lxr/source/include/connect/ncbi_socket.h"><tt>SOCK</tt></a> API.
It allows the user to create a peer-to-peer data channel between two programs, which could be located anywhere on the
Internet.

<p>
In order to create the socket connection the user has to create
a socket connector first, then pass it to <i><b>CONN_Create()</b></i>,
as in the following example:
<pre>
#include &lt;connect/ncbi_socket_connector.h&gt;
#include &lt;connect/ncbi_connection.h&gt;

#define MAX_TRY	3 /* Try to connect this many times before giving up */

unsigned short port = 1234;
CONNECTOR socket_connector = <a href="../lxr/ident?i=SOCK_CreateConnector">SOCK_CreateConnector</a>("host.foo.com", port, MAX_TRY);

if (!socket_connector)
	fprintf(stderr, "Cannot create SOCKET connector");
else {
	CONN conn;
  
	if (CONN_Create(socket_connector, &conn) != eIO_Success)
		fprintf(stderr, "CONN_Create failed");
	else {
		/* Connection created ok, use CONN_... function to access the network */
		...
  		CONN_Close(conn);
	}
}
</pre>

A variant form of this connector's constructor,
<a href="../lxr/ident?i=SOCK_CreateConnectorEx"><i><b>SOCK_CreateConnectorEx()</b></i></a>,
takes two more arguments: a pointer to data (of type <i><b>void*</b></i>),
and data size (bytes) to specify the data to be sent as soon as
the link has been established.

<p>
<hr>


<a name="ref_FileConnector"></a><h3>File connector</h3>

Constructors defined in:
<pre>
#include &lt;<a href="../lxr/source/include/connect/ncbi_file_connector.h">connect/ncbi_file_connector.h</a>&gt;

CONNECTOR file_connector = <a href="../lxr/ident?i=FILE_CreateConnector">FILE_CreateConnector</a>("InFile", "OutFile");
</pre>

This connector could be used for both reading and writing files, when
input goes from one file, and output goes to another file.
(This differs from normal file I/O when a single handle is used to access only one file,
but rather resembles data exchange via socket. )

<p>
Extended variant of this connector's constructor,
<a href="../lxr/ident?i=FILE_CreateConnectorEx"><i><b>FILE_CreateConnectorEx()</b></i></a>
takes an additional argument, pointer to a structure of type <a href="../lxr/ident?i=SFileConnAttr"><b><i>SFileConnAttr</i></b></a>
describing file connector attributes, like initial read position to start from in the input file, open mode for output file (append
<a href="../lxr/ident?i=EFileConnMode"><i><b>eFCM_Append</b></i></a>, truncate <i><b>eFCM_Truncate</b></i>, or seek <i><b>eFCM_Seek</b></i>
to start writing at a specified file position), and the position in the output file, which is used in <i>seek</i> open mode.
Attribute pointer passed as <tt>NULL</tt> is equivalent to a call to
<i><b>FILE_CreateConnector()</b></i>, which reads from the very
beginning of the input file, and entirely overwrites the output file (if any) implicitly using <i><b>eFCM_Truncate</b></i>. 

<p>
<hr>


<a name="ref_HTTPConnector"></a><h3>HTTP connector</h3>

Constructors defined in:
<pre>
#include &lt;<a href="../lxr/source/include/connect/ncbi_http_connector.h">connect/ncbi_http_connector.h</a>&gt;
</pre>

The simplest form of this connector's constructor takes 3 parameters:
<pre>
extern CONNECTOR <a href="../lxr/ident?i=HTTP_CreateConnector">HTTP_CreateConnector</a>
(const <a href="../lxr/ident?i=SConnNetInfo">SConnNetInfo</a>* info,
 const char*         user_header,
 <a href="../lxr/ident?i=THCC_Flags">THCC_Flags</a>          flags
 );
</pre>
a pointer to network information structure (can be <tt>NULL</tt>), a pointer to
a custom HTTP tag-value(s) so called user-header, and bitmask of various flags.
The user-header has to be in the form <tt>"HTTP-Tag: Tag-value\r\n"</tt>, or even multiple tag-values delimited and
terminated by <tt>"\r\n"</tt>.
If specified, <tt>user_header</tt> parameter overrides the
<a href="#ref_HttpUserHeader">corresponding field</a> in <tt>info</tt>.

<p>
Network information structure (from <a href="../lxr/source/include/connect/ncbi_connutil.h"><i><b>connect/ncbi_connutil.h</b></i></a>)
defines parameters of the connection point,
where the HTTP server is running.<br>
<u>Note</u>: Not all parameters of the structure depicted below apply to this connector.

<pre>
/* Network connection related configurable info struct
 */
typedef struct {
  char           client_host[64];  /* effective client hostname            */
  char           host[64];         /* host to connect to                   */
  unsigned short port;             /* port to connect to, host byte order  */
  char           path[1024];       /* service: path(e.g. to  a CGI script) */
  char           args[1024];       /* service: args(e.g. for a CGI script) */
  <a href="../lxr/ident?i=EReqMethod">EReqMethod</a>     req_method;       /* method to use in the request         */
  <a href="../lxr/ident?i=STimeout">STimeout</a>       timeout;          /* i/o timeout                          */
  unsigned int   max_try;          /* max. # of attempts to establish conn */
  char           http_proxy_host[64];  /* hostname of HTTP proxy server    */
  unsigned short http_proxy_port;      /* port #   of HTTP proxy server    */
  char           <a name="ref_ProxyHost"></a>proxy_host[64];   /* host of CERN-like firewall proxy srv */
  <a href="../lxr/ident?i=EDebugPrintout">EDebugPrintout</a> debug_printout;   /* printout some debug info             */
  int/*bool*/    stateless;        /* to connect in HTTP-like fashion only */
  int/*bool*/    firewall;         /* to use firewall/relay in connects    */
  int/*bool*/    <a name="ref_LbDisable"></a>lb_disable;       /* to disable local load-balancing      */
  const char*    <a name="ref_HttpUserHeader"></a>http_user_header; /* user header to add to HTTP request   */
  
  /* the following field(s) are for the internal use only! */
  int/*bool*/    http_proxy_adjusted;
} <a href="../lxr/ident?i=SConnNetInfo">SConnNetInfo</a>;
</pre>

<u>Caution</u>: Unlike other "static fields" of this structure,
<a href="#ref_HttpUserHeader"><tt>http_user_header</tt></a> (if non-<tt>NULL</tt>)
is assumed to be dynamically allocated on the heap
(via a call to <tt>malloc</tt>, <tt>calloc</tt> or related function,
like <tt>strdup</tt>).

<p>
<a name="ref_SConnNetInfo"></a>While the user can create and fill out this structure via field-by-field assignments,
there is however a better, easier, much safer and configurable way (and interface
defined in <a href="../lxr/source/include/connect/ncbi_connutil.h"><i><b>connect/ncbi_connutil.h</b></i></a>)
to deal with this structure:

<ul>
<li> <a name="ref_ConnNetInfo_Create"></a><a href="../lxr/ident?i=ConnNetInfo_Create"><i><b>ConnNetInfo_Create</b></i></a>&nbsp;<tt>(const char* service)</tt><br>
  Create and return a pointer to new <tt>SConnNetInfo</tt> structure, filled with
  parameters specific either for a named <tt>service</tt> or by default if <tt>service</tt> specified as <tt>NULL</tt> (most likely
  the case for ordinary HTTP connections). Parameters for the structure are taken from (in order of precedence):<ul>
  <li> Environment variables of the form <tt><i>&lt;service&gt;</i>_CONN_<i>&lt;name&gt;</i></tt>,
  where <tt>name</tt> is the name of the field;
  <li> Service-specific <a href="#ref_Registry"><u>registry</u></a> section named <tt>[service]</tt>
  using the key <tt>CONN_<i>&lt;name&gt;</i></tt>;
  <li> Environment variable of the form <tt>CONN_<i>&lt;name&gt;</i></tt>;
  <li> Registry section named <tt>[CONN]</tt> using <tt>name</tt> as a key;
  <li> And finally, default value is applied, if none of the above resulted in a successful match.
  </ul>
  
  Search for the keys in both environment and registry is not case-sensitive; but the values of the keys are case-sensitive
  (except for enumerated types and boolean values, which can be of any -&nbsp;even mixed&nbsp;- case).
  Boolean fields accept <tt>1</tt>, <tt>"YES"</tt> and <tt>"TRUE"</tt> as <tt>true</tt> values, all other values are
  treated as <tt>false</tt>. In addition to a floating point number treated as a number of seconds,
  <tt>timeout</tt> can accept (case-insensitively) keyword <tt>"INFINITE"</tt>.
  <br>
  <u>Note</u>: The first 2 steps in the above sequence are skipped if <tt>service</tt> name is passed as <tt>NULL</tt>.<br>
  <u>Caution</u>: The library does not provide reasonable
  default values for <tt>path</tt> and <tt>args</tt> when the structure is used for HTTP connectors.

<li> <a href="../lxr/ident?i=ConnNetInfo_Destroy"><i><b>ConnNetInfo_Destroy</b></i></a>&nbsp;<tt>(SConnNetInfo* info)</tt><br>
  Delete and free the info structure via passed pointer (note that the HTTP user header <tt>http_user_header</tt>
  is freed, too).
<li> <a href="../lxr/ident?i=ConnNetInfo_SetUserHeader"><i><b>ConnNetInfo_SetUserHeader</b></i></a>&nbsp;<tt>(SConnNetInfo* info, const char* new_user_header)</tt><br>
  Set the new HTTP user header (freeing the previous one if any) by cloning the passed string argument and storing it in
  <tt>http_user_header</tt> field. <tt>New_user_header</tt> passed as <tt>NULL</tt> resets the field.
<li> <a href="../lxr/ident?i=ConnNetInfo_Clone"><i><b>ConnNetInfo_Clone</b></i></a>&nbsp;<tt>(SConnNetInfo* info)</tt><br>
  Create and return pointer to a new <tt>SConnNetInfo</tt> structure, which is an exact
  copy of the passed structure. This function is aware of dynamic nature of the HTTP
  <a href="#ref_HttpUserHeader">user header field</a>.
</ul>

<ol>
<a name="ref_Registry"></a><b><u>Note about the registry</u></b>. The registry used by <tt>connect</tt> library is
separate from <a href="../programming_manual/registry.html"><b><i>CNcbiRegistry</i></b></a> class.
Namely, in order to be included in <i>both</i> C <i>and</i> C++ NCBI Toolkits, <tt>connect</tt> library
uses another <a href="../lxr/ident?i=REG">registry</a> (C structure), called C registry and defined in
<a href="../lxr/source/include/connect/ncbi_core.h"><b><i>connect/ncbi_core.h</i></b></a>.
The global registry object (so called <i>CORE C registry</i>) consulted by the library
is set by means of <a href="../lxr/ident?i=CORE_SetREG"><b><i>CORE_SetREG()</i></b></a>
declared in <a href="../lxr/source/include/connect/ncbi_util.h"><b><i>connect/ncbi_util.h</i></b></a>.
The same notice applies to the logging facility, that is <tt>connect</tt> library has its own
<a href="../lxr/ident?i=LOG">logger</a> defined in the
same header <a href="../lxr/source/include/connect/ncbi_core.h"><b><i>connect/ncbi_core.h</i></b></a>. The
global logger (<i>CORE logger</i>) used by the library is set by convenience routines declared in
<a href="../lxr/source/include/connect/ncbi_util.h"><b><i>connect/ncbi_util.h</i></b></a>:
<a href="../lxr/ident?i=CORE_SetLOG"><b><i>CORE_SetLOG()</i></b></a>,
<a href="../lxr/ident?i=CORE_SetLOGFILE"><b><i>CORE_SetLOGFILE()</i></b></a> etc.
There is, however, a means for a C++ program, using NCBI C++ Toolkit, to bind <b><i>CNcbiRegistry</b></i>
object to the C registry <b><i>REG</i></b>, <a href="../programming_manual/diag.html"><b><i>CNcbiDiag</i></b></a> to the C logger
<b><i>LOG</i></b> etc.
The interface defined in <a href="../lxr/source/include/connect/ncbi_core_cxx.hpp"><b><i>connect/ncbi_core_cxx.hpp</i></b></a>
includes the following C++ functions:
<ul>
<li> <tt>REG</tt> <a href="../lxr/ident?i=REG_cxx2c"><b><i>REG_cxx2c</i></b></a>&nbsp;<tt>(CNcbiRegistry* reg, bool pass_ownership = false)</tt>
<li> <tt>LOG</tt> <a href="../lxr/ident?i=LOG_cxx2c"><b><i>LOG_cxx2c</i></b></a>&nbsp;<tt>(void)</tt>
</ul>
Returned <b><i>REG</i></b> and <b><i>LOG</i></b> are created on top of the corresponding C++ objects,
and then both C and C++ objects could be manipulated interchangeably, causing exactly the same effect on the underlying
registry or logger. An example could be seen in the test program
<a href="../lxr/source/src/connect/test/test_ncbi_conn_stream.cpp"><tt>test_ncbi_conn_stream.cpp</tt></a>.
Also, returned C handles <b><i>REG</i></b> and <b><i>LOG</i></b>
can be set as <i>CORE</i> registry and logger using <b><i>CORE_SetREG()</i></b> and <b><i>CORE_SetLOG()</i></b>,
respectively.
</ol>

<p>
The following fields of <b><i>SConnNetInfo</i></b> pertain to the HTTP connector:
<tt>client_host</tt>, <tt>host</tt>, <tt>port</tt>, <tt>path</tt>, <tt>args</tt>, <tt>req_method</tt> (can be one of
<tt>"GET"</tt>, <tt>"POST"</tt>, and <tt>"ANY"</tt>),
<tt>timeout</tt>, <tt>max_try</tt> (analog of maximal try parameter for the
<a href="#ref_SocketConnector">socket connector</a>), <tt>http_proxy_host</tt>, <tt>http_proxy_port</tt>,
<tt>debug_printout</tt> (values are <tt>"NONE"</tt> to disable any trace printout
of the connection data, <tt>"SOME"</tt> to enable printing of <tt>SConnNetInfo</tt>
structure before each connection attempt, and <tt>"DATA"</tt> to print both
headers and data of the HTTP packets in addition to dumps of <tt>SConnNetInfo</tt> structures). Values of other fields are ignored.

<p>
Argument <tt>flags</tt> in the HTTP connector's constructor is a bitwise <tt>OR</tt> of the following values:
<ul>
<li> <a href="../lxr/ident?i=EHCC_Flags"><i><b>fHCC_AutoReconnect</b></i></a><br>
 Allow multiple request/reply HTTP transactions. (Otherwise by default, only one request/reply is allowed.)
<li> <i><b>fHCC_SureFlush</b></i><br>
  Always flush a request (maybe solely consisting of HTTP header with
  no body at all) down to the HTTP server before preforming any read
  or close operations.
<li> <a name="fHCC_KeepHeader"></a><i><b>fHCC_KeepHeader</b></i><br>
  By default, HTTP connection sorts out the HTTP header and parses
  HTTP errors (if any). Thus, normally reading from the connection returns
  data from the HTTP body only. The flag disables this feature, and the HTTP
  header is not parsed but instead passed <i>'as is'</i> to the application on a call to <a href="#CONN_Read"><i><b>CONN_Read()</b></i></a>.
<li> <i><b>fHCC_UrlDecodeInput</b></i><br>
  Decode input data passed in HTTP body from the HTTP server.
<li> <i><b>fHCC_UrlEncodeOutput</b></i><br>
  Encode output data passed in HTTP body to the HTTP server.
<li> <i><b>fHCC_UrlCodec</b></i><br>
  Perform both encoding and encoding (<tt>fHCC_UrlDecodeInput | fHCC_UrlEncodeOutput</tt>).
<li> <i><b>fHCC_UrlEncodeArgs</b></i><br>
  Encode URL if it contains special characters like <tt>'+'</tt>. By default,
  the arguments are passed <i>'as is'</i> (exactly as taken from <tt>SConnNetInfo</tt>).
<li> <i><b>fHCC_DropUnread</b></i><br>
  Drop unread data, which might exist in connection, before making another
  request/reply HTTP shot. Normally, the connection first tries to read out
  the data from the HTTP server entirely, until <tt>EOF</tt>, and store them
  in the internal buffer even if either application did not requested the
  data for reading, or the data were read only partially, so that
  the next read operation will see the data.
<li> <i><b>fHCC_NoUpread</b></i><br>
  Do not attempt to empty incoming data channel into a temporary
  intermediate buffer while writing to the outgoing data channel.
  By default, writing always makes checks that incoming data are
  available for reading, and those data are extracted and stored in
  buffer. This approach allows to avoid I/O deadlock, when
  writing creates a backward stream of data, which if unread
  blocks the connection entirely.
</ul>

The HTTP connection will be established using the following URL:
<pre>
<font color="#009900">http://host:port/path?args</font>
</pre>
<u>Note</u> that <tt>path</tt> has to have a leading slash "/" as the very first character, that is, only "http://" and "?" are added by the connector,
all other characters appear exactly as specified (but maybe encoded with <i><b>fHCC_UrlEncodeArgs</b></i>).
The question mark does not appear if the URL has no arguments.

<p>
More elaborate form of the HTTP connector's constructor has the following prototype:
<pre>
typedef int/*bool*/ (*FHttpParseHTTPHeader)
(const char* http_header,
 void*       adjust_data,
 int/*bool*/ server_error);
 
typedef int/*bool*/ (*FHttpAdjustInfo)
(SConnNetInfo* info,
 void*         adjust_data,
 unsigned int  n_failed);
 
typedef void (*FHttpAdjustCleanup)
(void* adjust_data
 );
 
extern CONNECTOR <a href="../lxr/ident?i=HTTP_CreateConnectorEx">HTTP_CreateConnectorEx</a>
(const SConnNetInfo*  net_info,
 THCC_Flags           flags,
 FHttpParseHTTPHeader parse_http_hdr, /* may be NULL, then no addtl. parsing  */
 FHttpAdjustInfo      adjust_info,    /* may be NULL, then no adjustments     */
 void*                adjust_data,    /* for "adjust_info" & "adjust_cleanup" */
 FHttpAdjustCleanup   adjust_cleanup  /* may be NULL                          */
 );
</pre>
This form is assumed to be rarely used by the users directly, but it provides rich access to the internal management of HTTP connections.

<p>
The first two arguments are identical to their counterparts in the arguments number
one and three of <a href="../lxr/ident?i=HTTP_CreateConnector"><i><b>HTTP_CreateConnector()</b></i></a>.
HTTP user header field (if any) is taken directly from <a href="#ref_HttpUserHeader"><tt>http_user_header</tt></a>
field of <b><i>SConnNetInfo</i></b>, pointer to which is passed as <tt>net_info</tt> (which in turn can be passed as
<tt>NULL</tt> meaning to use the environment, registry and defaults as described <a href="#ref_SConnNetInfo">above</a>).

<p>
The third parameter specifies a callback to be activated to
parse the HTTP reply header (passed as a single string, with <tt>CR-LF</tt> -&nbsp;carriage return/line feed&nbsp;- characters incorporated to divide header lines). This callback
also gets some custom data <tt>adjust_data</tt> as supplied in the fifth argument of the connector's constructor,
and a boolean value <tt>true</tt> if parsed response code from the server was not okay. The callback can return
<tt>false</tt> (zero), which is considered the same way as having an error
from the HTTP server. However, pre-parsed error condition (passed in <tt>server_error</tt>) retains even if the
return value of the callback is <tt>true</tt>, that is the callback is unable to "fix" the error code from the server.
This callback is <i>not</i> called if <a href="#fHCC_KeepHeader"><i><b>fHCC_KeepHeader</b></i></a> is set in flags.

<p>
The forth argument is a callback, which gets control when an attempt to connect
to the HTTP server has failed. On entry, this callback has current <b><i>SConnNetInfo</i></b>, which is requested to be adjusted in a faith that
the connection to the HTTP server will finally succeed. That is, the callback
can change anything in the info structure, and the modified structure
will be kept for all further connection attempts, until changed by this callback again.
The number (starting from 1) of successive failed attempts is given in the last callback's
argument. The callback return value <tt>true</tt> (non-zero) means successful adjustment. Return value
<tt>false</tt> (zero) stops gives up connection tryings and returns an error to the application.

<p>
When connector is been destroyed, the custom object <tt>adjust_data</tt> can be
destroyed in the callback, specified as the last argument of the
extended constructor.

<p>
<u>Note</u>: Any callback may be specified as <tt>NULL</tt>, which means that no action
is foreseen by the application, and default behavior occurs.

<p>
<hr>


<a name="ref_ServiceConnector"></a><h3>Service connector</h3>

Constructors defined in:
<pre>
#include &lt;<a href="../lxr/source/include/connect/ncbi_service_connector.h">connect/ncbi_service_connector.h</a>&gt;
</pre>

This is the most complex connector in the library. It can initiate data exchange between an application and a named NCBI service,
and data link can be either wrapped in HTTP or be just a byte-stream (like in a socket). In fact, this connector
sits on top of either <a href="#ref_HTTPConnector">HTTP</a> or <a href="#ref_SocketConnector">SOCKET</a> connectors.

<p>
The library provides two forms of connector's constructor:
<pre>
<a href="../lxr/ident?i=SERVICE_CreateConnector">SERVICE_CreateConnector</a>(const char* service_name);

<a href="../lxr/ident?i=SERVICE_CreateConnectorEx">SERVICE_CreateConnectorEx</a>
(const char*           service_name, /* The registered name of an NCBI service */
 <a href="../../lxr/ident?i=TSERV_Type">TSERV_Type</a>            types,        /* Accepted server types, bitmask         */
 const <a href="../../lxr/ident?i=SConnNetInfo">SConnNetInfo</a>*   net_info,     /* Connection parameters                  */
 const <a href="../../lxr/ident?i=SSERVICE_Extra">SSERVICE_Extra</a>* params        /* Addtl set of parameters, may be NULL   */
 );
</pre>
The first form is equivalent to <i><b>SERVICE_CreateConnectorEx(</b></i><tt>service_name, fSERV_Any, 0, 0</tt><i><b>)</b></i>.

<form name="io_bounce" method="POST" action="http://www.ncbi.nlm.nih.gov/Service/dispd.cgi?service=io_bounce">
<input type="hidden" name="name" value="value">
</form>
A named NCBI service is a CGI program or standalone server (which can be of one of two supported types), which runs at the NCBI site,
and accessible by the outside world. Special dispatcher (which runs on the <a href="http://www.ncbi.nlm.nih.gov">NCBI Web-servers</a>)
allows automatic switching to the appropriate server without
having the client to know <i>a priori</i> the connection point. That is,
the client just uses the main entry gate of the NCBI Web (usually, <a href="http://www.ncbi.nlm.nih.gov"><tt>www.ncbi.nlm.nih.gov</tt></a>)
with a request to have a service "<i>service_name</i>", and depending on the service availability, the request will be either 
<a href="http://www.ncbi.nlm.nih.gov/Service/dispd.cgi?service=io_bounce" onclick="javascript:io_bounce.submit(); return false">honored</a> (by switching and routing the client to the machine
actually running the server: clicking on the previous link should bring you
to a page containing "name=value" message, obtained from the special bouncing
service as a result of the form submission), <a href="http://www.ncbi.nlm.nih.gov/Service/dispd.cgi?service=blahblah">rejected</a>,
or <a href="http://www.ncbi.nlm.nih.gov/Service/dispd.cgi?service=TaxServer">declined</a>. To the client,
the entire process of dispatching is seen as completely transparent (for
example, try clicking several times on either of the latter two links and see that the
error replies are actually sent from different hosts, so is the successful processing of the
first link done by one of several hosts running the bouncing service).

<p>
<a name="ref_dispd_cgi"></a><a href="../tools/dispatcher/DISPD.html">Dispatching protocol</a>&nbsp;<i>per se</i> is implemented on top of the HTTP protocol, and is parsed by a
CGI program <a href="../lxr/source/src/connect/daemons/dispd_cgi.c"><tt>dispd.cgi</tt></a> (or another dispatching CGI), which is
available on the NCBI Web. On every server running the named services, another program, called
<a href="../tools/dispatcher/LBSMD.html">load-balancing daemon</a>&nbsp; (<a href="../lxr/source/src/connect/daemons/lbsmd.c"><tt>lbsmd</tt></a>),
is executing. This daemon supports having the same service running on different machines, and allows to choose among them the one machine, which is less loaded.
When <tt>dispd.cgi</tt> receives a request for a named service, it first consults the load-balancing table, which is broadcasted by each
load-balancing daemon, and re-assembled in a network-wide form on each server. When the corresponding server is found,
the client request can be passed, or a dedicated connection to the server can be established. The dispatching is made such a way that it
can be also used directly from the Internet browsers.

<p>
The named service facility uses the following distinction of <a name="ref_ServerTypes"></a>server types:
<ul>
<li>HTTP servers, which are usually CGI programs:
  <ul>
  <li><font color="#CC33CC"><tt>HTTP_GET</tt></font> servers are those accepting requests only using HTTP <tt>GET</tt>
      method.
  <li><font color="#CC33CC"><tt>HTTP_POST</tt></font> servers are those accepting requests only using HTTP
      <tt>POST</tt> method.
  <li><font color="#CC33CC"><tt>HTTP</tt></font> servers are those accepting both of either <tt>GET</tt> or <tt>POST</tt> methods.
  </ul>
  <li><font color="#CC33CC"><tt>NCBID</tt></font> servers are those run by a special
      <a href="../tools/dispatcher/DISPD.html#ref_NCBID">CGI engine</a>, called
      <a href="../lxr/source/src/connect/daemons/dispd_cgi.c"><tt>ncbid.cgi</tt></a>, a configurable program
      (now integrated within <a href="#ref_dispd_cgi"><tt>dispd.cgi</tt></a> itself), which can convert byte-stream
      output from another program (server) started by the request from dispatcher to an HTTP-compliant reply
      (that is a packet having both HTTP header and body, and suitable e.g. for Web-browsers).
  <li><font color="#CC33CC"><tt>STANDALONE</tt></font> servers, like mailing daemons, are those listening on their own
      onto the network for incoming connections.
  <li><font color="#CC33CC"><tt>FIREWALL</tt></font> servers are the special pseudo-servers, not existing in reality, but are created
      and used internally by the dispatcher software to indicate that only a firewall connection mode can
      be used to access the requested service.
</ul>

Formal description of these types is given in
<a href="../lxr/source/include/connect/ncbi_server_info.h"><i><b>connect/ncbi_server_info.h</b></i></a>:
<pre>
/* Server types
 */
typedef enum {
  fSERV_Ncbid      = 0x1,
  fSERV_Standalone = 0x2,
  fSERV_HttpGet    = 0x4,
  fSERV_HttpPost   = 0x8,
  fSERV_Http       = fSERV_HttpGet | fSERV_HttpPost,
  fSERV_Firewall   = 0x10
} <a href="../../lxr/ident?i=ESERV_Type">ESERV_Type</a>;

#define fSERV_Any           0
#define fSERV_StatelessOnly 0x80
typedef unsigned TSERV_Type;  /* bit-wise OR of "ESERV_Type" flags */
</pre>

The bitwise <tt>OR</tt> of the <i><b>ESERV_Type</b></i> flags can be used to
restrict the search for the servers, matching the requested service name.
These flags passed as argument <tt>types</tt> are used by the
dispatcher when figuring out, which server is acceptable for the client.
Special value&nbsp;<tt>0</tt> (or, better <i><b>fSERV_Any</b></i>) states no
such preference whatsoever. Special bit-value <i><b>fSERV_StatelessOnly</b></i>
set together with other bits or just alone specifies that the servers
should be of stateless (HTTP-alike) type only, and it is the client which is responsible for keeping
track of the logical sequence of transactions.

<p>
Normally the last parameter of <b><i>SERVICE_CreateConnectorEx()</i></b> is left <tt>NULL</tt>, which
sets all additional parameters to their default values. Among others, default procedure of choosing
an appropriate server is used by the connector when looking for mapping of name into server address.
To see how this parameter can be used to change the mapping procedure
please refer to a <a href="#ref_ServiceAPI">later section</a>.

<p>
The following code fragment establishes service connection to
the named service <tt>"io_bounce"</tt>, using only stateless servers:
<pre>
  CONNECTOR c;
  CONN conn;

  if (!(c = SERVICE_CreateConnectorEx("io_bounce", fSERV_StatelessOnly, 0, 0)))
    fprintf(stderr, "No such service available");
  else if (CONN_Create(c, &conn) != eIO_Success)
    fprintf(stderr, "Failed to create connection");
  else {
    static const char buffer[] = "Data to pass to the server";
    size_t n_written;
    
    CONN_Write(conn, buffer, sizeof(buffer) - 1, &n_written);
    ...
  }
</pre>

The real type of the data channel can be obtained via call to
<a href="#CONN_GetType"><i><b>CONN_GetType(</b></i><tt>conn</tt><i><b>)</b></i></a>.

<p>
<u>Note</u>: In the above example the client has no assumption how the
data actually passed to the server. The server could be of any
type in principle, even a standalone server, which was used
in the request/reply mode of one-shot transactions. If necessary,
such wrapping would have been made by the dispatching facility as well.

<p>
The last parameter of the extended constructor is the network info,
described in section devoted to <a href="#ref_HTTPConnector">HTTP connector</a>.
Service connector uses all fields of this structure, except for
<a href="#ref_HttpUserHeader"><tt>http_user_header</tt></a>,
and the following assumptions apply:
<ul>
<li><tt>path</tt> specifies the dispatcher program (defaulted to <tt>dispd.cgi</tt>);
<li><tt>args</tt> specifies parameters for the requested service, this is service-specific, no defaults;
<li><tt>stateless</tt> is used to set <i><b>fSERV_StatelessOnly</b></i>
flag in the server type bitmask, if it was not set there already
(convenient to modify the dispatching using environment and/or registry,
if the flag is not set; yet allows to hardcode the flag at compile-time
by setting it in constructor's <tt>types</tt> argument explicitly);
<li><tt>lb_disable</tt> set to <tt>true</tt> (non-zero) means to always use remote dispatcher
(via network connection) even if locally running load-balancing daemon is available
(by default, local load-balancing deamon consulted first to resolve
the name of the service);
<li><tt>firewall</tt> set to <tt>true</tt> (non-zero) disables the direct connection to
the service. Instead, either a connection to a proxy <a href="../tools/dispatcher/fwdaemon.html">firewall daemon</a>
(<a href="../lxr/source/src/connect/daemons/fwdaemon.c">fwdaemon</a>), running
at the NCBI site, is initiated to pass the data in stream mode, or data get relayed
via dispatcher if stateless server is used;
<li><tt>http_user_header</tt> ignored (asserted to be <tt>NULL</tt> in debug compilation mode).
</ul>

<p>
As with HTTP connector, if network information structure is specified as
<tt>NULL</tt>, default values are obtained as described above, as with the call to
<a href="#ref_ConnNetInfo_Create"><i><b>ConnNetInfo_Create(</b></i><tt>service_name</tt><i><b>)</b></i></a>.

<p>
Library provides additional <a href="#ref_ServiceAPI">interface to named service mapper</a>, which
can be found in <a href="../lxr/source/include/connect/ncbi_service.h"><i><b>connect/ncbi_service.h</b></i></a>.

<p>
<u>Note</u>: Requesting&nbsp; <b><i>fSERV_Firewall</i></b> in the <tt>types</tt> parameter effectively selects
firewall mode regardless of the network parameters, loaded via <b><i>SConnNetInfo</i></b> structure.

<p>
<hr>


<a name="ref_CxxConnectionStreams"></a><h2>C++ Connection Streams</h2>

Using connections and connectors (in its most entirely procedural approach)
in C++ programs overkills the power of the language.
Therefore, we provide C++ users with the stream classes, all
derived from standard <tt>iostream</tt> class, and as a result, which can be used with
all famous stream I/O operators, manipulators etc.

<p>
The declarations of the stream's constructors can be found in
<a href="../lxr/source/include/connect/ncbi_conn_stream.hpp"><i><b>connect/ncbi_conn_stream.hpp</b></i></a>.
We tried to keep the same number and order of constructor's
parameters, as they appear in the corresponding connector's constructors in C.

<p>
The code below is a C++-style example from the previous section devoted to the
<a href="#ref_ServiceConnector">service connector</a>:
<pre>
#include &lt;connect/ncbi_conn_stream.hpp&gt;
  
  try {
    <a href="../lxr/ident?i=CConn_HttpStream">CConn_HttpStream</a> ios("io_bounce", fSERV_StatelessOnly, 0);
    ios << "Data to be passed to the server";
  } <a href="../lxr/ident?i=STD_CATCH_ALL">STD_CATCH_ALL</a>("Connection problem");
  
  ...
</pre>
<u>Note</u>:
Stream constructor may throw an exception if, for instance,
the requested service is not found, or other kind of problem arose.
To see the actual reason, we used standard toolkit macro <i><b>STD_CATCH_ALL()</b></i>, which prints the message and problem
description into the log file (<tt>cerr</tt>, by default).

<p>
<hr>


<a name="ref_ServiceAPI"></a><h2>Service mapping API</h2>

The API defined in <a href="../lxr/source/include/connect/ncbi_service.h"><b><i>connect/ncbi_service.h</i></b></a>
maps required sevice name into server address. Internally, the mapping is done <a href="#ref_DirectIndirect">either directly or indirectly</a> by means of
<a href="../tools/dispatcher/LBSMD.html">load-balancing daemon</a>, running at NCBI site.
For the client, the mapping is seen as a reading from an iterator created by a call to
<b><i>SERV_Open()</i></b> like in the following
fragment (for more examples please refer to the test program
<a href="../lxr/source/src/connect/test/test_ncbi_disp.c"><tt>test_ncbi_disp.c</tt></a>):
<pre>
#include &lt;connect/ncbi_service.h&gt;

    <a href="../lxr/ident?i=SERV_ITER">SERV_ITER</a> iter = <a href="../lxr/ident?i=SERV_Open">SERV_Open</a>("my_service", <a href="../lxr/ident?i=ESERV_Type">fSERV_Any</a>, <a href="../lxr/ident?i=SERV_ANYHOST">SERV_ANYHOST</a>, 0);
    int n = 0;

    if (iter != 0) {
        <a href="../lxr/ident?i=SSERV_Info">SSERV_Info</a>* info = <a href="../lxr/ident?i=SERV_GetNextInfo">SERV_GetNextInfo</a>(iter);

        while (info != 0) {
            char* str = <a href="../lxr/ident?i=SERV_WriteInfo">SERV_WriteInfo</a>(info);

            printf("Service = `%s'\n", str);
            free(str);
            n++;
        }
        <a href="../lxr/ident?i=SERV_Close">SERV_Close</a>(iter);
    }
    if (!iter || !n)
        printf("Service not found\n");
</pre>
<u>Note</u>: Non-<tt>NULL</tt> iterator returned from <b><i>SERV_Open()</i></b> <i>does not</i> yet
guarantee that the service is available, whereas <tt>NULL</tt> iterator definitely
means that the service does not exist.

<p>
As shown in the above example, loop reading from the iterator results in the sequence of successive structures
(none of which is to be freed by the program!), which along with conversion functions
<a href="../lxr/ident?i=SERV_ReadInfo"><b><i>SERV_ReadInfo()</i></b></a>,
<a href="../lxr/ident?i=SERV_WriteInfo"><b><i>SERV_WriteInfo()</i></b></a> and others are defined
in <a href="../lxr/source/include/connect/ncbi_server_info.h"><b><i>connect/ncbi_server_info.h</i></b></a>.
Structure <a href="../lxr/ident?i=SSERV_Info"><b><i>SSERV_Info</i></b></a> describes the server, which implements
requested service.
<tt>NULL</tt> gets returned, when no more servers (if any) could be found. The iterator returns servers in the order
the load-balancing algorithm extracts them. Each server has a rate, and the larger the rate
the better the chance for the server to be chosen first.

<p>
<u>Note</u>: Servers returned from the iterator are all of the requested type, with only one
exception: they can include servers of type <b><i>fSERV_Firewall</i></b> even if this type
was not explicitly requested. So the application must sort these servers out, if not interested in them.
But if <b><i>fSERV_Firewall</i></b> is set in the types, then the search is done for whichever else types requested,
and with the assumption that the client has chosen firewall connection mode, regardless of network parameters
supplied in <b><i>SConnNetInfo</i></b>, or read out from either registry or environment.

<p>
There is a simplified version of <b><i>SERV_Open()</i></b>, called <a href="../lxr/ident?i=SERV_OpenSimple"><b><i>SERV_OpenSimple()</i></b></a>,
as well as an advanced version, called <a href="../lxr/ident?i=SERV_OpenEx"><b><i>SERV_OpenEx()</i></b></a>.
The former takes only one argument, the service name. The latter takes two more arguments, which describe the
set of servers <i>not</i> to be seen from the iterator (excluded server descriptors).

<p>
There is also an advanced version of <b><i>SERV_GetNextInfo()</i></b>, called
<a href="../lxr/ident?i=SERV_GetNextInfoEx"><b><i>SERV_GetNextInfoEx()</i></b></a>, which allows via its second
argument to get so called <a href="../tools/dispatcher/LBSMD.html#ref_HostEnvironment">host environment</a>,
a <tt>'\0'</tt>-terminated string, consisting of set of lines
separated by <tt>'\n'</tt> characters, and specified in the configuration file of
<a href="../tools/dispatcher/LBSMD.html">load-balancing daemon</a>
of the host, where the returned server was found. The typical line within the set has a form <tt>"name=value"</tt>
and resembles very much the shell environment, where its name comes from. The host environment could be
very handy to pass additional information to applications if the host has some limitations or requires special
handling should the server be selected and used on this host. <a href="#ref_Example">Example below</a> should give an idea.<br>
For the time of writing, getting the host environment is only implemented when the service is obtained via <a href="#ref_DirectIndirect">direct access</a> to
the load-balancing daemon. Unlike returned server descriptors, the returned host environment is not a constant object i.e. it
could be modified, and it must be explicitly freed by the application when no longer needed.
If the server descriptor was obtained using dispatching CGI (<a href="#ref_DirectIndirect">indirect dispatching</a>),
then the host enrivonment is always returned as <tt>NULL</tt> (no host environment available).

<p>
<a name="ref_DirectIndirect"></a>The back end of the service mapping API is split into 2 independent parts: <i><u>direct</u></i> access to
<a href="../tools/dispatcher/LBSMD.html"><tt>LBSMD</tt></a>, if the one is both available on the current host and is not
disabled by parameter <a href="#ref_LbDisable"><tt>lb_disable</tt></a> at the iterator opening. If <tt>LBSMD</tt> is either unavailable
or disabled, the second (<u><i>indirect</i></u>) part of the back-end API is used, which involves connection to
<a href="../tools/dispatcher/DISPD.html">dispatching CGI</a>, which in turn connects to <tt>LBSMD</tt> in order to carry out the request.
Attempt to use the CGI is only done, if <a href="../lxr/ident?i=SERV_OpenEx"><tt>net_info</tt></a> argument is provided non-<tt>NULL</tt> in the
calls to <b><i>SERV_Open()</i></b> or <b><i>SERV_OpenEx()</i></b>.<br>
<u>Note</u>: In call to <b><i>SERV_OpenSimple()</i></b>, <tt>net_info</tt> gets created internally before upcall to
<b><i>SERV_Open()</i></b> and thus CGI dispatching is likely to happen, unless <tt>net_info</tt> could not be constructed
from the environment.<br>
<u>Note</u>: In the above conditions, the network service name resolution is also undertaken if service name could
not be resolved (due to service inexistence or other error) with the use of locally found <tt>LBSMD</tt>.

<p>
<a name="ref_Example"></a>The following code example uses both <a href="#ref_ServiceConnector">service connector</a> and the service
mapping API to access certain service using an alternate way (other than connector's default) of choosing appropriate servers.
By default, service connector opens an internal service iterator and then tries to connect to the next server,
which <b><i>SERV_GetNextInfo()</i></b> returns when given the iterator. That is, the server with higher rate is
tried first. If the user provides a pointer to structure <b><i>SSERVICE_Extra</i></b> as the last parameter of the connector's
constructor, then the user-supplied routine (if any) can be called instead in order to obtain the next server. The routine is also
given a supplemental custom argument <tt>data</tt> taken from <b><i>SSERVICE_Extra</i></b>.
The (intentionally simplified) example below tries to create connector to an imaginary service <tt>"my_service"</tt>
in restriction that the server has additionally to have a certain (user-specified) database present. The database name is taken
from <a href="../tools/dispatcher/LBSMD.html#ref_HostEnvironment">LBSMD host environment</a> keyed <tt>"my_service_env"</tt>,
the first word of which is assumed to be the name.

<pre>
#include &lt;<a href="../lxr/source/include/connect/ncbi_service_connector.h">connect/ncbi_service_connector.h</a>&gt;
#include &lt;ctype.h>
#include &lt;stdlib.h>
#include &lt;string.h>

#define ENV_DB_KEY "my_service_env="


/* This routine gets called when connector is about to close.
 */
static void s_CleanupData(void* data)
{
    free(data); /* we kept database name there */
}


/* 'Iter' is an internal service iterator used by service connector; it must remain open.
 * 'Data' is what we supplied among extra-parameters in connector's constructor.
 */
static const SSERV_Info* s_GetNextInfo(<a href="../lxr/ident?i=SERV_ITER">SERV_ITER</a> iter, void* data)
{
    const char* db_name = (const char*) data;
    size_t len = strlen(db_name);
    <a href="../lxr/ident?i=SSERV_Info">SSERV_Info</a>* info;
    int reset = 0;
    char* env;

    for (;;) {
        while ((info = <a href="../lxr/ident?i=SERV_GetNextInfoEx">SERV_GetNextInfoEx</a>(iter, &amp;env)) != 0) {
            const char* c;
            for (c = env; c; c = strchr(c, '\n')) {
                if (strncmp(c == env ? c : ++c, ENV_DB_KEY, sizeof(ENV_DB_KEY)-1) == 0) {
                    /* Our keyword has been detected in environment for this host */
                    c += sizeof(ENV_DB_KEY) - 1;
                    while (*c && isspace(*c))
                        c++;
                    if (strncmp(c, db_name, len) == 0 && !isalnum(c + len)) {
                        /* Database match */
                        free(env); /* must be freed explicitly */
                        return info;
                    }
                }
            }
            if (env)
                free(env); /* must be freed explicitly */
        }
        if (reset)
            break; /* coming to reset 2 times in a row means no server fits */
        <a href="../lxr/ident?i=SERV_Reset">SERV_Reset</a>(iter);
        reset = 1;
    }
    return 0; /* no match found */
}


int main(int argc, char* argv[])
{
    char* db_name = strdup(argv[1]);
    <a href="../lxr/ident?i=SSERVICE_Extra">SSERVICE_Extra</a> params;
    <a href="../lxr/ident?i=CONNECTOR">CONNECTOR</a> c;
    <a href="../lxr/ident?i=CONN">CONN</a> conn;

    memset(&params, 0, sizeof(params));
    params.data = db_name;                /* custom data, anything        */
    params.cleanup = s_CleanupData;       /* cleanup routine, may be NULL */
    params.get_net_info = s_GetNextInfo;  /* custom iterator routine      */
    if (!(c = <a href="../lxr/ident?i=SERVICE_CreateConnectorEx">SERVICE_CreateConnectorEx</a>("my_service", fSERV_Any, NULL, &amp;params))) {
        fprintf(stderr, "Cannot create connector");
        exit(1);
    }

    if (<a href="../lxr/ident?i=CONN_Create">CONN_Create</a>(c, &conn) != <a href="../lxr/ident?i=EIO_Status">eIO_Success</a>) {
        fprintf(stderr, "Cannot create connection");
        exit(1);
    }

    /* Now we can use <a href="../lxr/ident?i=CONN_Read">CONN_Read()</a>, <a href="../lxr/ident?i=CONN_Write">CONN_Write()</a> etc to operate with connection,
     * and we are assured that the connection is made only to the server on such a host,
     * which has "db_name" specified in configuration file of <a href="../tools/dispatcher/LBSMD.html">LBSMD</a>.
     */

    ...
    <a href="../lxr/ident?i=CONN_Close">CONN_Close</a>(conn); /* this also calls cleanup of user data provided in params */

    return 0;
}
</pre>
<u>Note</u>: No network (indirect) mapping occurs in the above example because <tt>net_info</tt> is passed as <tt>NULL</tt>
to the connector's constructor.

<p>
<hr>
<table border=0 width="100%" cellspacing=0>
<tr>
<td align=left>
  <address><a href="mailto:lavr@ncbi.nlm.nih.gov">Anton Lavrentiev</a></address>
</td>
<!-- <td align=center><i>$Revision$</i></td> -->
<td align=right><i>$Date$</i></td>
</tr>
</table>

<!--#include virtual="../ssi/footer.shtml" -->
