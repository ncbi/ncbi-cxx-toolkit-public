<!--#set var="TITLE" value="Connection Library" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->
<i><h1><font color="#FF0000"><span style="background-color: #FFFFFF">Warning: This HTML page is deprecated</span></font></h1>

All new changes are being made to the Toolkit Book
at the following locations:
<ul>
<li>
<i>Official Release:</i> <a href="http://www.ncbi.nlm.nih.gov/books/bv.fcgi?call=bv.View..ShowTOC&rid=toolkit.TOC&depth=2">
    C++ Toolkit Book</a>.
</li>
<li>
<i>Development Version:</i> <a href="http://xpubmed0.ncbi.nlm.nih.gov:5701/books/bv.fcgi?call=bv.View..ShowTOC&rid=toolkit.TOC&depth=2">

    C++ Toolkit Book (no search engine, accessible from inside NCBI only)</a>. </li> </ul> The Development Version is the most recent documentation before it becomes an Official Release. While the Development Version is the lastest version, it is accessible only from inside NCBI, and the search engine functionality is currently missing. Also, the location of the Development Version may change without warning! So it is suggested that you use the Official Release, and use the Development Version only when necessary.</p> </i>

<hr>
<!--EOW-->

<h1>Connection Library (CONNECT)</h1>

<font size=1><span class="ncbi_note">Note</span>: Due to security issues, not all links in the public version
of this file could be accessible by outside NCBI users. Unrestricted version of this document is available to
inside NCBI users at:
<a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/libs/conn.html" class="ncbi_url">http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/libs/conn.html</a>.
</font>

<h2>Contents</h2>

<ol>
<ul>
    <li> <a href="#ref_Overview">Overview</a>
    <li> <a href="#ref_Connections">Connections</a>: notion of connection; different types of connections that library provides;
	programming API.
    <ul>
	<li> <a href="#ref_SocketConnector">Socket Connector</a>
	<li> <a href="#ref_FileConnector">File Connector</a>
	<li> <a href="#ref_HTTPConnector">HTTP Connector</a>
	<li> <a href="#ref_ServiceConnector">Service Connector</a>
    </ul>
    <li> <a href="#ref_Debugging">Debugging Tools and Troubleshooting</a>
    <li> <a href="#ref_CxxConnectionStreams">C++ Connection Streams</a> built on top of connection objects.
    <li> <a href="#ref_ServiceAPI">Service mapping API</a>: description of service name resolution API.
    <li> <a href="#ref_ThreadedServer">Threaded Server Support</a>
</ul>
</ol>

<p>
<hr>


<a name="ref_Overview"></a><h2>Overview</h2>

NCBI C++ platform-independent
connection library (<a href="../lxr/source/src/connect"><span class="ncbi_dir">src/connect</span></a>
and <a href="../lxr/source/include/connect"><span class="ncbi_dir">include/connect</span></a>)
consists of 2 parts:
<ol>
<li> Lower-level library written in C (also used as a replacement of existing
connection library in the NCBI C Toolkit);
<li> Upper-level library written in C++ and using C++ streams.
</ol>
<p>
Functionality of the library includes:
<ul>
	<li> <span class="ncbi_interface">SOCK</span> interface (sockets), which works
         interchangeable on most UNIX flavors, MS-Windows, and Mac;
	<li> <span class="ncbi_interface">SERV</span> interface, which provides mapping of symbolic service names into server addresses;
	<li> <span class="ncbi_interface">CONN</span> interface, which allows to
         create a <span class="ncbi_term">connection</span>, the special object capable to
         do read, write etc. I/O operations;
	<li> C++ streams built on top of <span class="ncbi_interface">CONN</span> interface.
</ul>
<p>
<span class="ncbi_note">Note</span>:
The most lower-level <span class="ncbi_interface">SOCK</span> interface is not covered in this document.
Well-commented API can be found in
<a href="../lxr/source/include/connect/ncbi_socket.h" class="ncbi_file">connect/ncbi_socket.h</a>.

<p>
<hr>


<a name="ref_Connections"></a><h2>Connections</h2>

There are 3 simple types of connections: <span class="ncbi_term">socket</span>, <span class="ncbi_term">file</span> and
<span class="ncbi_term">http</span>; and one hybrid type, <span class="ncbi_term">service</span> connection.

<p>
A connection is created with a call to <a href="../lxr/ident?i=CONN_Create"><span class="ncbi_func">CONN_Create()</span></a>,
declared in <a href="../lxr/source/include/connect/ncbi_connection.h"><span class="ncbi_file">connect/ncbi_connection.h</span></a>,
and returned by a pointer to <span class="ncbi_type">CONN</span> passed as a second argument:
<pre class="ncbi_code">
CONN conn;          /* connection handle */
EIO_Status status = CONN_Create(connector, &conn);
</pre>
The first argument of this function is a handle of a so-called <span class="ncbi_term">connector</span>,
a special object implementing functionality of the connection being built.
Above, for each type of connection there is a special connector in the
library. For each connector, one or more "constructors" defined, each
returning the connector's handle. Connectors' constructors are defined in individual
header files, like <a href="../lxr/source/include/connect/ncbi_socket_connector.h"><span class="ncbi_file">connect/ncbi_socket_connector.h</span></a>,
<a href="../lxr/source/include/connect/ncbi_http_connector.h"><span class="ncbi_file">connect/ncbi_http_connector.h</span></a>,
<a href="../lxr/source/include/connect/ncbi_service_connector.h"><span class="ncbi_file">connect/ncbi_service_connector.h</span></a> etc.
<span class="ncbi_func">CONN_Create()</span> <a href="#CONN_SetTimeout">resets</a> all timeouts to the default value
<a href="../lxr/ident?i=CONN_DEFAULT_TIMEOUT" class="ncbi_var">CONN_DEFAULT_TIMEOUT</span></a>.

<p>
After successful creation with <span class="ncbi_func">CONN_Create()</span>, the following
calls from <span class="ncbi_interface">CONN</span> API
<a href="../lxr/source/include/connect/ncbi_connection.h"><span class="ncbi_file">connect/ncbi_connection.h</span></a> become available.
All calls (except <a href="#CONN_GetTimeout"><span class="ncbi_func">CONN_GetTimeout()</span></a> and <a href="#CONN_GetType"><span class="ncbi_func">CONN_GetType()</span></a>)
return I/O completion status of type <a href="../lxr/ident?i=EIO_Status"><span class="ncbi_type">EIO_Status</span></a>.
Normal completion has code <span class="ncbi_var">eIO_Success</span>.
<ul>

<li><a name="CONN_Read"></a><span class="ncbi_code"><a href="../lxr/ident?i=CONN_Read"><em>CONN_Read</em></a> (CONN conn, void* buf, size_t bufsize, size_t* n_read, EIO_ReadMethod how);</span><br>
Read or peek data, depending on read method <span class="ncbi_var">how</span>, up to <span class="ncbi_var">bufsize</span> bytes from connection to specified buffer
<span class="ncbi_var">buf</span>, return (via pointer argument <span class="ncbi_var">n_read</span>) the number of actually read bytes. The last argument
<span class="ncbi_var">how</span> can be one of the following:
<ul>
<li><a href="../lxr/ident?i=EIO_ReadMethod"><span class="ncbi_var">eIO_ReadPlain</span></a> - to read data in a regular way, that is extracting data from the connection,
<li><span class="ncbi_var">eIO_ReadPeek</span> - to peek data from the connection, i.e. the next read operation will see the data again,
<li><span class="ncbi_var">eIO_ReadPersist</span> - to read exactly (not less than) <span class="ncbi_var">bufsize</span> bytes or until an error condition occurs.
</ul>
Return value other than <span class="ncbi_var">eIO_Success</span> means trouble.
Specifically, return value <span class="ncbi_var">eIO_Timeout</span> indicates that the operation could not
be completed within the preset amount of time; but some data may, however,
be available in the buffer (e.g. in case of persistent reading, with <span class="ncbi_var">eIO_ReadPersist</span>), and this is actually the case for any return code.

<li> <span class="ncbi_code"><a href="../lxr/ident?i=CONN_Write"><em>CONN_Write</em></a> (CONN conn, const void* buf, size_t bufsize, size_t* n_written);</span><br>
Write the specified number of bytes <span class="ncbi_var">bufsize</span> from the buffer <span class="ncbi_var">buf</span> to the connection. Return (via <span class="ncbi_var">n_written</span>)
the number of actually written data, and completion code as a return value.

<li> <span class="ncbi_code"><a href="../lxr/ident?i=CONN_Flush"><em>CONN_Flush</em></a> (CONN conn);</span><br>
Flush internal output queue, if this is supported by the current connection type.

<li> <a name="CONN_SetTimeout"><span class="ncbi_code"></a><a href="../lxr/ident?i=CONN_SetTimeout"><em>CONN_SetTimeout</em></a> (CONN conn, EIO_Event action, const STimeout* timeout);</span><br>
Set the timeout on the specified I/O action, <a href="../lxr/ident?i=EIO_Event"><span class="ncbi_var">eIO_Read</span></a>, <span class="ncbi_var">eIO_Write</span>,
<span class="ncbi_var">eIO_ReadWrite</span>, <span class="ncbi_var">eIO_Open</span>, and <span class="ncbi_var">eIO_Close</span>. The latter 2 actions are
used in a phase of opening and closing the link, respectively: if connection
cannot be established (closed) within the specified period, <span class="ncbi_var">eIO_Timeout</span> would result.
<span class="ncbi_var">eIO_Timeout</span> results if reading/writing could not
be completed within specified time range, correspondingly. A timeout can be passed as
the <span class="ncbi_macro">NULL</span>-pointer. This special case denotes an infinite value for that timeout.
Also, a special value <span class="ncbi_var">CONN_DEFAULT_TIMEOUT</span> may be used for any timeout.
This value specifies the timeout set by default for the current connection type.

<li> <a name="CONN_GetTimeout"></a><span class="ncbi_code"><a href="../lxr/ident?i=CONN_GetTimeout">a<em>CONN_GetTimeout</em></a> (CONN conn, EIO_Event action);</span><br>
Obtain (via return value of type <span class="ncbi_type">const <a href="../lxr/ident?i=STimeout">STimeout</a>*</span>)
timeouts set by <a href="#CONN_SetTimeout" class="ncbi_func">>CONN_SetTimeout()</a> routine, or active by default
(i.e. special value <span class="ncbi_var">CONN_DEFAULT_TIMEOUT</span>).
<br>
<span class="ncbi_note">Caution</span>: Returned pointer valid only for the time the connection
handle is valid, i.e. up to a call to <a href="#CONN_Close"><span class="ncbi_func">CONN_Close()</span></a>.

<li> <a name="CONN_ReInit"></a><span class="ncbi_code"><a href="../lxr/ident?i=CONN_ReInit"><em>CONN_ReInit</em></a> (CONN conn, CONNECTOR replacement);</span><br>
This function allows to clear current contents of a
connection, and "immerse" a new connector into it.
Previous connector (if any) is closed first (if open),
then gets destroyed, and thus must not be referenced again in the program.
As a special case, new connector can be
the same connector, which is currently active within the connection. It this case, the connector is not destroyed,
instead it will be effectively re-opened. If connector passed as <span class="ncbi_macro">NULL</span>, then the <span class="ncbi_var">conn</span> handle is kept
existing but unusable (the old connector closed and destroyed), and can be <span class="ncbi_func">CONN_ReInit()</span>ed later.
None of the timeouts are touched by this call.

<li> <span class="ncbi_code"><a href="../lxr/ident?i=CONN_Wait"><em>CONN_Wait</em></a> (CONN conn, EIO_Event event, const STimeout* timeout);</span><br>
Suspend the program until connection is ready to perform reading (<span class="ncbi_var">event</span> = <span class="ncbi_var">eIO_Read</span>) or writing
(<span class="ncbi_var">event</span> = <span class="ncbi_var">eIO_Write</span>), or until timeout (if non-<span class="ncbi_macro">NULL</span>) expired. If timeout is passed as <span class="ncbi_macro">NULL</span>, then the wait time is infinite.

<li> <span class="ncbi_code"><a href="../lxr/ident?i=CONN_Status"><em>CONN_Status</em></a> (CONN conn, EIO_Event direction);</span><br>
Provide the information about recent low-level data exchange in the link.
Operation direction has to be specified as either <span class="ncbi_var">eIO_Read</span> or <span class="ncbi_var">eIO_Write</span>.
The necessity of this call arises from the fact that
sometimes return value of a <span class="ncbi_interface">CONN</span> API function does not really tell that the
problem has been detected: suppose, the user peeks data into a 100-byte buffer and gets 10 bytes.
Return status <span class="ncbi_var">eIO_Success</span> signals that those 10 bytes were found
in the connection okay. But how to know whether the end-of-file condition
occurred during last operation? It is where <span class="ncbi_func">CONN_Status()</span> comes
handy. When inquired about read operation, return value <span class="ncbi_var">eIO_Closed</span> denotes that
<span class="ncbi_macro">EOF</span> was actually hit while making the peek, and those 10 bytes are in fact the only data
left untaken, no more are expected to come.

<li> <a name="CONN_Close"></a><span class="ncbi_code"><a href="../lxr/ident?i=CONN_Close"><em>CONN_Close</em></a> (CONN conn);</span><br>
Close the connection by closing the link (if open), deleting underlying
connector(s) (if any) and the connection itself. Regardless of the return status (which may indicate certain problems),
the connection handle becomes invalid and cannot be used in the program again.

<li> <a name="CONN_GetType"></a><span class="ncbi_code"><a href="../lxr/ident?i=CONN_GetType"><em>CONN_GetType</em></a> (CONN conn);</span><br>
Return character string (0-terminated), verbally representing the current
connection type, like <span class="ncbi_value">"HTTP"</span>, <span class="ncbi_value">"SOCKET"</span>, <span class="ncbi_value">"SERVICE/HTTP"</span> etc. Unknown connection
type gets returned as <span class="ncbi_macro">NULL</span>.

<li> <span class="ncbi_code"><a href="../lxr/ident?i=CONN_SetCallback"><em>CONN_SetCallback</em></a> (CONN conn, ECONN_Callback type,<br>&nbsp;&nbsp;&nbsp;&nbsp;  const SCONN_Callback* new_cb, SCONN_Callback* old_cb);</span><br>
Set user callback function to be called upon an event specified by
callback <span class="ncbi_var">type</span>. The old callback (if any) gets returned via
passed pointer <span class="ncbi_var">old_cb</span> (if not <span class="ncbi_macro">NULL</span>). Callback
structure <a href="../lxr/ident?i=SCONN_Callback"><span class="ncbi_type">SCONN_Callback</span></a>
has the following fields: callback function <span class="ncbi_func">func</span> and
<span class="ncbi_ccode">void* data</span>. Callback function <span class="ncbi_var">func</span> should have the
following prototype:
<pre class="ncbi_code">
    typedef void (*FConnCallback)(CONN conn, ECONN_Callback type, void* data);
</pre>
When called, both <span class="ncbi_var">type</span> of callback and <span class="ncbi_var">data</span> pointer
are supplied. The only callback type defined as of writing of
this note is <a href="../lxr/ident?i=ECONN_Callback" class="ncbi_var">eCONN_OnClose</a>.
Callback function is always called prior to the event to happen, e.g. close callback is
called when the connection is about to close.
</ul>

<span class="ncbi_note">Note</span>: There is no means to "open" a connection: it is done
automatically when actually needed, and in most cases at
the first I/O operation.
But forming of actual link between source and destination
can be postponed even longer. These details are hidden and made transparent to
the connection's user. The connection is seen as a two-way communication channel,
which is clear to use right away after a call to <span class="ncbi_func">CONN_Create()</span>.
<p>
<span class="ncbi_note">Note</span>: If for some reason <span class="ncbi_func">CONN_Create()</span> failed to create
a connection (return code differs from <span class="ncbi_var">eIO_Success</span>), then the
connector passed to this function is left intact; that is, its
handle can be used again.
Otherwise, if connection is created successfully, the passed
connector handle becomes invalid, and cannot be referenced anywhere else throughout
the program (with one, however, exception: it may be used as a replacing connector in a call to
<a href="#CONN_ReInit"><span class="ncbi_var">CONN_ReInit()</span></a> for the same connection).
<p>
<span class="ncbi_note">Note</span>: There are no public connectors' "destructors". Connector successfully put into connection
is deleted automatically along with that connection by <span class="ncbi_var">CONN_Close()</span>,
or explicitly with a call to <span class="ncbi_var">CONN_ReInit()</span> provided that replacing connector is
<span class="ncbi_macro">NULL</span> or different from the original.

<p>
<hr>


<a name="ref_SocketConnector"></a><h3>Socket Connector</h3>

Constructors are defined in:
<pre class="ncbi_code">
#include &lt;<a href="../lxr/source/include/connect/ncbi_socket_connector.h">connect/ncbi_socket_connector.h</a>&gt;
</pre>

<p>
Socket connection based on the socket connector brings almost direct
access to the <a href="../lxr/source/include/connect/ncbi_socket.h"><span class="ncbi_interface">SOCK</span></a> API.
It allows the user to create a peer-to-peer data channel between two programs, which could be located anywhere on the
Internet.

<p>
In order to create the socket connection the user has to create
a socket connector first, then pass it to <span class="ncbi_var">CONN_Create()</span>,
as in the following example:
<pre class="ncbi_code">
#include &lt;connect/ncbi_socket_connector.h&gt;
#include &lt;connect/ncbi_connection.h&gt;

#define MAX_TRY 3 /* Try to connect this many times before giving up */

unsigned short port = 1234;
CONNECTOR socket_connector = <a href="../lxr/ident?i=SOCK_CreateConnector">SOCK_CreateConnector</a>("host.foo.com", port, MAX_TRY);

if (!socket_connector)
    fprintf(stderr, "Cannot create SOCKET connector");
else {
    CONN conn;

    if (CONN_Create(socket_connector, &conn) != eIO_Success)
        fprintf(stderr, "CONN_Create failed");
    else {
        /* Connection created ok, use CONN_... function */
        /* to access the network */
        ...
        CONN_Close(conn);
    }
}
</pre>

A variant form of this connector's constructor,
<a href="../lxr/ident?i=SOCK_CreateConnectorEx"><span class="ncbi_var">SOCK_CreateConnectorEx()</span></a>,
takes three more arguments: a pointer to data (of type <span class="ncbi_type">void*</span>),
data size (bytes) to specify the data to be sent as soon as
the link has been established, and flags, which presently can only
be used to turn debugging information on.

<p>
<span class="ncbi_proj">CONN</span> library defines two more constructors, which build SOCKET connectors on top of existing <a href="../lxr/source/include/connect/ncbi_socket.h">SOCK</a>
objects:
<a href="../lxr/ident?i=SOCK_CreateConnectorOnTop" class="ncbi_func">SOCK_CreateConnectorOnTop()</a> and
<a href="../lxr/ident?i=SOCK_CreateConnectorOnTopEx" class="ncbi_func">SOCK_CreateConnectorOnTopEx()</a>,
the description of which is intentionally omitted here as SOCK
is not discussed either. Please refer to
<a href="../lxr/source/include/connect/ncbi_socket_connector.h">description</a> in the Tookit code.

<p>
<hr>


<a name="ref_FileConnector"></a><h3>File Connector</h3>

Constructors defined in:
<pre class="ncbi_code">
#include &lt;<a href="../lxr/source/include/connect/ncbi_file_connector.h">connect/ncbi_file_connector.h</a>&gt;

CONNECTOR file_connector = <a href="../lxr/ident?i=FILE_CreateConnector">FILE_CreateConnector</a>("InFile", "OutFile");
</pre>

This connector could be used for both reading and writing files, when
input goes from one file, and output goes to another file.
(This differs from normal file I/O when a single handle is used to access only one file,
but rather resembles data exchange via socket. )

<p>
Extended variant of this connector's constructor,
<a href="../lxr/ident?i=FILE_CreateConnectorEx"><span class="ncbi_func">FILE_CreateConnectorEx()</span></a>
takes an additional argument, pointer to a structure of type <a href="../lxr/ident?i=SFileConnAttr" class="ncbi_type">SFileConnAttr</a>
describing file connector attributes, like initial read position to start from in the input file, open mode for the output file (append
<a href="../lxr/ident?i=EFileConnMode" class="ncbi_var">eFCM_Append</a>, truncate <span class="ncbi_var">eFCM_Truncate</span>, or seek <span class="ncbi_var">eFCM_Seek</span>
to start writing at a specified file position), and the position in the output file, which is used in <span class="ncbi_term">seek open mode</span>.
Attribute pointer passed as <span class="ncbi_macro">NULL</span> is equivalent to a call to
<span class="ncbi_func">FILE_CreateConnector()</span>, which reads from the very
beginning of the input file, and entirely overwrites the output file (if any) implicitly using <span class="ncbi_var">eFCM_Truncate</span>.

<p>
<hr>


<a name="ref_HTTPConnector"></a><h3>HTTP Connector</h3>

Constructors defined in:
<pre class="ncbi_code">
#include &lt;<a href="../lxr/source/include/connect/ncbi_http_connector.h">connect/ncbi_http_connector.h</a>&gt;
</pre>

The simplest form of this connector's constructor takes 3 parameters:
<pre class="ncbi_code">
extern CONNECTOR <a href="../lxr/ident?i=HTTP_CreateConnector">HTTP_CreateConnector</a>
(const <a href="../lxr/ident?i=SConnNetInfo">SConnNetInfo</a>* info,
 const char*         user_header,
 <a href="../lxr/ident?i=THCC_Flags">THCC_Flags</a>          flags
 );
</pre>
a pointer to network information structure (can be <span class="ncbi_macro">NULL</span>), a pointer to
a custom HTTP tag-value(s) so called user-header, and bitmask of various flags.
The user-header has to be in the form <span class="ncbi_code">"HTTP-Tag: Tag-value\r\n"</span>, or even multiple tag-values delimited and
terminated by <span class="ncbi_value">"\r\n"</span>.
If specified, <span class="ncbi_var">user_header</span> parameter overrides the
<a href="#ref_HttpUserHeader">corresponding field</a> in <span class="ncbi_var">info</span>.

<p>
Network information structure (from <a href="../lxr/source/include/connect/ncbi_connutil.h"><span class="ncbi_file">connect/ncbi_connutil.h</span></a>)
defines parameters of the connection point,
where the HTTP server is running.<br>
<span class="ncbi_note">Note</span>: Not all parameters of the structure depicted below apply to this connector.

<pre class="ncbi_code">
/* Network connection related configurable info struct
 */
typedef struct {
  char           client_host[64];      /* effective client hostname            */
  char           host[64];             /* host to connect to                   */
  unsigned short port;                 /* port to connect to, host byte order  */
  char           path[1024];           /* service: path(e.g. to  a CGI script) */
  char           args[1024];           /* service: args(e.g. for a CGI script) */
  <a href="../lxr/ident?i=EReqMethod">EReqMethod</a>     req_method;           /* method to use in the request         */
  <a href="../lxr/ident?i=STimeout">STimeout</a>       timeout;              /* I/O timeout                          */
  unsigned int   max_try;              /* max. # of attempts to establish conn */
  char           http_proxy_host[64];  /* hostname of HTTP proxy server        */
  unsigned short http_proxy_port;      /* port #   of HTTP proxy server        */
  char           <a name="ref_ProxyHost"></a>proxy_host[64];       /* host of CERN-like firewall proxy srv */
  <a href="../lxr/ident?i=EDebugPrintout">EDebugPrintout</a> debug_printout;       /* printout some debug info             */
  int/*bool*/    stateless;            /* to connect in HTTP-like fashion only */
  int/*bool*/    firewall;             /* to use firewall/relay in connects    */
  int/*bool*/    <a name="ref_LbDisable"></a>lb_disable;           /* to disable local load-balancing      */
  const char*    <a name="ref_HttpUserHeader"></a>http_user_header;     /* user header to add to HTTP request   */

  /* the following field(s) are for the internal use only! */
  int/*bool*/    http_proxy_adjusted;
} <a href="../lxr/ident?i=SConnNetInfo">SConnNetInfo</a>;
</pre>

<span class="ncbi_note">Caution</span>: Unlike other "static fields" of this structure,
<a href="#ref_HttpUserHeader"><span class="ncbi_var">http_user_header</span></a> (if non-<span class="ncbi_macro">NULL</span>)
is assumed to be dynamically allocated on the heap
(via a call to <span class="ncbi_func">malloc</span>, <span class="ncbi_func">calloc</span> or related function,
like <span class="ncbi_func">strdup</span>).

<p>
<a name="ref_SConnNetInfo"></a>While the user can create and fill out this structure via field-by-field assignments,
there is however a better, easier, much safer and configurable way (and interface
defined in <a href="../lxr/source/include/connect/ncbi_connutil.h"><span class="ncbi_file">connect/ncbi_connutil.h</span></a>)
to deal with this structure:

<ul>
<li> <a name="ref_ConnNetInfo_Create"></a><span class="ncbi_code"><a href="../lxr/ident?i=ConnNetInfo_Create"><em>ConnNetInfo_Create</em></a> (const char* service)</span><br>
  Create and return a pointer to new <span class="ncbi_type">SConnNetInfo</span> structure, filled with
  parameters specific either for a named <span class="ncbi_var">service</span> or by default if <span class="ncbi_var">service</span> specified as <span class="ncbi_macro">NULL</span> (most likely
  the case for ordinary HTTP connections). Parameters for the structure are taken from (in order of precedence):<ul>
  <li> Environment variables of the form <span class="ncbi_env">&lt;service&gt;_CONN_&lt;name&gt;</span>,
  where <span class="ncbi_var">name</span> is the name of the field;
  <li> Service-specific <a href="#ref_Registry">registry</a> section named <span class="ncbi_reg">[service]</span> using the key CONN_&lt;name&gt;;
  <li> Environment variable of the form <span class="ncbi_env">CONN_&lt;name&gt;</span>;
  <li> Registry section named <span class="ncbi_reg">[CONN]</span> using <span class="ncbi_reg_var">name</span> as a key;
  <li> And finally, default value is applied, if none of the above resulted in a successful match.
  </ul>

  Search for the keys in both environment and registry is not case-sensitive; but the values of the keys are case-sensitive
  (except for enumerated types and boolean values, which can be of any -&nbsp;even mixed&nbsp;- case).
  Boolean fields accept <span class="ncbi_value">1</span>, <span class="ncbi_value">"YES"</span> and <span class="ncbi_value">"TRUE"</span> as <span class="ncbi_value">true</span> values, all other values are
  treated as <span class="ncbi_value">false</span>. In addition to a floating point number treated as a number of seconds,
  <span class="ncbi_var">timeout</span> can accept (case-insensitively) keyword <span class="ncbi_value">"INFINITE"</span>.
  <br>
  <span class="ncbi_note">Note</span>: The first 2 steps in the above sequence are skipped if <span class="ncbi_var">service</span> name is passed as <span class="ncbi_macro">NULL</span>.<br>
  <span class="ncbi_note">Caution</span>: The library does not provide reasonable
  default values for <span class="ncbi_var">path</span> and <span class="ncbi_var">args</span> when the structure is used for HTTP connectors.

<li> <span class="ncbi_code"><a href="../lxr/ident?i=ConnNetInfo_Destroy"><em>ConnNetInfo_Destroy</em></a> (SConnNetInfo* info)</span><br>
  Delete and free the info structure via passed pointer (note that the HTTP user header <span class="ncbi_var">http_user_header</span>
  is freed, too).
<li> <span class="ncbi_code"><a href="../lxr/ident?i=ConnNetInfo_SetUserHeader"><em>ConnNetInfo_SetUserHeader</em></a> (SConnNetInfo* info, const char* new_user_header)</span><br>
  Set the new HTTP user header (freeing the previous one if any) by cloning the passed string argument and storing it in
  <span class="ncbi_var">http_user_header</span> field. <span class="ncbi_var">New_user_header</span> passed as <span class="ncbi_macro">NULL</span> resets the field.
<li> <span class="ncbi_code"><a href="../lxr/ident?i=ConnNetInfo_Clone"><em>ConnNetInfo_Clone</em></a> (SConnNetInfo* info)</span><br>
  Create and return pointer to a new <span class="ncbi_type">SConnNetInfo</span> structure, which is an exact
  copy of the passed structure. This function is aware of dynamic nature of the HTTP
  <a href="#ref_HttpUserHeader">user header field</a>.
</ul>
</ol>

<a name="ref_Registry"></a><span class="ncbi_note">Note about the registry</span>. The registry used by <span class="ncbi_proj">connect</span> library is
separate from <a href="../programming_manual/registry.html" class="ncbi_class">CNcbiRegistry</a> class.
To learn more about the difference, and how to use both objects together in
a single program, please follow <a href="c_cxx.html">this link</a>.

<p>
The following fields of <span class="ncbi_type">SConnNetInfo</span> pertain to the HTTP connector:
<span class="ncbi_var">client_host</span>, <span class="ncbi_var">host</span>, <span class="ncbi_var">port</span>, <span class="ncbi_var">path</span>, <span class="ncbi_var">args</span>, <span class="ncbi_var">req_method</span> (can be one of
<span class="ncbi_value">"GET"</span>, <span class="ncbi_value">"POST"</span>, and <span class="ncbi_value">"ANY"</span>),
<span class="ncbi_var">timeout</span>, <span class="ncbi_var">max_try</span> (analog of maximal try parameter for the
<a href="#ref_SocketConnector">socket connector</a>), <span class="ncbi_var">http_proxy_host</span>, <span class="ncbi_var">http_proxy_port</span>,
<span class="ncbi_var">debug_printout</span> (values are <span class="ncbi_value">"NONE"</span> to disable any trace printout
of the connection data, <span class="ncbi_value">"SOME"</span> to enable printing of <span class="ncbi_type">SConnNetInfo</span>
structure before each connection attempt, and <span class="ncbi_value">"DATA"</span> to print both
headers and data of the HTTP packets in addition to dumps of <span class="ncbi_type">SConnNetInfo</span> structures). Values of other fields are ignored.

<p>
Argument <span class="ncbi_var">flags</span> in the HTTP connector's constructor is a bitwise <span class="ncbi_term">OR</span> of the following values:
<ul>
<li> <a href="../lxr/ident?i=EHCC_Flags" class="ncbi_var">fHCC_AutoReconnect</a><br>
 Allow multiple request/reply HTTP transactions. (Otherwise by default, only one request/reply is allowed.)
<li> <span class="ncbi_var">fHCC_SureFlush</span><br>
  Always flush a request (maybe solely consisting of HTTP header with
  no body at all) down to the HTTP server before preforming any read
  or close operations.
<li> <a name="fHCC_KeepHeader"></a><span class="ncbi_var">fHCC_KeepHeader</span><br>
  By default, HTTP connection sorts out the HTTP header and parses
  HTTP errors (if any). Thus, normally reading from the connection returns
  data from the HTTP body only. The flag disables this feature, and the HTTP
  header is not parsed but instead passed 'as is' to the application on a call to <a href="#CONN_Read"><span class="ncbi_func">CONN_Read()</span></a>.
<li> <span class="ncbi_var">fHCC_UrlDecodeInput</span><br>
  Decode input data passed in HTTP body from the HTTP server.
<li> <span class="ncbi_var">fHCC_UrlEncodeOutput</span><br>
  Encode output data passed in HTTP body to the HTTP server.
<li> <span class="ncbi_var">fHCC_UrlCodec</span><br>
  Perform both encoding and encoding (<span class="ncbi_var">fHCC_UrlDecodeInput | fHCC_UrlEncodeOutput</span>).
<li> <span class="ncbi_var">fHCC_UrlEncodeArgs</span><br>
  Encode URL if it contains special characters like '+'. By default,
  the arguments are passed 'as is' (exactly as taken from <span class="ncbi_type">SConnNetInfo</span>).
<li> <span class="ncbi_var">fHCC_DropUnread</span><br>
  Drop unread data, which might exist in connection, before making another
  request/reply HTTP shot. Normally, the connection first tries to read out
  the data from the HTTP server entirely, until <span class="ncbi_macro">EOF</span>, and store them
  in the internal buffer even if either application did not requested the
  data for reading, or the data were read only partially, so that
  the next read operation will see the data.
<li> <span class="ncbi_var">fHCC_NoUpread</span><br>
  Do not attempt to empty incoming data channel into a temporary
  intermediate buffer while writing to the outgoing data channel.
  By default, writing always makes checks that incoming data are
  available for reading, and those data are extracted and stored in
  buffer. This approach allows to avoid I/O deadlock, when
  writing creates a backward stream of data, which if unread
  blocks the connection entirely.
</ul>

The HTTP connection will be established using the following URL - <span class="ncbi_url">http://host:port/path?args</span><p>
<span class="ncbi_note">Note</span> that <span class="ncbi_var">path</span> has to have a leading slash "/" as the very first character, that is, only "http://" and "?" are added by the connector,
all other characters appear exactly as specified (but maybe encoded with <span class="ncbi_var">fHCC_UrlEncodeArgs</span>).
The question mark does not appear if the URL has no arguments.

<p>
More elaborate form of the HTTP connector's constructor has the following prototype:

<pre class="ncbi_code">
typedef int/*bool*/ (*FHttpParseHTTPHeader)
(const char* http_header,
 void*       adjust_data,
 int/*bool*/ server_error);

typedef int/*bool*/ (*FHttpAdjustInfo)
(SConnNetInfo* info,
 void*         adjust_data,
 unsigned int  n_failed);

typedef void (*FHttpAdjustCleanup)
(void* adjust_data
 );

extern CONNECTOR <a href="../lxr/ident?i=HTTP_CreateConnectorEx">HTTP_CreateConnectorEx</a>
(const SConnNetInfo*  net_info,
 THCC_Flags           flags,
 FHttpParseHTTPHeader parse_http_hdr, /* may be NULL, then no addtl.parsing */
 FHttpAdjustInfo      adjust_info,    /* may be NULL, then no adjustments   */
 void*                adjust_data,    /* for "adjust_info"& "adjust_cleanup"*/
 FHttpAdjustCleanup   adjust_cleanup  /* may be NULL                        */
 );
</pre>

This form is assumed to be rarely used by the users directly, but it provides rich access to the internal management of HTTP connections.

<p>
The first two arguments are identical to their counterparts in the arguments number
one and three of <a href="../lxr/ident?i=HTTP_CreateConnector"><span class="ncbi_func">HTTP_CreateConnector()</span></a>.
HTTP user header field (if any) is taken directly from <a href="#ref_HttpUserHeader"><span class="ncbi_var">http_user_header</span></a>
field of <span class="ncbi_type">SConnNetInfo</span>, pointer to which is passed as <span class="ncbi_var">net_info</span> (which in turn can be passed as
<span class="ncbi_macro">NULL</span> meaning to use the environment, registry and defaults as described <a href="#ref_SConnNetInfo">above</a>).

<p>
The third parameter specifies a callback to be activated to
parse the HTTP reply header (passed as a single string, with <tt>CR-LF</tt> -&nbsp;carriage return/line feed&nbsp;- characters incorporated to divide header lines). This callback
also gets some custom data <span class="ncbi_var">adjust_data</span> as supplied in the fifth argument of the connector's constructor,
and a boolean value <span class="ncbi_value">true</span> if parsed response code from the server was not okay. The callback can return
<span class="ncbi_value">false</span> (zero), which is considered the same way as having an error
from the HTTP server. However, pre-parsed error condition (passed in <span class="ncbi_var">server_error</span>) retains even if the
return value of the callback is <span class="ncbi_value">true</span>, that is the callback is unable to "fix" the error code from the server.
This callback is <em>not called</em> if <a href="#fHCC_KeepHeader" class="ncbi_var">fHCC_KeepHeader</a> is set in flags.

<p>
The forth argument is a callback, which gets control when an attempt to connect
to the HTTP server has failed. On entry, this callback has current <span class="ncbi_type">SConnNetInfo</span>, which is requested to be adjusted in a faith that
the connection to the HTTP server will finally succeed. That is, the callback
can change anything in the info structure, and the modified structure
will be kept for all further connection attempts, until changed by this callback again.
The number (starting from 1) of successive failed attempts is given in the last callback's
argument. The callback return value <span class="ncbi_value">true</span> (non-zero) means successful adjustment. Return value
<span class="ncbi_value">false</span> (zero) stops connection attempts and returns an error to the application.

<p>
When connector is being destroyed, the custom object <span class="ncbi_var">adjust_data</span> can be
destroyed in the callback, specified as the last argument of the
extended constructor.

<p>
<span class="ncbi_note">Note</span>: Any callback may be specified as <span class="ncbi_macro">NULL</span>, which means that no action
is foreseen by the application, and default behavior occurs.

<p>
<hr>


<a name="ref_ServiceConnector"></a><h3>Service Connector</h3>

Constructors defined in:
<pre class="ncbi_code">
#include &lt;<a href="../lxr/source/include/connect/ncbi_service_connector.h">connect/ncbi_service_connector.h</a>&gt;
</pre>

This is the most complex connector in the library. It can initiate data exchange between an application and a named NCBI service,
and data link can be either wrapped in HTTP or be just a byte-stream (like in a socket). In fact, this connector
sits on top of either <a href="#ref_HTTPConnector">HTTP</a> or <a href="#ref_SocketConnector">SOCKET</a> connectors.

<p>
The library provides two forms of connector's constructor:
<pre class="ncbi_code">
<a href="../lxr/ident?i=SERVICE_CreateConnector">SERVICE_CreateConnector</a>(const char* service_name);

<a href="../lxr/ident?i=SERVICE_CreateConnectorEx">SERVICE_CreateConnectorEx</a>
(const char*           service_name,  /* The registered name of an NCBI service */
 <a href="../lxr/ident?i=TSERV_Type">TSERV_Type</a>            types,         /* Accepted server types, bitmask         */
 const <a href="../lxr/ident?i=SConnNetInfo">SConnNetInfo</a>*   net_info,      /* Connection parameters                  */
 const <a href="../lxr/ident?i=SSERVICE_Extra">SSERVICE_Extra</a>* params         /* Addtl set of parameters, may be NULL   */
 );
</pre>

The first form is equivalent to <span class="ncbi_ccode">SERVICE_CreateConnectorEx(service_name, fSERV_Any, 0, 0)</span>.

<form name="io_bounce" method="POST" action="http://www.ncbi.nlm.nih.gov/Service/dispd.cgi?service=io_bounce">
<input type="hidden" name="name" value="value">
</form>
A named NCBI service is a CGI program or standalone server (can be one of two supported types), which runs at the NCBI site,
and accessible by the outside world. Special dispatcher (which runs on the <a href="http://www.ncbi.nlm.nih.gov">NCBI Web-servers</a>)
allows automatic switching to the appropriate server without
having the client to know a priori the connection point. That is,
the client just uses the main entry gate of the NCBI Web (usually, <a href="http://www.ncbi.nlm.nih.gov"><span class="ncbi_url">www.ncbi.nlm.nih.gov</span></a>)
with a request to have a service "<span class="ncbi_value">service_name</span>", and depending on the service availability, the request will be either
<a href="http://www.ncbi.nlm.nih.gov/Service/dispd.cgi?service=io_bounce" onclick="javascript:io_bounce.submit(); return false">honored</a> (by switching and routing the client to the machine
actually running the server: clicking on the previous link should bring you
to a page containing "name=value" message, obtained from the special bouncing
service as a result of the form submission), <a href="http://www.ncbi.nlm.nih.gov/Service/dispd.cgi?service=blahblah">rejected</a>,
or <a href="http://www.ncbi.nlm.nih.gov/Service/dispd.cgi?service=TaxServer">declined</a>. To the client,
the entire process of dispatching is seen as completely transparent (for
example, try clicking several times on either of the latter two links and see that the
error replies are actually sent from different hosts, so is the successful processing of the
first link done by one of several hosts running the bouncing service).

<p>
<a name="ref_dispd_cgi"></a><a href="../tools/dispatcher/DISPD.html">Dispatching protocol</a> per se is implemented on top of the HTTP protocol, and is parsed by a
CGI program <a href="../lxr/source/src/connect/daemons/dispd_cgi.c"><span class="ncbi_cgi">dispd.cgi</span></a> (or another dispatching CGI), which is
available on the NCBI Web. On every server running the named services, another program, called
<a href="../tools/dispatcher/LBSMD.html">load-balancing daemon</a>&nbsp; (<a href="../lxr/source/src/connect/daemons/lbsmd.c"><span class="ncbi_app">lbsmd</span></a>),
is executing. This daemon supports having the same service running on different machines, and allows to choose among them the one machine, which is less loaded.
When <span class="ncbi_cgi">dispd.cgi</span> receives a request for a named service, it first consults the load-balancing table, which is broadcasted by each
load-balancing daemon, and re-assembled in a network-wide form on each server. When the corresponding server is found,
the client request can be passed, or a dedicated connection to the server can be established. The dispatching is made such a way that it
can be also used directly from the Internet browsers.

<p>
The named service facility uses the following distinction of <a name="ref_ServerTypes"></a>server types:
<ul>
<li>HTTP servers, which are usually CGI programs:
  <ul>
  <li><span class="ncbi_type">HTTP_GET</span> servers are those accepting requests only using HTTP <span class="ncbi_interface">GET</span>
      method.
  <li><span class="ncbi_type">HTTP_POST</span> servers are those accepting requests only using HTTP
      <span class="ncbi_interface">POST</span> method.
  <li><span class="ncbi_type">HTTP</span> servers are those accepting both of either <span class="ncbi_interface">GET</span> or <span class="ncbi_interface">POST</span> methods.
  </ul>
  <li><span class="ncbi_type">NCBID</span> servers are those run by a special
      <a href="../tools/dispatcher/DISPD.html#ref_NCBID">CGI engine</a>, called
      <a href="../lxr/source/src/connect/daemons/dispd_cgi.c"><span class="ncbi_cgi">ncbid.cgi</span></a>, a configurable program
      (now integrated within <a href="#ref_dispd_cgi"><span class="ncbi_cgi">dispd.cgi</span></a> itself), which can convert byte-stream
      output from another program (server) started by the request from dispatcher to an HTTP-compliant reply
      (that is a packet having both HTTP header and body, and suitable e.g. for Web-browsers).
  <li><span class="ncbi_type">STANDALONE</span> servers, like mailing daemons, are those listening on their own
      onto the network for incoming connections.
  <li><span class="ncbi_type">FIREWALL</span> servers are the special pseudo-servers, not existing in reality, but are created
      and used internally by the dispatcher software to indicate that only a firewall connection mode can
      be used to access the requested service.
  <li><span class="ncbi_type">DNS</span> servers are beyond the scope of this document cause they are
      to declare domain names, which used internally at NCBI site to help
      load-balancing based DNS lookup (see <a href="../lxr/source/src/connect/daemons/mghbn.c">here</a>).
</ul>

Formal description of these types is given in
<a href="../lxr/source/include/connect/ncbi_server_info.h"><span class="ncbi_file">connect/ncbi_server_info.h</span></a>:
<pre class="ncbi_code">
/* Server types
 */
typedef enum {
  fSERV_Ncbid      = 0x1,
  fSERV_Standalone = 0x2,
  fSERV_HttpGet    = 0x4,
  fSERV_HttpPost   = 0x8,
  fSERV_Http       = fSERV_HttpGet | fSERV_HttpPost,
  fSERV_Firewall   = 0x10,
  fSERV_Dns        = 0x20
} <a href="../lxr/ident?i=ESERV_Type">ESERV_Type</a>;

#define fSERV_Any           0
#define fSERV_StatelessOnly 0x80
typedef unsigned TSERV_Type;  /* bit-wise OR of "ESERV_Type" flags */
</pre>

The bitwise <span class="ncbi_term">OR</span> of the <span class="ncbi_type">ESERV_Type</span> flags can be used to
restrict the search for the servers, matching the requested service name.
These flags passed as argument <span class="ncbi_var">types</span> are used by the
dispatcher when figuring out, which server is acceptable for the client.
Special value&nbsp;<span class="ncbi_value">0</span> (or, better <span class="ncbi_var">fSERV_Any</span>) states no
such preference whatsoever. Special bit-value <span class="ncbi_var">fSERV_StatelessOnly</span>
set together with other bits or just alone specifies that the servers
should be of stateless (HTTP-alike) type only, and it is the client which is responsible for keeping
track of the logical sequence of transactions.

<p>
The following code fragment establishes service connection to
the named service <span class="ncbi_value">"io_bounce"</span>, using only stateless servers:
<pre class="ncbi_code">
CONNECTOR c;
CONN conn;

if (!(c = SERVICE_CreateConnectorEx("io_bounce", fSERV_StatelessOnly, 0, 0)))
    fprintf(stderr, "No such service available");
else if (CONN_Create(c, &conn) != eIO_Success)
    fprintf(stderr, "Failed to create connection");
else {
    static const char buffer[] = "Data to pass to the server";
    size_t n_written;

    CONN_Write(conn, buffer, sizeof(buffer) - 1, &n_written);
    ...
}
</pre>

The real type of the data channel can be obtained via call to
<a href="#CONN_GetType" class="ncbi_ccode">>CONN_GetType(conn)</a>.

<p>
<span class="ncbi_note">Note</span>: In the above example the client has no assumption how the
data actually passed to the server. The server could be of any
type in principle, even a standalone server, which was used
in the request/reply mode of one-shot transactions. If necessary,
such wrapping would have been made by the dispatching facility as well.

<p>
The last but one parameter of the extended constructor is the network info,
described in section devoted to <a href="#ref_HTTPConnector">HTTP connector</a>.
Service connector uses all fields of this structure, except for
<a href="#ref_HttpUserHeader"><span class="ncbi_var">http_user_header</span></a>,
and the following assumptions apply:
<ul>
<li><span class="ncbi_var">path</span> specifies the dispatcher program (defaulted to <span class="ncbi_cgi">dispd.cgi</span>);
<li><span class="ncbi_var">args</span> specifies parameters for the requested service, this is service-specific, no defaults;
<li><span class="ncbi_var">stateless</span> is used to set <span class="ncbi_var">fSERV_StatelessOnly</span>
flag in the server type bitmask, if it was not set there already
(convenient to modify the dispatching using environment and/or registry,
if the flag is not set; yet allows to hardcode the flag at compile-time
by setting it in constructor's <span class="ncbi_var">types</span> argument explicitly);
<li><span class="ncbi_var">lb_disable</span> set to <span class="ncbi_value">true</span> (non-zero) means to always use remote dispatcher
(via network connection) even if locally running load-balancing daemon is available
(by default, local load-balancing deamon consulted first to resolve
the name of the service);
<li><span class="ncbi_var">firewall</span> set to <span class="ncbi_value">true</span> (non-zero) disables the direct connection to
the service. Instead, either a connection to a proxy <a href="../tools/dispatcher/fwdaemon.html">firewall daemon</a>
(<a href="../lxr/source/src/connect/daemons/fwdaemon.c">fwdaemon</a>), running
at the NCBI site, is initiated to pass the data in stream mode, or data get relayed
via dispatcher if stateless server is used;
<li><span class="ncbi_var">http_user_header</span> ignored (asserted to be <span class="ncbi_macro">NULL</span> in debug compilation mode).
</ul>

<p>
As with HTTP connector, if network information structure is specified as
<span class="ncbi_macro">NULL</span>, default values are obtained as described above, as with the call to <a href="#ref_ConnNetInfo_Create" class="ncbi_ccode">ConnNetInfo_Create(service_name)</a>.

<p>
Normally the last parameter of <span class="ncbi_func">SERVICE_CreateConnectorEx()</span> is left <span class="ncbi_macro">NULL</span>, which
sets all additional parameters to their default values. Among others, this includes default procedure
of choosing an appropriate server when the connector is looking for a mapping of the service name
into a server address. To see how this parameter can be used to change the mapping procedure
please refer to a <a href="#ref_ServiceAPI">later section</a>.

<p>
Library provides additional <a href="#ref_ServiceAPI">interface to named service mapper</a>, which
can be found in <a href="../lxr/source/include/connect/ncbi_service.h" class="ncbi_file">connect/ncbi_service.h</a>.

<p>
<span class="ncbi_note">Note</span>: Requesting <span class="ncbi_var">fSERV_Firewall</span> in the <span class="ncbi_var">types</span> parameter effectively selects
firewall mode regardless of the network parameters, loaded via <span class="ncbi_type">SConnNetInfo</span> structure.

<p>
<hr>


<a name="ref_Debugging"></a><h2>Debugging Tools and Troubleshooting</h2>

Each connector (except for <span class="ncbi_type">FILE</span> connector) provides means to view data flow
in the connection. In case of <a href="#ref_SocketConnector"><span class="ncbi_type">SOCKET</span></a> connector debugging information can be
turned on by the last argument in
<a href="../lxr/ident?i=SOCK_CreateConnectorEx" class="ncbi_func">SOCK_CreateConnectorEx()</a>,
or by using global routine <a href="../lxr/ident?i=SOCK_SetDataLoggingAPI"><span class="ncbi_func">SOCK_SetDataLoggingAPI()</span></a>
(declared in <a href="../lxr/source/include/connect/ncbi_socket.h" class="ncbi_file">connect/ncbi_socket.h</a>)
<br>
<span class="ncbi_note">Note</span>: In the latter case every socket (including sockets implicitly used by
other connectors like <span class="ncbi_type">HTTP</span> or <span class="ncbi_type">SERVICE</span>) will generate debug printouts.

<p>
In case of <a href="#ref_HTTPConnector"><span class="ncbi_type">HTTP</span></a> or <a href="#ref_ServiceConnector"><span class="ncbi_type">SERVICE</span></a> connectors,
which employ <a href="../lxr/ident?i=SConnNetInfo" class="ncbi_type">SConnNetInfo</a>,
debugging can be activated directly from the environment by setting
<span class="ncbi_var">CONN_DEBUG_PRINTOUT</span> to <span class="ncbi_value">TRUE</span> or <span class="ncbi_value">SOME</span>. Similarly, a registry key
<span class="ncbi_var">DEBUG_PRINTOUT</span> with a value of either <span class="ncbi_value">TRUE</span> or <span class="ncbi_reg_var">SOME</span> found in the section <span class="ncbi_reg">[CONN]</span>
would have the same effect: it turns on only logging of connection parameters each time the link gets established.
When set to <span class="ncbi_value">ALL</span>, this variable (or key) also turns on debugging output on all
underlying sockets ever created during the life of the connection. Value <span class="ncbi_value">FALSE</span>
(default) turns debugging printouts off. Moreover, for <span class="ncbi_type">SERVICE</span> connector the debugging
output option can be set on a per-service basis using <span class="ncbi_env">&lt;service&gt;_CONN_DEBUG_PRINTOUT</span>
environment variables, or individual registry sections <span class="ncbi_reg">[&lt;service&gt;]</span> and
key <span class="ncbi_reg_var">CONN_DEBUG_PRINTOUT</span> in them.
<br>
<span class="ncbi_note">Note</span>: Debugging printouts can only be controlled in a described way via
environment or registry if and only if <span class="ncbi_type">SConnNetInfo</span> is always
created with the use of <a href="#ref_SConnNetInfo">convenience routines</a>.

<p>
Debugging output is always sent to the same destination, CORE log file,
which is a C object shared between both C and C++ Toolkits. As said, the logger
is an abstract object, i.e. it is empty and cannot produce any output if not tuned
accordingly. The library defines few calls gathered in <a href="../lxr/source/include/connect/ncbi_util.h" class="ncbi_code">connect/ncbi_util.h</a> which allow the logger to go via <span class="ncbi_type">FILE</span> file pointer, like <span class="ncbi_var">stderr</span>:
<a href="../lxr/ident?i=CORE_SetLOGFILE" class="ncbi_func">CORE_SetLOGFILE()</a> as e.g. shown in
the example <a href="../lxr/source/src/connect/test/test_ncbi_service_connector.c"><span class="ncbi_file">test_ncbi_service_connector.c</span></a>, or
to be a regular file on disk. Moreover, both Toolkits <a href="cxx2c.html">define interfaces</a>
to deal with registries, loggers and locks that use native objects of each toolkit and use
them as replacements for corresponding abstract layer's objects.

<p>
There is a common problem reported several times and actually concerning
network configuration rather than misbehavior of the library. If a test program,
which connects to a named NCBI service, is not getting anything back from the NCBI
site, one first has to check whether there is a transparent proxying/caching in between the
host and NCBI. As the service dispatching is implemented on top of ordinary HTTP
protocol, the transparent proxying may latch unsuccessful service searches (which could
happen and may not indicate a real problem) as error responses from the NCBI
server. Afterwards, instead of actually connecting to NCBI, the proxy returns
those cached errors (or sometimes just an empty document),
which breaks the service dispatcher code. In most cases there are configurable ways
to exclude certain URLs from proxying and caching, and they are subject for discussion
with a local network administrator.

<p>
There is another tip: Make sure that all custom HTTP header tags (as
passed, for example, in
<a href="#ref_HttpUserHeader">SConnNetInfo::user_header</a> field)
do have "\r\n" as tag separators (including the last tag).
Many proxy servers (including transparent proxies, which usually
the user is not even aware of) are known to be sensitive to that each
and every HTTP tag is closed by "\r\n" (and not by a single
"\n" character). Otherwise the HTTP packet would be treated as lame and gets
discarded.

<p>
<hr>


<a name="ref_CxxConnectionStreams"></a><h2>C++ Connection Streams</h2>

Using connections and connectors (via the entirely procedural approach)
in C++ programs overkills the power of the language.
Therefore, we provide C++ users with the stream classes, all
derived from standard <span class="ncbi_class">iostream</span> class, and as a result, which can be used with
all famous stream I/O operators, manipulators etc.

<p>
The declarations of the stream's constructors can be found in
<a href="../lxr/source/include/connect/ncbi_conn_stream.hpp" class="ncbi_file">connect/ncbi_conn_stream.hpp</a>.
We tried to keep the same number and order of constructor's
parameters, as they appear in the corresponding connector's constructors in C.

<p>
The code below is a C++-style example from the previous section devoted to the
<a href="#ref_ServiceConnector">service connector</a>:
<pre class="ncbi_code">
#include &lt;connect/ncbi_conn_stream.hpp&gt;

  try {
    <a href="../lxr/ident?i=CConn_HttpStream">CConn_HttpStream</a> ios("io_bounce", fSERV_StatelessOnly, 0);
    ios << "Data to be passed to the server";
  } <a href="../lxr/ident?i=STD_CATCH_ALL">STD_CATCH_ALL</a>("Connection problem");

  ...
</pre>
<span class="ncbi_note">Note</span>:
Stream constructor may throw an exception if, for instance,
the requested service is not found, or other kind of problem arose.
To see the actual reason, we used standard toolkit macro <span class="ncbi_macro">STD_CATCH_ALL()</span>, which prints the message and problem
description into the log file (<span class="ncbi_var">cerr</span>, by default).

<p>
<hr>


<a name="ref_ServiceAPI"></a><h2>Service mapping API</h2>

The API defined in <a href="../lxr/source/include/connect/ncbi_service.h" class="ncbi_file">connect/ncbi_service.h</a>
maps required sevice name into server address. Internally, the mapping is done <a href="#ref_DirectIndirect">either directly or indirectly</a> by means of
<a href="../tools/dispatcher/LBSMD.html">load-balancing daemon</a>, running at NCBI site.
For the client, the mapping is seen as a reading from an iterator created by a call to
<span class="ncbi_func">SERV_Open()</span> like in the following
fragment (for more examples please refer to the test program
<a href="../lxr/source/src/connect/test/test_ncbi_disp.c"><span class="ncbi_file">test_ncbi_disp.c</span></a>):
<pre class="ncbi_code">
#include &lt;connect/ncbi_service.h&gt;

    <a href="../lxr/ident?i=SERV_ITER">SERV_ITER</a> iter = <a href="../lxr/ident?i=SERV_Open">SERV_Open</a>("my_service", <a href="../lxr/ident?i=ESERV_Type">fSERV_Any</a>, <a href="../lxr/ident?i=SERV_ANYHOST">SERV_ANYHOST</a>, 0);
    int n = 0;

    if (iter != 0) {
        <a href="../lxr/ident?i=SSERV_Info">SSERV_Info</a>* info = <a href="../lxr/ident?i=SERV_GetNextInfo">SERV_GetNextInfo</a>(iter);

        while (info != 0) {
            char* str = <a href="../lxr/ident?i=SERV_WriteInfo">SERV_WriteInfo</a>(info);

            printf("Server = `%s'\n", str);
            free(str);
            n++;
        }
        <a href="../lxr/ident?i=SERV_Close">SERV_Close</a>(iter);
    }
    if (!iter || !n)
        printf("Service not found\n");
</pre>

<span class="ncbi_note">Note</span>: Non-<span class="ncbi_macro">NULL</span> iterator returned from <span class="ncbi_func">SERV_Open()</span> <em>does not</em> yet
guarantee that the service is available, whereas <span class="ncbi_macro">NULL</span> iterator definitely
means that the service does not exist.

<p>
As shown in the above example, loop over reading from the iterator results in the sequence of successive structures
(none of which is to be freed by the program!) that along with conversion functions
<a href="../lxr/ident?i=SERV_ReadInfo"><span class="ncbi_func">SERV_ReadInfo()</span></a>,
<a href="../lxr/ident?i=SERV_WriteInfo"><span class="ncbi_func">SERV_WriteInfo()</span></a> and others are defined
in <a href="../lxr/source/include/connect/ncbi_server_info.h"><span class="ncbi_file">connect/ncbi_server_info.h</span></a>.
Structure <a href="../lxr/ident?i=SSERV_Info"><span class="ncbi_type">SSERV_Info</span></a> describes a server that implements
requested service.
<span class="ncbi_macro">NULL</span> gets returned when no more servers (if any) could be found. The iterator returns servers in the order
the load-balancing algorithm arrange them. Each server has a rating, and the larger the rating
the better the chance for the server to be chosen first.

<p>
<span class="ncbi_note">Note</span>: Servers returned from the iterator are all of the requested type, with only one
exception: they can include servers of type <span class="ncbi_var">fSERV_Firewall</span> even if this type
was not explicitly requested. So the application must sort these servers out, if not interested in them.
But if <span class="ncbi_var">fSERV_Firewall</span> is set in the types, then the search is done for whichever else types requested,
and with the assumption that the client has chosen firewall connection mode, regardless of network parameters
supplied in <span class="ncbi_type">SConnNetInfo</span>, or read out from either registry or environment.

<p>
<span class="ncbi_note">Note</span>: Search for servers of type <span class="ncbi_var">fSERV_Dns</span> is not inclusive with
<span class="ncbi_var">fSERV_Any</span> specified as server type. That is, servers of type DNS are only
returned if specifically requested in the server mask at the time the iterator was opened.

<p>
There is a simplified version of <span class="ncbi_func">SERV_Open()</span>, called <a href="../lxr/ident?i=SERV_OpenSimple"><span class="ncbi_func">SERV_OpenSimple()</span></a>,
as well as an advanced version, called <a href="../lxr/ident?i=SERV_OpenEx"><span class="ncbi_func">SERV_OpenEx()</span></a>.
The former takes only one argument, the service name. The latter takes two more arguments, which describe the
set of servers <em>not</em> to be seen from the iterator (excluded server descriptors).

<p>
There is also an advanced version of <span class="ncbi_func">SERV_GetNextInfo()</span>, called
<a href="../lxr/ident?i=SERV_GetNextInfoEx"><span class="ncbi_func">SERV_GetNextInfoEx()</span></a>, which via its second
argument allows to get many host parameters, among which is a so called host environment
<a href="../tools/dispatcher/LBSMD.html#ref_HostEnvironment">host environment</a>,
a <span class="ncbi_value">"\0"</span>-terminated string, consisting of set of lines
separated by <span class="ncbi_value">"\n"</span> characters, and specified in the configuration file of
<a href="../tools/dispatcher/LBSMD.html">load-balancing daemon</a>
of the host, where the returned server was found. The typical line within the set has a form <span class="ncbi_value">"name=value"</span>
and resembles very much the shell environment, where its name comes from. The host environment could be
very handy for passing additional information to applications if the host has some limitations or requires special
handling should the server be selected and used on this host. <a href="#ref_Example">Example below</a> should give an idea.<br>
At the time of writing, getting the host information is only implemented when the service is obtained via
<a href="#ref_DirectIndirect">direct access</a> to the load-balancing daemon. Unlike returned server descriptors,
the returned host information handle is not a constant object and must be explicitly freed by the application when
no longer needed. All operations (getter methods) that are defined on the host information handle are declared in
<a href="../lxr/source/include/connect/ncbi_host_info.h"><span class="ncbi_file">connect/ncbi_host_info.h</span></a>.
If the server descriptor was obtained using dispatching CGI (<a href="#ref_DirectIndirect">indirect dispatching</a>),
then the host information handle is always returned as <span class="ncbi_macro">NULL</span> (no host information available).

<p>
<a name="ref_DirectIndirect"></a>The back end of the service mapping API is split into 2 independent parts: <span class="ncbi_term">direct</span> access to
<a href="../tools/dispatcher/LBSMD.html" <span class="ncbi_app">>LBSMD</a>, if the one is both available on the current host and is not
disabled by parameter <a href="#ref_LbDisable"><span class="ncbi_var">lb_disable</span></a> at the iterator opening. If <span class="ncbi_app">LBSMD</span> is either unavailable
or disabled, the second (<span class="ncbi_term">indirect</span>) part of the back-end API is used, which involves connection to
<a href="../tools/dispatcher/DISPD.html">dispatching CGI</a>, which in turn connects to <span class="ncbi_app">LBSMD</span> in order to carry out the request.
Attempt to use the CGI is only done, if <a href="../lxr/ident?i=SERV_OpenEx"><span class="ncbi_macro">net_info</span></a> argument is provided non-<span class="ncbi_macro">NULL</span> in the
calls to <span class="ncbi_func">SERV_Open()</span> or <span class="ncbi_func">SERV_OpenEx()</span>.<br>
<span class="ncbi_note">Note</span>: In call to <span class="ncbi_func">SERV_OpenSimple()</span>, <span class="ncbi_var">net_info</span> gets created internally before upcall to
<span class="ncbi_func">SERV_Open()</span> and thus CGI dispatching is likely to happen, unless either <span class="ncbi_var">net_info</span> could not be constructed
from the environment, or environment varaible <span class="ncbi_env">CONN_LB_DISABLE</span> (or service-specific one, or either of corresponding registry keys)
is set to <span class="ncbi_value">TRUE</span>.<br>
<span class="ncbi_note">Note</span>: In the above conditions, the network service name resolution is also undertaken if service name
could not be resolved (due to service inexistence or other error) with the use of locally found <span class="ncbi_app">LBSMD</span>.

<p>
<a name="ref_Example"></a>The following code example uses both <a href="#ref_ServiceConnector">service connector</a> and the service
mapping API to access certain service using an alternate way (other than connector's default) of choosing appropriate servers.
By default, service connector opens an internal service iterator and then tries to connect to the next server,
which <span class="ncbi_func">SERV_GetNextInfo()</span> returns when given the iterator. That is, the server with higher rate is
tried first. If the user provides a pointer to structure <span class="ncbi_type">SSERVICE_Extra</span> as the last parameter of the connector's
constructor, then the user-supplied routine (if any) can be called instead in order to obtain the next server. The routine is also
given a supplemental custom argument <span class="ncbi_var">data</span> taken from <span class="ncbi_type">SSERVICE_Extra</span>.
The (intentionally simplified) example below tries to create connector to an imaginary service <span class="ncbi_value">"my_service"</span>
in restriction that the server has additionally to have a certain (user-specified) database present. The database name is taken
from <a href="../tools/dispatcher/LBSMD.html#ref_HostEnvironment">LBSMD host environment</a> keyed <span class="ncbi_value">"my_service_env"</span>,
the first word of which is assumed to be the name.

<pre class="ncbi_code">
#include &lt;<a href="../lxr/source/include/connect/ncbi_service_connector.h">connect/ncbi_service_connector.h</a>&gt;
#include &lt;ctype.h>
#include &lt;stdlib.h>
#include &lt;string.h>

#define ENV_DB_KEY "my_service_env="


/* This routine gets called when connector is about to be destructed.
 */
static void s_CleanupData(void* data)
{
    free(data); /* we kept database name there */
}


/* This routine gets called on each internal close of the connector
 * (which may be followed by a subsequent internal open).
 */
static void s_Reset(void* data)
{
    /* just see that reset happens by printing DB name */
    printf("Connection reset, DB: %s\n", (char*) data);
}


/* 'Iter' is an internal service iterator used by service connector; it must
 *  remain open.
 * 'Data' is what we supplied among extra-parameters in connector's
    constructor.
 */
static const SSERV_Info* s_GetNextInfo(<a href="../lxr/ident?i=SERV_ITER">SERV_ITER</a> iter, void* data)
{
    const char* db_name = (const char*) data;
    size_t len = strlen(db_name);
    <a href="../lxr/ident?i=SSERV_Info">SSERV_Info</a>* info;
    HOST_INFO hinfo;
    int reset = 0;

    for (;;) {
        while ((info = <a href="../lxr/ident?i=SERV_GetNextInfoEx">SERV_GetNextInfoEx</a>(iter, &amp;hinfo)) != 0) {
            const char* env = <a href="../lxr/ident?i=HINFO_Environment">HINFO_Environment</a>(hinfo);
            const char* c;
            for (c = env; c; c = strchr(c, '\n')) {
                if (strncmp(c == env ? c : ++c, ENV_DB_KEY,
                            sizeof(ENV_DB_KEY)-1) == 0) {
                    /* Our keyword has been detected in environment */
                    /* for this host */
                    c += sizeof(ENV_DB_KEY) - 1;
                    while (*c && isspace(*c))
                        c++;
                    if (strncmp(c, db_name, len) == 0 && !isalnum(c + len)) {
                        /* Database match */
                        free(hinfo); /* must be freed explicitly */
                        return info;
                    }
                }
            }
            if (hinfo)
                free(hinfo); /* must be freed explicitly */
        }
        if (reset)
            break; /* coming to reset 2 times in a row means no server fit */
        <a href="../lxr/ident?i=SERV_Reset">SERV_Reset</a>(iter);
        reset = 1;
    }
    return 0; /* no match found */
}


int main(int argc, char* argv[])
{
    char* db_name = strdup(argv[1]);
    <a href="../lxr/ident?i=SSERVICE_Extra">SSERVICE_Extra</a> params;
    <a href="../lxr/ident?i=CONNECTOR">CONNECTOR</a> c;
    <a href="../lxr/ident?i=CONN">CONN</a> conn;

    memset(&amp;params, 0, sizeof(params));
    params.data = db_name;                /* custom data, anything       */
    params.reset = s_Reset;               /* reset routine, may be NULL  */
    params.cleanup = s_CleanupData;       /* cleanup routine, may be NULL*/
    params.get_net_info = s_GetNextInfo;  /* custom iterator routine     */
    if (!(c = <a href="../lxr/ident?i=SERVICE_CreateConnectorEx">SERVICE_CreateConnectorEx</a>("my_service",
          fSERV_Any, NULL, &amp;params))) {
        fprintf(stderr, "Cannot create connector");
        exit(1);
    }

    if (<a href="../lxr/ident?i=CONN_Create">CONN_Create</a>(c, &conn) != <a href="../lxr/ident?i=EIO_Status">eIO_Success</a>) {
        fprintf(stderr, "Cannot create connection");
        exit(1);
    }

    /* Now we can use <a href="../lxr/ident?i=CONN_Read">CONN_Read()</a>, <a href="../lxr/ident?i=CONN_Write">CONN_Write()</a> etc to operate with
     * connection, and we are assured that the connection is made only
     * to the server on such a host which has "db_name" specified in
     * configuration file of <a href="../tools/dispatcher/LBSMD.html">LBSMD</a>.
     */

    ...
    <a href="../lxr/ident?i=CONN_Close">CONN_Close</a>(conn);
    /* this also calls cleanup of user data provided in params */

    return 0;
}
</pre>

<span class="ncbi_note">Note</span>: No network (indirect) mapping occurs in the above example because <span class="ncbi_var">net_info</span> is passed as <span class="ncbi_macro">NULL</span>
to the connector's constructor.

<p>
<hr>


<a name="ref_ThreadedServer"></a><h2>Threaded Server Support</h2>
This library also provides
<a href="../lxr/ident?i=CThreadedServer&d=C">CThreadedServer</a>, an
abstract base class for multithreaded network servers.
<a href="../lxr/source/src/connect/test/test_threaded_server.cpp">Here</a>
is a demonstration of its use.  Note that this class <em>does not</em>
support multiplexing traffic over a single TCP connection; rather,
each thread has an individual TCP connection created when a client
connects to the server's listening port.


<!--#include virtual="../ssi/navlinks.shtml" -->

<table border=0 width="100%" cellspacing=0>
<tr>
<td align=left>
  <address><a href="mailto:cpp-core@ncbi.nlm.nih.gov">Anton Lavrentiev</a></address>
</td>
<!-- <td align=center><span class="ncbi_cvs_rev">$Revision$</span></td> -->
<td align=right><span class="ncbi_cvs_date">$Date$</span></td>
</tr>
</table>

<!--#include virtual="../ssi/footer.shtml" -->
