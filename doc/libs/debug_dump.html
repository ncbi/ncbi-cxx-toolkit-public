<!-- $Id$ -->
<!--#set var="TITLE" value="NCBI C++ Toolkit:  Debugging Dump" -->
<!--#set var="HEADING" value="DebugDump: Take an Object State Snapshot" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->

<a name="ref_DumpTop"></a>

<ul>
<li><a href="#Terminology">Terminology.</a></li>
<li><a href="#Requirements">Requirements.</a></li>
<li><a href="#Architecture">Architecture.</a></li>
<li><a href="#Implementation">Implementation.</a>
  <ul>
    <li><a href="#CDebugDumpable">CDebugDumpable</a></li>
    <li><a href="#CDebugDumpContext">CDebugDumpContext</a></li>
    <li><a href="#CDebugDumpFormatter">CDebugDumpFormatter</a></li>
  </ul>
</li>
<li><a href="#Examples">Examples.</a></li>
</ul>
<hr>


<p>
Debugging is an inevitable part of software developement.
When it comes to a "mystical" problem, one can spend days and days hunting
for a glitch.  So, being prepared is not just a "nice thing to have", it is a requirement.
</p>

<p>
When a system being developed crashes consistently, debugging is easy in the sense
that the problem is reproducable.  Were that all bugs like this!  It is much more "fun",
when the system crashes intermittently, under circumstances about which we have only a vague idea,
if any, of the symptoms or the cause.  What the developer needs in this case is information - the more the better.
One short message ("Assertion failed") is good and a coredump is better, but we typically need a more
user-friendly reporting of the program status at the point of failure.
</p>

<p>
One possible idea is to make the object tell about itself.  That is, in case of trouble
(but not necessarily trouble), an object could call a function that
would report as much as possible about itself and other object it contains or to which it refers.
During such operation the object should not do anything important, something that could potentially
cause other problems.  The diagnostic must of course be safe - it should only take a snapshot
of an object's state and never alter that data.
</p>

<p>
Sure, <var>DebugDump</var> may cause problems by itself, even if everything is "correct".
Let us say there are two object, which "know" each other:
<tt>Object A</tt> refers to <tt>Object B</tt>, while
<tt>Object B</tt> refers to <tt>Object A</tt> (very common scenario in fact).
Now dumping contents of <tt>Object A</tt> will cause dumping of <tt>Object B</tt>,
which in turn will cause dumping of <tt>Object A</tt>,  and so on until the stack is over.
</p>




<h2><a name="Terminology"></a>
Terminology.</h2>
<p>
So, dumping the object contents should look as a single function call, i.e. something like this:
<pre>
    Object name;
    ...
    name.DebugDump(?);
</pre>
The packet of information produced by such operation we call <var>bundle</var>.
<br />
The class <tt>Object</tt> is most likely derived from other classes. The function should be
called sequentially for each subclass, so it could print its data members.
The piece of information produced by the subclass we call <var>frame</var>.
<br />
The object may refer to other objects. Dumping of such object produces a <var>sub-bundle</var>,
which consists of its own <var>frames</var>.
<br />
To help fight cyclicity, we introduce <var>depth</var> of the dump. When an object being dumped
want to dump other objects it refers to, it should reduce the <var>depth</var> by one.
If the <var>depth</var> is already zero, other objects should not be dumped.
</p>




<h2><a name="Requirements"></a>
Requirements.</h2>
<ul>
  <li>
The dump data should be separated from its representation. That is, the object should only
supply data, something else should format it. Examples of formatting may include generating
human-readable text or file in a special format (HTML, XML), or even transmitting the data
over the network.
  </li>
  <li>
Debug and release libraries should be compatible.
  </li>
  <li>
It should be globally configurable as to whether the dump produces any output or not,
  </li>
</ul>




<h2><a name="Architecture"></a>
Architecture.</h2>
<p>
Class <var>CDebugDumpable</var> is a special abstract base class. Its purpose is to define
a virtual function <var>DebugDump</var>, which any derived class should implement.
Another purpose is to store any global dump options. Any real dump should be initiated
through a non-virtual function of this class - so, global option could be applied.
<br />
Class <var>CObject</var> is derived from this class. So, any classes based on
<var>CObject</var> may benefit from this functionality right away. Other classes
may use this class as a base later on (e.g. using multiple inheritance).
</p>
<p>
Class <var>CDebugDumpContext</var> provides a generic dump interface for dumpable objects.
The class has nothing to do with data representation. Its purpose is the ability to
describe the location of where the data comes from, accept it from the object and
transfer to the data formatter.
</p>
<p>
Class <var>CDebugDumpFormatter</var> defines the dump formatting interface. It is an
abstract class.
</p>
<p>
Class <var>CDebugDumpFormatterText</var> is derived from <var>CDebugDumpFormatter</var>.
Based on incoming data, it generates a human-readable text and passes it into any
output stream (<tt>ostream</tt>).
</p>
<p>
In general, the system works like this:
</p>
<ol>
  <li>
Client creates DebugDump formatter object (it could be an object of class
<var>CDebugDumpFormatterText</var> or any other class derived from <var>CDebugDumpFormatter</var>)
and passes it to a proper, non-virtual function of the object to be dumped.
Bundle name is to be defined here - it can be anything,
but a reasonable guess would be to specify the location of the call and the name of the object
being dumped.
  </li>
  <li>
<var>CDebugDumpable</var> analyses global settings, creates <var>CDebugDumpContext</var> object
and calls virtual DebugDump() function of the object.
  </li>
  <li>
DebugDump function of each subclass defines a frame name (which must be the type of the subclass),
calls DebugDump function of a base class and finally logs its own data members.	From within
the DebugDump(), the object being dumped "sees" only <var>CDebugDumpContext</var>.
It does not know any specifics about target format in which dump data will be
eventually represented.
  </li>
</ol>




<h2><a name="Implementation"></a>
Implementation.</h2>

<h3><a name="CDebugDumpable"></a>
CDebugDumpable.</h3>
<p>
The class is an abstract one. Global options are stored as static variable(s).
<font size="-1">
<pre>
public:
    // Enable/disable debug dump
    static void EnableDebugDump(bool on);

    // Dump using text formatter
    void DebugDumpText(ostream& out,
                       const string& bundle, unsigned int depth) const;
    // Dump using external dump formatter
    void DebugDumpFormat(CDebugDumpFormatter& ddf,
                   const string& bundle, unsigned int depth) const;

    // Function that does the dump - to be overloaded
    virtual void DebugDump(CDebugDumpContext ddc, unsigned int depth) const = 0;
</pre>
</font>
Any derived class must impelement a relevant DebugDump function.
</p>

<h3><a name="CDebugDumpContext"></a>
CDebugDumpContext.</h3>
<p>
The class defines a public dump interface for a client object. It receives the data
from the object and decides when and what functions of dump formatter to call.
</p>
<p>
The dump interface looks like this:
<font size="-1">
<pre>
public:
    CDebugDumpContext(CDebugDumpFormatter&amp; formatter, const string&amp; bundle);
    // This is not exactly a copy constructor -
    // this mechanism is used internally to find out
    // where are we on the Dump tree
    CDebugDumpContext(CDebugDumpContext&amp; ddc);
    CDebugDumpContext(CDebugDumpContext&amp; ddc, const string&amp; bundle);

public:
    // First thing in DebugDump() function - call this function
    // providing class type as the frame name
    void SetFrame(const string&amp; frame);
    // Log data in the form [name, data, comment]
    // All data is passed to a formatter as string, still sometimes
    // it is probably worth to emphasize that the data is REALLY a string
    void Log(const string&amp; name, const string&amp; value, bool is_string = true, const string&amp; comment = kEmptyStr);
    void Log(const string&amp; name, bool value,          const string&amp; comment = kEmptyStr);
    void Log(const string&amp; name, long value,          const string&amp; comment = kEmptyStr);
    void Log(const string&amp; name, unsigned long value, const string&amp; comment = kEmptyStr);
    void Log(const string&amp; name, double value,        const string&amp; comment = kEmptyStr);
    void Log(const string&amp; name, const void* value,   const string&amp; comment = kEmptyStr);
    void Log(const string&amp; name, const CDebugDumpable* value, unsigned int depth);
</pre>
</font>

A number of overloaded <var>Log</var> functions is
provided for convenience only.
</p>

<h3><a name="CDebugDumpFormatter"></a>
CDebugDumpFormatter.</h3>
<p>
This abstract class defines dump formatting interface:
<font size="-1">
<pre>
public:
    virtual bool StartBundle(unsigned int level, const string& bundle) = 0;
    virtual void EndBundle(  unsigned int level, const string& bundle) = 0;

    virtual bool StartFrame( unsigned int level, const string& frame) = 0;
    virtual void EndFrame(   unsigned int level, const string& frame) = 0;

    virtual void PutValue(   unsigned int level, const string& name,
                             const string& value, bool is_string,
                             const string& comment) = 0;
</pre>
</font>
</p>


<h2><a name="Examples"></a>
Examples.</h2>
<p>
Supposed that there is an object <tt>m_ccObj</tt> of class <tt>CSomeObject</tt>
derived from <tt>CObject</tt>.
In order to dump it into the standard <tt>cerr</tt> stream,
one should do one of the following:
<pre>
    m_ccObj.DebugDumpText(cerr, "m_ccObj", 0);
</pre>
or
<pre>
    {
        CDebugDumpFormatterText ddf(cerr);
        m_ccObj.DebugDumpFormat(ddf, "m_ccObj", 0);
    }
</pre>
</p>
<p>
The <tt>DebugDump</tt> function should look like this:
<font size="-1">
<pre>
void CSomeObject::DebugDump(CDebugDumpContext ddc, unsigned int depth) const
{
    ddc.SetFrame("CSomeObject");
    CObject::DebugDump(ddc,depth);
    ddc.Log("m_1", m_1);
    ddc.Log("m_2", m_2);
    ... etc for each data member
}
</pre>
</font>
</p>

<!--#include virtual="../ssi/navlinks.shtml" -->

<!-- Begin footer content -->

<table border="0" cellspacing="0" width="100%">
  <tbody>
  <script>
  <!--
  print_author('cpp-core', 'Andrei Gourianov', '$Date$');
  // -->
  </script>
  </tbody>
</table>

<!--#include virtual="../ssi/footer.shtml" -->
