<!-- $Id$ -->
<!--#set var="TITLE" value="NCBI C++ Toolkit:  Debugging Dump" -->
<!--#set var="HEADING" value="DebugDump: Take an Object State Snapshot" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->
<i><h1><font color="#FF0000"><span style="background-color: #FFFFFF">Warning: This HTML page is deprecated</span></font></h1>

All new changes are being made to the Toolkit Book
at the following locations:
<ul>
<li>
<i>Official Release:</i> <a href="http://www.ncbi.nlm.nih.gov/books/bv.fcgi?call=bv.View..ShowTOC&rid=toolkit.TOC&depth=2">
    C++ Toolkit Book</a>.
</li>
<li>
<i>Development Version:</i> <a href="http://xpubmed0.ncbi.nlm.nih.gov:5701/books/bv.fcgi?call=bv.View..ShowTOC&rid=toolkit.TOC&depth=2">

    C++ Toolkit Book (no search engine, accessible from inside NCBI only)</a>. </li> </ul> The Development Version is the most recent documentation before it becomes an Official Release. While the Development Version is the lastest version, it is accessible only from inside NCBI, and the search engine functionality is currently missing. Also, the location of the Development Version may change without warning! So it is suggested that you use the Official Release, and use the Development Version only when necessary.</p> </i>

<hr>
<!--EOW-->

<a name="ref_DumpTop"></a>

<ul>
<li><a href="#Terminology">Terminology</a></li>
<li><a href="#Requirements">Requirements</a></li>
<li><a href="#Architecture">Architecture</a></li>
<li><a href="#Implementation">Implementation</a>
  <ul>
    <li><a href="#CDebugDumpable">CDebugDumpable</a></li>
    <li><a href="#CDebugDumpContext">CDebugDumpContext</a></li>
    <li><a href="#CDebugDumpFormatter">CDebugDumpFormatter</a></li>
  </ul>
</li>
<li><a href="#Examples">Examples</a></li>
</ul>
<hr>


<p>
Debugging is an inevitable part of software developement.
When it comes to a "mystical" problem, one can spend days and days hunting
for a glitch.  So, being prepared is not just a "nice thing to have", it is a requirement.
</p>

<p>
When a system being developed crashes consistently, debugging is easy in the sense
that the problem is reproducable.  Were that all bugs like this!  It is much more "fun",
when the system crashes intermittently, under circumstances about which we have only a vague idea,
if any, of the symptoms or the cause.  What the developer needs in this case is information - the more the better.
One short message ("Assertion failed") is good and a coredump is better, but we typically need a more
user-friendly reporting of the program status at the point of failure.
</p>

<p>
One possible idea is to make the object tell about itself.  That is, in case of trouble
(but not necessarily trouble), an object could call a function that
would report as much as possible about itself and other object it contains or to which it refers.
During such operation the object should not do anything important, something that could potentially
cause other problems.  The diagnostic must of course be safe - it should only take a snapshot
of an object's state and never alter that data.
</p>

<p>
Sure, <span class="ncbi_func">DebugDump</span> may cause problems by itself, even if everything is "correct".
Let us say there are two object, which "know" each other:
<span class="ncbi_var">Object A</span> refers to <span class="ncbi_var">Object B</span>, while
<span class="ncbi_var">Object B</span> refers to <span class="ncbi_var">Object A</span> (very common scenario in fact).
Now dumping contents of <span class="ncbi_var">Object A</span> will cause dumping of <span class="ncbi_var">Object B</span>,
which in turn will cause dumping of <span class="ncbi_var">Object A</span>,  and so on until the stack is over.
</p>




<h2><a name="Terminology"></a>Terminology</h2>
<p>
So, dumping the object contents should look as a single function call, i.e. something like this:
<pre class="ncbi_code">
    Object name;
    ...
    name.DebugDump(?);
</pre>
The packet of information produced by such operation we call <span class="ncbi_term">bundle</span>.
<br />
The class <span class="ncbi_class">Object</span> is most likely derived from other classes. The function should be
called sequentially for each subclass, so it could print its data members.
The piece of information produced by the subclass we call <span class="ncbi_term">frame</span>.
<br />
The object may refer to other objects. Dumping of such object produces a <span class="ncbi_term">sub-bundle</span>,
which consists of its own <span class="ncbi_term">frames</span>.
<br />
To help fight cyclicity, we introduce <span class="ncbi_term">depth</span> of the dump. When an object being dumped
want to dump other objects it refers to, it should reduce the <span class="ncbi_term">depth</span> by one.
If the <span class="ncbi_term">depth</span> is already zero, other objects should not be dumped.
</p>




<h2><a name="Requirements"></a>Requirements</h2>
<ul>
  <li>
The dump data should be separated from its representation. That is, the object should only
supply data, something else should format it. Examples of formatting may include generating
human-readable text or file in a special format (HTML, XML), or even transmitting the data
over the network.
  </li>
  <li>
Debug and release libraries should be compatible.
  </li>
  <li>
It should be globally configurable as to whether the dump produces any output or not,
  </li>
</ul>




<h2><a name="Architecture"></a>Architecture</h2>
<p>
Class <span class="ncbi_class">CDebugDumpable</span> is a special abstract base class. Its purpose is to define
a virtual function <span class="ncbi_func">DebugDump</span>, which any derived class should implement.
Another purpose is to store any global dump options. Any real dump should be initiated
through a non-virtual function of this class - so, global option could be applied.
<br />
Class <span class="ncbi_class">CObject</span> is derived from this class. So, any classes based on
<span class="ncbi_class">CObject</span> may benefit from this functionality right away. Other classes
may use this class as a base later on (e.g. using multiple inheritance).
</p>
<p>
Class <span class="ncbi_class">CDebugDumpContext</span> provides a generic dump interface for dumpable objects.
The class has nothing to do with data representation. Its purpose is the ability to
describe the location of where the data comes from, accept it from the object and
transfer to the data formatter.
</p>
<p>
Class <span class="ncbi_class">CDebugDumpFormatter</span> defines the dump formatting interface. It is an
abstract class.
</p>
<p>
Class <span class="ncbi_class">CDebugDumpFormatterText</span> is derived from <span class="ncbi_class">CDebugDumpFormatter</span>.
Based on incoming data, it generates a human-readable text and passes it into any
output stream (<span class="ncbi_class">ostream</span>).
</p>
<p>
In general, the system works like this:
</p>
<ol>
  <li>
Client creates DebugDump formatter object (it could be an object of class
<span class="ncbi_class">CDebugDumpFormatterText</span> or any other class derived from <span class="ncbi_class">CDebugDumpFormatter</span>)
and passes it to a proper, non-virtual function of the object to be dumped.
Bundle name is to be defined here - it can be anything,
but a reasonable guess would be to specify the location of the call and the name of the object
being dumped.
  </li>
  <li>
<span class="ncbi_class">CDebugDumpable</span> analyses global settings, creates <span class="ncbi_class">CDebugDumpContext</span> object
and calls virtual DebugDump() function of the object.
  </li>
  <li>
DebugDump function of each subclass defines a frame name (which must be the type of the subclass),
calls DebugDump function of a base class and finally logs its own data members.	From within
the DebugDump(), the object being dumped "sees" only <span class="ncbi_class">CDebugDumpContext</span>.
It does not know any specifics about target format in which dump data will be
eventually represented.
  </li>
</ol>




<h2><a name="Implementation"></a>Implementation</h2>

<h3><a name="CDebugDumpable"></a>CDebugDumpable</h3>
<p>
The class is an abstract one. Global options are stored as static variable(s).
<blockquote>
<pre class="ncbi_code">
public:
    // Enable/disable debug dump
    static void EnableDebugDump(bool on);

    // Dump using text formatter
    void DebugDumpText(ostream& out,
                       const string& bundle, unsigned int depth) const;
    // Dump using external dump formatter
    void DebugDumpFormat(CDebugDumpFormatter& ddf,
                   const string& bundle, unsigned int depth) const;

    // Function that does the dump - to be overloaded
    virtual void DebugDump(CDebugDumpContext ddc, unsigned int depth) const = 0;
</pre></blockquote>
Any derived class must impelement a relevant DebugDump function.
</p>

<h3><a name="CDebugDumpContext"></a>CDebugDumpContext</h3>
<p>
The class defines a public dump interface for a client object. It receives the data
from the object and decides when and what functions of dump formatter to call.
</p>
<p>
The dump interface looks like this:

<blockquote>
<pre class="ncbi_code">
public:
    CDebugDumpContext(CDebugDumpFormatter&amp; formatter, const string&amp; bundle);
    // This is not exactly a copy constructor -
    // this mechanism is used internally to find out
    // where are we on the Dump tree
    CDebugDumpContext(CDebugDumpContext&amp; ddc);
    CDebugDumpContext(CDebugDumpContext&amp; ddc, const string&amp; bundle);

public:
    // First thing in DebugDump() function - call this function
    // providing class type as the frame name
    void SetFrame(const string&amp; frame);
    // Log data in the form [name, data, comment]
    // All data is passed to a formatter as string, still sometimes
    // it is probably worth to emphasize that the data is REALLY a string
    void Log(const string&amp; name, const string&amp; value, bool is_string = true, const string&amp; comment = kEmptyStr);
    void Log(const string&amp; name, bool value,          const string&amp; comment = kEmptyStr);
    void Log(const string&amp; name, long value,          const string&amp; comment = kEmptyStr);
    void Log(const string&amp; name, unsigned long value, const string&amp; comment = kEmptyStr);
    void Log(const string&amp; name, double value,        const string&amp; comment = kEmptyStr);
    void Log(const string&amp; name, const void* value,   const string&amp; comment = kEmptyStr);
    void Log(const string&amp; name, const CDebugDumpable* value, unsigned int depth);
</pre>
</blockquote>

A number of overloaded <span class="ncbi_func">Log</span> functions is
provided for convenience only.
</p>

<h3><a name="CDebugDumpFormatter"></a>CDebugDumpFormatter</h3>
<p>
This abstract class defines dump formatting interface:

<blockquote>
<pre class="ncbi_code">
public:
    virtual bool StartBundle(unsigned int level, const string& bundle) = 0;
    virtual void EndBundle(  unsigned int level, const string& bundle) = 0;

    virtual bool StartFrame( unsigned int level, const string& frame) = 0;
    virtual void EndFrame(   unsigned int level, const string& frame) = 0;

    virtual void PutValue(   unsigned int level, const string& name,
                             const string& value, bool is_string,
                             const string& comment) = 0;
</pre>
</blockquote>
</p>


<h2><a name="Examples"></a>Examples</h2>
<p>
Supposed that there is an object <span class="ncbi_var">m_ccObj</span> of class <span class="ncbi_class">CSomeObject</span>
derived from <span class="ncbi_class">CObject</span>.
In order to dump it into the standard <span class="ncbi_var">cerr</span> stream,
one should do one of the following:
<pre class="ncbi_code">
    m_ccObj.DebugDumpText(cerr, "m_ccObj", 0);
</pre>
or
<pre class="ncbi_code">
    {
        CDebugDumpFormatterText ddf(cerr);
        m_ccObj.DebugDumpFormat(ddf, "m_ccObj", 0);
    }
</pre>
</p>
<p>
The <span class="ncbi_func">DebugDump</span> function should look like this:

<blockquote>
<pre class="ncbi_code">
void CSomeObject::DebugDump(CDebugDumpContext ddc, unsigned int depth) const
{
    ddc.SetFrame("CSomeObject");
    CObject::DebugDump(ddc,depth);
    ddc.Log("m_1", m_1);
    ddc.Log("m_2", m_2);
    ... etc for each data member
}
</pre>
</blockquote>
</p>

<!--#include virtual="../ssi/navlinks.shtml" -->

<!-- Begin footer content -->

<table border="0" cellspacing="0" width="100%">
  <tbody>
  <script>
  <!--
  print_author('cpp-core', 'Andrei Gourianov', '$Date$');
  // -->
  </script>
  </tbody>
</table>

<!--#include virtual="../ssi/footer.shtml" -->
