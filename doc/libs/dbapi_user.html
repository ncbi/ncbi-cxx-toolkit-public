<!--#set var="TITLE" value="NCBI DBAPI User-Layer Docs" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->


<!--<B><FONT FACE="Arial" SIZE=4><P>DBAPI Interface Overview.</P></B></FONT><P>&nbsp;</P>-->
<h1>
NCBI DBAPI User-Layer Reference</h3>

<h2>Contents</h2>

<ul>
    <li> <a href="#ref_ObjHierarchy">Object Hierarchy</a> </li>
    <li> <a href="#ref_Includes">Includes</a> </li>
    <li> <a href="#ref_Objects">Objects</a> </li>
    <li> <a href="#ref_ObjLifeCycle">Object Life Cycle</a> </li>
    <li> <a href="#ref_CVariant">CVariant Type</a> </li>
    <li> <a href="#ref_ChooseDriver">Choosing the Driver</a> </li>
    <li> <a href="#ref_SrcCnxns">Data Source and Connections</a> </li>
    <li> <a href="#ref_MainLoop">Main Loop</a> </li>
	<li> <a href="#ref_IOParams">Input and Output Parameters</a> </li>
	<li> <a href="#ref_StoredProcs">Stored Procedures</a> </li>
	<li> <a href="#ref_Cursors">Cursors</a> </li>
	<li> <a href="#ref_Libraries">Libraries</a> </li>
</ul>

<p></p>
<hr>

<!-- List of different sections to get indentation of text from heading
     NOTE:  spacing is preserved in PRE blocks, so that is *not* indented here!
	 NOTE:  <blockquote> converts <TAB> to 8 spaces in NS4.78; untabify those regions-->


<dl>

<a name="ref_ObjHierarchy"></a>
<dt><h3>Object hierarchy</h3></dt>
	<dd>
		<P><IMG SRC="dbapi_user.gif" WIDTH=681 HEIGHT=464></P>
	</dd>

<P>&nbsp;</P>
<a name="ref_Includes"></a>
<dt><h3>Includes</h3></dt>
	<dd>
		<P>For most purposes it is sufficient to include one file in the user source file: dbapi.hpp.</P>

	<PRE>
#include &lt;dbapi/dbapi.hpp&gt;  <FONT FACE="Arial"><B>or,</B></FONT>
#include &lt;dbapi/driver/drivers.hpp&gt; <FONT FACE="Arial">(for static linkage only!)</FONT>
    </PRE>

	</dd>

<a name="ref_Objects"></a>
<dt><h3>Objects</h3></dt>
	<dd>
		<P>All objects are returned by pointers to their respective
		interfaces. The null (0) value is valid, meaning that no object was
		returned.</P>
	</dd>

<a name="ref_ObjLifeCycle"></a>
<dt><h3>Object Life Cycle</h3></dt>
<dd>
	<P>In general, any child object is valid only in the
	scope of its parent object. This is  because most of the objects share
	the same internal structures. There is no need to delete every object
	explicitly, as all created objects will be deleted upon program exit.</P>
</dd>

<a name="ref_CVariant"></a>
<dt><h3>CVariant type</h3></dt>
	<dd>
		<P></P>
		The <a href="../docxx/CVariant.html"><tt>CVariant</tt></a> type is used to represent any database data
		type (except BLOBs). It is an object, not a pointer, so it behaves
		like a primitive C++ type. Basic comparison operators are supported
		<FONT FACE="Courier New">(==, !=, &lt; </FONT>)  for identical
		internal types. If types are not identical, <a href="../docxx/CVariantException.html"><tt>CVariantException</tt></a> is
		thrown. <a href="../docxx/CVariant.html"><tt>CVariant</tt></a> has a set of getters to extract a value of a
		particular type, e.g. <tt>GetInt4(), GetByte(), GetString()</tt>, etc. If
		<tt>GetString()</tt> is called for a different type, like <tt>DateTime</tt> or <tt>integer</tt>
		it tries to convert it to a string. It it doesn't succeed,
		<a href="../docxx/CVariantException.html"><tt>CVariantException</tt></a> is thrown.

		<p></p>
		There is a set of factory methods (static functions) for creating <a href="../docxx/CVariant.html"><tt>CVariant</tt></a> objects of a particular type, such as
		<tt><a href="../docxx/CVariant.html">CVariant</a>::BigInt(), <a href="../docxx/CVariant.html">CVariant</a>::SmallDateTime(), <a href="../docxx/CVariant.html">CVariant</a>::VarBinary()</tt>,
		etc. For more details please see the comments in <a href="lxr/source/include/dbapi/variant.hpp">variant.hpp</a> file.
		</dd>

<P></P>
<a name="ref_ChooseDriver"></a>
<dt><h3>Choosing the driver</h3></dt>
	<dd>
		<P>There are several drivers for working with different SQL servers on
		different platforms.  The ones presently implemented are "<b>ctlib</b>"
		(Sybase), "<b>dblib</b>"(MS SQL), "<b>ftds</b>" (cross platform). For static linkage
		these drivers should be registered manually; for dynamic linkage this
		is not necessary. The <a href="../docxx/CDriverManager.html"><tt>CDriverManager</tt></a> object maintains all registered
		drivers.</P>

		<blockquote>
		<pre>
CDriverManager &amp;dm = CDriverManager::GetInstance();
DBAPI_RegisterDriver_CTLIB(dm);
DBAPI_RegisterDriver_DBLIB(dm);

		</pre>
		</blockquote>

	</dd>

<a name="ref_SrcCnxns"></a>
<dt><h3>Data Source and Connections</h3></dt>
	<dd>
		<P>The <a href="../docxx/IDataSource.html"><tt>IDataSource</tt></a> interface defines the database platform.
		To create an object implementing this
		interface, use the method <tt>CreateDs(const string&amp; driver)</tt>.  An
		<a href="../docxx/IDataSource.html"><tt>IDataSource</tt></a> can create objects represented by an
		<a href="../docxx/IConnection.html"><tt>IConnection</tt></a> interface,
		which is responsible for the connection to the database.  It is highly
		recommended to specify the database name as an argument to the
		<tt>CreateConnction()</tt> method, or use the <tt>SetDatabase()</tt> method of
		a <a href="../docxx/CConnection.html"><tt>CConneciton</tt></a>
		object instead of using a reqular SQL statement.  In the later case, the library
		won't be able to track the current database. </P>

		<blockquote>
		<PRE>
IDataSource *ds = dm.CreateDs("ctlib");
IConnection *conn = ds-&gt;CreateConnection();
conn-&gt;Connect("user", "password", "server", "database");
IStatement *stmt = conn-&gt;CreateStatement();

		</PRE>
		</blockquote>

		</FONT><P>Every additional call to <tt><a href="../docxx/IConnection.html">IConnection</a>::CreateStatement()</tt>
		results in cloning the connection for each statement. These
		connections inherit the same default database, which was specified in the
		<tt>Connect()</tt> or <tt>SetDatabase()</tt> method.  Thus if the default database was
		changed by calling <tt>SetDatabase()</tt>, all subsequent cloned connections
		created by <tt>CreateStatement()</tt> will inherit this particular default
		database.</P>

	</dd>

<a name="ref_MainLoop"></a>
<dt><h3>Main loop</h3></dt>
	<dd>
		<P>The library simulates the main result-retrieving loop of
		the Sybase client library by using the <tt><a href="../docxx/IStatement.html">IStatement</a>::HasMoreResults()</tt> method:</P>

		<blockquote>
        <PRE>
stmt-&gt;Execute(&quot;select …&quot;);
while( stmt-&gt;HasMoreResults() ) {
    if( stmt-&gt;HasRows() ) {
        IResultSet *rs = stmt-&gt;GetResultset();

        // Retrieve results, if any

        while( rs-&gt;Next() ) {
            int col1 = rs-&gt;GetVariant(1).GetInt4();
            ...
        }
    }
}
        </PRE>
		</blockquote>

		<P>This method should be called until it returns false, which
		means that no more results is available. It returns as soon as a
		result is ready. The type of the result can be obtained by calling the
		<tt><a href="../docxx/IResultSet.html">IResultSet</a>::GetResultType()</tt> method.  Supported result types are
		<tt>eRowResult, eParamResult, eComputeResult, eStatusResult,
		eCursorResult</tt>. The method <tt><a href="../docxx/IStatement.html">IStatement</a>::GetRowCount()</tt> returns the
		number of updated or deleted rows.</P>

		<P>The <tt><a href="../docxx/IStatement.html">IStatement</a>::ExecuteUpdate()</tt> method is used for SQL statements that do not return rows:</P>

		<blockquote>
		<PRE>
stmt-&gt;ExecuteUpdate("update...");
int rows = stmt-&gt;GetRowCount();

		</PRE>
		</blockquote>

		<P>The method <tt><a href="../docxx/IStatement.html">IStatement</a>::GetResultSet()</tt> returns an <a href="../docxx/IResultSet.html"><tt>IResultSet</tt></a>
		object. The method <tt><a href="../docxx/IResultSet.html">IResultSet</a>::Next()</tt> actually does fetch, so it
		should be always called first. It returns false when no more fetch
		data is available. All column data, except Image and Text is
		represented by a single <a href="../docxx/CVariant.html"><tt>CVariant</tt></a> object. The method
		<tt><a href="../docxx/IResultSet.html">IResultSet</a>::GetVariant()</tt> takes one parameter – column
		number. Column numbers start with 1. </P>
		<P>&nbsp;</P>
	</dd>

<a name="ref_IOParams"></a>
<dt><h3>Input and Output Parameters</h3></dt>
	<dd>
		<P>The method <tt><a href="../docxx/ICallableStatement.html">ICallableStatement</a>::SetParam(const
		CVariant&amp; v, const string&amp; name)</tt> is used to pass parameters to
		stored procedures and dynamic SQL statements. To ensure the correct parameter
		type it is recommended to use <a href="../docxx/CVariant.html"><tt>CVariant</tt></a> type factories (static methods)
		to create a <a href="../docxx/CVariant.html"><tt>CVariant</tt></a> of the required internal type.  Here are a few
		examples:  <tt><a href="../docxx/CVariant.html">CVariant</a>::Int4(Int4 *p), <a href="../docxx/CVariant.html">CVariant</a>::TinyInt(UInt1 *p),
		<a href="../docxx/CVariant.html">CVariant</a>::VarChar(const char *p, size_t len )</tt> etc.

		<p>
		There are also corresponding constructors, like <tt><a href="../docxx/CVariant.html">CVariant</a>::CVariant(Int4 v),
		<a href="../docxx/CVariant.html">CVariant</a>::CVariant(const string&amp; s), ...</tt>, but the user must ensure
		the proper type conversion in the arguments, and not all internal
		types can be created using constructors.

		<p></p>
		Output parameters are set by the
		<tt><a href="../docxx/ICallableStatement.html">ICallableStatement</a>::SetOutputParam(const CVariant&amp; v, const
		string&amp; name)</tt> method, where the first argument is a null <a href="../docxx/CVariant.html"><tt>CVariant</tt></a>
		of a particular type, e.g. <tt>SetOutputParam(CVariant::SmallInt(0),"@arg")</tt>.</P>
	</dd>

<a name="ref_StoredProcs"></a>
<dt><h3>Stored Procedures</h3></dt>
	<dd>
		<P>The <a href="../docxx/ICallableStatement.html"><tt>ICallableStatement</tt></a> object is used for calling stored
		procedures. Fist get the object itself by calling
		<tt><a href="../docxx/IConnection.html">IConnection</a>::PrepareCall()</tt>. Then set any parameters. If the parameter name
		is empty, the calls to <tt>SetParam()</tt> should be in the exact order of the actual
		parameters.  Retrieve all results in the main loop. Get the status of the
		stored procedure using the <tt><a href="../docxx/ICallableStatement.html">ICallableStatement</a>::GetReturnStatus()</tt> method.</P>

		<blockquote>
		<PRE>
ICallableStatement *cstmt = conn-&gt;PrepareCall(&quot;ProcName&quot;);
Uint1 status = 1;
cstmt-&gt;SetParam(CVariant(&quot;test&quot;), &quot;@test_input&quot;);
cstmt-&gt;SetParam(CVariant::TinyInt(&amp;status), &quot;@status&quot;);
cstmt-&gt;SetOutputParam(CVariant::Int(0), &quot;@result&quot;);

cstmt-&gt;Execute();

while(cstmt-&gt;HasMoreResults()) {
    if( cstmt-&gt;HasRows() ) {
        IResultSet *rs = cstmt-&gt;GetResultSet();
        switch( rs-&gt;GetResultType() ) {
            case eRowResult:
                  while(rs-&gt;Next()) {

                  // retrieve row results

                  }
                  break;
            case eParamResult:
                  while(rs-&gt;Next()) {

                  // Retrieve parameter row

                  }
                  break;
        }
    }
}

// Get status
int status = cstmt-&gt;GetReturnStatus();

		</PRE>
		</blockquote>

	</dd>

<a name="ref_Cursors"></a>
<dt><h3>Cursors</h3></dt>
	<dd>
		<P>The library currently supports basic cursor features
		such as setting parameters and cursor update and delete
		operations.</P>

		<blockquote>
		<PRE>
ICursor *cur = conn-&gt;CreateCursor("table_cur",
                                  "select ... for update of ...");
IResultSet *rs = cur-&gt;Open();
while(rs-&gt;Next()) {
    cur-&gt;Update(table, sql_statement_for_update);
}
cur-&gt;Close();

		</PRE>
		</blockquote>

	</dd>

<a name="ref_Libraries"></a>
<dt><h3>Libraries</h3></dt>
	<dd>
		<FONT FACE="Courier New">
		</FONT><P>The following libraries should be used (the order is significant):</P>
		<dl>
			<dt>for <b>ctlib</b> (Sybase):</dt>
			<dd><FONT FACE="Courier New"><P>dbapi dbapi_driver_ctlib dbapi_driver</P>
			</FONT><P>plus corresponding Sybase libraries.</P>
			</dd>

			<dt>for <b>dblib</b> (MS SQL):</dt>
			<dd><FONT FACE="Courier New"><P>dbapi dbapi_driver_dblib dbapi_driver </P>
			</FONT><P>plus Sybase <FONT FACE="Courier New">sybdb</P></FONT>
			</dd>
		</dl>
	</dd>
</dl>

<p>
<hr>
<table border=0 width="100%" cellspacing=0>
<tr>
<td align=left>
  <address><a href="mailto:kholodov@ncbi.nlm.nih.gov">Michael Kholodov</a></address>
</td>
<!-- <td align=center><i>$Revision$</i></td> -->
<td align=right><i>$Date$</i></td>
</tr>
</table>

<!--#include virtual="../ssi/footer.shtml" -->
