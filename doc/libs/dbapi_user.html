<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
   <meta name="GENERATOR" content="Mozilla/4.79 [en] (Windows NT 5.0; U) [Netscape]">
<!--#set var="TITLE" value="NCBI DBAPI User-Layer Docs" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->
<!--<B><FONT FACE="Arial" SIZE=4><P>DBAPI Interface Overview.</P></B></FONT><P>&nbsp;</P>-->
</head>
<body>

<h1>
NCBI DBAPI User-Layer Reference</h1>

<h2>
Contents</h2>

<ul>
<li>
<a href="#ref_ObjHierarchy">Object Hierarchy</a></li>

<li>
<a href="#ref_Includes">Includes</a></li>

<li>
<a href="#ref_Objects">Objects</a></li>

<li>
<a href="#ref_ObjLifeCycle">Object Life Cycle</a></li>

<li>
<a href="#ref_CVariant">CVariant Type</a></li>

<li>
<a href="#ref_ChooseDriver">Choosing the Driver</a></li>

<li>
<a href="#ref_SrcCnxns">Data Source and Connections</a></li>

<li>
<a href="#ref_MainLoop">Main Loop</a></li>

<li>
<a href="#ref_IOParams">Input and Output Parameters</a></li>

<li>
<a href="#ref_StoredProcs">Stored Procedures</a></li>

<li>
<a href="#ref_Cursors">Cursors</a></li>

<li>
<a href="#ref_Blobs">Updating BLOBs using cursors</a></li>

<li>
<a href="#ref_BulkInsert">Using bulk insert</a></li>
</ul>

<hr><!-- List of different sections to get indentation of text from heading
     NOTE:  spacing is preserved in PRE blocks, so that is *not* indented here!
	 NOTE:  <blockquote> converts <TAB> to 8 spaces in NS4.78; untabify those regions-->
<dl><a NAME="ref_ObjHierarchy"></a>
<h3>
Object hierarchy</h3>
<img SRC="dbapi_user.gif" height=464 width=681>
<br>&nbsp;
<p><a NAME="ref_Includes"></a>
<h3>
Includes</h3>
For most purposes it is sufficient to include one file in the user source
file: dbapi.hpp.
<pre>#include &lt;dbapi/dbapi.hpp></pre>
For static linkage the following include file is also necessary:
<pre>#include &lt;dbapi/driver/drivers.hpp></pre>
<a NAME="ref_Objects"></a>
<h3>
Objects</h3>
All objects are returned by pointers to their respective interfaces. The
null (0) value is valid, meaning that no object was returned.
<br><a NAME="ref_ObjLifeCycle"></a>
<h3>
Object Life Cycle</h3>
In general, any child object is valid only in the scope of its parent object.
This is because most of the objects share the same internal structures.
There is no need to delete every object explicitly, as all created objects
will be deleted upon program exit. Specifically, all objects are derived
from the static CDriverManager object, and will be destroyed when CDriverManager
is destroyed. Thus it is recommended to reuse the objects such as <tt><a href="../docxx/IStatement.html">IStatement,</a><a href="../docxx/ICallableStatement.html">ICallableStatement</a></tt>or
delete them explicitly, if otherwise is not possible.
<br><a NAME="ref_CVariant"></a>
<h3>
CVariant type</h3>
The <tt><a href="../docxx/CVariant.html">CVariant</a></tt> type is used
to represent any database data type (except BLOBs). It is an object, not
a pointer, so it behaves like a primitive C++ type. Basic comparison operators
are supported <font face="Courier New">(==, !=, &lt; </font>) for identical
internal types. If types are not identical, <tt><a href="../docxx/CVariantException.html">CVariantException</a></tt>
is thrown. <tt><a href="../docxx/CVariant.html">CVariant</a></tt> has a
set of getters to extract a value of a particular type, e.g. <tt>GetInt4(),
GetByte(), GetString()</tt>, etc. If <tt>GetString()</tt> is called for
a different type, like <tt>DateTime</tt> or <tt>integer</tt> it tries to
convert it to a string. It it doesn't succeed, <tt><a href="../docxx/CVariantException.html">CVariantException</a></tt>
is thrown.
<br>There is a set of factory methods (static functions) for creating <tt><a href="../docxx/CVariant.html">CVariant</a></tt>
objects of a particular type, such as <tt><a href="../docxx/CVariant.html">CVariant</a>::BigInt(),
<a href="../docxx/CVariant.html">CVariant</a>::SmallDateTime(),
<a href="../docxx/CVariant.html">CVariant</a>::VarBinary()</tt>,
etc. For more details please see the comments in <a href="lxr/source/include/dbapi/variant.hpp">variant.hpp</a>
file.
<br><a NAME="ref_ChooseDriver"></a>
<h3>
Choosing the driver</h3>
There are several drivers for working with different SQL servers on different
platforms. The ones presently implemented are "<b>ctlib</b>" (Sybase),
"<b>dblib</b>"(MS SQL, Sybase), "<b>ftds</b>" (MS SQLcross platform). For
static linkage these drivers should be registered manually; for dynamic
linkage this is not necessary. The <tt><a href="../docxx/CDriverManager.html">CDriverManager</a></tt>
object maintains all registered drivers.
<blockquote>
<pre>CDriverManager &amp;dm = CDriverManager::GetInstance();
DBAPI_RegisterDriver_CTLIB(dm);
DBAPI_RegisterDriver_DBLIB(dm);

</pre>
</blockquote>
<a NAME="ref_SrcCnxns"></a>
<h3>
Data Source and Connections</h3>
The <tt><a href="../docxx/IDataSource.html">IDataSource</a></tt> interface
defines the database platform. To create an object implementing this interface,
use the method <tt>CreateDs(const string&amp; driver)</tt>. An <tt><a href="../docxx/IDataSource.html">IDataSource</a></tt>
can create objects represented by an <tt><a href="../docxx/IConnection.html">IConnection</a></tt>
interface, which is responsible for the connection to the database. It
is highly recommended to specify the database name as an argument to the
<tt>CreateConnction()</tt>
method, or use the <tt>SetDatabase()</tt> method of a <tt><a href="../docxx/CConnection.html">CConneciton</a></tt>
object instead of using a reqular SQL statement. In the later case, the
library won't be able to track the current database.
<blockquote>
<pre>IDataSource *ds = dm.CreateDs("ctlib");
IConnection *conn = ds->CreateConnection();
conn->Connect("user", "password", "server", "database");
IStatement *stmt = conn->CreateStatement();

</pre>
</blockquote>
Every additional call to <tt><a href="../docxx/IConnection.html">IConnection</a>::CreateStatement()</tt>
results in cloning the connection for each statement. These connections
inherit the same default database, which was specified in the <tt>Connect()</tt>
or <tt>SetDatabase()</tt> method. Thus if the default database was changed
by calling <tt>SetDatabase()</tt>, all subsequent cloned connections created
by <tt>CreateStatement()</tt> will inherit this particular default database.
<br><a NAME="ref_MainLoop"></a>
<h3>
Main loop</h3>
The library simulates the main result-retrieving loop of the Sybase client
library by using the <tt><a href="../docxx/IStatement.html">IStatement</a>::HasMoreResults()</tt>
method:
<blockquote>
<pre>stmt->Execute("select à");
while( stmt->HasMoreResults() ) {
&nbsp;&nbsp;&nbsp; if( stmt->HasRows() ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IResultSet *rs = stmt->GetResultset();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Retrieve results, if any

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( rs->Next() ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int col1 = rs->GetVariant(1).GetInt4();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
}</pre>
</blockquote>
This method should be called until it returns false, which means that no
more results is available. It returns as soon as a result is ready. The
type of the result can be obtained by calling the <tt><a href="../docxx/IResultSet.html">IResultSet</a>::GetResultType()</tt>
method. Supported result types are <tt>eDB_RowResult, eDB_ParamResult,
eDB_ComputeResult, eDB_StatusResult, eDB_CursorResult</tt>. The method
<tt><a href="../docxx/IStatement.html">IStatement</a>::GetRowCount()</tt>
returns the number of updated or deleted rows.
<p>The <tt><a href="../docxx/IStatement.html">IStatement</a>::ExecuteUpdate()</tt>
method is used for SQL statements that do not return rows:
<blockquote>
<pre>stmt->ExecuteUpdate("update...");
int rows = stmt->GetRowCount();

</pre>
</blockquote>
The method <tt><a href="../docxx/IStatement.html">IStatement</a>::GetResultSet()</tt>
returns an <tt><a href="../docxx/IResultSet.html">IResultSet</a></tt> object.
The method <tt><a href="../docxx/IResultSet.html">IResultSet</a>::Next()</tt>
actually does fetch, so it should be always called first. It returns false
when no more fetch data is available. All column data, except Image and
Text is represented by a single <tt><a href="../docxx/CVariant.html">CVariant</a></tt>
object. The method <tt><a href="../docxx/IResultSet.html">IResultSet</a>::GetVariant()</tt>
takes one parameter û column number. Column numbers start with 1.
<br>&nbsp;
<p><a NAME="ref_IOParams"></a>
<h3>
Input and Output Parameters</h3>
The method <tt><a href="../docxx/ICallableStatement.html">ICallableStatement</a>::SetParam(const
CVariant&amp; v, const string&amp; name)</tt> is used to pass parameters
to stored procedures and dynamic SQL statements. To ensure the correct
parameter type it is recommended to use <tt><a href="../docxx/CVariant.html">CVariant</a></tt>
type factories (static methods) to create a <tt><a href="../docxx/CVariant.html">CVariant</a></tt>
of the required internal type. Here are a few examples: <tt><a href="../docxx/CVariant.html">CVariant</a>::Int4(Int4
*p), <a href="../docxx/CVariant.html">CVariant</a>::TinyInt(UInt1 *p),<br>
<a href="../docxx/CVariant.html">CVariant</a>::VarChar(const char *p, size_t
len )</tt> etc.
<p>There are also corresponding constructors, like <tt><a href="../docxx/CVariant.html">CVariant</a>::CVariant(Int4
v), <a href="../docxx/CVariant.html">CVariant</a>::CVariant(const string&amp;
s), ...</tt>, but the user must ensure the proper type conversion in the
arguments, and not all internal types can be created using constructors.
<br>Output parameters are set by the <tt><a href="../docxx/ICallableStatement.html">ICallableStatement</a>::SetOutputParam(const
CVariant&amp; v, const string&amp; name)</tt> method, where the first argument
is a null <tt><a href="../docxx/CVariant.html">CVariant</a></tt> of a particular
type, e.g. <tt>SetOutputParam(CVariant(eDB_SmallInt),"@arg")</tt>.
<br>&nbsp;
<p><a NAME="ref_StoredProcs"></a>
<h3>
Stored Procedures</h3>
The <tt><a href="../docxx/ICallableStatement.html">ICallableStatement</a></tt>
object is used for calling stored procedures. Fist get the object itself
by calling <tt><a href="../docxx/IConnection.html">IConnection</a>::PrepareCall()</tt>.
Then set any parameters. If the parameter name is empty, the calls to <tt>SetParam()</tt>
should be in the exact order of the actual parameters. Retrieve all results
in the main loop. Get the status of the stored procedure using the <tt><a href="../docxx/ICallableStatement.html">ICallableStatement</a>::GetReturnStatus()</tt>
method.
<blockquote>
<pre>ICallableStatement *cstmt = conn->PrepareCall("ProcName");
Uint1 byte = 1;
cstmt->SetParam(CVariant("test"), "@test_input");
cstmt->SetParam(CVariant::TinyInt(&amp;byte), "@byte");
cstmt->SetOutputParam(CVariant(eDB_Int), "@result");

cstmt->Execute();

while(cstmt->HasMoreResults()) {
&nbsp;&nbsp;&nbsp; if( cstmt->HasRows() ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IResultSet *rs = cstmt->GetResultSet();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch( rs->GetResultType() ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case eDB_RowResult:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(rs->Next()) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // retrieve row results

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case eDB_ParamResult:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(rs->Next()) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Retrieve parameter row

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
}

// Get status
int status = cstmt->GetReturnStatus();</pre>
</blockquote>
It is also possible to use <tt>IStatement</tt> interface to call stored
procedures using standard SQL language call. The difference from <tt>ICallableStatement</tt>
is that there is no <tt>SetOutputParam()</tt> call. The output parameter
is passed as regular <tt>SetParam()</tt> call with the <b>non null</b>
<tt>CVariant argument</tt>. There is no <tt>GetReturnStatus()</tt> call
in <tt>IStatement,</tt> so use the result type filter to get it.
<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sql = "exec SampleProc
@id, @f, @o output";</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stmt->SetParam(CVariant(5),
"@id");</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stmt->SetParam(CVariant::Float(&amp;f),
"@f");</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stmt->SetParam(CVariant(5),
"@o");</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stmt->Execute(sql);</tt>
<br><tt>&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(stmt->HasMoreResults())
{</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
IResultSet *rs = stmt->GetResultSet();</tt><tt></tt>
<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if( rs == 0 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
continue;</tt><tt></tt>
<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
switch( rs->GetResultType() ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
case eDB_ParamResult:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
while( rs->Next() ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
NcbiCout &lt;&lt; "Output param: "</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;&lt; rs->GetVariant(1).GetInt4()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;&lt; endl;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
case eDB_StatusResult:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
while( rs->Next() ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
NcbiCout &lt;&lt; "Return status: "</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;&lt; rs->GetVariant(1).GetInt4()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;&lt; endl;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
case eDB_RowResult:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
while( rs->Next() ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if( rs->GetVariant(1).GetInt4() == 2121 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
NcbiCout &lt;&lt; rs->GetVariant(2).GetString() &lt;&lt; "|"</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;&lt; rs->GetVariant(3).GetString() &lt;&lt; "|"</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;&lt; rs->GetVariant(4).GetString() &lt;&lt; "|"</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;&lt; rs->GetVariant(5).GetString() &lt;&lt; "|"</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;&lt; rs->GetVariant(6).GetString() &lt;&lt; "|"</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;&lt; rs->GetVariant(7).GetString() &lt;&lt; "|"</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;&lt; endl;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
NcbiCout &lt;&lt; rs->GetVariant(1).GetInt4() &lt;&lt; "|"</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;&lt; rs->GetVariant(2).GetFloat() &lt;&lt; "|"</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;&lt; rs->GetVariant("date_val").GetString() &lt;&lt; "|"</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;&lt; endl;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt><tt></tt>
<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stmt->ClearParamList();</tt>
<p><a NAME="ref_Cursors"></a>
<h3>
Cursors</h3>
The library currently supports basic cursor features such as setting parameters
and cursor update and delete operations.
<blockquote>
<pre>ICursor *cur = conn->CreateCursor("table_cur",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "select ... for update of ...");
IResultSet *rs = cur->Open();
while(rs->Next()) {
&nbsp;&nbsp;&nbsp; cur->Update(table, sql_statement_for_update);
}
cur->Close();

</pre>
</blockquote>
<a NAME="ref_Blobs"></a>
<h3>
Updating BLOBs using cursors</h3>
It is recommended to update BLOBs using cursors, because this is the only
way to work with ODBC driver and no additional connection is open.
<dl>&nbsp;
<br><font face="Courier New,Courier"><font size=-1>&nbsp; ICursor *blobCur
= conn->CreateCursor("test",</font></font>
<br><font face="Courier New,Courier"><font size=-1>&nbsp;&nbsp; "select
id, blob from BlobSample for update of blob");</font></font>
<p><font face="Courier New,Courier"><font size=-1>&nbsp; IResultSet *blobRs
= blobCur->Open();</font></font>
<br><font face="Courier New,Courier"><font size=-1>&nbsp; while(blobRs->Next())
{</font></font>
<br><font face="Courier New,Courier"><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ostream&amp; out = blobCur->GetBlobOStream(2, blob.size());</font></font>
<br><font face="Courier New,Courier"><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
out.write(buf, blob.size());</font></font>
<br><font face="Courier New,Courier"><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
out.flush();</font></font>
<br><font face="Courier New,Courier"><font size=-1>&nbsp; </font></font><font face="Courier New">}</font>
<br>&nbsp;
<p>Note that GetBlobOStream() takes the column number as the first argument
and this call is invalid untill the cursor is open.</dl>
<a NAME="ref_BulkInsert"></a>
<h3>
Using bulk insert</h3>
Bulk insert is useful when it is necessary to insert big amounts of data.
The <tt>IConnection::CreateBulkInsert()</tt> takes two parameters, the
table name and number of columns. The <tt>CVariant::Truncate(size_t len)</tt>
method truncates the internal buffer of CDB_Text and CDB_Image object from
the right. If no paramter specified, it erases the whole buffer.<tt></tt>
<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NcbiCout &lt;&lt; "Initializing
BlobSample table..." &lt;&lt; endl;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string im = ......;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IBulkInsert *bi = conn->CreateBulkInsert("BlobSample",
2);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CVariant col1 = CVariant(eDB_Int);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CVariant col2 = CVariant(eDB_Text);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bi->Bind(1, &amp;col1);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bi->Bind(2, &amp;col2);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int i = 0; i &lt;
ROWCOUNT; ++i ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
string im = "BLOB data " + NStr::IntToString(i);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
col1 = i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
col2.Truncate();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
col2.Append(im.c_str(), im.size());</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
bi->AddRow();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bi->Complete();</tt>
<br>&nbsp;</dl>
<!--#include virtual="../ssi/navlinks.shtml" --><!-- Begin footer content -->
<table BORDER=0 CELLSPACING=0 WIDTH="100%" >
<tr>
<td ALIGN=LEFT>
<address>
<a href="mailto:cpp-core@ncbi.nlm.nih.gov">Michael Kholodov</a></address>
</td>

<td><!-- <td align=center><i>$Revision$</i></td> --></td>

<td ALIGN=RIGHT><i>$Date$</i></td>
</tr>
</table>
<!--#include virtual="../ssi/footer.shtml" -->
</body>
</html>
