<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>NCBI C++ error handling and diagnostics</title>
  </head>

  <body>
	 <h1>NCBI C++ error handling and diagnostics</h1>

	 <ul>
		<li> <a href="#ref_Assert">
		  Debug-mode(internal use) checks and diagnostics</a>

		<li> <a href="#ref_Exception">
		  C++ exceptions</a>
		  <ul>
			 <li> <a href="#ref_ExceptionStd">
				  Standard C++ exception classes; NCBI exception
				  classes (<i>CErrnoException, CParseException</i>) </a>
			 <li> <a href="#ref_ExceptionCatch">
				  Using <i><b>STD_CATCH*(...)</b></i>
				  to <i>catch</i> and report exceptions </a>
			 <li> <a href="#ref_ExceptionThrow">
				  Using <i><b>THROW*_TRACE(...)</b></i>
				  to <i>throw</i> exceptions </a>
				<ul>
				  <li> <a href="#ref_ExceptionThrowTrace">
						Trace the exception at the <i>throw</i> </a>
				  <li> <a href="#ref_ExceptionThrowAbort">
						Abort the program at the <i>throw</i> </a>
				</ul>
			 <li> <a href="#ref_ExceptionSpec">
				  <i><b>THROWS*(...)</b></i> -- exception specification
				</a>
		  </ul>

		<li> <a href="#ref_Message">
			 Standard NCBI C++ message posting</a>
		  <ul>
			 <li> <a href="#ref_Manipulators">
				  <i>Manipulators</i></a>
			 <li> <a href="#ref_ERR_POST">
				  <i><b>ERR_POST(message)</i></b> macro</a>
			 <li> <a href="#ref_Tracing">
				  <i>Turn on the tracing (as per <b>_TRACE, eDiag_Trace</b></i>)</a>		
		  </ul>
	 </ul>


	 <br></br>
	 <a name="ref_Assert"><h2>Debug-mode(internal use) checks and diagnostics</h2></a>

	 <p> <i>#include &lt;corelib/ncbidbg.hpp&gt;</i>
       &nbsp;&nbsp;[also included in <i>&lt;corelib/ncbistd.hpp&gt;</i>]

	 <p>
	 There are 4 preprocessor macros
	 (<i>_TROUBLE</i>, <i>_ASSERT</i>, <i>_VERIFY</i> and <i>_TRACE</i>)
	 to help the developer to catch some (logical) errors on the
	 early stages of code development and to hardcode some
	 assertions on the code and data behaviour for internal use.
	 All these macros gets disabled in the non-debug versions lest
	 to affect the application performance and functionality;  to
	 turn them on, one must <i>#define</i> the <i>"_DEBUG"</i> preprocessor
	 variable. Developer must be careful and do not use
	 any code with side effects in <i>_ASSERT</i> or <i>_TRACE</i>
	 as this will cause a discrepancy in functionality between debug
	 and non-debug code. For example, <i>_ASSERT(a++)</i> and
	 <i>_TRACE("a++ = " &lt;&lt; a++)</i> would increment <i>"a"</i>
	 in the debug version but do nothing in the non-debug one).
	 <ul>
		<li> <b><i>_TROUBLE</i></b> --
		Has absolutely no effect if <i>"_DEBUG"</i> is not defined;
		otherwise, unconditionally halt the application.

		<li> <b><i>_ASSERT(expr)</i></b> --
		Has absolutely no effect if <i>"_DEBUG"</i> is not defined;
		otherwise, evaluate expression <b><i>expr</i></b> and halt the
		application if <b><i>expr</i></b> resulted in zero(or <i>"false"</i>).

		<li> <b><i>_VERIFY(expr)</i></b> --
		Evaluate expression <b><i>expr</i></b>; if <i>"_DEBUG"</i> is defined
		and <b><i>expr</i></b> resulted in zero(or <i>"false"</i>) then halt the
		application.
		
		<li> <b><i>_TRACE(message)</i></b> --
		Has absolutely no effect if <i>"_DEBUG"</i> is not defined;
		otherwise, it outputs the <b><i>message</i></b> using
		<a href="#ref_Message">Standard NCBI C++ message posting</a>.
		NOTE: as a matter of fact, the tracing is turned off by default,
      even if <i>"_DEBUG"</i> is defined, and you still have to do
		<a href="#ref_Tracing">a special configuration</a> to
      really turn it on.
	 </ul> </ul>

	 All these macros automatically report the file name and line
	 number to the diagnostics. For example, this code located in file
	 <i>"somefile.cpp"</i> at line 333:
<pre>
int x = 100;
_TRACE( "x + 5 = "  <<  (x + 5) ); </pre>
	 will output:
<pre>
"somefile.cpp", line 333: Trace:  x + 5 = 105
</pre>


	 <br></br>
	 <a name="ref_Exception"><h2>C++ exceptions</h2></a>

	 <p> <i>#include &lt;corelib/ncbiexpt.hpp&gt;</i>
       &nbsp;&nbsp;[also included in <i>&lt;corelib/ncbistd.hpp&gt;</i>]

	 <p>
	 <a name="ref_ExceptionStd">
		  <h4>Standard C++ exception classes, and two useful NCBI exception
			 classes (
		<a href="../docxx/CErrnoException.html"> CErrnoException </a>
		,
		<a href="../docxx/CParseException.html"> CParseException </a>
		)
	 </h4>
	 </a>

	 One must use
	 <a href="http://www.cygnus.com/misc/wp/dec96pub/lib-diagnostics.html#lib.std.exceptions">standard C++ exceptions</a>
	 as much as possible. There is also a couple of auxiliary exception
	 classes derived from <i>std::runtime_error</i>:
	 <ul>
		<li> <a href="../docxx/CErrnoException.html"> CErrnoException </a>
		  -- to report failure in a standard C library
		  function; it automatically appends to the user message a
		  system-spefific description reported by <b>errno</b>
		<li> <a href="../docxx/CParseException.html"> CParseException </a>
		  -- to report an erroneous position (passed in
		  the additional constructor parameter) along with the user message
	 </ul>
	 
	 <p>
	 Then, it is <b>strictly recommended</b> that when the basic functionality
	 provided by standard C++ exceptions is unsufficient for some reason,
	 one must derive the new ad hoc exception classes from one of the
	 standard exception classes.	-- This is to provide a more uniform way
	 of exceprion handling, for we could smartly catch/handle most of
	 thrown exceptions using <b><i>STD_CATCH(message)</i></b> and
	 <b><i>STD_CATCH_ALL(message)</i></b> preprocessor macros.

	 <p>
	 <a name="ref_ExceptionCatch">
		  <h4>
			 Using <i><b>STD_CATCH*(...)</b></i> to <i>catch</i> and report exceptions
		  </h4>
		</a>

	 <p>
	 You can use <b><i>STD_CATCH(message)</i></b> macro to catch an exception
    derived from the standard exception class (<i>std::exception</i>) --
    when all you want to do about this exception is just to print out
    the "message" along with the info passed with the <i>std::exception::what()</i>.
	 <b><i>STD_CATCH_ALL(message)</i></b> first tries to catch a
	 <i>std::exception</i>-derived exception (with <b><i>STD_CATCH(message)</i></b>); and
	 if the thrown exception is not "standard" then it posts the "message".

	 <p>
	 The "message" argument can be of any form acceptable by the
	 <a href="#ref_Message">diagnostic class <i>CNcbiDiag</i></a>.
	 

	 <p>
	 This way, the easy way of dealing with exception in the NCBI C++
	 code will be like:
	 <pre>
class foreign_exception { ..... };
class exception_derived_user : public exception { ..... };
...........
char arg1 = "qqq";
int  arg2 = 888;
try {
   SomeFunc(arg1, arg2);
} catch (foreign_exception& fe) {
   // do something special with the particular "non-standard"
   // (not derived from "std::exception") exception "foreign_exception"
} catch (exception_derived_user& eu)  {
   // do something special with the particular "standard"
   // (derived from "std::exception") exception "exception_derived_user"
}
// handle all the rest "standard" exceptions in a uniform way
STD_CATCH ( "in SomeFunc(" << arg1 << "," << arg2 << ")" ); </pre>

	 <p>
	 Here, if <i>SomeFunc</i> do <i>throw std::runtime_error("Invalid Arg2");</i>
	 then the application will print out (to its diagnostic stream)
	 something like:
	 <pre>
Error: [in SomeFunc(qqq,888)] Exception: Invalid Arg2
	 </pre>

	 <p>
	 <a name="ref_ExceptionThrow">
		  <h4>
			 Using <i><b>THROW*_TRACE(...)</b></i> to <i>throw</i> exceptions
		  </h4>
		</a>

		If you use one of <i><b>THROW*_TRACE(...)</b></i> macros to <i>throw</i>
		an exception, and the source was compiled in a debug mode
		(i.e. with the preprocessor <i>"_DEBUG"</i> defined), then
		you can turn on the following features that proved to be very useful
		for debugging:
	 <ul>
		<li> <a name="ref_ExceptionThrowTrace"> </a>
		  If the <a href="#ref_Tracing">tracing is on</a>, then the location
		  of the <i>throw</i> in the source code and the thrown exception will
		  be printed out to the current diagnostic stream, e.g.:
<pre>
THROW_TRACE(CParseException, ("Failed parsing(at pos. 123)", 123));

"coretest.cpp", line 708: Trace: CParseException: {123} Failed parsing(at pos. 123)

---------------------------------

strtod("1e-999999", 0);
THROW1_TRACE(CErrnoException, "Failed strtod('1e-999999', 0)");

"coretest.cpp", line 718: Trace: CErrnoException: Failed strtod('1e-999999', 0): Result too large
</pre>


		<li> <a name="ref_ExceptionThrowAbort"> </a>
		  Sometimes, it can be convenient to just abort the program execution
		  at the place where you throw an exception, e.g. in order to examine
		  the program stack and overall state that led to this <i>throw</i>.

		  By default, this feature is not activated. You can turn it on
		  for your whole application by either setting the environment
		  variable <b><i>$ABORT_ON_THROW</i></b> to an arbitrary non-empty
		  string, or by setting the application's registry entry
		  <b><i>ABORT_ON_THROW</i></b> (in the <b><i>[DEBUG]</i></b> section)
		  to an arbitrary non-empty value.

		  You also can turn it on and off in your program code, calling
		  function <a href="../docxx/General.html#SetThrowTraceAbort">SetThrowTraceAbort()</a>.
	 </ul>

	 NOTE: if the source was not compiled in the debug mode, then the 
	 <i><b>THROW*_TRACE(...)</b></i> would just <i>throw</i> the specified
	 exception, without doing any of the "fancy stuff" we just described.

	 <p>
	 <a name="ref_ExceptionSpec">
		  <h4>
			 <i><b>THROWS*(...)</b></i> -- exception specification
		  </h4>
		</a>

	 <p>
	 One is encouraged to write
	 <a href="http://www.cygnus.com/misc/wp/dec96pub/except.html#except.spec">
		exception specifications</a>
	 for NCBI C++ functions. However, due to some discrepancy in how different
	 compilers handle <i>unexpected</i> exception events we decided to use
	 <i>THROWS_NONE</i> and <i>THROWS()</i> preprocessor macros for the case
	 of "poor" compilers.
	 
	 <p>
	 Thus, you must use:
	 <pre>
void f1(int i) THROWS_NONE;
int  f2(void) THROWS((e0));
int  f3(long) THROWS((e1,e2)); </pre>
	 in the place of:
	 <pre>
void f1(int i) throw();
int  f2(void)  throw(e0);
int  f3(long)  throw(e1,e2); </pre>
	 respectively. -- Please note the double parenthesis for <i>THROWS()</i>.



	 <br></br>
	 <br></br>
	 <a name="ref_Message"><h2>Standard NCBI C++ message posting</h2></a>

	 <p> <i>#include &lt;corelib/ncbidiag.hpp&gt;</i>
       &nbsp;&nbsp;[also included in <i>&lt;corelib/ncbistd.hpp&gt;</i>]

	 <p>
	 Standard diagnostics is provided with the <b><i>CNcbiDiag</i></b> class.
	 Given application can have as many objects of this class as
	 needed. The trick is that each instance of the <b><i>CNcbiDiag</i></b> class
	 actually stores (and allows to append to) only one message at a
	 time. When the message controlled by an instance of <b><i>CNcbiDiag</i></b>
	 is complete, <b><i>CNcbiDiag</i></b> calls a global callback function
	 (of type <b><i>FDiagHandler</i></b>) and pass the message (along with its
	 severity level) as the function arguments.

	 <p>
	 Usually, this global callback would merely dump the message to
	 a diagnostic stream, and there is an auxiliary function
	 <b><i>SetDiagStream()</i></b> to specify output stream for the diagnostics
	 (one can call <b><i>SetDiagStream(&amp;NcbiCerr)</i></b> to dump the diagnostics
    to the standard error output stream):
	 <pre>
extern void SetDiagStream(CNcbiOstream* os, bool quick_flush=true); </pre>

	 Using <b><i>SetDiagHandler()</i></b>, one can install his own callback function
	 of type <b><i>FDiagHandler</i></b> to process messages posted via
	 <b><i>CNcbiDiag</i></b>.
	 The implementation of the <b><i>SetDiagStream()</i></b> in <i>"ncbidiag.cpp"</i>
	 is a good example of how to do this.
	 <pre>
typedef void (*FDiagHandler)(const SDiagMessage& mess);

typedef void (*FDiagCleanup)(void* data);

extern void SetDiagHandler(FDiagHandler func,
                           void*        data,
                           FDiagCleanup cleanup); </pre>

	 where:
	 <pre>
struct SDiagMessage {
    SDiagMessage(EDiagSev severity, const char* buf, size_t len, void* data,
                 const char* file = 0, size_t line = 0,
                 unsigned int flags = eDPF_Default, const char* prefix = 0);
    EDiagSev     m_Severity;
    const char*  m_Buffer;  // not guaranteed to be '\0'-terminated!
    size_t       m_BufferLen;
    void*        m_Data;
    const char*  m_File;
    size_t       m_Line;
    unsigned int m_Flags;   // bitwise OR of "EDiagPostFlag"
    const char*  m_Prefix;

    // allocate("new") and compose a message string in the "standard" format:
    //    "<file>", line <line>: <severity>: [<prefix>] <message>
    // NOTE:  it is user's responsibility to "delete" the returned string
    char* Compose(void) const;
};
	 </pre>

	 <p></p>
	 <a name="ref_Manipulators"><h4>Formatting and manipulators</h4></a>

	 <p>
	 To compose a diagnostic message with <b><i>CNcbiDiag</i></b> you can
	 use the formatting operator "<b><<</b>". It works practically the same
	 way as operator "<b><<</b>" for standard C++ output streams.
	 <b><i>CNcbiDiag</i></b> class also has some <b><i>CNcbiDiag</i></b>-specific
	 <i>manipulators</i> to control the message severity level:
	 <ul>
		<li> <i>Info</i> -- set severity level to <i>eDiag_Info</i>
		<li> <i>Warning</i> -- set severity level to <i>eDiag_Warning</i>
		<li> <i>Error</i> -- set severity level to <i>eDiag_Error</i> [default]
		<li> <i>Fatal</i> -- set severity level to <i>eDiag_Fatal</i>
		<li> <i>Trace</i> -- set severity level to <i>eDiag_Trace</i>
	 </ul>
	 NOTE: whenever the severity level is changed, <b><i>CNcbiDiag</i></b>
	 also automatically executes the following two <i>manipulators</i>:
	 <ul>
		<li> <i>Endm</i> -- means that the message is complete and to be
		flushed(via the global callback as described above)
		<li> <i>Reset</i> -- directs to discard the content of presently
		composed message
	 </ul>
	 The <i>Endm</i> manipulator also gets executed on the
	 <b><i>CNcbiDiag</i></b> object destruction.

	 <p>
	 For example, this code:
	 <pre>
int iii = 1234;
CNcbiDiag diag1;

diag1 << "Message1_Start " << iii;  // message 1 is started but not ready yet
{ CNcbiDiag diag2;  diag2 << Info << "Message2"; } // message 2 flushed in destructor
diag1 << "Message1_End" << Endm;  // message 1 finished and flushed by "Endm"
diag1 << "Message1_1";  // will be flushed by the following "Warning"
diag1 << Warning << "Discard this warning" << ++iii << Reset; // message discarded
diag1 << "This is a warning " << iii;
diag1 << Endm; </pre>
	 will write to the diagnostic stream(if the latter was set with
	 <b><i>SetDiagStream()</i></b>):
	 <pre>
Error: Message1_Start 1234
Info: Message2
Error: Message1_End
Error: Message1_1
Warning: This is a warning 1235
	 </pre>


	 <a name="ref_ERR_POST"><h4>ERR_POST macro</h4></a>

	 There is an <b><i>ERR_POST(message)</i></b> macro that can be used to
	 shorten the error posting code. This macro implicitely creates a temporary
	 <b><i>CNcbiDiag</i></b> object and put the passed "message" into it.
	 The default severity for the posted message is <i>eDiag_Trace</i> but it
	 can be easily overwritten using the
	 <a href="#ref_Manipulators"><i>manipulators</i></a>
	 (see the 2nd example below).  For example:

	 <pre>
long lll = 345;
ERR_POST("My ERR_POST message, print long: " << lll); </pre>
	 would write to the diagnostic stream something like:
	 <pre>
"somefile.cpp", line 111: Error:  My ERR_POST message, print long: 345 </pre>

	 and:

	 <pre>
double ddd = 123.345;
ERR_POST(Warning << "...print double: " << ddd); </pre>
	 would write to the diagnostic stream something like:
	 <pre>
"somefile.cpp", line 222: Warning:  ...print double: 123.345 </pre>

	 <a name="ref_Tracing"><h4>Turn on the tracing</h4></a>

	 The tracing (messages with severity level <i>eDiag_Trace</i>) is considered
    to be a special, debug-oriented feature, and therefore it is not
    affected by <i>SetDiagPostLevel()</i> and <i>SetDiagDieLevel()</i>.
	 To turn the tracing on or off in your code you can use function
    <a href="../docxx/General.html#SetDiagTrace">SetDiagTrace()</a>.

	 <p>
	 By default, the tracing is off -- unless you assign environment
    variable <b><i>$DIAG_TRACE</i></b> to an arbitrary non-empty string
    (or, alternatively, you can set <b><i>DIAG_TRACE</i></b> entry in the
    <b><i>[DEBUG]</i></b> section of your registry to any non-empty value).


	 <hr>
	 <table border=0 width="100%" cellspacing=0>
		<tr>
		  <td><address><a href="mailto:vakatov@ncbi.nlm.nih.gov">Denis Vakatov</a></address></td>
<!-- <td align=center><i>$Revision$</i></td> -->
    <td align=right>($Date$)</td></tr>
	 </table>
  </body>
</html>
