<!--#set var="TITLE" value="NCBI C++ Object Manager library" -->
<!--#set var="DOCROOT" value="../.." -->
<!--#include virtual="../../ssi/header.shtml" -->
<i><h1><font color="#FF0000"><span style="background-color: #FFFFFF">Warning: This HTML page is deprecated</span></font></h1>

All new changes are being made to the Toolkit Book
at the following locations:
<ul>
<li>
<i>Official Release:</i> <a href="http://www.ncbi.nlm.nih.gov/books/bv.fcgi?call=bv.View..ShowTOC&rid=toolkit.TOC&depth=2">
    C++ Toolkit Book</a>.
</li>
<li>
<i>Development Version:</i> <a href="http://xpubmed0.ncbi.nlm.nih.gov:5701/books/bv.fcgi?call=bv.View..ShowTOC&rid=toolkit.TOC&depth=2">

    C++ Toolkit Book (no search engine, accessible from inside NCBI only)</a>. </li> </ul> The Development Version is the most recent documentation before it becomes an Official Release. While the Development Version is the lastest version, it is accessible only from inside NCBI, and the search engine functionality is currently missing. Also, the location of the Development Version may change without warning! So it is suggested that you use the Official Release, and use the Development Version only when necessary.</p> </i>

<hr>
<!--EOW-->


<div align="Center">
<H1>Object Manager</H1>
</div>
<div align="Left">
<H2>How to use it</H2>
</div>

<HR>
<!-- =================== list of Q =============================== -->
<OL>

<LI>
<A HREF="#start">
Start working with the <span class="ncbi_term">Object Manager</span>.
</A>
</LI>

<LI>
<A HREF="#add_tse">
Add externally created top-level Seq_entry to the <span class="ncbi_term">Scope</span>.
</A>
</LI>


<LI>
<A HREF="#add_data_loader">
Add a data loader to the <span class="ncbi_term">Scope</span>.
</A>
</LI>


<LI>
<A HREF="#add_annot">
Modify Seq_entry data.
</A>
</LI>


<LI>
<A HREF="#find_tse">
Start working with a Seq_entry (bio.sequence), load entry if necessary.
</A>
</LI>


<LI>
<A HREF="#seq_vector">
Access bio sequence data.
</A>
</LI>


<LI>
<A HREF="#descriptions">
Enumerate sequence descriptions.
</A>
</LI>


<LI>
<A HREF="#annotations">
Enumerate sequence annotations.
</A>
</LI>

</OL>



<HR>
<!-- =================== start =============================== -->
<A NAME="start"></a>
<H4>Start working with the <span class="ncbi_term">Object Manager</span></H4>
<P>
Include the necessary headers:
<pre class="ncbi_code">
#include &lt;objects/objmgr/object_manager.hpp&gt;
#include &lt;objects/objmgr/scope.hpp&gt;
#include &lt;objects/objmgr/bioseq_handle.hpp&gt;
#include &lt;objects/objmgr/seq_vector.hpp&gt;
#include &lt;objects/objmgr/desc_ci.hpp&gt;
#include &lt;objects/objmgr/feat_ci.hpp&gt;
#include &lt;objects/objmgr/align_ci.hpp&gt;
</PRE>
Create <span class="ncbi_term">Object Manager</span> as a referenced object on the heap:
<pre class="ncbi_code">
    CRef&lt;CObjectManager&gt; obj_mgr = new CObjectManager;
</PRE>
Create a <span class="ncbi_term">Scope</span> of reference resolution. There is a lot
of freedom in how the <span class="ncbi_term">Scope</span>
can be created: either as an object on the stack, or on the heap, either as
a referenced or non-referenced object:
<pre class="ncbi_code">
    CRef&lt;CScope&gt; scope1 = new CScope(*obj_mgr);
    CScope scope2(*obj_mgr);
    CScope* scope3 = new CScope(*obj_mgr);
</PRE>
</P>


<HR>
<!-- =================== add_tse =============================== -->
<A NAME="add_tse"></a>
<H4>
Add externally created top-level Seq_entry to the <span class="ncbi_term">Scope</span>.
</H4>
<P>
Once there is a Seq_entry created somehow, it can be added to the
<span class="ncbi_term">Scope</span> using the following:
<pre class="ncbi_code">
    CSeq_entry* entry = ...;
    scope.AddTopLevelSeqEntry(*entry);
</PRE>
</P>



<HR>
<!-- =================== add_data_loader =============================== -->
<A NAME="add_data_loader"></a>
<H4>Add a data loader to the <span class="ncbi_term">Scope</span>.</H4>
<P>
<span class="ncbi_term">Data loader</span> is designed to be a replaceable object.
There can be a variety of data loaders, each of which would load bio sequence data
from different databases, flat files, etc. Data loader must be created by the
client and registered with the <span class="ncbi_term">Object Manager</span>.
One distinguishes them later by their names.
At present there is only one data loader implemented - the one that
loads data from the GenBank. Here is how to create and register it:
<pre class="ncbi_code">
    #include &lt;objects/objmgr/gbloader.hpp&gt;
    #include &lt;objects/objmgr/reader_id1.hpp&gt;
    ...
    obj_mgr->RegisterDataLoader(*(new CGBDataLoader("GENBANK")),
                                CObjectManager::eDefault);
</pre>
There are default and non-default data loaders.
A <span class="ncbi_term">Scope</span> can request a data loader from the
<span class="ncbi_term">Object Manager</span> either one at a time - by name:
<pre class="ncbi_code">
    scope.AddDataLoader("GENBANK");
</PRE>
or all default data loaders at once:
<pre class="ncbi_code">
    scope.AddDefaults();
</PRE>
</P>



<HR>
<!-- =================== add_annot =============================== -->
<A NAME="add_annot"></a>
<H4>Modify Seq_entry data.</H4>
<P>
One can modify the Seq_entry data using the following interface of the <span class="ncbi_term">Scope</span> object:
<pre class="ncbi_code">
    // Add annotations to a seq-entry (seq or set)
    bool AttachAnnot(const CSeq_entry& entry, CSeq_annot& annot);
    // Add new sub-entry to the existing tree if it is in this scope
    bool AttachEntry(const CSeq_entry& parent, CSeq_entry& entry);
    // Add sequence map for a bioseq if it is in this scope
    bool AttachMap(const CSeq_entry& entry, CSeqMap& seqmap);
    // Add seq-data to a bioseq if it is in this scope
    bool AttachSeqData(const CSeq_entry& entry, CSeq_data& seq,
                       TSeqPosition start, TSeqLength length);
</PRE>
Once the entry is modified in one <span class="ncbi_term">Scope</span>, the changes become visible in
other <<span class="ncbi_term">Scopes</span> as well, provided all the <span class="ncbi_term">Scopes</span> belong to the same
<span class="ncbi_term">Object Manager</span> of course.
Please note, all the changes is being made <em>locally</em>.
There is no way this modifications can be uploaded to the source database.
</P>



<HR>
<!-- =================== find_tse =============================== -->
<A NAME="find_tse"></a>
<H4>Start working with a Seq_entry (bio.sequence), load entry if necessary.</H4>
<P>
In order to be able to access bio.sequence data, one has to obtain a
<span class="ncbi_term">Bioseq handle</span> from the Scope, based on a known Seq_id:
<pre class="ncbi_code">
    CSeq_id seqid;
    seqid.SetGi(3);
    CBioseq_Handle handle = scope.GetBioseqHandle(seqid);
</PRE>
It is possible then to get direct access to the sequence data or Seq_entry
by calling either one of these functions:
<pre class="ncbi_code">
    const CBioseq&   bioseq = handle.GetBioseq();
    const CSeq_entry& entry = handle.GetTopLevelSeqEntry();
</PRE>
</P>



<HR>
<!-- =================== seq_vector =============================== -->
<A NAME="seq_vector"></a>
<H4>Access bio sequence data.</H4>
<P>
The access to the sequence data is provided through the <span class="ncbi_term">Sequence vector</span> object,
which is created by <span class="ncbi_term">Bioseq handle</span>:
<pre class="ncbi_code">
    CSeqVector seq_vec = handle.GetSeqVector();
</PRE>
There are basically three functions available:
<pre class="ncbi_code">
    // Target sequence coding.
    void SetCoding(TCoding coding);
    // length of the sequence
    size_t size(void);
    // 0-based array of residues
    TResidue operator[] (int pos);
</PRE>
For example:
<pre class="ncbi_code">
    CSeqVector seq_vec = handle.GetSeqVector();
    string sout;
    for (size_t i = 0; i < seq_vec.size(); i++) {
        sout += seq_vec[i];
    }
</PRE>
<span class="ncbi_term">Sequence vector</span> is much more than the plain data storage.
It rather "knows where to find" the data. As a result of a query, it may initiate
reference resolution process, send requests to the source database for more data etc.
</P>
<P>
There is another useful object, which describes sequence data - <span class="ncbi_term">Sequence map</span>.
It is a collection of <span class="ncbi_term">segments</span>, which describe sequence parts in general -
location and type only, without providing any real data.
To obtain <span class="ncbi_term">Sequence map</span> from a <span class="ncbi_term">Bioseq handle</span>:
<pre class="ncbi_code">
    const CSeqMap& seqmap = handle.GetSeqMap();
</PRE>
It is possible then to enumerate all the segments in the map asking their type, length or position:
<pre class="ncbi_code">
    const CSeqMap& seqmap = handle.GetSeqMap();
    int len = 0;
    for (size_t i = 0; i < seq_map.size(); i++) {
        switch (seq_map[i].GetType()) {
            case CSeqMap::eSeqData:
                len += seq_map[i].GetLength();
                break;
            case CSeqMap::eSeqRef:
                len += seq_map[i].GetLength();
                break;
            case CSeqMap::eSeqGap:
                len += seq_map[i].GetLength();
                break;
            default:
                break;
        }
    }
</PRE>
</P>



<HR>
<!-- =================== descriptions =============================== -->
<A NAME="descriptions"></a>
<H4>Enumerate sequence descriptions.</H4>
<P>
Description iterator uses <span class="ncbi_term">Bioseq handle</span> to access the sequence data.
It makes it possible to enumerate all CSeq_descr data objects the sequence refers to:
<pre class="ncbi_code">
    CDesc_CI(const CBioseq_Handle& handle);
    for (CDesc_CI desc_it(handle); desc_it; ++desc_it) {
        const CSeq_descr& descr = *desc_it;
        ... your code here ...
    }
</PRE>
</P>




<HR>
<!-- =================== annotations =============================== -->
<A NAME="annotations"></a>
<H4>Enumerate sequence annotations.</H4>
<P>
It is possible to search either all top-level seq. entries in the Scope, or only one of them.
Accordingly, there are two types of constructors of annotation iterator, one may wish to use:
<BR>
<BR>
Feature iterator:
<pre class="ncbi_code">
    // Search all TSEs in the Scope
    CFeat_CI(CScope& scope, const CSeq_loc& loc,
             SAnnotSelector::TFeatChoice feat_choice);
    // Search only in TSE, which contains the bioseq
    CFeat_CI(CBioseq_Handle& bioseq, int start, int stop,
             SAnnotSelector::TFeatChoice feat_choice);
</PRE>
Alignment data iterator:
<pre class="ncbi_code">
    CAlign_CI(CScope& scope, const CSeq_loc& loc);
    CAlign_CI(CBioseq_Handle& handle, int start, int stop);
</PRE>
Graph data iterator:
<pre class="ncbi_code">
    CGraph_CI(CScope& scope, const CSeq_loc& loc);
    CGraph_CI(CBioseq_Handle& handle, int start, int stop);
</PRE>
<span class="ncbi_var">Start</span> and <span class="ncbi_var">stop</span> parameters are used here instead of Seq_loc
to describe a continuous interval on the bio sequence.
<BR>
<BR>
Example of usage:
<pre class="ncbi_code">
    for (CFeat_CI feat_it(scope, loc, CSeqFeatData::e_not_set);
         feat_it;  ++feat_it) {
         const CSeq_feat& feat = *feat_it;
         ... or ...
         const CSeq_annot& annot = feat_it.GetSeq_annot();
         ... your code here ...
    }
</PRE>
</P>

<!--#include virtual="../../ssi/navlinks.shtml" -->
<!--#include virtual="../../ssi/footer.shtml" -->
