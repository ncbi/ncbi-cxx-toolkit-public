<!--#set var="TITLE" value="NCBI C++ CGI library" -->
<!--#set var="DOCROOT" value="../.." -->
<!--#include virtual="../../ssi/header.shtml" -->



<div align="Center">
<h1>Object Manager.</h1>
</div>


<h2>Classes - attributes and operations.</h2>

<ul>
  <li><a href="#Object_manager">Object manager</a></li>
  <li><a href="#Scope">Scope</a></li>
  <li><a href="#Bioseq_handle">Bioseq handle</a></li>
  <li><a href="#Seq_vector">Seq vector</a></li>
  <li><a href="#Seq_map">Seq map</a></li>
  <li><a href="#Data_loader">Data loader</a></li>
  <li><a href="#Description_iterator">Description iterator</a></li>
  <li><a href="#Annotation_iterator">Annotation iterator</a></li>
  <li><a href="#Feature_iterator">Feature iterator</a></li>
  <li><a href="#Graph_data_iterator">Graph data iterator</a></li>
  <li><a href="#Alignment_iterator">Alignment iterator</a></li>
</ul>
<hr>




<h3><a name="Object_manager"></a>Object manager.</h3>
<p>
Before being able to use any Scopes, a client must 
create and initialize Object Manager
(<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CObjectManager">CObjectManager</a>).
Initialization functions include registration of Data loaders,
some  of which may be declared as default ones. All   default Data  
loaders are added  to a Scope when the latter asks for them.   All Data
loaders are  named, so Scopes may refer to them by name. Another   kind
of data object is
<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSeq_entry">CSeq_entry</a>
&#8211; it does not require any data loader, but also 
may   be  registered  with the Object Manager. Seq.entry may not be 
a default  data object.                       
</p>

<h4>Object methods:</h4>
<pre>
    // register existing data loader.
    // data loader must be created in the heap (ie using operator new)
    void RegisterDataLoader(CDataLoader&amp; loader, EIsDefault is_default=eNonDefault);

    // Revoke previously registered data loader.
    // Return FALSE if the loader is still in use (by some scope).
    // Throw an exception if the loader is not registered with this ObjMgr.
    bool RevokeDataLoader(CDataLoader&amp; Loader);
    bool RevokeDataLoader(string LoaderName);

    // register top-level seq_entry
    bool RegisterTopLevelSeqEntry(CSeq_entry&amp; TopEntry);
</pre>





<h3><a name="Scope"></a>Scope.</h3>
<p>
Scope
(<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CScope">CScope</a>)
is designed to be a lightweight object, which could be  easily  
created     and destroyed. Scope may even be created on the stack  &#8211; as
an  automatic    object.  Scope is populated with data by adding data loaders 
or  already   created  Seq_entries  to it. Data loader can only be added by
name,  that   is it must  be registered  with the Object Manager beforehand. 
It is  impossible  to add  a data loader  directly to the scope or remove 
it. Once  an externally  created  Seq_entry is added to a Scope, it should 
not be modified  any more.  Safe solution  would  be creating a copy of the
Seq_entry and storing  it  instead of the original  - this was refused because
bio sequences may contain  huge amount of data and copying it without a
good  reason is impractical in most cases.
</p>


<h4>Object methods:</h4>
<pre>
    // Constructor:
    CScope( CObjectManager&amp; ObjMgr);

    // Add default data loaders from object manager
    bool AddDefaults(void);
    // Add data loader by name (the loader must be known to Object Manager)
    bool AddDataLoader(string LoaderName);
    // Add seq_entry    
    bool AddTopLevelSeqEntry(CSeq_entry&amp; TopEntry);

    // Add annotations to a seq-entry (seq or set)
    bool AttachAnnot(const CSeq_entry&amp; entry, CSeq_annot&amp; annot);
    // Add new sub-entry to the existing tree if it is in this scope
    bool AttachEntry(const CSeq_entry&amp; parent, CSeq_entry&amp; entry);
    // Add sequence map for a bioseq if it is in this scope
    bool AttachMap(const CSeq_entry&amp; bioseq, CSeqMap&amp; seqmap);
    // Add seq-data to a bioseq if it is in this scope
    bool AttachSeqData(const CSeq_entry&amp; bioseq, CSeq_data&amp; seq,
                      TSeqPosition start, TSeqLength length);

    // Construct BioseqHandle
    CBioseqHandle  GetBioseqHandle(const CSeq_id&amp; id);
</pre>




<h3><a name="Bioseq_handle"></a>Bioseq handle.</h3>
<p>
When a client wants to access a bio sequence data, it asks
the Scope for a Bioseq handle
(<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CBioseq_Handle">CBioseq_Handle</a>).
Bioseq handle object is responsible for resolving    any internal
references  in the sequence. It has comparison operators,  which   make 
sense   only for objects created by the same Scope. It is impossible    
to compare Bioseq   handles created by different Scopes.
</p>


<h4>Object methods:</h4>
<pre>
    // public constructors
    CBioseq_Handle(const CBioseq_Handle&amp; h);
    CBioseq_Handle&amp; operator= (const CBioseq_Handle&amp; h);

    // Comparison
    // Handles must belong to the same scope
    bool operator== (const CBioseq_Handle&amp; h) const;
    bool operator!= (const CBioseq_Handle&amp; h) const;

    // Validity check
    operator bool(void) const;
    bool operator!(void) const;

    // Get Seq_id
    const CSeq_id* GetSeqId(void)  const;
    // Get the complete bioseq (as loaded by now)
    const CBioseq&amp; GetBioseq(void) const;
    // Get top level seq-entry for a bioseq
    const CSeq_entry&amp; GetTopLevelSeqEntry(void) const;
    // Get bioseq core structure
    TBioseqCore GetBioseqCore(void) const;

    // Get sequence map. References to the whole bioseqs may have
    // length of 0 unless GetSeqVector() has been called for the handle.
    const CSeqMap&amp; GetSeqMap(void) const;
    // Get sequence map with resolved multi-level references.
    // The resulting map should contain regions of literals, gaps
    // and references to literals only (but no gaps or refs) to other
    // sequences.
    const CSeqMap&amp GetResolvedSeqMap(void) const;

    // construct SeqVector
    CSeqVector GetSeqVector(bool plus_strand = true);
    // Get sequence's title (used in various flat-file formats.)
    string GetTitle(TGetTitleFlags flags = 0);
</pre>





<h3><a name="Seq_vector"></a>Seq vector.</h3>
<p>
SeqVector
(<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSeqVector">CSeqVector</a>)
is a sequence data container. The object may only be constructed
by  a Bioseq handle. Seq.vector not necessarily contains all the sequence
data. It rather requests it from all available sources when needed.
In  order    to do so it may access Data loader or other Data sources within
the same   Scope. It may not access other Scopes.
</p>


<h4>Object methods:</h4>
<pre>
    // public constructors
    CSeqVector(const CSeqVector&amp; vec);
    CSeqVector&amp; operator= (const CSeqVector&amp; vec);
    // size
    size_t size(void);
    // 0-based array of residues
    TResidue operator[] (int pos);
    // Target sequence coding.
    TCoding GetCoding(void);
	// Set target coding. In case this function was never called
	// SeqVector does not perform any conversion, returning the data
	// in the original format (in which it receives it from the database)
    void SetCoding(TCoding coding);
    // Set coding to either Iupacaa or Iupacna depending on molecule type
    void SetIupacCoding(void);
</pre>





<h3><a name="Seq_map"></a>Seq map.</h3>
<p>
Seqmap
(<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSeqMap">CSeqMap</a>)
object gives a general description of the bio sequence data: location 
and type only without data itself. The object may only be constructed 
by   a Bioseq handle.
</p>


<h4>Object methods:</h4>
<pre>
    // public constructors
    CSeqMap(const CSeqMap&amp; another);
    CSeqMap&amp; operator=(const CSeqMap&amp; another);
    // size of the map
    const size_t size(void) const;
    // Get an interval
    const CSegmentInfo&amp; operator[](int seg_idx) const;
</pre>

<h4>CSeqMap::CSegmentInfo object methods:</h4>
<pre>
     // public constructors
    CSegmentInfo(const CSegmentInfo&amp; seg);
    CSegmentInfo&amp; operator= (const CSegmentInfo&amp; seg);
    bool operator== (const CSegmentInfo&amp; seg) const;
    bool operator&lt;  (const CSegmentInfo&amp; seg) const;
    // Sequence interval description 
    ESegmentType GetType(void) const;
    TSeqPosition GetPosition(void) const;
    TSeqLength   GetLength(void) const;
</pre>





<h3><a name="Data_loader"></a>Data loader.</h3>
<p>
Data loader is never used by a client application directly.
</p>




<h3><a name="Description_iterator"></a>Description iterator.</h3>
<p>
Description iterator
(<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CDesc_CI">CDesc_CI</a>)
uses Bioseq handle to access the sequence data. It enables to enumerate
all
<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSeq_descr">CSeq_descr</a>
data objects the sequence refers to.
</p>


<h4>Object methods:</h4>
<pre>
    // Constructors 
    CDesc_CI(const CBioseq_Handle&amp; handle);
    CDesc_CI(const CDesc_CI&amp; iter);
    CDesc_CI&amp; operator= (const CDesc_CI&amp; iter);
    // Search for data 
    CDesc_CI&amp; operator++ (void);
    CDesc_CI&amp; operator++ (int);
    // Validity check 
    operator bool (void) const;
    // Data access operators 
    const CSeq_descr&amp; operator*  (void) const;
    const CSeq_descr* operator-&gt; (void) const;
</pre>
<p>
There is also another type of description iterator - 
<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSeqdesc_CI">CSeqdesc_CI</a>.
It is provided for convenience. Since
<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSeq_descr">CSeq_descr</a>
object is actually a container - list of
<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSeqdesc">CSeqdesc</a>
objects, it would be more convenient to enumerate the latters directly.
</p>

<h4>Object methods:</h4>
<pre>
    // Constructors 
    CSeqdesc_CI(const CDesc_CI&amp; desc_it,
                CSeqdesc::E_Choice choice = CSeqdesc::e_not_set);
    CSeqdesc_CI(const CSeqdesc_CI&amp; iter);
    CSeqdesc_CI&amp; operator= (const CSeqdesc_CI&amp; iter);
    // Search for data 
    CSeqdesc_CI&amp; operator++ (void);
    CSeqdesc_CI  operator++ (int);
    // Validity check 
    operator bool (void) const;
    // Data access operators 
    const CSeqdesc&amp; operator*  (void) const;
    const CSeqdesc* operator-> (void) const;
</pre>





<h3><a name="Annotation_iterator"></a>Annotation iterator.</h3>
<p>
Any annotation iterator
(<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CAnnotTypes_CI">CAnnotTypes_CI</a>)
starts with the following data: sequence location
(<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/SDKDOCS/SEQLOC.HTML">Seq_loc</a>)
and a Scope. In turn, Seq_loc refers to a Seq_id. Examining
all   Data   Sources  in the Scope, iterator object finds all top-level
seq.entries,    which  contain  annotations pointing to the proper Seq_id.
After that the    special  filtering  rules are to be applied:
</p>

<ol>
  <li>If a top-level seq.entry (TSE) contains bio sequence identified by the
    Seq_id, include the TSE into the resulting TSE set. If multiple TSEs contain
    bio sequence, possibly identified by ID (e.g., different versions of the
    same accession, while ID specifies accession only), select the live TSE and
    ignore dead entries. If all TSEs selected are dead, report an error - we
    cannot decide which one is acceptable. (The latest information about the
    ID sequence will always include good annotations for this sequence).</li>
  <li>If multiple TSEs contain bioseqs, possibly identified by ID, and one 
    of these TSEs has been recorded in the Scope's history, select this 
    TSE    and  ignore other entries. If more than one TSE can be found in the 
    Scope's    history,  report an error. (This means, the user has explicitly 
    selected   a dead sequence  for his query).</li>
  <li>If a TSE, containing only references to ID (but no bioseqs identified 
    by ID) is live, include it into the resulting set. (Live TSE always 
    contains      information, which may be used to describe the sequence, even 
    if the sequence     itself is already dead).</li>
  <li>From dead TSEs not containing the ID bioseq itself select only those 
    found in the scope's history. (Dead TSE means it is not good anymore 
    and    should not be used to describe the ID sequence, no matter live or 
    dead.  History  record means the user has explicitly selected the dead TSE 
    for his  query).</li>
</ol>

<p>
The algorithm for selecting TSEs is as follows:
</p>

<ol>
  <li>Select all TSEs, containing annotations with references to the ID;</li>
  <li>Find all TSEs from the set selected in (1), containing bioseqs identified 
    by ID;</li>
  <li>Check the scope's history for TSEs found in (2). If there is more than 
    one match - report an error. If there is one match, select it and ignore 
    others, proceed to (5). If there are no matches, proceed to (4).</li>
  <li>Check whether any of the TSEs from the (2) set is live. If there is 
    no live TSE and the set contains multiple dead TSEs, report an error. 
    Otherwise    select the live or the only dead TSE.</li>
  <li>From the set of TSEs found in (1) exclude all TSEs selected in (2).</li>
  <li>From (5) select live TSEs, include all in the resulting set.</li>
  <li>From (5) select dead TSEs. From the resulting set select TSEs contained 
    in the scope's history.</li>
</ol>

<p>
Annotation iterator is a base class for defining other iterators (feature,
graph and alignment) - it is not used directly.
</p>





<h3><a name="Feature_iterator"></a>Feature iterator.</h3>
<p>
Feature iterator
(<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CFeat_CI">CFeat_CI</a>)
is kind of annotation iterator. It enumerates
<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSeq_feat">CSeq_feat</a>
data objects the sequence refers to.
</p>


<h4>Object methods:</h4>
<pre>
    // Constructors
    // Search all TSEs in all datasources
    CFeat_CI(CScope&amp; scope, const CSeq_loc&amp; loc,
             SAnnotSelector::TFeatChoice feat_choice,
             EResolveMethod resolve = eResolve_None);
    // Search only in TSE, which contains the bioseq
    CFeat_CI(CBioseq_Handle&amp; bioseq, int start, int stop,
             SAnnotSelector::TFeatChoice feat_choice,
             EResolveMethod resolve = eResolve_None);
    CFeat_CI(const CFeat_CI&amp; iter);
    CFeat_CI&amp; operator= (const CFeat_CI&amp; iter);
    // Search for data
    CFeat_CI&amp; operator++ (void);
    CFeat_CI&amp; operator++ (int);
    // Validity check
    operator bool (void) const;
    // Data access
    const CSeq_feat&amp; operator* (void) const;
    const CSeq_feat* operator-&gt; (void) const;
</b>
</pre>





<h3><a name="Graph_data_iterator"></a>Graph data iterator.</h3>
<p>
Graph data iterator
(<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CGraph_CI">CGraph_CI</a>)
is kind of annotation iterator. It enumerates
<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSeq_graph">CSeq_graph</a>
data objects the sequence refers to.
</p>


<h4>Object methods:</h4>
<pre>
    // Constructors
    // Search all TSEs in all datasources
    CGraph_CI(CScope&amp; scope, const CSeq_loc&amp; loc,
              EResolveMethod resolve = eResolve_None);
    // Search only in TSE, which contains the bioseq
    CGraph_CI(CBioseq_Handle&amp; bioseq, int start, int stop,
              EResolveMethod resolve = eResolve_None);
    CGraph_CI(const CGraph_CI&amp; iter);
    CGraph_CI&amp; operator= (const CGraph_CI&amp; iter);
    // Search for data
    CGraph_CI&amp; operator++ (void);
    CGraph_CI&amp; operator++ (int);
    // Validity check
    operator bool (void) const;
    // Data access
    const CSeq_graph&amp; operator* (void) const;
    const CSeq_graph* operator-&gt; (void) const;
</pre>





<h3><a name="Alignment_iterator"></a>Alignment iterator.</h3>
<p>
Alignment iterator
(<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CAlign_CI">CAlign_CI</a>)
is kind of annotation iterator. It enumerates
<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSeq_align">CSeq_align</a>
data objects the sequence refers to.
</p>


<h4>Object methods:</h4>
<pre>
    // Constructors
    // Search all TSEs in all datasources
    CAlign_CI(CScope&amp; scope, const CSeq_loc&amp; loc,
              EResolveMethod resolve = eResolve_None);
    // Search only in TSE, which contains the bioseq
    CAlign_CI(CBioseq_Handle&amp; bioseq, int start, int stop,
              EResolveMethod resolve = eResolve_None);
    CAlign_CI(const CAlign_CI&amp; iter);
    CAlign_CI&amp; operator= (const CAlign_CI&amp; iter);
    // Search for data
    CAlign_CI&amp; operator++ (void);
    CAlign_CI&amp; operator++ (int);
    // Validity check
    operator bool (void) const;
    // Data access
    const CSeq_align&amp; operator* (void) const;
    const CSeq_align* operator-&gt; (void) const;
</pre>




<!--#include virtual="../../ssi/footer.shtml" -->
