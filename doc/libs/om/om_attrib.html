<!--#set var="TITLE" value="NCBI C++ Object Manager library" -->
<!--#set var="DOCROOT" value="../.." -->
<!--#include virtual="../../ssi/header.shtml" -->
<i><h1><font color="#FF0000"><span style="background-color: #FFFFFF">Warning: This HTML page is deprecated</span></font></h1>

All new changes are being made to the Toolkit Book
at the following locations:
<ul>
<li>
<i>Official Release:</i> <a href="http://www.ncbi.nlm.nih.gov/books/bv.fcgi?call=bv.View..ShowTOC&rid=toolkit.TOC&depth=2">
    C++ Toolkit Book</a>.
</li>
<li>
<i>Development Version:</i> <a href="http://xpubmed0.ncbi.nlm.nih.gov:5701/books/bv.fcgi?call=bv.View..ShowTOC&rid=toolkit.TOC&depth=2">

    C++ Toolkit Book (no search engine, accessible from inside NCBI only)</a>. </li> </ul> The Development Version is the most recent documentation before it becomes an Official Release. While the Development Version is the lastest version, it is accessible only from inside NCBI, and the search engine functionality is currently missing. Also, the location of the Development Version may change without warning! So it is suggested that you use the Official Release, and use the Development Version only when necessary.</p> </i>

<hr>
<!--EOW-->


<div align="Center">
<h1>Object Manager</h1>
</div>

<h2>Classes - attributes and operations</h2>

<ul>
  <li><a href="#Object_manager">Object manager</a></li>
  <li><a href="#Scope">Scope</a></li>
  <li><a href="#Bioseq_handle">Bioseq handle</a></li>
  <li><a href="#Seq_vector">Seq vector</a></li>
  <li><a href="#Seq_map">Seq map</a></li>
  <li><a href="#Data_loader">Data loader</a></li>
  <li><a href="#Description_iterator">Description iterator</a></li>
  <li><a href="#Annotation_iterator">Annotation iterator</a></li>
  <li><a href="#Feature_iterator">Feature iterator</a></li>
  <li><a href="#Graph_data_iterator">Graph data iterator</a></li>
  <li><a href="#Alignment_iterator">Alignment iterator</a></li>
</ul>
<hr>


<h3><a name="Object_manager"></a>Object manager</h3>
<p>
Before being able to use any Scopes, a client must
create and initialize Object Manager
(<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CObjectManager">CObjectManager</a>).
Initialization functions include registration of Data loaders,
some  of which may be declared as default ones. All   default Data
loaders are added  to a Scope when the latter asks for them.   All Data
loaders are  named, so Scopes may refer to them by name. Another   kind
of data object is
<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSeq_entry">CSeq_entry</a>
&#8211; it does not require any data loader, but also
may   be  registered  with the Object Manager. Seq.entry may not be
a default  data object.
</p>

<h4>Object methods:</h4>
<pre class="ncbi_code">
    // register existing data loader.
    // data loader must be created in the heap (ie using operator new)
    void RegisterDataLoader(CDataLoader&amp; loader, EIsDefault is_default=eNonDefault);

    // Revoke previously registered data loader.
    // Return FALSE if the loader is still in use (by some scope).
    // Throw an exception if the loader is not registered with this ObjMgr.
    bool RevokeDataLoader(CDataLoader&amp; Loader);
    bool RevokeDataLoader(string LoaderName);

    // register top-level seq_entry
    bool RegisterTopLevelSeqEntry(CSeq_entry&amp; TopEntry);
</pre>


<h3><a name="Scope"></a>Scope</h3>
<p>
Scope
(<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CScope">CScope</a>)
is designed to be a lightweight object, which could be  easily
created     and destroyed. Scope may even be created on the stack  &#8211; as
an  automatic    object.  Scope is populated with data by adding data loaders
or  already   created  Seq_entries  to it. Data loader can only be added by
name,  that   is it must  be registered  with the Object Manager beforehand.
It is  impossible  to add  a data loader  directly to the scope or remove
it. Once  an externally  created  Seq_entry is added to a Scope, it should
not be modified  any more.  Safe solution  would  be creating a copy of the
Seq_entry and storing  it  instead of the original  - this was refused because
bio sequences may contain  huge amount of data and copying it without a
good  reason is impractical in most cases.
</p>


<h4>Object methods:</h4>
<pre class="ncbi_code">
    // Constructor:
    CScope( CObjectManager&amp; ObjMgr);

    // Add default data loaders from object manager
    bool AddDefaults(void);
    // Add data loader by name (the loader must be known to Object Manager)
    bool AddDataLoader(string LoaderName);
    // Add seq_entry
    bool AddTopLevelSeqEntry(CSeq_entry&amp; TopEntry);

    // Add annotations to a seq-entry (seq or set)
    bool AttachAnnot(const CSeq_entry&amp; entry, CSeq_annot&amp; annot);
    // Add new sub-entry to the existing tree if it is in this scope
    bool AttachEntry(const CSeq_entry&amp; parent, CSeq_entry&amp; entry);
    // Add sequence map for a bioseq if it is in this scope
    bool AttachMap(const CSeq_entry&amp; bioseq, CSeqMap&amp; seqmap);
    // Add seq-data to a bioseq if it is in this scope
    bool AttachSeqData(const CSeq_entry&amp; bioseq, CSeq_data&amp; seq,
                      TSeqPosition start, TSeqLength length);

    // Construct BioseqHandle
    CBioseqHandle  GetBioseqHandle(const CSeq_id&amp; id);
</pre>


<h3><a name="Bioseq_handle"></a>Bioseq handle</h3>
<p>
When a client wants to access a bio sequence data, it asks
the Scope for a Bioseq handle
(<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CBioseq_Handle">CBioseq_Handle</a>).
Bioseq handle object is responsible for resolving    any internal
references  in the sequence. It has comparison operators,  which   make
sense   only for objects created by the same Scope. It is impossible
to compare Bioseq   handles created by different Scopes.
</p>


<h4>Object methods:</h4>
<pre class="ncbi_code">
    // public constructors
    CBioseq_Handle(const CBioseq_Handle&amp; h);
    CBioseq_Handle&amp; operator= (const CBioseq_Handle&amp; h);

    // Comparison
    // Handles must belong to the same scope
    bool operator== (const CBioseq_Handle&amp; h) const;
    bool operator!= (const CBioseq_Handle&amp; h) const;

    // Validity check
    operator bool(void) const;
    bool operator!(void) const;

    // Get Seq_id
    const CSeq_id* GetSeqId(void)  const;
    // Get the complete bioseq (as loaded by now)
    const CBioseq&amp; GetBioseq(void) const;
    // Get top level seq-entry for a bioseq
    const CSeq_entry&amp; GetTopLevelSeqEntry(void) const;
    // Get bioseq core structure
    TBioseqCore GetBioseqCore(void) const;

    // Get sequence map. References to the whole bioseqs may have
    // length of 0 unless GetSeqVector() has been called for the handle.
    const CSeqMap&amp; GetSeqMap(void) const;
    // Get sequence map with resolved multi-level references.
    // The resulting map should contain regions of literals, gaps
    // and references to literals only (but no gaps or refs) to other
    // sequences.
    const CSeqMap&amp; GetResolvedSeqMap(void) const;

    // construct SeqVector.
	// Data encoding is  Iupacna or Iupacaa if use_iupac_coding equals true,
	// otherwise the data representation is same as in the database
    virtual CSeqVector GetSeqVector(bool use_iupac_coding = false,
        bool plus_strand = true) const;

    // construct SeqVector.
    // Sequence filtering: get a SeqVector for a part of the sequence.
    // The part shown depends on the mode selected. If the location
    // contains references to other sequences, they are ignored (unlike
    // CBioseq constructor, which constructs a bioseq using all references
    // from a location). Strand information from "location" is ingored
    // when creating merged or excluded views. If "minus_strand" is true,
    // the result is reverse-complement.
    enum ESequenceViewMode {
        e_ViewConstructed,    // Do not merge or reorder intervals
        e_ViewMerged,         // Merge overlapping intervals, sort by location
        e_ViewExcluded        // Show intervals not included in the seq-loc
    };
    virtual CSeqVector GetSequenceView(const CSeq_loc&amp; location,
                                       ESequenceViewMode mode,
                                       bool use_iupac_coding = false,
                                       bool plus_strand = true) const;
</pre>

<p>
There are also some external utility functions which accept Bioseq
handles; in particular,
<a href="../../lxr/source/include/objects/util/sequence.hpp">&lt;objects/util/sequence.hpp&gt;</a>
declares (within namespace <span class="ncbi_ccode">ncbi::objects::sequence::</span>)
</p>
<pre class="ncbi_code">
    // Get sequence's title (used in various flat-file formats.)
    enum EGetTitleFlags {
        fGetTitle_Reconstruct = 0x1, // ignore existing title Seqdesc.
        fGetTitle_Organism    = 0x2  // append [organism]
    };
    typedef int TGetTitleFlags;
    string GetTitle(const CBioseq_Handle& hnd, TGetTitleFlags flags = 0);
</pre>
<p>
This function is available in the <span class="ncbi_proj">xobjutil</span> library.
</p>

<h3><a name="Seq_vector"></a>Seq vector</h3>
<p>
SeqVector
(<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSeqVector">CSeqVector</a>)
is a sequence data container. The object may only be constructed
by  a Bioseq handle. Seq.vector not necessarily contains all the sequence
data. It rather requests it from all available sources when needed.
In  order    to do so it may access Data loader or other Data sources within
the same   Scope. It may not access other Scopes.
</p>


<h4>Object methods:</h4>
<pre class="ncbi_code">
    // public constructors
    CSeqVector(const CSeqVector&amp; vec);
    CSeqVector&amp; operator= (const CSeqVector&amp; vec);
    // size
    size_t size(void);
    // 0-based array of residues
    TResidue operator[] (int pos);
    // Fill the buffer string with the sequence data for the interval
    // [start, stop).
    void GetSeqData(TSeqPos start, TSeqPos stop, string& buffer);
    // Target sequence coding.
    TCoding GetCoding(void);
    // Set target coding. In case this function was never called
    // SeqVector does not perform any conversion, returning the data
    // in the original format (in which it receives it from the database)
    void SetCoding(TCoding coding);
    // Set coding to either Iupacaa or Iupacna depending on molecule type
    void SetIupacCoding(void);
    // Return gap symbol corresponding to the selected coding
    TResidue GetGapChar(void);
</pre>


<h3><a name="Seq_map"></a>Seq map</h3>
<p>
Seqmap
(<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSeqMap">CSeqMap</a>)
object gives a general description of the bio sequence data: location
and type only without data itself. The object may only be constructed
by   a Bioseq handle.
</p>


<h4>Object methods:</h4>
<pre class="ncbi_code">
    // public constructors
    CSeqMap(const CSeqMap&amp; another);
    CSeqMap&amp; operator=(const CSeqMap&amp; another);
    // size of the map
    const size_t size(void) const;
    // Get an interval
    const CSegmentInfo&amp; operator[](int seg_idx) const;
</pre>

<h4>CSeqMap::CSegmentInfo object methods:</h4>
<pre class="ncbi_code">
     // public constructors
    CSegmentInfo(const CSegmentInfo&amp; seg);
    CSegmentInfo&amp; operator= (const CSegmentInfo&amp; seg);
    bool operator== (const CSegmentInfo&amp; seg) const;
    bool operator&lt;  (const CSegmentInfo&amp; seg) const;
    // Sequence interval description
    ESegmentType GetType(void) const;
    TSeqPosition GetPosition(void) const;
    TSeqLength   GetLength(void) const;
    // The following function makes sense only
    // when the segment is a reference to another sequence
    const CSeq_id& GetRefSeqid(void) const;
</pre>


<h3><a name="Data_loader"></a>Data loader</h3>
<p>
Data loader is never used by a client application directly.
</p>


<h3><a name="Description_iterator"></a>Description iterator</h3>
<p>
Description iterator
(<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CDesc_CI">CDesc_CI</a>)
uses Bioseq handle to access the sequence data. It enables to enumerate
all
<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSeq_descr">CSeq_descr</a>
data objects the sequence refers to.
</p>


<h4>Object methods:</h4>
<pre class="ncbi_code">
    // Constructors
    CDesc_CI(const CBioseq_Handle&amp; handle);
    CDesc_CI(const CDesc_CI&amp; iter);
    CDesc_CI&amp; operator= (const CDesc_CI&amp; iter);
    // Search for data
    CDesc_CI&amp; operator++ (void);
    CDesc_CI&amp; operator++ (int);
    // Validity check
    operator bool (void) const;
    // Data access operators
    const CSeq_descr&amp; operator*  (void) const;
    const CSeq_descr* operator-&gt; (void) const;
</pre>
<p>
There is also another type of description iterator -
<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSeqdesc_CI">CSeqdesc_CI</a>.
It is provided for convenience. Since
<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSeq_descr">CSeq_descr</a>
object is actually a container - list of
<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSeqdesc">CSeqdesc</a>
objects, it would be more convenient to enumerate the latters directly.
</p>

<h4>Object methods:</h4>
<pre class="ncbi_code">
    // Constructors
    CSeqdesc_CI(const CDesc_CI&amp; desc_it,
                CSeqdesc::E_Choice choice = CSeqdesc::e_not_set);
    CSeqdesc_CI(const CSeqdesc_CI&amp; iter);
    CSeqdesc_CI&amp; operator= (const CSeqdesc_CI&amp; iter);
    // Search for data
    CSeqdesc_CI&amp; operator++ (void);
    CSeqdesc_CI  operator++ (int);
    // Validity check
    operator bool (void) const;
    // Data access operators
    const CSeqdesc&amp; operator*  (void) const;
    const CSeqdesc* operator-> (void) const;
</pre>


<h3><a name="Annotation_iterator"></a>Annotation iterator</h3>
<p>
Any annotation iterator
(<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CAnnotTypes_CI">CAnnotTypes_CI</a>)
starts with the following data: sequence location
(<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/SDKDOCS/SEQLOC.HTML">Seq_loc</a>)
and a Scope. In turn, Seq_loc refers to a Seq_id. Examining
all   Data   Sources  in the Scope, iterator object finds 
all appropriate annotations.
Annotation iterator is a base class for defining other iterators (feature,
graph and alignment) - it is not used directly.
</p>


<h3><a name="Feature_iterator"></a>Feature iterator</h3>
<p>
Feature iterator
(<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CFeat_CI">CFeat_CI</a>)
is kind of annotation iterator. It enumerates
<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSeq_feat">CSeq_feat</a>
data objects the sequence refers to.
</p>


<h4>Object methods:</h4>
<pre class="ncbi_code">
    // Constructors
    // Search all TSEs in all datasources, by default do not get
    // annotations defined for segmented bioseq parts.
    CFeat_CI(CScope&amp; scope, const CSeq_loc&amp; loc,
             SAnnotSelector::TFeatChoice feat_choice,
             EResolveMethod resolve = eResolve_None);
    // Search only in TSE, which contains the bioseq
    CFeat_CI(CBioseq_Handle&amp; bioseq, int start, int stop,
             SAnnotSelector::TFeatChoice feat_choice,
             EResolveMethod resolve = eResolve_None);
    CFeat_CI(const CFeat_CI&amp; iter);
    CFeat_CI&amp; operator= (const CFeat_CI&amp; iter);
    // Search for data
    CFeat_CI&amp; operator++ (void);
    CFeat_CI&amp; operator++ (int);
    // Validity check
    operator bool (void) const;
    // Data access
    const CSeq_feat&amp; operator* (void) const;
    const CSeq_feat* operator-&gt; (void) const;
</b>
</pre>


<h3><a name="Graph_data_iterator"></a>Graph data iterator.</h3>
<p>
Graph data iterator
(<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CGraph_CI">CGraph_CI</a>)
is kind of annotation iterator. It enumerates
<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSeq_graph">CSeq_graph</a>
data objects the sequence refers to.
</p>


<h4>Object methods:</h4>
<pre class="ncbi_code">
    // Constructors
    // Search all TSEs in all datasources, by default do not get
    // annotations defined for segmented bioseq parts.
    CGraph_CI(CScope&amp; scope, const CSeq_loc&amp; loc,
              EResolveMethod resolve = eResolve_None);
    // Search only in TSE, which contains the bioseq
    CGraph_CI(CBioseq_Handle&amp; bioseq, int start, int stop,
              EResolveMethod resolve = eResolve_None);
    CGraph_CI(const CGraph_CI&amp; iter);
    CGraph_CI&amp; operator= (const CGraph_CI&amp; iter);
    // Search for data
    CGraph_CI&amp; operator++ (void);
    CGraph_CI&amp; operator++ (int);
    // Validity check
    operator bool (void) const;
    // Data access
    const CSeq_graph&amp; operator* (void) const;
    const CSeq_graph* operator-&gt; (void) const;
</pre>


<h3><a name="Alignment_iterator"></a>Alignment iterator</h3>
<p>
Alignment iterator
(<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CAlign_CI">CAlign_CI</a>)
is kind of annotation iterator. It enumerates
<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSeq_align">CSeq_align</a>
data objects the sequence refers to.
</p>


<h4>Object methods:</h4>
<pre class="ncbi_code">
    // Constructors
    // Search all TSEs in all datasources, by default do not get
    // annotations defined for segmented bioseq parts.
    CAlign_CI(CScope&amp; scope, const CSeq_loc&amp; loc,
              EResolveMethod resolve = eResolve_None);
    // Search only in TSE, which contains the bioseq
    CAlign_CI(CBioseq_Handle&amp; bioseq, int start, int stop,
              EResolveMethod resolve = eResolve_None);
    CAlign_CI(const CAlign_CI&amp; iter);
    CAlign_CI&amp; operator= (const CAlign_CI&amp; iter);
    // Search for data
    CAlign_CI&amp; operator++ (void);
    CAlign_CI&amp; operator++ (int);
    // Validity check
    operator bool (void) const;
    // Data access
    const CSeq_align&amp; operator* (void) const;
    const CSeq_align* operator-&gt; (void) const;
</pre>


<!--#include virtual="../../ssi/navlinks.shtml" -->
<!--#include virtual="../../ssi/footer.shtml" -->
