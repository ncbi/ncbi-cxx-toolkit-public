<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
  <title> Processing ASN.1 Data. </title>
</head>
<body BGCOLOR="white">

<h1> Processing ASN.1 Data </h1>

Although this discussion refers specifically to ASN.1 formatted data, the data
structures and tools described here have been designed to (potentially) support
any formalized specification, including for example, XML. Many of the tools 
and objects have open-ended abstract or template implementations that can be 
instantiated differently to fit various specifications. This discussion however,
will only refer to ASN.1 data. <p>

<ul>
  <li> <a href="#headersandlibs"> Using the ASN Header Files and Serialization Libraries </a>
  <li> <a href="#example1"> Reading and Writing ASN.1 Data: An Example Application </a>
  <li> <a href="#includes"> Determining Which Header Files to Include</a>
  <li> <a href="#linklibs"> Determining Which Libraries to Link To</a>
  <li> <a href="#general"> Generalizing the Input/Output Formats </a>
  <li> <a href="traverse.html"> Traversing an ASN.1 Data Structure. </a>
</ul>

<a name="headersandlibs">
<h3> Using the ASN Header Files and Serialization Libraries </h3> 

Reading and writing ASN.1 data is implemented by an integrated set of streams, filters,
and ASN.1 object types. Writing an application to read, write or otherwise interpret ASN.1
data will require include statements in your source files as well as specific library
names to link to in your makefiles.  The ASN.1 object header and implementation files are
located in the <i>include/objects</i> and <i>src/objects</i> subtrees of the C++ tree
respectively. The header and implementation files for serialized streams and type
information are found in the <i>include/serial</i> and <i>src/serial</i> directories.

<p>

If you have checked out the <i> objects </i> directories, but not explicitly run the <i>
datatool </i> code generator, then you will find that your <i>include/objects</i>
subdirectories are empty, and the source subdirectories contain only ASN.1 specifications.
However, building your own local copies of these header and implementation files is
neither necessary nor recommended, as it is simpler to use include statements and library
specifications. <p>

The pre-built header and implementation files can be found in <i>
$NCBI/c++/include/objects/ </i> and <i> $NCBI/c++/src/objects/ </i> respectively.
Assuming your makefile defines an include path to $NCBI/c++/include, selected ASN.1
header files such as <i> Date.hpp </i>, can be specified as:
<center>
<xmp>
#include <objects/general/Date.hpp>
</xmp>
</center>

This header file, along with the implementations in the accompanying src directory, were
generated by <i> datatool </i> using the specifications found in <i>
$NCBI/c++/src/objects/general/general.asn </i>. 

<a name="example1">
<h3> Reading and Writing ASN.1 Data </h3>

As a first example, we consider what is involved in implementing a program to translate an
ASN.1 data file of a given type from binary to text format. <a href="asntrans_cpp.html"> <i>
asntrans.cpp </i> </a>, reads an ASN.1 Biostruc file in binary format and writes it out in
text format.<p>

The program begins by initializing the diagnostic stream to write errors to a
local file called <i> errs.asntran</i>. First, the file is opened with the definition of
<i> diag </i> as an instance of <i> CNcbiOfstream</i>. The subsequent call to
<i>SetDiagStream</i> then establishes this stream as the one to log messages to.
Exception handling, program tracing, and error logging are described in the
<a href="diag.html">
Diagnostic Streams </a> section.<p>

The next two blocks of code define the ASN.1 binary input and text output streams.
The two streams are referenced in the program via <a href="cref.html"> auto_ptrs</a>, with the
implementation sequence:

<ol> 
 <li> <i>Instantiate</i> the auto_ptr template with the type of stream it will reference;
 <li> <i>Declare</i> a pointer variable to that stream type;
 <li> <i>Instantiate</i> that stream pointer with a call to <i>new</i>;
 <li> <i>Associate</i> the referenced variable with the pointer using a call to <i> reset</i>
</ol>

The streams now need to have <i> CObjectStreams</i> associated with them to provide
buffering of the data. These objects are also specialized to accomodate binary versus text
formats as well as ASN, XML, and other specialized data formats. Accordingly, the program
defines atuo_ptr for the appropriate object types, and associates them with their
respective streams using the <i>reset</i> function.  <p>

Note that in this case the objects stored in the auto_ptrs are "anonymous".  That is,
they do not have independent variable names that can be accessed outside of the auto_pts, 
as these are not needed in this context.  Conversely, the stream objects
<i>were</i> explicitly declared as they serve as arguments to the <i> CObjectStream</i>
constructors.<p>

Finally, a variable for the ASN.1 type, in this case a <i> Biostruc</i>, is defined, and
the stream operators "<<" and ">>" are used to load and write the ASN data.  It is <i> not
</i> possible to simply "pass the data through" the input stream to the output stream
using a construct like: 

<center><pre> *inObject >> *outObject </center></pre> 

The ASN.1 object, in this case a Biostruc, acts as a parser that is required in order to
regenerate the ASN.1 data structure on the output stream.

<a name="includes">
<h3>Determining Which Header Files to Include </h3>

As always, you will need to include your own local header file defining the current
application class. In this example, <a href="asntrans_hpp.html"> asntrans.hpp</a> defines the
<i>CTestAsn</i> class, and in turn, includes the necessary <i>corelib</i> header files for
<i> CNcbiApplication </i>.<p>

Determining what additional header files should be included is fairly straighforward: look
at the objects defined in your source code and locate the files which define these
classes or specify type definitions for these names. In this case, the objects include:
<ol>
<li> CNcbiIfstream
<li> CNcbiIstream 
<li> CNcbiOfstream
<li> CNcbiOstream
<li> CObjectIStream
<li> CObjectIStreamAsnBinary
<li> CObjectOStream 
<li> CObjectOStreamAsn
<li> CBiostruc bs;
</ol>

Since the first four of these are stream objects independent of data format, a likely
place to find their definitions is in the <i>corelib</i> directory. Looking at <i>
ncbistre.hpp</i>, we see that all of these are typedefs in that file.  The next four items
refer to <i>CObject*Stream</i> classes - two of which specialize for ASN formatted data,
so a likely place to search for these is in the <i>serial</i> directory. Lacking any clues
for where to look however, the <i>identifier search</i> tool in the <a
href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/source/"> source code
navigator </a> should allow you to find whatever class you are looking for.<p>

In the serial directory, we find three files that must be included: objistrasnb.hpp,
objostrasn.hpp and serial.hpp. The names of the first two files are self-documenting: the
first defines objects associated with input streams containing binary ASN data; the second
defines objects associated with output streams containing ASN text. The last file, serial.hpp,
defines the input and output operators on <i>CObjectIStreams</i> and <i> CObjectOStreams</i>
respectively.<p>

Finally, we must include the object file headers for the ASN type we are using. Currently,
the object files generated by <i> datatool </i> are not copied to the source directory, so
it is not possible to use the source code navigator. Browsing <i> $NCBI/c++/include/objects/mmdb*/</i>
however, we find the <i>CBiostruc</i> class defined in <i>Biostruc.hpp</i>. In summary, the
following include statements appear at the top of <i>asntrans.cpp</i>:

<xmp>
#include <corelib/ncbistre.hpp>
#include <serial/serial.hpp>          
#include <serial/objistrasnb.hpp>     
#include <serial/objostrasn.hpp>
#include <objects/mmdb1/Biostruc.hpp>
#include  "asntrans.hpp" 
</xmp>

<a name="linklibs">
<h3>Determining Which Libraries to Link To </h3>
Determining which libraries must be linked to requires a bit more work and may involve
some trial and error. The list of available libraries currently includes:
<pre>
access	 medlars  ncbimime  seq	      seqloc  xconnect
biblio	 medline  objprt    seqalign  seqres  xfcgi
cdd	 mmdb1	  proj	    seqblock  seqset  xhtml
featdef	 mmdb2	  pub	    seqcode   submit  xncbi
general	 mmdb3    pubmed    seqfeat   xcgi    xser
</pre>

It should be clear that we will need to link to the core library, <i>xncbi</i>, as
well as the serial library, <i>xser</i>. In addition we will need to link to whatever
object libraries are entailed by using a <i>CBiostruc</i> object. Minimally, one would
expect to link to the <i>mmdb</i> libraries. This in itself is insufficient however,
as the <i>Biostruc</i> class embeds other types of objects, including PubMed citations,
features, and sequences, which in turn embed additional objects such as <i>dates</i>.
The Makefile for asntrans.cpp, <a href="make_asntrans.html"> Makefile.asntrans.app</a> lists 
the required libraries for linking under the make variable <i>LIB</i>.
<p>

<a name="general"> 
<h3> Generalizing the Input/Output Formats </h3>

The previous application can easily be generalized to allow binary or text input as well
as output. <a href="asn2asn_cpp.html"> <i> asn2asn.cpp</i></a> works on <i> Seq-entry</i> and
<i> Bioseq-set</i> types.  Because we now support binary/text input and output, the number
of <i>include</i> files has increased to support the additional stream types entailed.
Comparing the two <a href="make_asn2asn.html"> <i>Makefiles</i></a>, we see that the differences
between them is in the object libraries linked to, as each specializes for different ASN.1
types.


<br>
<p>
</body>
<a href="sub_tree.html"> <i> previous</i> </a>
&nbsp;&nbsp;&nbsp;
<a href="traverse.html"> <i> next </i> </a>
</html>


	 <hr>
	 <table border=0 width="100%" cellspacing=0>
		<tr>
		  <td><address><a href="mailto:zimmerma@ncbi.nlm.nih.gov">Diane Zimmerman</a></address></td>
		  <!-- <td align=center><i>$Revision$</i></td> -->
		  <td align=right><i>$Date$</i></td>
	 </table>
