<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
  <title>Working within the C++ source tree </title>
</head>
<body BGCOLOR=white>
<h1> Working within the C++ source tree </h1>
<ul>
  <li> <a href="#checkout"> Check out the source tree and configure a build directory</a> 
  <li> <a href="#makefiles"> The project's directories and makefiles </a>
  <li> <a href="#make_in"> <i>Makefile.in</i> meta files</a>
  <li> <a href="#example">  An example <i>meta-makefile</i> and its associated project makefiles</a>
  <li> <a href="#exec">  Executing <i>make</i></a>
  <li> <a href="#usr_make"> Makefile.myProj</a>
  <li> <a href="#lib_make"> Makefile.myProj.lib</a>
  <li> <a href="#app_make"> Makefile.myProj.app</a>
  <li> <a href="#config"> The <i>configure</i> scripts</a>
</ul>

Most users will find that working in a <i>checked-out</i> subtree or a private
directory is preferable to working directly in the C++ source tree. There are
two good reasons to avoid doing so:
<ol>
<li> Building your own versions of the extensive libraries can be very time-consuming.
<li> There is no guarantee that the library utilities your private code links to have not
become obsolete.
</ol>

This section is provided for those developers who must work within the source tree.  The
Reference Manual sections provide more complete and technical discussion of
the topics reviewed here, and many links to the relevant sections are provided. This
page is provided as an overview of material presented in the 
<a href="../new_proj.html#ref_Makefile">
Reference Manual</a>.

<a name="checkout">

<h3><a href="../config.html#ref_Source">Checkout</a> the source tree and configure a build directory</h3>
Since you will be working inside the C++ source tree you will first
need to checkout <i>$CVSROOT/internal/c++</i>. If you do not wish to include all of the
subprojects contained in <i>$CVSROOT/internal/c++/internal</i>, you may want to use
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/source/scripts/cvs_core.sh">
<i>cvs_core.sh</i></a> (provided in the <a
href="../new_proj.html#ref_Checkout"><i>scripts</i></a> directory) for checking out.<p>

Once you have done so, you will need to run one of the <i>configure</i> scripts in the
<i>internal/c++</i> directory.  For example, to configure your environment to work with the
<i>gcc</i> compiler on Solaris, just run: <i>./configure</i>.

The <a href="../config.html#ref_Configure"><i>configure script</i></a> is a multi-platform
configuration shell script (generated from <i>configure.in</i> using
<i>autoconf</i>). Here are some pointers to sections in the Reference Manual that will
help you configure the build environment:
<ul>
<li> <a href="../config.html#ref_Wrappers"> Wrapper scripts</a> supporting various platforms
<li> <a href="../config.html#ref_Running"> Optional configuration flags</a>
</ul>

The <i>configure</i> script concludes with a message describing how to build the C++ Toolkit
libraries. If your application will be working with ASN.1 data, use the <i>--with-objects</i> flag
in running the <i>configure</i> script, so as to populate the <i>include/objects</i> and
<i>src/objects</i> subdirectories.

<a name="makefiles">
<h3> The project's directories and makefiles </h3>

To start a new project ("<i>myProj</i>"), you should begin by creating both a <i>src</i>
and an <i>include</i> subtree for that project inside the C++ tree.  In general, all
header files that will be accessed by multiple source modules outside the project
directory should be placed in the <i>include</i> directory. Header files that will be used
solely inside the project's <i>src</i> directory should be placed there, along with the
implementation files. <p>

In addition to the C++ source files, the <i>src</i> subtrees contain <i>meta-makefiles</i>
named <i>Makefile*.in</i>, which are used by the <i>configure</i> script to generate the
corresponding <i>makefiles</i> in the <i>build</i> subtrees. Figure 1 shows slices of the
directory structure reflecting the correspondences between the <i>meta-makefiles</i> in the <i>src</i>
subtrees and makefiles in the <i>build</i> subtrees. Figure 2 is a sketch of the entire C++ tree
in which these directories are defined.<p>

During the configuration process, each of the <i>meta-makefiles</i> in the top-level of the
<i>src</i> tree is translated into a corresponding <i>Makefile*</i> in the top-level of the
<i>build</i> tree. Then, for each project directory containing a <i>Makefile.in</i>, the
<i>configure</i> script will: (1) create a corresponding subdirectory of the same name in the
<i>build</i> tree if it does not already exist, and (2) generate a corresponding
<i>Makefile</i> in the project's <i>build</i> subdirectory. The contents of the project's
<i>Makefile.in</i> in the <i>src</i> subdirectory determine what is written to the project's
<i>Makefile</i> in the <i>build</i> subdirectory. Project subdirectories that do not contain a
<i>meta-makefile</i> are ignored by the configure script. <p>

Thus, you will also need to create a <i>meta-makefile</i> in the newly created
<i>src/myProj</i> directory before configuring your <i>build</i> directory to include the new
project. The <i>configure</i> script will then create the corresponding subtree in the
<i>build</i> directory, along with a new <i>Makefile</i> generated from the <i>Makefile.in</i>
you created.

<center><img SRC="make.gif"></center>
<center><img SRC="cpptree.jpg"></center>
<a name="make_in"> <h3> Makefile.in meta files</h3>
The meta file <i>myProj/Makefile.in</i> should contain macros whose definitions have 
the following interpretation:

<ul> 
<li> <i><b>USR_PROJ</b></i> (optional) - a list of names for user-defined makefiles.<br>

This macro is provided for the usage of ordinary stand-alone makefiles which do not utilize
the <i>make</i> commands contained in additional makefiles in the top-level <i>build</i>
directory.  Each <i>p_i</i> listed in <i>USR_PROJ = p_1 ... p_N</i> must have a corresponding
<a href="#usr_make"> <i>Makefile.p_i</i></a> in the project's source directory. When <i>make</i>
is executed, the <i>make</i> directives contained in these files will be executed directly to
build the targets as specified.<p>

<li> <i><b>LIB_PROJ</b></i> (optional) - a list of names for library makefiles.<br>
For each library <i>l_i</i> listed in <i>LIB_PROJ = l_1 ... l_N</i>, you must have created a
corresponding project makefile named <a href="#lib_make"><i>Makefile.l_i.lib</i></a> in the
project's source directory. When <i>make</i> is executed, these library project makefiles will be
used along with <i>Makefile.lib</i> and <i>Makefile.lib.tmpl</i> (located in the top-level
of the <i>build</i> tree) to build the specified libraries.<p>

<li> <i><b>APP_PROJ</b></i> (optional) - a list of names for application makefiles.<br>
Similarly, each application (<i>p1, p2, ..., pN</i>) listed under <i>APP_PROJ</i> must have a
corresponding project makefile named <a href="#app_make"><i>Makefile.p*.app</i></a> in the
project's source directory.  When <i>make</i> is executed, these application project makefiles
will be used along with <i>Makefile.app</i> and <i>Makefile.app.tmpl</i> to build the
specified executables.<p>

<li> <i><b>SUB_PROJ</b></i> (optional) - a list of names for subproject directories (used on recursive makes).<br>
The <i>SUB_PROJ</i> macro is used to recursively define make targets; items listed here define
the subdirectories rooted in the project's source directory where <i>make</i> should also be
executed.

</ul>
The <i>Makefile.in</i> meta file in the project's source directory defines a kind of road map
that will be used by the configure script to generate a makefile in the corresponding directory
of the <i>build</i> tree. <i>Makefile.in</i> does <i>not</i> participate in the actual execution
of <i>make</i>, but rather, defines what will happen at that time by directing the <i>configure</i>
script in the creation of the <i>Makefile</i> that <i>will</i> be executed (see also the
Reference Manual's description of <a href="../new_proj.html#ref_Makefile"> makefile
targets</a>). <p>

<a name="example"> <h3>An example <i>meta-makefile</i> and its associated project makefiles</h3>
A simple example should help to make this more concrete.

Assuming that <i>myProj</i> is used to develop an application named <i>myProj</i>,
<i>myProj/Makefile.in</i> should contain the following:

<font color=blue><pre>####### Example: src/myProj/Makefile.in</pre></font>
<font color=#000080><pre>APP_PROJ = myProj

srcdir = @srcdir@
include @builddir@/Makefile.meta
</pre></font>
<p>
The last two lines in <i>Makefile.in</i> should always be exactly as shown here.
These two lines specify <i>make</i> variable templates using the <i>@var_name@</i> syntax. When
generating the corresponding <i>Makefile</i> in the <i>build</i> directory, the <i>configure</i> script
will substitute each identifier name bearing that notation with full path definitions. 
<p>
The corresponding <i>Makefile</i> in <i>build/myProj</i>
generated by the <i>configure</i> script for this example will then contain:
<font color=blue><pre>####### Example: myBuild/build/myProj/Makefile</pre></font>
<font color=#000080><pre># Generated automatically from Makefile.in by configure.

APP_PROJ = myProj

srcdir = /home/zimmerma/internal/c++/src/myProj
include /home/zimmerma/internal/c++/myBuild/build/Makefile.meta
</pre></font>

As demonstrated in this example, the <i>@srcdir@</i> and <i>@builddir@</i> aliases in the
makefile template have been replaced with absolute paths in the generated <i>Makefile</i>,
while the definition of <i>APP_PROJ</i> is copied verbatim. <p>

The only build target in this example is <i>myProj</i>, which is specified as
an application target - not a library (because it is listed under <i>APP_PROJ</i>).
Note that there must also be a file named <i>Makefile.myProj.app</i> in the <i>src/myProj</i> 
directory. This project makefile specifies: 
<ul>
<li> <i>APP</i> - the name to be used for the resulting executable
<li> <i>OBJ</i> - a list of object files to use in the compilation
<li> <i>LIB</i> - a list of C++ libraries to use in the linking
<li> <i>LIBS</i> - a list of C libraries to use in the linking
</ul>

A suitable makefile for this simple example might contain just the following text:
<font color=blue><pre>####### Example: src/myProj/Makefile.myProj.app</pre></font>
<font color=#000080><pre>APP = myProj
OBJ = myProj
LIB = xncbi
</pre></font>

In this simple example, the <i>APP_PROJ</i> definition in <i>Makefile.in</i> is identical to
the definitions of both <i>APP</i> and <i>OBJ</i> in <i>Makefile.myProj.app</i>. This is not
always the case however, as the <i>APP_PROJ</i> macro is used to define which makefiles in the
<i>src</i> directory should be used during compilation, while <i>APP</i> defines the name of
the resulting executable and <i>OBJ</i> specifies the names of object files. (Project makefiles
for applications are described in more detail <a href="#app_make">below</a>.)


<a name = "exec"> <h3> Executing <i>make</i></h3>
Given these makefile definitions, executing <i>make all_r</i> in the <i>build</i> project
subdirectory causes <i>build/Makefile.meta</i> to be executed, which sets the following chain
of events in motion:

<ol>
 <li> For each <i><b>proj_name</b></i> listed in <i>USR_PROJ</i>, 
<i>Makefile.meta</i> first tests to see if <i>Makefile.proj_name</i> is available in the
current <i>build</i> directory, and if so, executes:

<font size=2><pre>
   make -f Makefile.proj_name builddir="$(builddir)" srcdir="$(srcdir)" $(MFLAGS)
</pre></font>

Otherwise, <i>Makefile.meta</i> assumes the required makefile is in the project's source
directory, and executes:

<font size=2><pre>
   make -f $(srcdir)/Makefile.proj_name builddir="$(builddir)" srcdir="$(srcdir)" $(MFLAGS)
</pre></font>

In either case, the important thing to note here is that the commands contained in the
project's makefiles are executed directly and are <i>not</i> combined with additional makefiles
in the top-level <i>build</i> directory. The aliased <i>srcdir, builddir</i>, and <i>MFLAGS</i> are
still available and can be referred to inside <i>Makefile.proj_name</i>.  By default, the
resulting libraries and executables are written to the <i>build</i> directory only. <p>

 <li> For each <i><b>lib_name</b></i> listed in <i>LIB_PROJ</i>, 
     <i>make -f $(builddir)/Makefile.lib.tmpl</i> is executed. This in turn specifies 
     that <i>$(builddir)/Makefile.mk, $(srcdir)/Makefile.<b>lib_name</b>.lib</i>, and 
     <i>$(builddir)/Makefile.lib</i> should be included in the generated makefile commands
     that actually get executed. The resulting libraries are written to the <i>build</i> subdirectory
     and copied to the <i>lib</i> subtree. <p>

 <li> For each <i><b>app_name</b></i> listed in <i>APP_PROJ</i>, 
     <i>make -f $(builddir)/Makefile.app.tmpl</i> is executed. This in turn specifies 
     that <i>$(builddir)/Makefile.mk, $(srcdir)/Makefile.<b>app_name</b>.app</i>, and <i>$(builddir)/Makefile.app</i>
     should be included in the generated makefile commands that actually get executed. 
     The resulting executables are written to the <i>build</i> subdirectory and copied to 
     the <i>bin</i> subtree. <p>

 <li> For each <i><b>dir_name</b></i> listed in <i>SUB_PROJ</i> (on <i>make all_r</i>), 
     <i>cd <b>dir_name</b></i> is executed and <i>make all_r</i> is executed. Steps 
     (1) - (3) are then repeated in the project subdirectory.
</ol>

More generally, for each subdirectory listed in <i>SUB_PROJ</i>, the <i>configure</i> script
will create a relative subdirectory inside the new <i>build</i> project directory, and generate
the new subdirectory's <i>Makefile</i> from the corresponding meta-makefile in the <i>src</i>
subtree.  Note that each subproject directory must also contain its own <i>Makefile.in</i>
along with the corresponding project makefiles. The recursive make commands, <i>make all_r,
make clean_r</i>, and <i>make purge_r</i> all refer to this definition of the subprojects to
define what targets should be recursively built or removed. <p>

<a name="usr_make"> <a href="../new_proj.html#ref_MakeProjUsr"><h3> Makefile.myProj</h3> </a>
As described, regular makefiles contained in the project's <i>src</i> directory will be invoked
from the <i>build</i> directory if their <i>suffixes</i> are specified in the $USR_PROJ$
macro. This macro is originally defined in the project's <i>src</i> directory in the
<i>Makefile.in</i> meta file, and is propagated to the corresponding <i>Makefile</i> in the
<i>build</i> directory by the <i>configure</i> script. <p>

For example, if <i>USR_PROJ = myProj</i> in the <i>build</i> directory's <i>Makefile</i>,
executing <i>make</i> will cause <i>Makefile.myProj</i> (the project makefile) to be
executed. This project makefile may be located in either the current <i>build</i> directory
<i>or</i> the corresponding <i>src</i> directory. 

In either case, although the makefile is executed directly, references to the source and object
files (contained in the project makefile) must give complete paths to those files. In the first
case, <i>make</i> is invoked as: <i>make -f Makefile.myProj</i>, so the makefile is located in
the current working (<i>build</i>) directory but the source files are not. In the second case,
<i>make</i> is invoked as: <i>make -f $(srcdir)/Makefile.myProj</i>, so both the project
makefile <i>and</i> the source files are non-local.  For example:

<font color=#000080><pre>####### Makefile.myProj

include $(NCBI)/ncbi.mk
CC = $(NCBI_CC)			# use the NCBI default compiler for this platform
INCPATH = $(NCBI_INCDIR)	# along with the default include 
LIBPATH = $(NCBI_LIBDIR)	# and library paths

all: $(srcdir)/myProj.c
	$(CC) -o myProj $(srcdir)/myProj.c $(NCBI_CFLAGS) -I($INCPATH) -L($LIBPATH) -lncbi
	cp -p myProj $(builddir)/bin

clean:
	-rm  myProj myProj.o

purge: clean
	-rm  $(builddir)/bin/myProj
</pre></font>
<p>
will cause the C program <i>myProj</i> to be built directly from <i>Makefile.myProj</i> using
the default C compiler, library paths, include paths, and compilation flags defined in <i>ncbi.mk</i>.


The executables and libraries generated from the targets specified in <i>USR_PROJ</i> are by
default written to the current <i>build</i> directory only. In this example however, they are
also explicitly copied to the <i>bin</i> directory, and accordingly, the <i>purge</i> directives
also remove the copied executable. <p>

<a name="lib_make"> <a href="../new_proj.html#ref_MakeProjLib"><h3> Makefile.myProj.lib</h3> </a>
<i>Makefile.<b>lib_name</b>.lib</i> should contain the following macro definitions:
<ul>
  <li> <i> $(LIBOBJ) </i> - the names of all source files to compile and include in the library
  <li> <i> $(LOBJ) </i> - the names of any pre-compiled object files to include in the library
  <li> <i> $(LIB)</i> - the name of the library being built
</ul>

In addition, any of the make variables defined in <i>build/Makefile.mk</i>, such as <i>$CPPFLAGS, 
$LINK,</i> etc., can be referred to and/or redefined in the project makefile, e.g.:
<pre>
CFLAGS   = $(ORIG_CFLAGS)   -abc -DFOOBAR_NOT_CPLUSPLUS
CXXFLAGS = $(ORIG_CXXFLAGS) -xyz
CPPFLAGS = $(ORIG_CPPFLAGS) -UFOO -DP1_PROJECT -I$(NCBI_C_INCLUDE)
LINK     = purify $(ORIG_LINK)
</pre>
For a simple example, see <a
href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/source/src/corelib/Makefile.corelib.lib">
Makefile.corelib.lib</a>, and for additional documentation, refer to the 
<a name="lib_make"> <a href="../new_proj.html#ref_MakeProjLib"> Reference Manual</a> section. 
This customized makefile can be used to build both static and dynamic(DLL) versions of the library. 
To build as a DLL on the appropriate platforms, you can explicitly specify: 

<pre>LIB_OR_DLL = dll</pre>

Conversely, if you want the library to always be built as static, specify: 

<pre>LIB_OR_DLL = lib</pre>

<a name="app_make"> <a href="../new_proj.html#ref_MakeProjApp"><h3> Makefile.myProj.app</h3> </a>
<i>Makefile.<b>app_name</b>.app</i> should contain the following macro definitions:
<ul>
  <li><i> $(OBJ) </i> - the names of the object modules to build and link to the application
  <li><i> $(LIB)</i> - specific libraries in the NCBI C++ Toolkit to include in the linking
  <li><i> $(LIBS) </i> - all other libraries to link to (outside the C++ Toolkit)
  <li><i> $(APP) </i> - the name of the application being built
</ul>
For example, if C libraries should also be included in the linking, use:

<pre> LIBS = $(NCBI_C_LIBPATH) -lncbi $(ORIG_LIBS)</pre>

The project's application makefile can also redefine the compiler and linker, along with other
flags and tools affecting the build process, as described above for <i>Makefile.*.lib</i> files, 
For an example, see 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/source/src/corelib/test/Makefile.coretest.app">
Makefile.coretest.app</a>. For additional documentation refer also to the 
<a name="lib_make"> <a href="../new_proj.html#ref_MakeProjApp"> Reference Manual</a> section. 
<p>

<a name="config"> <h3>The <i>configure</i> scripts</h3>

A number of compiler-specific wrappers for different platforms are described in the
<a href="http://sunweb.ncbi.nlm.nih.gov:6224/IEB/corelib/cpp/config.html#ref_Wrappers"> Reference Manual</a>.
Each of these wrappers performs some pre-initialization for the tools and flags used in the <i>configure</i>
script before running it. The compiler-specific wrappers are in the 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/source/compilers/">
<i>c++/compilers</i></a> directory.

The <i>configure</i> script serves two very different types of function: (1) it tests the
selected compiler and environment for a multitude of features and generates <i>#include</i> and
<i>#define</i> statements accordingly, and (2) it reads the <i>Makefile.in</i> files in the <i>src</i>
directories and creates the corresponding <i>build</i> subtrees and makefiles accordingly. <p>

Frequently during development it is necessary to make minor adjustments to the <i>Makefile.in</i> files,
such as adding new projects or subprojects to the list of targets. In these contexts
however, the compiler, environment, and source directory structures remain unchanged, and 
<i>configure</i> is actually doing more work than is necessary. In fact, there is even some risk of 
failing to recreate the same configuration environment if the user does not exactly duplicate the
same set of configure flags when re-running <i>configure</i>. In these situations it is preferable
to run an auxilliary script named <a href="../config.html#ref_Reconf"><i>config.status</i></a>, located
at the top level of the <i>build</i> directory in a subdirectory named <i>status</i>. 
<p>
In contrast, changes to the <i>src</i> directory structure, or the addition/deletion of 
<i>Makefile.in</i> files, all require re-running the <i>configure</i> script, as these actions require
the creation/deletion of subdirectories in the <i>build</i> tree and/or the creation/deletion of the 
associated <i>Makefile</i> in those directories.

<p>

</body>
<a href="sub_tree.html"> <i> previous </i> </a>
&nbsp;&nbsp;&nbsp;
<a href="../index.html"> <i> up </i> </a>
</html>


	 <hr>
	 <table border=0 width="100%" cellspacing=0>
		<tr>
		  <td><address><a href="mailto:zimmerma@ncbi.nlm.nih.gov">Diane Zimmerman</a></address></td>
		  <!-- <td align=center><i>$Revision$</i></td> -->
		  <td align=right><i>$Date$</i></td>
	 </table>

