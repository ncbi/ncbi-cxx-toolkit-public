<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.75 [en] (X11; U; SunOS 5.7 sun4u) [Netscape]">
   <title>Working within the C++ source tree </title>
</head>
<body bgcolor="#FFFFFF">

<h1>
Working within the C++ source tree</h1>

<ul>
<li>
<a href="#checkout">Check out the source tree and configure a build directory</a></li>

<li>
<a href="#makefiles">The project's directories and makefiles</a></li>

<li>
<a href="#make_in"><i>Makefile.in</i> meta files</a></li>

<li>
<a href="#example">An example <i>meta-makefile</i> and its associated project
makefiles</a></li>

<li>
<a href="#exec">Executing <i>make</i></a></li>

<li>
<a href="#usr_make">Custom project makefile: Makefile.myProj</a></li>

<li>
<a href="#lib_make">Library project makefile: Makefile.myProj.lib</a></li>

<li>
<a href="#app_make">Application project makefile: Makefile.myProj.app</a></li>

<li>
<a href="#config">The <i>configure</i> scripts</a></li>
</ul>
Most users will find that working in a <i>checked-out</i> subtree or a
private directory is preferable to working directly in the C++ source tree.
There are two good reasons to avoid doing so:
<ol>
<li>
Building your own versions of the extensive libraries can be very time-consuming.</li>

<li>
There is no guarantee that the library utilities your private code links
to have not become obsolete.</li>
</ol>
This section is provided for those developers who must work within the
source tree. The Reference Manual sections provide more complete and technical
discussion of the topics reviewed here, and many links to the relevant
sections are provided. This page is provided as an overview of material
presented in the <a href="../new_proj.html#ref_Makefile">Reference Manual</a>.&nbsp;<a NAME="checkout"></a>
<h3>
<a href="../config.html#ref_Source">Checkout</a> the source tree and configure
a build directory</h3>
Since you will be working inside the C++ source tree you will first need
to checkout <i>$CVSROOT/internal/c++</i>. If you do not wish to include
all of the subprojects contained in <i>$CVSROOT/internal/c++/internal</i>,
you may want to use
<i><a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/source/scripts/cvs_core.sh">cvs_core.sh</a></i>
(provided in the <i><a href="../new_proj.html#ref_Checkout">scripts</a></i>
directory) for checking out.
<p>&nbsp;Once you have done so, you will need to run one of the <i>configure</i>
scripts in the
<i>internal/c++</i> directory. For example, to configure
your environment to work with the
<i>gcc</i> compiler (on any platform),
just run: <i>./configure</i>. Users working under Windows NT should consult
the <i><a href="../config.html#ref_MsvcProj">MS Visual C++</a></i> section
in the reference manual.
<p>&nbsp;The <i><a href="../config.html#ref_Configure">configure script</a></i>
is a multi-platform configuration shell script (generated from <i>configure.in</i>
using
<i>autoconf</i>). Here are some pointers to sections in the Reference
Manual that will help you configure the build environment:
<ul>
<li>
<a href="../config.html#ref_Wrappers">Wrapper scripts</a> supporting various
platforms</li>

<li>
<a href="../config.html#ref_Running">Optional configuration flags</a></li>
</ul>
The <i>configure</i> script concludes with a message describing how to
build the C++ Toolkit libraries. If your application will be working with
ASN.1 data, use the <i>--with-objects</i> flag in running the <i>configure</i>
script, so as to populate the <i>include/objects</i> and
<i>src/objects</i>
subdirectories and build the <i>objects</i> libraries. The <i>objects</i>
directories and libraries can also be updated separately from the rest
of the compilation, by executing <i>make</i> inside the <i>build/objects</i>
directory. Prior to doing so however, you should always verify that your
<i>build/bin</i> directory contains the latest version of <i>datatool</i>.&nbsp;<a NAME="makefiles"></a>
<h3>
The project's directories and makefiles</h3>
To start a new project ("<i>myProj</i>"), you should begin by creating
both a <i>src</i> and an <i>include</i> subtree for that project inside
the C++ tree. In general, all header files that will be accessed by multiple
source modules outside the project directory should be placed in the <i>include</i>
directory. Header files that will be used solely inside the project's <i>src</i>
directory should be placed there, along with the implementation files.
<p>In addition to the C++ source files, the <i>src</i> subtrees contain
<i>meta-makefiles</i> named <i>Makefile*.in</i>, which are used by the
<i>configure</i> script to generate the corresponding <i>makefiles</i>
in the <i>build</i> subtrees. Figure 1 shows slices of the directory structure
reflecting the correspondences between the <i>meta-makefiles</i> in the
<i>src</i> subtrees and makefiles in the <i>build</i> subtrees. Figure
2 is a sketch of the entire C++ tree in which these directories are defined.
<p>&nbsp;During the configuration process, each of the <i>meta-makefiles</i>
in the top-level of the
<i>src</i> tree is translated into a corresponding
<i>Makefile*</i> in the top-level of the
<i>build</i> tree. Then, for each
project directory containing a <i>Makefile.in</i>, the
<i>configure</i>
script will: (1) create a corresponding subdirectory of the same name in
the
<i>build</i> tree if it does not already exist, and (2) generate a
corresponding
<i>Makefile</i> in the project's <i>build</i> subdirectory.
The contents of the project's
<i>Makefile.in</i> in the <i>src</i> subdirectory
determine what is written to the project's
<i>Makefile</i> in the <i>build</i>
subdirectory. Project subdirectories that do not contain any
<i>*.in</i>
files are ignored by the <i>configure</i> script.
<p>Thus, you will also need to create a <i>meta-makefile</i> in the newly
created
<i>src/myProj</i> directory before configuring your <i>build</i>
directory to include the new project. The <i>configure</i> script will
then create the corresponding subtree in the
<i>build</i> directory, along
with a new <i>Makefile</i> generated from the <i>Makefile.in</i> you created.
<center><img SRC="make.gif" >
<br><img SRC="cpptree.jpg" ></center>
<a NAME="make_in"></a>
<h3>
Makefile.in meta files</h3>
The <i>meta-makefile myProj/Makefile.in</i> should define at least one
of the following macros:
<ul>
<li>
<a NAME="musr"></a><b><i>USR_PROJ</i></b> (optional) - a list of names
for user-defined makefiles.</li>

<br>This macro is provided for the usage of ordinary stand-alone makefiles
which do not utilize the <i>make</i> commands contained in additional makefiles
in the top-level <i>build</i> directory. Each <i>p_i</i> listed in <i>USR_PROJ
= p_1 ... p_N</i> must have a corresponding
<i><a href="#usr_make">Makefile.p_i</a></i>
in the project's source directory. When <i>make</i> is executed, the <i>make</i>
directives contained in these files will be executed directly to build
the targets as specified.
<br>&nbsp;
<br>&nbsp;
<li>
<a NAME="mlib"></a><b><i>LIB_PROJ</i></b> (optional) - a list of names
for library makefiles.</li>

<br>For each library <i>l_i</i> listed in <i>LIB_PROJ = l_1 ... l_N</i>,
you must have created a corresponding project makefile named <i><a href="#lib_make">Makefile.l_i.lib</a></i>
in the project's source directory. When <i>make</i> is executed, these
library project makefiles will be used along with <i>Makefile.lib</i> and
<i>Makefile.lib.tmpl</i> (located in the top-level of the <i>build</i>
tree) to build the specified libraries.
<br>&nbsp;
<br>&nbsp;
<li>
<a NAME="mapp"></a><b><i>APP_PROJ</i></b> (optional) - a list of names
for application makefiles.</li>

<br>Similarly, each application (<i>p1, p2, ..., pN</i>) listed under <i>APP_PROJ</i>
must have a corresponding project makefile named <i><a href="#app_make">Makefile.p*.app</a></i>
in the project's source directory. When <i>make</i> is executed, these
application project makefiles will be used along with <i>Makefile.app</i>
and <i>Makefile.app.tmpl</i> to build the specified executables.
<br>&nbsp;
<br>&nbsp;
<li>
<a NAME="msub"></a><b><i>SUB_PROJ</i></b> (optional) - a list of names
for subproject directories (used on recursive makes).</li>

<br>The <i>SUB_PROJ</i> macro is used to recursively define <i>make</i>
targets; items listed here define the subdirectories rooted in the project's
source directory where <i>make</i> should also be executed.</ul>
The <i>Makefile.in</i> meta file in the project's source directory defines
a kind of road map that will be used by the <i>configure</i> script to
generate a makefile (<i>Makefile</i>) in the corresponding directory of
the <i>build</i> tree. <i>Makefile.in</i> does <i>not</i> participate in
the actual execution of <i>make</i>, but rather, defines what will happen
at that time by directing the <i>configure</i> script in the creation of
the <i>Makefile</i> that
<i>will</i> be executed (see also the Reference
Manual's description of <i><a href="../new_proj.html#ref_Makefile">Makefile
targets</a></i>).
<p><a NAME="example"></a>
<h3>
An example <i>meta-makefile</i> and its associated project makefiles</h3>
A simple example should help to make this more concrete. Assuming that
<i>myProj</i> is used to develop an application named <i>myProj</i>,
<i>myProj/Makefile.in</i>
should contain the following:
<pre><font color="#0000FF">####### Example: src/myProj/Makefile.in</font></pre>

<pre><font color="#000080">APP_PROJ = myProj

srcdir = @srcdir@
include @builddir@/Makefile.meta</font></pre>
The last two lines in <i>Makefile.in</i> should always be exactly as shown
here. These two lines specify <i>make</i> variable templates using the
<i>@var_name@</i> syntax. When generating the corresponding <i>Makefile</i>
in the <i>build</i> directory, the <i>configure</i> script will substitute
each identifier name bearing that notation with full path definitions.
<p>The corresponding <i>Makefile</i> in <i>build/myProj</i> generated by
the <i>configure</i> script for this example will then contain:
<pre><font color="#0000FF">####### Example: myBuild/build/myProj/Makefile</font></pre>

<pre><font color="#000080"># Generated automatically from Makefile.in by configure.

APP_PROJ = myProj

srcdir = /home/zimmerma/internal/c++/src/myProj
include /home/zimmerma/internal/c++/myBuild/build/Makefile.meta</font></pre>
As demonstrated in this example, the <i>@srcdir@</i> and <i>@builddir@</i>
aliases in the makefile template have been replaced with absolute paths
in the generated <i>Makefile</i>, while the definition of <i>APP_PROJ</i>
is copied verbatim.
<p>The only build target in this example is <i>myProj</i>. <i>myProj</i>
is specified as an application - not a library - because it is listed under
<i>APP_PROJ</i> rather than under <i>LIB_PROJ</i>. Accordingly, there must
also be a file named <i>Makefile.myProj.app</i> in the <i>src/myProj</i>
directory. A project's application makefile specifies:
<ul>
<li>
<i>APP</i> - the name to be used for the resulting executable</li>

<li>
<i>OBJ</i> - a list of object files to use in the compilation</li>

<li>
<i>LIB</i> - a list of NCBI C++ Toolkit libraries to use in the linking</li>

<li>
<i>LIBS</i> - a list of other libraries to use in the linking</li>
</ul>
There may be any number of application or library makefiles for the project,
Each application should be listed under <i>APP_PROJ</i> and each library
should be listed under <i>LIB_PROJ</i> in <i>Makefile.in</i>. A suitable
application makefile for this simple example might contain just the following
text:
<pre><font color="#0000FF">####### Example: src/myProj/Makefile.myProj.app</font></pre>

<pre><font color="#000080">APP = myProj
OBJ = myProj
LIB = xncbi</font></pre>
In this simple example, the <i>APP_PROJ</i> definition in <i>Makefile.in</i>
is identical to the definitions of both <i>APP</i> and <i>OBJ</i> in <i>Makefile.myProj.app</i>.
This is not always the case however, as the <i>APP_PROJ</i> macro is used
to define which makefiles in the
<i>src</i> directory should be used during
compilation, while <i>APP</i> defines the name of the resulting executable
and <i>OBJ</i> specifies the names of object files. (Project makefiles
for applications are described in more detail <a href="#app_make">below</a>.)&nbsp;<a NAME="exec"></a>
<h3>
Executing <i>make</i></h3>
Given these makefile definitions, executing <i>make all_r</i> in the <i>build</i>
project subdirectory indirectly causes <i>build/Makefile.meta</i> to be
executed, which sets the following chain of events in motion:
<ol>
<li>
For each <b><i>proj_name</i></b> listed in <i><a href="#musr">USR_PROJ</a></i>,
<i>Makefile.meta</i> first tests to see if <i>Makefile.proj_name</i> is
available in the current <i>build</i> directory, and if so, executes:</li>

<pre><font size=-1>&nbsp;&nbsp; make -f Makefile.proj_name builddir="$(builddir)" srcdir="$(srcdir)" $(MFLAGS)</font></pre>
Otherwise, <i>Makefile.meta</i> assumes the required makefile is in the
project's source directory, and executes:
<pre><font size=-1>&nbsp;&nbsp; make -f $(srcdir)/Makefile.proj_name builddir="$(builddir)" srcdir="$(srcdir)" $(MFLAGS)</font></pre>
In either case, the important thing to note here is that the commands contained
in the project's makefiles are executed directly and are <i>not</i> combined
with additional makefiles in the top-level <i>build</i> directory. The
aliased <i>srcdir, builddir</i>, and <i>MFLAGS</i> are still available
and can be referred to inside <i>Makefile.proj_name</i>. By default, the
resulting libraries and executables are written to the <i>build</i> directory
only.
<li>
For each <b><i>lib_name</i></b> listed in <i><a href="#mlib">LIB_PROJ</a></i>,
<i>make -f $(builddir)/Makefile.lib.tmpl</i> is executed. This in turn
specifies that <i>$(builddir)/Makefile.mk, $(srcdir)/Makefile.<b>lib_name</b>.lib</i>,
and <i>$(builddir)/Makefile.lib</i> should be included in the generated
makefile commands that actually get executed. The resulting libraries are
written to the <i>build</i> subdirectory and copied to the <i>lib</i> subtree.</li>

<li>
For each <b><i>app_name</i></b> listed in <i><a href="#mapp">APP_PROJ</a></i>,
<i>make -f $(builddir)/Makefile.app.tmpl</i> is executed. This in turn
specifies that <i>$(builddir)/Makefile.mk, $(srcdir)/Makefile.<b>app_name</b>.app</i>,
and <i>$(builddir)/Makefile.app</i> should be included in the generated
makefile commands that actually get executed. The resulting executables
are written to the <i>build</i> subdirectory and copied to the <i>bin</i>
subtree.</li>

<li>
For each <b><i>dir_name</i></b> listed in <i><a href="#msub">SUB_PROJ</a></i>
(on <i>make all_r</i>), <i>cd <b>dir_name</b></i> is executed and <i>make
all_r</i> is executed. Steps (1) - (3) are then repeated in the project
subdirectory.</li>
</ol>
More generally, for each subdirectory listed in <i>SUB_PROJ</i>, the <i>configure</i>
script will create a relative subdirectory inside the new <i>build</i>
project directory, and generate the new subdirectory's <i>Makefile</i>
from the corresponding meta-makefile in the <i>src</i> subtree. Note that
each subproject directory must also contain its own <i>Makefile.in</i>
along with the corresponding project makefiles. The recursive make commands,
<i>make all_r, make clean_r</i>, and <i>make purge_r</i> all refer to this
definition of the subprojects to define what targets should be recursively
built or removed.
<p><a NAME="usr_make"></a>
<h3>
<a href="../new_proj.html#ref_MakeProjUsr">Custom project makefile: Makefile.myProj</a></h3>
As described, regular makefiles contained in the project's <i>src</i> directory
will be invoked from the <i>build</i> directory if their <i>suffixes</i>
are specified in the <i>USR_PROJ</i> macro. This macro is originally defined
in the project's <i>src</i> directory in the
<i>Makefile.in</i> meta file,
and is propagated to the corresponding <i>Makefile</i> in the
<i>build</i>
directory by the <i>configure</i> script.
<p>For example, if <i>USR_PROJ = myProj</i> in the <i>build</i> directory's
<i>Makefile</i>, executing <i>make</i> will cause <i>Makefile.myProj</i>
(the project makefile) to be executed. This project makefile may be located
in either the current <i>build</i> directory
<i>or</i> the corresponding
<i>src</i> directory. In either case, although the makefile is executed
directly, references to the source and object files (contained in the project
makefile) must give complete paths to those files. In the first case, <i>make</i>
is invoked as: <i>make -f Makefile.myProj</i>, so the makefile is located
in the current working (<i>build</i>) directory but the source files are
not. In the second case,
<i>make</i> is invoked as: <i>make -f $(srcdir)/Makefile.myProj</i>,
so both the project makefile <i>and</i> the source files are non-local.
For example:
<pre><font color="#000080">####### Makefile.myProj

include $(NCBI)/ncbi.mk
CC = $(NCBI_CC)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # use the NCBI default compiler for this platform
INCPATH = $(NCBI_INCDIR)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # along with the default include&nbsp;
LIBPATH = $(NCBI_LIBDIR)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # and library paths

all: $(srcdir)/myProj.c
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $(CC) -o myProj $(srcdir)/myProj.c $(NCBI_CFLAGS) -I($INCPATH) \
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -L($LIBPATH) -lncbi
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cp -p myProj $(builddir)/bin

clean:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -rm&nbsp; myProj myProj.o

purge: clean
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -rm&nbsp; $(builddir)/bin/myProj</font></pre>
will cause the C program <i>myProj</i> to be built directly from <i>Makefile.myProj</i>
using the default C compiler, library paths, include paths, and compilation
flags defined in <i>ncbi.mk</i>. The executables and libraries generated
from the targets specified in <i>USR_PROJ</i> are by default written to
the current <i>build</i> directory only. In this example however, they
are also explicitly copied to the <i>bin</i> directory, and accordingly,
the <i>purge</i> directives also remove the copied executable.
<p><a NAME="lib_make"></a>
<h3>
<a href="../new_proj.html#ref_MakeProjLib">Library project makefile: Makefile.myProj.lib</a></h3>
<i>Makefile.<b>lib_name</b>.lib</i> should contain the following macro
definitions:
<ul>
<li>
<i>$(LIBOBJ) </i>- the names of all source files to compile and include
in the library</li>

<li>
<i>$(LOBJ) </i>- the names of any pre-compiled object files to include
in the library</li>

<li>
<i>$(LIB)</i> - the name of the library being built</li>
</ul>
In addition, any of the make variables defined in <i>build/Makefile.mk</i>,
such as <i>$CPPFLAGS, $LINK,</i> etc., can be referred to and/or redefined
in the project makefile, e.g.:
<pre>CFLAGS&nbsp;&nbsp; = $(ORIG_CFLAGS)&nbsp;&nbsp; -abc -DFOOBAR_NOT_CPLUSPLUS
CXXFLAGS = $(ORIG_CXXFLAGS) -xyz
CPPFLAGS = $(ORIG_CPPFLAGS) -UFOO -DP1_PROJECT -I$(NCBI_C_INCLUDE)
LINK&nbsp;&nbsp;&nbsp;&nbsp; = purify $(ORIG_LINK)</pre>
For a simple example, see <a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/source/src/corelib/Makefile.corelib.lib">Makefile.corelib.lib</a>,
and for additional documentation, refer to the <a href="../new_proj.html#ref_MakeProjLib">Reference
Manual</a> section. This customized makefile can be used to build both
static and dynamic(DLL) versions of the library. To build as a DLL on the
appropriate platforms, you can explicitly specify:
<pre>LIB_OR_DLL = dll</pre>
Conversely, if you want the library to always be built as static, specify:
<pre>LIB_OR_DLL = lib</pre>
<a NAME="app_make"></a>
<h3>
<a href="../new_proj.html#ref_MakeProjApp">Application project makefile:
Makefile.myProj.app</a></h3>
<i>Makefile.<b>app_name</b>.app</i> should contain the following macro
definitions:
<ul>
<li>
<i>$(OBJ) </i>- the names of the object modules to build and link to the
application</li>

<li>
<i>$(LIB)</i> - specific libraries in the NCBI C++ Toolkit to include in
the linking</li>

<li>
<i>$(LIBS) </i>- all other libraries to link to (outside the C++ Toolkit)</li>

<li>
<i>$(APP) </i>- the name of the application being built</li>
</ul>
For example, if C Toolkit libraries should also be included in the linking,
use:
<pre>&nbsp;LIBS = $(NCBI_C_LIBPATH) -lncbi $(ORIG_LIBS)</pre>
The project's application makefile can also redefine the compiler and linker,
along with other flags and tools affecting the build process, as described
above for <i>Makefile.*.lib</i> files, For an example, see <a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/source/src/corelib/test/Makefile.coretest.app">Makefile.coretest.app</a>.
For additional documentation refer also to the <a href="../new_proj.html#ref_MakeProjApp">Reference
Manual</a> section.
<p><a NAME="config"></a>
<h3>
The <i>configure</i> scripts</h3>
A number of compiler-specific wrappers for different platforms are described
in the
<a href="../config.html#ref_Wrappers">Reference Manual</a>. Each
of these wrappers performs some pre-initialization for the tools and flags
used in the <i>configure</i> script before running it. The compiler-specific
wrappers are in the <i><a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/source/compilers/">c++/compilers</a></i>
directory. The <i>configure</i> script serves two very different types
of function: (1) it tests the selected compiler and environment for a multitude
of features and generates <i>#include</i> and
<i>#define</i> statements
accordingly, and (2) it reads the <i>Makefile.in</i> files in the <i>src</i>
directories and creates the corresponding <i>build</i> subtrees and makefiles
accordingly.
<p>Frequently during development it is necessary to make minor adjustments
to the
<i>Makefile.in</i> files, such as adding new projects or subprojects
to the list of targets. In these contexts however, the compiler, environment,
and source directory structures remain unchanged, and <i>configure</i>
is actually doing much more work than is necessary. In fact, there is even
some risk of failing to re-create the same configuration environment if
the user does not exactly duplicate the same set of configure flags when
re-running <i>configure</i>. In these situations, it is preferable to run
an auxilliary script named <i><a href="../config.html#ref_Reconf">config.status</a></i>,
located at the top level of the
<i>build</i> directory in a subdirectory
named <i>status</i>.
<p>In contrast, changes to the <i>src</i> directory structure, or the addition/deletion
of <i>Makefile.in</i> files, all require re-running the <i>configure</i>
script, as these actions require the creation/deletion of subdirectories
in the <i>build</i> tree and/or the creation/deletion of the associated
<i>Makefile</i> in those directories.
<p><i><a href="sub_tree.html">previous&nbsp;</a></i>&nbsp;&nbsp; 
<i><a href="../index.html">up&nbsp;</a></i>&nbsp;&nbsp;&nbsp;
<i><a href="objects.html">next</a></i>
<hr>
<table BORDER=0 CELLSPACING=0 WIDTH="100%" >
<tr>
<td>
<address>
<a href="mailto:zimmerma@ncbi.nlm.nih.gov">Diane Zimmerman</a></address>
</td>

<td><!-- <td align=center><i>$Revision$</i></td> --></td>

<td ALIGN=RIGHT><i>$Date$</i></td>
</tr>
</table>

</body>
</html>
