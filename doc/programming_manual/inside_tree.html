<!--#set var="TITLE" value="Working within the C++ source tree" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->
<i><h1><font color="#FF0000"><span style="background-color: #FFFFFF">Warning: This HTML page is deprecated</span></font></h1>

All new changes are being made to the Toolkit Book
at the following locations:
<ul>
<li>
<i>Official Release:</i> <a href="http://www.ncbi.nlm.nih.gov/books/bv.fcgi?call=bv.View..ShowTOC&rid=toolkit.TOC&depth=2">
    C++ Toolkit Book</a>.
</li>
<li>
<i>Development Version:</i> <a href="http://xpubmed0.ncbi.nlm.nih.gov:5701/books/bv.fcgi?call=bv.View..ShowTOC&rid=toolkit.TOC&depth=2">

    C++ Toolkit Book (no search engine, accessible from inside NCBI only)</a>. </li> </ul> The Development Version is the most recent documentation before it becomes an Official Release. While the Development Version is the lastest version, it is accessible only from inside NCBI, and the search engine functionality is currently missing. Also, the location of the Development Version may change without warning! So it is suggested that you use the Official Release, and use the Development Version only when necessary.</p> </i>

<hr>
<!--EOW-->

<h1>
Working within the C++ source tree</h1>

<ul>
<li>
<a href="#checkout">Check out the source tree and configure a build directory</a></li>

<li>
<a href="#makefiles">The project's directories and makefiles</a></li>

<li>
<a href="#make_in">Makefile.in meta files</a></li>

<li>
<a href="#example">An example meta-makefile and its associated project
makefiles</a></li>

<li>
<a href="#exec">Executing <span class="ncbi_util">make</span></a></li>

<li>
<a href="#usr_make">Custom project makefile: Makefile.myProj</a></li>

<li>
<a href="#lib_make">Library project makefile: Makefile.myProj.lib</a></li>

<li>
<a href="#app_make">Application project makefile: Makefile.myProj.app</a></li>

<li>
<a href="#config">The <span class="ncbi_script">configure</span> scripts</a></li>
</ul>
Most users will find that working in a <span class="ncbi_term">checked-out</span> subtree or a
private directory is preferable to working directly in the C++ source tree.
There are two good reasons to avoid doing so:
<ol>
<li>
Building your own versions of the extensive libraries can be very time-consuming.</li>

<li>
There is no guarantee that the library utilities your private code links
to have not become obsolete.</li>
</ol>
This section is provided for those developers who must work within the
source tree. The Reference Manual sections provide more complete and technical
discussion of the topics reviewed here, and many links to the relevant
sections are provided. This page is provided as an overview of material
presented in the <a href="../new_proj.html#ref_Makefile">Reference Manual</a>
and on the <a href="../makefiles.html">Working with Makefiles</a> pages.
<p><br>


<a NAME="checkout"></a>
<h3><a href="../config.html#ref_Source">Checkout</a> the source tree and configure
a build directory</h3>

Since you will be working inside the C++ source tree you will first need
to checkout <span class="ncbi_cvs_path">$CVSROOT/internal/c++</span>. If you do not wish to include
all of the subprojects contained in <span class="ncbi_cvs_path">$CVSROOT/internal/c++/internal</span>,
you may want to use <a href="../lxr/source/scripts/cvs_core.sh" class="ncbi_script">cvs_core.sh</a>
(provided in the <a href="../new_proj.html#ref_Checkout" class="ncbi_dir">scripts</a>
directory) for checking out.
<p>&nbsp;Once you have done so, you will need to run one of the <span class="ncbi_script">configure</span>
scripts in the
<span class="ncbi_dir">internal/c++</span> directory. For example, to configure
your environment to work with the
<span class="ncbi_util">gcc</span> compiler (on any platform),
just run: <span class="ncbi_script">./configure</span>. Users working under Windows NT should consult the <a href="../config.html#ref_MsvcProj">MS Visual C++</a> section
in the reference manual.
<p>
The <a href="../config.html#ref_Configure">configure script</a>
is a multi-platform configuration shell script (generated from <span class="ncbi_file">configure.in</span>
using
<span class="ncbi_util">autoconf</span>). Here are some pointers to sections in the Reference
Manual that will help you configure the build environment:
<ul>
<li>
<a href="../config.html#ref_Wrappers">Wrapper scripts</a> supporting various
platforms</li>

<li>
<a href="../config.html#ref_Running">Optional configuration flags</a></li>
</ul>
The <span class="ncbi_script">configure</span> script concludes with a message describing how to
build the C++ Toolkit libraries. If your application will be working with
ASN.1 data, use the <span class="ncbi_conf_flag">--with-objects</span> flag in running the <span class="ncbi_script">configure</span>
script, so as to populate the <span class="ncbi_dir">include/objects</span> and
<span class="ncbi_dir">src/objects</span>
subdirectories and build the <span class="ncbi_dir">objects</span> libraries. The <span class="ncbi_dir">objects</span>
directories and libraries can also be updated separately from the rest
of the compilation, by executing <span class="ncbi_util">make</span> inside the <span class="ncbi_dir">build/objects</span>
directory. Prior to doing so however, you should always verify that your
<span class="ncbi_dir">build/bin</span> directory contains the latest version of <span class="ncbi_app">datatool</span>.&nbsp;<a NAME="makefiles"></a>
<p><br>


<h3>The project's directories and makefiles</h3>

To start a new project ("<span class="ncbi_proj">myProj</span>"), you should begin by creating
both a <span class="ncbi_dir">src</span> and an <span class="ncbi_dir">include</span> subtree for that project inside
the C++ tree. In general, all header files that will be accessed by multiple
source modules outside the project directory should be placed in the <span class="ncbi_dir">include</span>
directory. Header files that will be used solely inside the project's <span class="ncbi_dir">src</span>
directory should be placed there, along with the implementation files.
<p>In addition to the C++ source files, the <span class="ncbi_dir">src</span> subtrees contain
<span class="ncbi_term">meta-makefiles</span> named <span class="ncbi_file">Makefile*.in</span>, which are used by the
<span class="ncbi_script">configure</span> script to generate the corresponding makefiles
in the <span class="ncbi_dir">build</span> subtrees. Figure 1 shows slices of the directory structure
reflecting the correspondences between the <span class="ncbi_term">meta-makefiles</span> in the
<span class="ncbi_dir">src</span> subtrees and makefiles in the <span class="ncbi_dir">build</span> subtrees. Figure
2 is a sketch of the entire C++ tree in which these directories are defined.
<p>&nbsp;During the configuration process, each of the <span class="ncbi_term">meta-makefiles</span>
in the top-level of the
<span class="ncbi_dir">src</span> tree is translated into a corresponding
<span class="ncbi_file">Makefile*</span> in the top-level of the
<span class="ncbi_dir">build</span> tree. Then, for each
project directory containing a <span class="ncbi_file">Makefile.in</span>, the
<span class="ncbi_script">configure</span>
script will: (1) create a corresponding subdirectory of the same name in
the
<span class="ncbi_dir">build</span> tree if it does not already exist, and (2) generate a
corresponding
<span class="ncbi_file">Makefile</span> in the project's <span class="ncbi_dir">build</span> subdirectory.
The contents of the project's
<span class="ncbi_file">Makefile.in</span> in the <span class="ncbi_dir">src</span> subdirectory
determine what is written to the project's
<span class="ncbi_file">Makefile</span> in the <span class="ncbi_dir">build</span>
subdirectory. Project subdirectories that do not contain any
<span class="ncbi_file">*.in</span>
files are ignored by the <span class="ncbi_script">configure</span> script.
<p>Thus, you will also need to create a <span class="ncbi_term">meta-makefile</span> in the newly
created
<span class="ncbi_dir">src/myProj</span> directory before configuring your <span class="ncbi_dir">build</span>
directory to include the new project. The <span class="ncbi_script">configure</span> script will
then create the corresponding subtree in the
<span class="ncbi_dir">build</span> directory, along
with a new <span class="ncbi_file">Makefile</span> generated from the <span class="ncbi_file">Makefile.in</span> you created.
<center><img SRC="make.gif" >
<br><img SRC="cpptree.jpg" ></center>
<p><br>


<a NAME="make_in"></a>
<h3>Makefile.in meta files</h3>

The <span class="ncbi_file">meta-makefile myProj/Makefile.in</span> should define at least one
of the following macros:
<ul>
<li>
<a NAME="musr"></a><span class="ncbi_make_var">USR_PROJ</span> (optional) - a list of names
for user-defined makefiles.</li>

<br>This macro is provided for the usage of ordinary stand-alone makefiles
which do not utilize the <span class="ncbi_util">make</span> commands contained in additional makefiles
in the top-level <span class="ncbi_dir">build</span> directory. Each <span class="ncbi_value">p_i</span> listed in <span class="ncbi_value">USR_PROJ = p_1 ... p_N</span> must have a corresponding
<a href="#usr_make" class="ncbi_file">Makefile.p_i</a>
in the project's source directory. When <span class="ncbi_util">make</span> is executed, the <span class="ncbi_util">make</span>
directives contained in these files will be executed directly to build
the targets as specified.
<br>&nbsp;
<br>&nbsp;
<li>
<a NAME="mlib"></a><span class="ncbi_make_var">LIB_PROJ</span> (optional) - a list of names
for library makefiles.</li>

<br>For each library <span class="ncbi_value">l_i</span> listed in <span class="ncbi_value">LIB_PROJ = l_1 ... l_N</span>,
you must have created a corresponding project makefile named <a href="#lib_make" class="ncbi_file">Makefile.l_i.lib</a>
in the project's source directory. When <span class="ncbi_util">make</span> is executed, these
library project makefiles will be used along with <span class="ncbi_file">Makefile.lib</span> and
<span class="ncbi_file">Makefile.lib.tmpl</span> (located in the top-level of the <span class="ncbi_dir">build</span>
tree) to build the specified libraries.
<br>&nbsp;
<br>&nbsp;
<li>
<a NAME="mapp"></a><span class="ncbi_make_var">APP_PROJ</span> (optional) - a list of names
for application makefiles.</li>

<br>Similarly, each application (<span class="ncbi_value">p1, p2, ..., pN</span>) listed under <span class="ncbi_make_var">APP_PROJ</span>
must have a corresponding project makefile named <a href="#app_make" class="ncbi_file">Makefile.p*.app</a>
in the project's source directory. When <span class="ncbi_util">make</span> is executed, these
application project makefiles will be used along with <span class="ncbi_file">Makefile.app</span>
and <span class="ncbi_file">Makefile.app.tmpl</span> to build the specified executables.
<br>&nbsp;
<br>&nbsp;
<li>
<a NAME="msub"></a><span class="ncbi_make_var">SUB_PROJ</span> (optional) - a list of names
for subproject directories (used on recursive makes).</li>

<br>The <span class="ncbi_make_var">SUB_PROJ</span> macro is used to recursively define <span class="ncbi_util">make</span>
targets; items listed here define the subdirectories rooted in the project's
source directory where <span class="ncbi_util">make</span> should also be executed.</ul>
The <span class="ncbi_file">Makefile.in</span> meta file in the project's source directory defines
a kind of road map that will be used by the <span class="ncbi_script">configure</span> script to
generate a makefile (<span class="ncbi_file">Makefile</span>) in the corresponding directory of
the <span class="ncbi_dir">build</span> tree. <span class="ncbi_file">Makefile.in</span> does <em>not</em> participate in
the actual execution of <span class="ncbi_util">make</span>, but rather, defines what will happen
at that time by directing the <span class="ncbi_script">configure</span> script in the creation of
the <span class="ncbi_file">Makefile</span> that <em>will</em> be executed (see also the Reference
Manual's description of <a href="../makefiles.html#ref_MakefilesTargets">Makefile
targets</a>).
<p><br>

<a NAME="example"></a>
<h3>An example <span class="ncbi_term">meta-makefile</span> and its associated project makefiles</h3>

A simple example should help to make this more concrete. Assuming that
<span class="ncbi_proj">myProj</span> is used to develop an application named <span class="ncbi_proj">myProj</span>,
<span class="ncbi_file">myProj/Makefile.in</span>
should contain the following:

<blockquote>
<pre class="ncbi_code">
####### Example: src/myProj/Makefile.in

APP_PROJ = myProj

srcdir = @srcdir@
include @builddir@/Makefile.meta
</pre>
</blockquote>

The last two lines in <span class="ncbi_file">Makefile.in</span> should always be exactly as shown
here. These two lines specify <span class="ncbi_util">make</span> variable templates using the
<span class="ncbi_conf_var">@var_name@</span> syntax. When generating the corresponding <span class="ncbi_file">Makefile</span>
in the <span class="ncbi_dir">build</span> directory, the <span class="ncbi_script">configure</span> script will substitute
each identifier name bearing that notation with full path definitions.
<p>The corresponding <span class="ncbi_file">Makefile</span> in <span class="ncbi_dir">build/myProj</span> generated by
the <span class="ncbi_script">configure</span> script for this example will then contain:

<blockquote>
<pre class="ncbi_code">
####### Example: myBuild/build/myProj/Makefile

# Generated automatically from Makefile.in by configure.

APP_PROJ = myProj

srcdir = /home/zimmerma/internal/c++/src/myProj
include /home/zimmerma/internal/c++/myBuild/build/Makefile.meta
</pre>
</blockquote>

As demonstrated in this example, the <span class="ncbi_conf_var">@srcdir@</span> and <span class="ncbi_conf_var">@builddir@</span>
aliases in the makefile template have been replaced with absolute paths
in the generated <span class="ncbi_file">Makefile</span>, while the definition of <span class="ncbi_make_var">APP_PROJ</span>
is copied verbatim.
<p>The only build target in this example is <span class="ncbi_proj">myProj</span>. <span class="ncbi_proj">myProj</span>
is specified as an application - not a library - because it is listed under
<span class="ncbi_make_var">APP_PROJ</span> rather than under <span class="ncbi_make_var">LIB_PROJ</span>. Accordingly, there must
also be a file named <span class="ncbi_file">Makefile.myProj.app</span> in the <span class="ncbi_dir">src/myProj</span>
directory. A project's application makefile specifies:
<ul>
<li>
<span class="ncbi_make_var">APP</span> - the name to be used for the resulting executable</li>

<li>
<span class="ncbi_make_var">OBJ</span> - a list of object files to use in the compilation</li>

<li>
<span class="ncbi_make_var">LIB</span> - a list of NCBI C++ Toolkit libraries to use in the linking</li>

<li>
<span class="ncbi_make_var">LIBS</span> - a list of other libraries to use in the linking</li>
</ul>
There may be any number of application or library makefiles for the project,
Each application should be listed under <span class="ncbi_make_var">APP_PROJ</span> and each library
should be listed under <span class="ncbi_make_var">LIB_PROJ</span> in <span class="ncbi_file">Makefile.in</span>. A suitable
application makefile for this simple example might contain just the following
text:

<blockquote>
<pre class="ncbi_code">
####### Example: src/myProj/Makefile.myProj.app

APP = myProj
OBJ = myProj
LIB = xncbi
</pre>
</blockquote>

In this simple example, the <span class="ncbi_make_var">APP_PROJ</span> definition in <span class="ncbi_file">Makefile.in</span>
is identical to the definitions of both <span class="ncbi_make_var">APP</span> and <span class="ncbi_make_var">OBJ</span> in <span class="ncbi_file">Makefile.myProj.app</span>.
This is not always the case however, as the <span class="ncbi_make_var">APP_PROJ</span> macro is used
to define which makefiles in the
<span class="ncbi_dir">src</span> directory should be used during
compilation, while <span class="ncbi_make_var">APP</span> defines the name of the resulting executable
and <span class="ncbi_make_var">OBJ</span> specifies the names of object files. (Project makefiles
for applications are described in more detail <a href="#app_make">below</a>.)&nbsp;<a NAME="exec"></a>
<p><br>


<h3>Executing <span class="ncbi_util">make</span></h3>

Given these makefile definitions, executing <span class="ncbi_cmd">make all_r</span> in the <span class="ncbi_dir">build</span>
project subdirectory indirectly causes <span class="ncbi_file">build/Makefile.meta</span> to be
executed, which sets the following chain of events in motion:
<ol>
<li>
For each <span class="ncbi_proj">proj_name</span> listed in <a href="#musr" class="ncbi_make_var">USR_PROJ</a>,
<span class="ncbi_file">Makefile.meta</span> first tests to see if <span class="ncbi_file">Makefile.proj_name</span> is
available in the current <span class="ncbi_dir">build</span> directory, and if so, executes:</li>

<blockquote>
<pre class="ncbi_cmd">
make -f Makefile.proj_name builddir="$(builddir)"
srcdir="$(srcdir)" $(MFLAGS)
</pre>
</blockquote>

Otherwise, <span class="ncbi_file">Makefile.meta</span> assumes the required makefile is in the
project's source directory, and executes:

<blockquote>
<pre class="ncbi_cmd">
make -f $(srcdir)/Makefile.proj_name builddir="$(builddir)"
srcdir="$(srcdir)" $(MFLAGS)
</pre>
</blockquote>

In either case, the important thing to note here is that the commands contained
in the project's makefiles are executed directly and are <em>not</em> combined
with additional makefiles in the top-level <span class="ncbi_dir">build</span> directory. The
aliased <span class="ncbi_make_var">srcdir</span>, <span class="ncbi_make_var">builddir</span>, and <span class="ncbi_make_var">MFLAGS</span> are still available
and can be referred to inside <span class="ncbi_file">Makefile.proj_name</span>. By default, the
resulting libraries and executables are written to the <span class="ncbi_dir">build</span> directory
only.
<li>
For each <span class="ncbi_lib">lib_name</span> listed in <a href="#mlib" class="ncbi_make_var">LIB_PROJ</a>,
<span class="ncbi_cmd">make -f $(builddir)/Makefile.lib.tmpl</span> is executed. This in turn
specifies that <span class="ncbi_file">$(builddir)/Makefile.mk</span>,
<span class="ncbi_file">$(srcdir)/Makefile.<b>lib_name</b><!--NCBI_MARK-->.lib</span>,
and <span class="ncbi_file">$(builddir)/Makefile.lib</span> should be included in the generated
makefile commands that actually get executed. The resulting libraries are
written to the <span class="ncbi_dir">build</span> subdirectory and copied to the <span class="ncbi_dir">lib</span> subtree.</li>

<li>
For each <span class="ncbi_app">app_name</span> listed in <a href="#mapp" class="ncbi_make_var">APP_PROJ</a>,
<span class="ncbi_cmd">make -f $(builddir)/Makefile.app.tmpl</span> is executed. This in turn
specifies that <span class="ncbi_file">$(builddir)/Makefile.mk</span>,
<span class="ncbi_file">$(srcdir)/Makefile.<b>app_name</b><!--NCBI_MARK-->.app</span>,
and <span class="ncbi_file">$(builddir)/Makefile.app</span> should be included in the generated
makefile commands that actually get executed. The resulting executables
are written to the <span class="ncbi_dir">build</span> subdirectory and copied to the <span class="ncbi_dir">bin</span>
subtree.</li>

<li>
For each <span class="ncbi_dir">dir_name</span> listed in <a href="#msub" class="ncbi_make_var">SUB_PROJ</a>
(on <span class="ncbi_cmd">make all_r</span>), <span class="ncbi_cmd">cd <b>dir_name</b><!--NCBI_MARK--></span> is executed and <span class="ncbi_cmd">make
all_r</span> is executed. Steps (1) - (3) are then repeated in the project
subdirectory.</li>
</ol>
More generally, for each subdirectory listed in <span class="ncbi_make_var">SUB_PROJ</span>, the <span class="ncbi_script">configure</span>
script will create a relative subdirectory inside the new <span class="ncbi_dir">build</span>
project directory, and generate the new subdirectory's <span class="ncbi_file">Makefile</span>
from the corresponding meta-makefile in the <span class="ncbi_dir">src</span> subtree. Note that
each subproject directory must also contain its own <span class="ncbi_file">Makefile.in</span>
along with the corresponding project makefiles. The recursive make commands,
<span class="ncbi_cmd">make all_r, make clean_r</span>, and <span class="ncbi_cmd">make purge_r</span> all refer to this
definition of the subprojects to define what targets should be recursively
built or removed.

<p><br>


<a NAME="usr_make"></a>
<h3><a href="../new_proj.html#ref_MakeProjUsr">Custom project makefile: Makefile.myProj</a></h3>

As described, regular makefiles contained in the project's <span class="ncbi_dir">src</span> directory
will be invoked from the <span class="ncbi_dir">build</span> directory if their suffixes
are specified in the <span class="ncbi_make_var">USR_PROJ</span> macro. This macro is originally defined
in the project's <span class="ncbi_dir">src</span> directory in the
<span class="ncbi_file">Makefile.in</span> meta file,
and is propagated to the corresponding <span class="ncbi_file">Makefile</span> in the
<span class="ncbi_dir">build</span>
directory by the <span class="ncbi_script">configure</span> script.
<p>For example, if <span class="ncbi_value">USR_PROJ = myProj</span> in the <span class="ncbi_dir">build</span> directory's
<span class="ncbi_file">Makefile</span>, executing <span class="ncbi_util">make</span> will cause <span class="ncbi_file">Makefile.myProj</span>
(the project makefile) to be executed. This project makefile may be located
in either the current <span class="ncbi_dir">build</span> directory
<em>or</em> the corresponding
<span class="ncbi_dir">src</span> directory. In either case, although the makefile is executed
directly, references to the source and object files (contained in the project
makefile) must give complete paths to those files. In the first case, <span class="ncbi_util">make</span>
is invoked as: <span class="ncbi_cmd">make -f Makefile.myProj</span>, so the makefile is located
in the current working (<span class="ncbi_dir">build</span>) directory but the source files are
not. In the second case,
<span class="ncbi_util">make</span> is invoked as: <span class="ncbi_cmd">make -f $(srcdir)/Makefile.myProj</span>,
so both the project makefile <em>and</em> the source files are non-local.
For example:

<blockquote>
<pre class="ncbi_code">

####### Makefile.myProj

include $(NCBI)/ncbi.mk
CC = $(NCBI_CC)                 # use the NCBI default compiler for this platform
INCPATH = $(NCBI_INCDIR)        # along with the default include 
LIBPATH = $(NCBI_LIBDIR)        # and library paths

all: $(srcdir)/myProj.c
        $(CC) -o myProj $(srcdir)/myProj.c $(NCBI_CFLAGS) -I($INCPATH) \
        -L($LIBPATH) -lncbi
        cp -p myProj $(builddir)/bin

clean:
        -rm  myProj myProj.o

purge: clean
        -rm  $(builddir)/bin/myProj
</pre>
</blockquote>

will cause the C program <span class="ncbi_proj">myProj</span> to be built directly from <span class="ncbi_file">Makefile.myProj</span>
using the default C compiler, library paths, include paths, and compilation
flags defined in <span class="ncbi_file">ncbi.mk</span>. The executables and libraries generated
from the targets specified in <span class="ncbi_make_var">USR_PROJ</span> are by default written to
the current <span class="ncbi_dir">build</span> directory only. In this example however, they
are also explicitly copied to the <span class="ncbi_dir">bin</span> directory, and accordingly,
the <span class="ncbi_conf_flag">purge</span> directives also remove the copied executable.
<p><br>


<a NAME="lib_make"></a>
<h3><a href="../new_proj.html#ref_MakeProjLib">Library project makefile: Makefile.myProj.lib</a></h3>

<span class="ncbi_file">Makefile.<b>lib_name</b><!--NCBI_MARK-->.lib</span> should contain the following macro
definitions:
<ul>
<li>
<span class="ncbi_make_var">$(SRC)</span> - the names of all source files to compile and include
in the library</li>

<li>
<span class="ncbi_make_var">$(OBJ)</span> - the names of any pre-compiled object files to include
in the library</li>

<li>
<span class="ncbi_make_var">$(LIB)</span> - the name of the library being built</li>
</ul>
In addition, any of the make variables defined in <span class="ncbi_file">build/Makefile.mk</span>,
such as <span class="ncbi_make_var">$CPPFLAGS</span>, <span class="ncbi_make_var">$LINK</span>, etc., can be referred to and/or redefined in the project makefile, e.g.:

<blockquote>
<pre class="ncbi_code">
CFLAGS   = $(ORIG_CFLAGS)   -abc -DFOOBAR_NOT_CPLUSPLUS
CXXFLAGS = $(ORIG_CXXFLAGS) -xyz
CPPFLAGS = $(ORIG_CPPFLAGS) -UFOO -DP1_PROJECT -I$(NCBI_C_INCLUDE)
LINK     = purify $(ORIG_LINK)
</pre>
</blockquote>

For a simple example, see <a href="../lxr/source/src/corelib/Makefile.corelib.lib">Makefile.corelib.lib</a>,
and for additional documentation, refer to the <a href="../new_proj.html#ref_MakeProjLib">Reference
Manual</a> section. This customized makefile can be used to build both
static and dynamic(DLL) versions of the library. To build as a DLL on the
appropriate platforms, you can explicitly specify:
<blockquote><pre class="ncbi_code">LIB_OR_DLL = dll</pre></blockquote>

Conversely, if you want the library to always be built as static, specify:
<blockquote><pre class="ncbi_code">LIB_OR_DLL = lib</pre></blockquote>

<p><br>


<a NAME="app_make"></a>
<h3><a href="../new_proj.html#ref_MakeProjApp">Application project makefile:
Makefile.myProj.app</a></h3>

<span class="ncbi_file">Makefile.<b>app_name</b><!--NCBI_MARK-->.app</span> should contain the following macro
definitions:
<ul>
<li>
<span class="ncbi_make_var">$(SRC)</span> - the names of the object modules to build and link to the
application</li>

<li>
<span class="ncbi_make_var">$(OBJ)</span> - the names of any pre-compiled object files to include
in the linking</li>

<li>
<span class="ncbi_make_var">$(LIB)</span> - specific libraries in the NCBI C++ Toolkit to include in
the linking</li>

<li>
<span class="ncbi_make_var">$(LIBS)</span> - all other libraries to link to (outside the C++ Toolkit)</li>

<li>
<span class="ncbi_make_var">$(APP)</span> - the name of the application being built</li>
</ul>
For example, if C Toolkit libraries should also be included in the linking,
use:
<blockquote>
<pre class="ncbi_code">
LIBS = $(NCBI_C_LIBPATH) -lncbi $(ORIG_LIBS)</pre></blockquote>

The project's application makefile can also redefine the compiler and linker,
along with other flags and tools affecting the build process, as described
above for <span class="ncbi_file">Makefile.*.lib</span> files, For an example, see <a href="../lxr/source/src/corelib/test/Makefile.coretest.app">Makefile.coretest.app</a>.
For additional documentation refer also to the <a href="../new_proj.html#ref_MakeProjApp">Reference
Manual</a> section.
<p><br>


<a NAME="config"></a>
<h3>The <span class="ncbi_script">configure</span> scripts</h3>

A number of compiler-specific wrappers for different platforms are described
in the
<a href="../config.html#ref_Wrappers">Reference Manual</a>. Each
of these wrappers performs some pre-initialization for the tools and flags
used in the <span class="ncbi_script">configure</span> script before running it. The compiler-specific wrappers are in the <a href="../lxr/source/compilers/" class="ncbi_dir">c++/compilers</a>
directory. The <span class="ncbi_script">configure</span> script serves two very different types
of function: (1) it tests the selected compiler and environment for a multitude
of features and generates <span class="ncbi_keyword">#include</span> and
<span class="ncbi_keyword">#define</span> statements
accordingly, and (2) it reads the <span class="ncbi_file">Makefile.in</span> files in the <span class="ncbi_dir">src</span>
directories and creates the corresponding <span class="ncbi_dir">build</span> subtrees and makefiles
accordingly.
<p>Frequently during development it is necessary to make minor adjustments
to the
<span class="ncbi_file">Makefile.in</span> files, such as adding new projects or subprojects
to the list of targets. In these contexts however, the compiler, environment,
and source directory structures remain unchanged, and <span class="ncbi_script">configure</span>
is actually doing much more work than is necessary. In fact, there is even
some risk of failing to re-create the same configuration environment if
the user does not exactly duplicate the same set of configure flags when
re-running <span class="ncbi_script">configure</span>. In these situations, it is preferable to run
an auxilliary script named <a href="../config.html#ref_Reconf" class="ncbi_script">config.status</a>,
located at the top level of the
<span class="ncbi_dir">build</span> directory in a subdirectory
named <span class="ncbi_dir">status</span>.
<p>In contrast, changes to the <span class="ncbi_dir">src</span> directory structure, or the addition/deletion
of <span class="ncbi_file">Makefile.in</span> files, all require re-running the <span class="ncbi_script">configure</span>
script, as these actions require the creation/deletion of subdirectories
in the <span class="ncbi_dir">build</span> tree and/or the creation/deletion of the associated
<span class="ncbi_file">Makefile</span> in those directories.

<p><i><a href="sub_tree.html">previous&nbsp;</a></i><!--NCBI_MARK-->&nbsp;&nbsp;
<i><a href="../index.html">up&nbsp;</a></i><!--NCBI_MARK-->&nbsp;&nbsp;&nbsp;
<i><a href="objects.html">next</a></i><!--NCBI_MARK-->

<!--#include virtual="../ssi/navlinks.shtml" -->

<table BORDER=0 CELLSPACING=0 WIDTH="100%" >
<tr>
<td>
<address>
<a href="mailto:cpp-core@ncbi.nlm.nih.gov">Diane Zimmerman</a></address>
</td>

<td><!-- <td align=center><span class="ncbi_cvs_rev">$Revision$</span></td> --></td>

<td ALIGN=RIGHT><span class="ncbi_cvs_date">$Date$</span></td>
</tr>
</table>

<!--#include virtual="../ssi/footer.shtml" -->
