<!--#set var="TITLE" value="Working with the serializable object classes" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->

<h1>
Working with the serializable object classes</h1>

<ul>
<li><a href="#intro">Introduction</a></li>
<li><a href="#locate">Locating and browsing serializable objects in the C++
Toolkit</a></li>
<li><a href="#base"><span class="ncbi_term">Base classes</span> and <span class="ncbi_term">user classes</span></a></li>
<li><a href="#methods">Adding methods to the <span class="ncbi_term">user classes</span></a></li>
</ul>

<p><br>

<a NAME="intro"></a>
<h3>Introduction</h3>

All of the ASN.1 data types defined in the C Toolkit have been re-implemented
in the C++ Toolkit as serializable objects. Header files for these classes
can be found in the <a href="../lxr/source/include/objects/" class="ncbi_dir">include/objects</a>
directories, and their implementations are located in the <a href="../lxr/source/src/objects/" class="ncbi_dir">src/objects</a>
directories.&nbsp; and
<p>The implementation of these classes as serializable objects has a number
of implications. It must be possible to use expressions like: <span class="ncbi_ccode">instream
>> myObject</span> and <span class="ncbi_ccode">outstream &lt;&lt; myObject,&nbsp;</span> where specializations
are entailed for the <span class="ncbi_term">serial format</span> of the iostreams (ASN.1, XML,
etc.) , as well as for the internal structure of the object.&nbsp; The
C++ Toolkit deploys several <a href="objstream.html">object stream
classes</a> that specialize in various formats, and which know how to access
and apply the <a href="typeinfo.html">type information </a> that
is associated with the serializable object.
<p>The type information for each class is defined in a separate static
<a href="typeinfo.html#ctypeinfo" class="ncbi_class">CTypeInfo</a>
object, which can be accessed by all instances of that class.&nbsp; This
is a very powerful device, which allows for the implementation of many
features generally found only in languages which have built-in class reflection.&nbsp;
Using the Toolkit's serializable objects will require some&nbsp; familiarity
with the usage of this type information, and several sections of this manual
cover these topics (see <a href="typeinfo.html"><span class="ncbi_term">Runtime Object Type
Information</span> </a>for a general discussion).
<p><br>

<a NAME="locate"></a>
<he>Locating and browsing serializable objects in the C++ Toolkit</h3>

The top level of the <a href="../lxr/source/include/objects/" class="ncbi_dir">include/objects</a>
subtree is a set of subdirectories, where each subdirectory includes the
public header files for a separately compiled library. Similarly, the <a href="../lxr/source/src/objects/" class="ncbi_dir">src/objects</a>
subtree includes a set of subtrees containing the source files for these
libraries. Finally, your <span class="ncbi_dir">build/objects</span> directory will contain a
corresponding set of build subtrees where these libraries are actually
built.
<p>If you checked out the entire C++ CVS tree,&nbsp; you may be surprised
to find that initially, the&nbsp; <span class="ncbi_dir">include/objects</span> subtrees are empty,
and the subdirectories in the <span class="ncbi_dir">src/objects</span> subtree contain only ASN.1
modules. This is because both the header files and source files are
auto-generated from the ASN.1 specifications by the <a href="../tools/datatool/datatool.html" class="ncbi_app">datatool</a>
program. As described in <a href="inside_tree.html">Working within the
C++ source tree</a>, you can build everything by running
<span class="ncbi_cmd">make all_r</span> in
the build directory.
<p><span class="ncbi_note">Note:</span> If you would like to have the <span class="ncbi_lib">objects</span>
libraries built locally, you <em>must</em> use the <span class="ncbi_conf_flag">--with-objects</span>
flag when running the <span class="ncbi_script">configure</span> script.
<p>You can also access the pre-generated serializable objects in the public
area, using the source browsers to locate the objects you are particularly
interested in. For example, if you are seeking the new class definition
for the <span class="ncbi_term">Bioseq struct</span> defined in the C Toolkit, you can search for
the <span class="ncbi_class">CBioseq</span> class, using either the <a href="../lxr/ident/">LXR</a>
identifier search tool, or the DOC++ <a href="../docxx/HIER.html">class
hierarchy</a> browser. Starting with the name of the data object as it
appears in the ASN.1 module, two simple rules apply in deriving the new
C++ class name:
<ol>
<li>
The one letter 'C' (for class) prefix should precede the ASN.1 name</li>

<li>
All hyphens ('-') should be replaced by underscores ('_')</li>
</ol>
For example, <span class="ncbi_term">Seq-descr </span> becomes <span class="ncbi_class">CSeq_descr</span>.
<p><br>

<a NAME="base"></a>
<h3><span class="ncbi_term">Base classes </span>and <span class="ncbi_term">user classes</span></h3>

The classes whose names are derived in this manner are called the <span class="ncbi_term">user
classes</span>, and each also has a corresponding <span class="ncbi_term">base class </span>implementation.
The name of the <span class="ncbi_term">base class</span> is arrived at by appending <span class="ncbi_value">"_Base"</span>
to the <span class="ncbi_term">user class</span> name.&nbsp; Most of the <span class="ncbi_term">user classes </span>are
empty wrapper classes that do not bring any new functionality or data members
to the inherited <span class="ncbi_term">base class</span>; they are simply provided as a platform
for development. In contrast, the <span class="ncbi_term">base classes</span> are <em>not</em> intended
for public use (other than browsing), and should never be modified.
<p>More generally, the <span class="ncbi_term">base classes</span> should <em>never</em> be instantiated
or accessed directly in an application. The relation between the two source
files and the classes they define reflects a general design used in developing
the object libraries: the base class files are auto-generated by
<a href="../tools/datatool/datatool.html" class="ncbi_app">datatool</a>
according to the ASN.1 specifications in the <span class="ncbi_dir">src/objects</span> directories;
the inherited class files (the so-called <span class="ncbi_term">user classes</span>) are intended
for developers who can extend these classes to support features above and
beyond the ASN.1 specifications.
<p>Many applications will involve a "tangled hierarchy" of these objects,
reflecting the complexity of the real world data that they represent.&nbsp;
For example, a <span class="ncbi_class">CBioseq_set</span> contains a list of <span class="ncbi_class">CSeq_entry</span>
objects, where each <span class="ncbi_class">CSeq_entry</span> is, in turn, a
<a href="choice.html">choice</a>
between a <span class="ncbi_class">CBioseq</span> and a <span class="ncbi_class">CBioseq_set</span>.
<p>Given the potential for this complexity of interactions, a critical
design issue becomes how one can ensure that methods which may have been
defined only in the <span class="ncbi_term">user class</span> will be available for all instances
of that class. In particular, these instances may occur as contained elements
of another object which is compiled in a different library.&nbsp; These
inter-object dependencies are the motivation for the <span class="ncbi_term">user classes</span>.
As depicted schematically below, all references to external objects which
occur inside the <span class="ncbi_term">base classes</span>, access external <span class="ncbi_term">user classes</span>,
so as to include any methods which may be defined only in the <span class="ncbi_term">user classes</span>:
<center><img SRC="user_base.gif" height=216 width=540></center>
In most cases, adding non-virtual methods to a <span class="ncbi_term">user class</span>
will <em>not</em> require re-compiling any libraries except the one which
defines the modified object. Note however, that addiing non-static
data members and/or <span class="ncbi_keyword">virtual</span> methods to the <span class="ncbi_term">user classes</span> <em>will change</em> the class layouts, and in these cases only, 
will entail recompiling any external library objects which access these classes.

<p><br>

<a NAME="methods"></a>
<h3>Adding methods to the <span class="ncbi_term">user classes</span></h3>

<span class="ncbi_note">Note:</span> This section describes the steps currently
required to add new methods to the <span class="ncbi_term">user classes</span>.
It is subject to change, and there is no guarantee the material here is up-to-date.
In general, it is not recommended practice to add methods to the <span class="ncbi_term">user
classes</span>, unless your purpose is to extend these classes across all
applications as part of a development effort.

<h4>Checking out source code, configuring the working environment, building
the libraries.</h4>

<ol>
<li>
Create a working directory (e.g. <span class="ncbi_dir">Work</span>)
and check out the C++ tree to that directory:, using either <a href="../new_proj.html#ref_Checkout">cvs checkout</a> or the shell script, <span class="ncbi_cmd">cvs_core.sh &lt;dirname></span>.</li>

<br>&nbsp;
<li>
<a href="../config.html#ref_Running">Configure</a>
the environment to work inside this tree using one of the configure <a href="../config.html#ref_Wrappers">scripts</a>,
according to the platform you will be working on. Be sure to include
the <span class="ncbi_conf_flag">--with-objects</span> flag in invoking the <span class="ncbi_script">configure</span> script.</li>

<br>&nbsp;
<li>
Build the <span class="ncbi_lib">xncbi</span>, <span class="ncbi_lib">xutil</span>&nbsp; and <span class="ncbi_lib">xser</span> libraries, 
and run <span class="ncbi_app">datatool</span> to create the objects header and 
source files, and build all of the object module libraries:
<blockquote>
<pre class="ncbi_cmd">
<p>cd <i>path_to_compile_dir</i>/build/corelib</p>
<p>make</p>
<p>cd <i>path_to_compile_dir</i>/build/util</p>
<p>make</p>
<p>cd <i>path_to_compile_dir</i>/build/serial</p>
<p>make all_r # might as well build datatool and avoid possible version skew </p>
<p>cd <i>path_to_compile_dir</i>/build/connect</p>
<p>make # needed for a few projects </p>
<p>cd <i>path_to_compile_dir</i>/build/objects</p>
<p>make all_r</p>
</pre>
<p>Here <i>path_to_compile_dir </i>is set to the compile work directory which 
depends on the compiler settings (e.g: ~/Work/internal/GCC-Debug). In addition to creating the header and source files, using <span class="ncbi_cmd">make all_r
</span>(instead
of just <span class="ncbi_util">make</span>) will build all the libraries. All libraries that are
built are also copied to the <span class="ncbi_dir">lib</span> dir, e.g.: <span class="ncbi_dir">~/Work/internal/c++/GCC-Debug/lib</span>.
Similarly, all executables (such as <span class="ncbi_app">asn2asn</span>) are copied to the bin
dir, e.g.: <span class="ncbi_dir">~/Work/internal/c++/GCC-Debug/bin</span>.</blockquote>

</ol>
You are now ready to edit the user class files and add methods.

<h4>Adding methods</h4>

As an example, suppose that we would like to&nbsp; add a method to the
<span class="ncbi_class">CSeq_inst</span>
class to calculate sequence length, e.g.: <span class="ncbi_func">CSeq_inst::CalculateLength()</span>.
We begin by adding a declaration of this method to the public section of
the user class definition in <span class="ncbi_file">Seq_inst.hpp</span>:

<blockquote>
<pre class="ncbi_code">class CSeq_inst : public CSeq_inst_Base
{
public:
    CSeq_inst(void);
    ~CSeq_inst(void);

    static CSeq_inst* New(void) 
        {
            return new CSeq_inst(eCanDelete);
        }

    int CalculateLength() const;

protected:
    CSeq_inst(ECanDelete);
};
</pre></blockquote>

and in the source file, <span class="ncbi_file">Seq_inst.cpp</span>, we implement

<blockquote>
<pre class="ncbi_code">int CSeq_inst::CalculateLength() const
{
    // implementation goes here
}
</pre>
</blockquote>

These files are in the <a href="../lxr/source/include/objects/seq" class="ncbi_dir">include/objects/seq</a>
and <a href="../lxr/source/src/objects/seq" class="ncbi_dir">src/objects/seq
</a> subdirectories,
respectively. Once you have made the modifications to the files, you need
to recompile the <span class="ncbi_lib">seq</span> library,<span class="ncbi_lib"> libseq.a</span>, i.e.:

<blockquote>
<pre class="ncbi_cmd">cd <i>path_to_compile_dir</i>/build/objects/seq
make
</pre>
</blockquote>

<p>Here <i>path_to_compile_dir</i> is set to the compile work directory which depends on the compiler settings (e.g: ~/Work/internal/GCC-Debug). The new method can now be invoked from within a <span class="ncbi_class">CBioseq</span> object
as: <span class="ncbi_ccode">myBioseq.GetInst().CalculateLength().</span>
<p>The key issue that determines whether or not you will need to rebuild
any <span class="ncbi_term">external</span> libraries that use the modified user class involves
the class layout in memory.  All of the external libraries which reference
the object refer to the class layout that existed prior to the changes
you have made. Thus, if your modifications do <em>not</em> affect the class
layout, you do not have to rebuild any external libraries.  Changes
that <em>do</em> affect memory mapping include:
<ul>
<li>
The addition of new, non-static data members</li>

<li>
The addition of virtual methods</li>
</ul>
If you have added either of the above to the <span class="ncbi_term">user class</span>, then you
will need to identify all external objects which use your object, and recompile
the libraries in which these objects are defined.

<p><a href="inside_tree.html"><i>previous</i>&nbsp;</a>&nbsp;&nbsp; <i><a href="../index.html">up&nbsp;</a></i><!--NCBI_MARK--><!-- a href=".html"> <i>next</a></i-->


<!--#include virtual="../ssi/navlinks.shtml" -->

<table BORDER=0 CELLSPACING=0 WIDTH="100%" >
<tr>
<td>
<address>
<a href="mailto:cpp-core@ncbi.nlm.nih.gov">Diane Zimmerman</a></address>
</td>

<td><!-- <td align=center><i>$Revision$</i><!--NCBI_MARK--></td> --></td>

<td ALIGN=RIGHT><span class="ncbi_cvs_date">$Date$</span></td>
</tr>
</table>

<!--#include virtual="../ssi/footer.shtml" -->