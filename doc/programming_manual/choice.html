<!--#set var="TITLE" value="Choice objects in the NCBI C++ Toolkit" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->

<h1>Choice objects in the NCBI C++ Toolkit</h1>

<ul>
<li>
<a href="#intro">Introduction</a></li>

<li>
<a href="#cppchoice">C++ choice objects&nbsp;</a><!--li> <a href="#typeinfo"> Type information for choice objects </a--></li>
</ul>
<a NAME="intro"></a>
<h3>
Introduction</h3>
The <i><a href="../tools/datatool/datatool.html">datatool</a></i> program
processes the ASN.1 specification files (<i>*.asn</i>) in the <i><a href="../lxr/source/src/objects/">src/objects/</a></i>directories
to generate the associated C++ class definitions. The corresponding program
implemented in the C Toolkit, <i>asntool</i>, used the ASN.1 specifications
to generate C enums, structs, and functions. In contrast, <i>datatool</i>
must generate C++ enums, classes and methods. In addition, for each defined
object type, <i>datatool</i> must also generate the associated <a href="typeinfo.html">type
information</a> method or function.
<p>There is a significant difference in how these two tools implement ASN.1
<i>choice</i>
elements. As an example, consider the following ASN.1 specification:
<pre>
Object-id ::= CHOICE {
    id INTEGER,
    str VisibleString
}</pre>
The ASN.1 <i>choice</i> element specifies that the corresponding object
may be any <i>one</i> of the listed types. In this case, the possible types
are an integer and a string. The approach used in
<i>asntool</i> was to
implement all choice objects as <i>ValNode</i>s, which were in turn defined
as:
<pre>
typedef struct valnode {
    unsigned choice;
    DataVal data;
    struct valnode *next;
} ValNode;
</pre>
The <i>DataVal</i> field is a <i>union,</i> which may directly store numerical
values, or alternatively, hold a <i>void</i> pointer to a character string
or C <i>struct</i>. Thus, to process a <i>choice</i> element in the C Toolkit,
one could first retrieve the <i>choice</i> field to determine how the data
should be interpreted, and subsequently, retrieve the data via the
<i>DataVal</i>
field. In particular, no explicit implementation of individual choice objects
was used, and it was left to functions which manipulate these elements
to enforce logical consistency and error checking for legitimate values.
A C <i>struct</i> which included a <i>choice</i> element as one of its
fields merely had to declare that element as type <i>ValNode</i>. This
design was further complicated by the use of a <i>void</i> pointer to store
non-primitive types such as
<i>struct</i>s or character strings.
<p>In contrast, the C++ <i>datatool</i> implementation of <i>choice</i>
elements defines a class with built-in, automatic error checking for each
<i>choice</i>
object. The usage of <a href="cref.html#cref">smart pointers,</a> in combination
with the <i><a href="cref.html#cobject">CObject</a></i> class hierarchy
(and the associated <a href="typeinfo.html">type information </a>methods)
solves many of the problems associated with working with <i>void</i> pointers.
<p><a NAME="cppchoice"></a>
<h3>
C++ choice objects</h3>
The classes generated by <i>datatool</i> for <i>choice</i> elements all
have the following general structure:
<pre>
class C[AsnChoiceName] : public CObject
{

public:
    ...                                 // constructors and destructors

    DECLARE_INTERNAL_TYPE_INFO();       // declare GetTypeInfo() method
    enum E_Choice {                     // enumerate the class names
       e_not_set,                       // for the choice variants
       e_Xxx,
       ...
    };

    typedef CXxx TXxx;                  // typedef each variant class
    ...

    virtual void Reset(void);           // reset selection to none
    E_Choice Which(void) const;         // return m_choice
    void Select(E_Choice index,         // change the current selection
                EResetVariant reset);

    static string SelectionName(E_Choice index);

    bool IsXxx(void) const;             // true if m_choice == eXxx
    CXxx&amp; GetXxx(void);
    const CXxx&amp; GetXxx(void) const;
    CXxx&amp; SetXxx(void);
    void SetXxx(const CRef&lt;CXxx>&amp; ref);
    ...

private:

    E_Choice m_choice;                  // choice state
    union {
       TXxx m_Xxx;
       ...
    };
    CObject *m_object;                  // variant's data
    ...
};
</pre>

For the above ASN.1 specification, <i>datatool</i> generates a class named
<i>CObject_id</i>,
which is derived from <i><a href="cref.html#cobject">CObject</a></i>. For
each choice variant in the specification, an enumerated value (in <i>E_Choice</i>),
and an internal <i>typedef</i> are defined, and a declaration in the <i>union</i>
data member is made. For this example then, we would have:
<pre>
enum E_Choice {
   e_not_set,
   e_Id,
   e_Str
};
...

typedef int TId;
typedef string TStr;
...

union {
   TId m_Id;
   string *m_string;
};
</pre>

In this case both of the choice variants are C++ built-in types. More generally
however, the choice variant types may refer to any type of object. For
convenience, we refer to their C++ type names here as "CXxx",
<p>Two private data members store information about the currently selected
choice variant:
<i>m_choice</i> holds the <i>enum</i> value, and <i>m_Xxx</i>
holds (or points to a <i>CObject</i> containing) the variant's data. The
choice object's member functions provide access to these two data members.
<i>Which()</i> returns the currently selected variant's <i>E_Choice enum</i>
value. Each choice variant has its own <i>Get()</i> and <i>Set()</i> methods.
Each <i>GetXxx()</i> method throws an exception if the variant type for
that method does not correspond to the current selection type. Thus, it
is not possible to unknowingly retrieve the incorrect type of choice variant.
<p><i>Select(e_Xxx)</i> uses a <i>switch(e_Xxx)</i> statement to initialize
<i>m_Xxx</i>
appropriately, sets <i>m_choice</i> to <i>e_Xxx</i>, and returns. Two <i>SetXxx()</i>
methods are defined, and both use this <i>Select()</i> method. <i>SetXxx()</i>
with no arguments calls <i>Select(e_Xxx)</i> and returns <i>m_Xxx</i> (as
initialized by <i>Select()</i>).&nbsp; <i>SetXxx(TXxx&amp; value)</i>
also calls <i>Select(e_Xxx)</i> but resets <i>m_Xxx</i> to <i>value</i>
before returning.
<p>Some example choice objects in the C++ Toolkit are:
<ul>
<li>
<i><a href="../docxx/CDate.html">CDate</a></i></li>

<li>
<i><a href="../docxx/CInt_fuzz.html">CInt_fuzz</a></i></li>

<li>
<i><a href="../docxx/CObject_id.html">CObject_id</a></i></li>

<li>
<i><a href="../docxx/CPerson_id.html">CPerson_id</a></i></li>

<li>
<i><a href="../docxx/CAnnotdesc.html">CAnnotdesc</a></i></li>

<li>
<i><a href="../docxx/CSeq_annot.html">CSeq_annot</a></i></li>
</ul>

<p>
<a href="asn.html"><i>previous</i>&nbsp;</a>&nbsp;&nbsp; 
<a href="../index.html"><i>up&nbsp;</i></a>&nbsp;&nbsp;

<hr>
<table BORDER=0 CELLSPACING=0 WIDTH="100%" >
<tr>
<td>
<address>
<a href="mailto:zimmerma@ncbi.nlm.nih.gov">Diane Zimmerman</a></address>
</td>

<td><!-- <td align=center><i>$Revision$</i></td> --></td>

<td ALIGN=RIGHT><i>$Date$</i></td>
</tr>
</table>

<!--#include virtual="../ssi/footer.shtml" -->
