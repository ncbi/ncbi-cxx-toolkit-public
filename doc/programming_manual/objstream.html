<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.75 [en] (X11; U; SunOS 5.7 sun4u) [Netscape]">
   <title>CObject[IO]Streams</title>
</head>
<body bgcolor="#FFFFFF">

<h1>
<i>CObject[IO]Streams</i></h1>

<ul>
<li>
<a href="#intro">Format Specific Streams: The <i>CObject[IO]Stream</i>
classes</a></li>

<li>
<a href="#objistr">The <i>CObjectIStream</i></a> classes</li>

<li>
<a href="#objostr">The <i>CObjectOStream</i></a> classes</li>

<li>
<a href="#objcopy">The <i>CObjectStreamCopier</i></a> classes</li>

<li>
<a href="#cback">Type-specific IO routines</a></li>

<li>
<a href="#readhooks">The <i>Read</i> hook classes</a></li>

<li>
<a href="#writehooks">The <i>Write</i> hook classes</a></li>

<li>
<a href="#copyhooks">The <i>Copy</i> hook classes</a></li>
</ul>
<a NAME="intro"></a>
<h3>
Format Specific Streams: The <i>CObject[IO]Stream</i> classes</h3>
The reading and writing of serialized data objects entails satisfying two
independent sets of constraints and specifications: (1) <i>format</i>-specific
parsing and encoding schemes, and (2)
<i>object</i>-specific internal structures
and rules of composition. The NCBI C++ Toolkit implements serial IO processes
by combining a set of <i>object stream</i> classes with an independently
defined set of
<i>data object</i> classes. These classes are implemented
in the <i>serial</i> and <i>objects</i> directories respectively.
<p>The base classes for the object stream classes are <i><a href="../docxx/CObjectIStream.html">CObjectIStream</a></i>
and <i><a href="../docxx/CObjectOStream.html">CObjectOStream</a></i>. Each
of these base classes has derived subclasses which specialize in different
formats, including XML, binary ASN.1, and text ASN.1. A simple example
program, <i><a href="xml2asn_cpp.html">xml2asn.cpp</a></i>, described in
the chapter on <i><a href="asn.html#example1">Processing serial data</a></i>,
uses these object stream classes in conjunction with a <i>CBiostruct</i>
object to translate a file from XML encoding to ASN.1 formats. In this
chapter, we consider in more detail the class definitions for object streams,
and how the <a href="typeinfo.html#ctypeinfo">type information</a> associated
with the data is used to implement serial input and output.
<p>Each object stream specializes in a serial data format and a direction
(in/out). It is not until the input and output operators are applied to
these streams, in conjunction with a specified serializable object, that
the object-specific type information comes into play. For example, if <i>instr</i>
is a
<i>CObjectIStream</i>, the statement: <i>instr >> myObject</i> invokes
a <i>Read()</i> method associated with the input stream, whose sole argument
is a <i><a href="typeinfo.html#cobjinfo">CObjectInfo</a></i> for <i>myObject</i>.
<p>Similarly, the output operators, when applied to a <i>CObjectOstream</i>
in conjunction with a serializable object, will invoke a <i>Write()</i>
method on the output stream which accesses the object's type information.
The object's type information defines what tag names and value types should
be encountered on the stream, while the <i>CObject[IO]Stream</i> subclasses
specialize the data serialization format.
<p><a NAME="objistr"></a>
<h3>
The <i><a href="../docxx/CObjectIStream.html">CObjectIStream</a></i> classes</h3>
<i>CObjectIStream</i> is a virtual base class for the <i><a href="../docxx/CObjectIStreamXml.html">CObjectIStreamXml</a></i>,
<i><a href="../docxx/CObjectIStreamAsn.html">CObjectIStreamAsn</a></i>,
and <i><a href="../docxx/CObjectIStreamAsnBinary.html">CObjectIStreamAsnBinary</a></i>
classes. As such, it has no public constructors, and its user interface
includes the following methods:
<ul>
<li>
<i><a href="#open">Open()</a></i></li>

<li>
<i><a href="#close">Close()</a></i></li>

<li>
<i><a href="#getdata">GetDataFormat()</a></i></li>

<li>
<i><a href="#readheader">ReadFileHeader()</a></i></li>

<li>
<i><a href="#read">Read()</a></i></li>

<li>
<i><a href="#readobj">ReadObject()</a></i></li>

<li>
<i><a href="#readsep">ReadSeparateObject()</a></i></li>

<li>
<i><a href="#skip">Skip()</a></i></li>

<li>
<i><a href="#skipobj">SkipObject()</a></i></li>
</ul>
<a NAME="open"></a>There are several <i>Open()</i> methods; most of these
are static class methods that return a pointer to a newly created <i>CobjectIstream</i>.
Typically, these methods are used with an
<i>auto_ptr</i>, as in:
<br>&nbsp;
<p><br>
<center>
<p><i>auto_ptr&lt;CObjectIStream> xml_in(CObjectIStream::Open(filename,
eSerial_Xml));</i></center>

<p>Here, an XML format is specified by the enumerated value <i>eSerial_Xml</i>,
defined in
<i><a href="../lxr/ident?i=ESerialDataFormat">ESerialDataFormat</a></i>.
Because these methods are static, they can be used to create a new instance
of a <i>CObjectIStream</i> subclass, <i>and</i> open it with one statement.
In this example, a <i><a href="../docxx/CObjectIStreamXml.html">CObjectIStreamXml</a></i>
is created and opened on the file <i>filename</i>.
<p>An additional non-static <i>Open()</i> method is provided, which can
only be invoked as a member function of a previously instantiated object
stream (whose format type is of course, implicit to its class). This method
takes a <i>CNcbiIstream</i> and a Boolean argument, specifying whether
or not the
<i>CNcbiIstream</i> should also be closed when the object stream
is closed:
<br>&nbsp;
<p><br>
<center>
<p><i>void Open(CNcbiIstream&amp; inStream, bool deleteInStream = false);</i></center>

<p><a NAME="close"></a><a NAME="getdata"></a><a NAME="readheader"></a>The
next three methods have the following definitions. <i>Close()</i> closes
the stream. <i>GetDataFormat()</i> returns the enumerated <i>ESerialDataFormat</i>
for the stream. <i>ReadFileHeader()</i> reads the first line from the file,
and returns it in a string. This might be used for example, in the following
context:
<pre><font color="#008080">&nbsp;&nbsp; auto_ptr&lt;CObjectIStream> in(CObjectIStream::Open(fname, eSerial_AsnText));
&nbsp;&nbsp; string type = in.ReadFileHeader();
&nbsp;
&nbsp;&nbsp; if (type.compare("Seq-entry") == 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CSeq_entry seqent;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in->Read(ObjectInfo(seqent), eNoFileHeader);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...
&nbsp;&nbsp; }
&nbsp;
&nbsp;&nbsp; else if (type.compare("Bioseq-set") == 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CBioseq_set seqset;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in->Read(ObjectInfo(seqset), eNoFileHeader);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...
&nbsp;&nbsp; }
&nbsp;&nbsp; // ...</font></pre>
The <i>ReadFileHeader()</i> method for the base <i>CObjectIStream</i> class
returns an empty string. Only those stream classes which specialize in
ASN.1 text or XML formats have actual implementations for this method.
<p><a NAME="read"></a>Several <i>Read*()</i> methods are provided for usage
in different contexts.
<i>CObjectIStream::Read()</i> should be used for
reading a top-level "root" object from a data file. For convenience, the
input operator <i>>></i>, as described above, indirectly invokes this method
on the input stream, using a <i><a href="typeinfo.html#cobjinfo">CObjectTypeInfo</a></i>
object derived from <i>myObject</i>. By default, the <i>Read()</i> method
first calls
<i>ReadFileHeader()</i>, and then calls <i>ReadObject()</i>.
Accordingly, calls to <i>Read()</i> which follow the usage of <i>ReadFileHeader()</i><b>must</b>
include the optional
<i>eNoFileHeader</i> argument.
<p><a NAME="readobj"></a><a NAME="readsep"></a>Most data objects also contain
embedded objects, and the default behavior of <i>Read()</i> is to load
the top-level object, along with all of its contained subobjects into memory.
In some cases this may require significant memory allocation, and it may
be only the top-level object which is needed by the application. The next
two methods, <i><a href="../lxr/ident?i=ReadObject">ReadObject()</a></i>and
<i><a href="../lxr/ident?i=ReadSeparateObject">ReadSeparateObject()</a></i>,
can be used to load subobjects as either persistent data members of the
root object or as temporary local objects. In contrast to <i>Read()</i>,
these methods assume that there is <i>not</i> a file header on the stream.
<p>&nbsp;As a result of executing <i>ReadObject(member)</i>, the newly
created subobject will be instantiated as a member of its parent object.
In contrast, <i>ReadSeparateObject(local)</i>, instantiates the subobject
in the local temporary variable only, and the corresponding data member
in the parent object is set to an appropriate <i>null</i> representation
for that data type. In this case, an attempt to reference that subobject
after exiting the scope where it was created generates an error.
<p><a NAME="skip"></a><a NAME="skipobj"></a>The <i>Skip()</i> and <i>SkipObject()</i>
methods allow entire top-level objects and subobjects to be "skipped".
In this case the input is still read from the stream and validated, but
no object representation for that data is generated. Instead, the data
is stored in a <i>delay</i> buffer associated with the object input stream,
where it can be accessed as needed. <i>Skip()</i> should only be applied
to top-level objects. As with the <i>Read()</i> method, the optional
<i>ENoFileHeader</i>
argument can be included if the file header has already been extracted
from the data stream. <i>SkipObject(member)</i> may be applied to subobjects
of the root object.
<p>All of the <i>Read</i> and <i>Skip</i> methods are like wrapper functions,
which define what activities take place immediately before and after the
data is actually read. How and when the data is then loaded into memory
is determined by the object itself. Each of the above methods ultimately
calls <i>objTypeInfo->ReadData()</i> or <i>objTypeInfo->SkipData()</i>,
where
<i>objTypeInto</i> is the static type information object associated
with the data object. This scheme allows the user to install type-specific
read, write, and copy hooks, which are described below. For example, the
default behavior of loading all subobjects of the top-level object can
be modified by installing appropriate read hooks which use the <i>ReadSeparateObject()</i>
and <i>SkipObject()</i> methods where needed.&nbsp;<a NAME="objostr"></a>
<h3>
The <i><a href="../docxx/CObjectOStream.html">CObjectOStream</a></i> classes</h3>
The output object stream classes mirror the <i>CObjectIStream</i> classes.
The <i>CObjectOStream</i> base class is used to derive the <i><a href="../docxx/CObjectOStreamXml.html">CObjectOStreamXml</a></i>,
<i><a href="../docxx/CObjectOStreamAsn.html">CObjectOStreamAsn</a></i>,
and <i><a href="../docxx/CObjectOStreamAsnBinary.html">CObjectOStreamAsnBinary</a></i>
classes. There are no public constructors, and the user interface includes
the following methods:
<ul>
<li>
<i>Open()</i></li>

<li>
<i>Close()</i></li>

<li>
<i>GetDataFormat()</i></li>

<li>
<i>WriteFileHeader()</i></li>

<li>
<i>Write()</i></li>

<li>
<i>WriteObject()</i></li>

<li>
<i>WriteSeparateObject()</i></li>

<li>
<i>Flush()</i></li>

<li>
<i>FlushBuffer()</i></li>
</ul>
Again, there are several <i>Open()</i> methods, which are static class
methods that return a pointer to a newly created <i>CobjectOstream</i>:
<pre><font color="#008080">&nbsp;static CObjectOStream* Open(const string&amp; fileName, ESerialDataFormat format);
&nbsp;static CObjectOStream* Open(ESerialDataFormat format,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const string&amp; fileName, unsigned openFlags = 0);
&nbsp;static CObjectOStream* Open(ESerialDataFormat format,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CNcbiOstream&amp; os, bool deleteOutStream = false);</font></pre>
The <i>Write*()</i> methods correspond to the <i>Read*()</i> methods defined
for the input streams. <i>Write()</i> first calls <i>WriteFileHeader()</i>,
and then calls <i>WriteObject()</i>.
<i>WriteSeparateObject()</i> can be
used to write a temporary object (and all of its children) to the output
stream. It is also possible to install type-specific <i>write</i> hooks.
Like the
<i>Read()</i> methods, these <i>Write()</i> methods serve as wrapper
functions that define what occurs immediately before and after the data
is actually written.
<p><a NAME="objcopy"></a>
<h3>
The <i><a href="../docxx/CObjectStreamCopier.html">CObjectStreamCopier</a></i>
classes</h3>
The <i>CObjectStreamCopier</i> class is neither an input nor an output
stream class, but a helper class, which allows one to "pass data through"
without storing the intermediate objects in memory. Its sole constructor
is:
<center>
<p><i>CObjectStreamCopier(CObjectIStream&amp; in, CObjectOStream&amp; out);</i></center>

<p>and its most important method is the <i>Copy(CObjectTypeInfo&amp;)</i>
method, which, given an object's description, reads that object from the
input stream and writes it to the output stream. The serial formats of
both the input and output object streams are implicit, and thus the translation
between two different formats is performed automatically.
<p>In keeping with the <i>Read</i> and <i>Write</i> methods of the
<i>CObjectIStream</i>
and
<i>CObjectOStream</i> classes, the <i>Copy</i> method takes an optional
<i>ENoFileHeader</i> argument, to indicate that the file header is not
available in the input and should not be generated on the output. The <i>CopyObject()</i>
method corresponds to the <i>ReadObject()</i> and
<i>WriteObject()</i>
methods.
<p>As an example, consider how the <i>Run()</i> method in&nbsp; <i><a href="xml2asn_cpp.html">xml2asn.cpp</a></i>
might be implemented differently using the <i>CObjectStreamCopier </i>class:
<p><tt><font color="#008080">int CTestAsn::Run() {</font></tt><tt><font color="#008080"></font></tt>
<p><tt><font color="#008080">&nbsp;&nbsp;&nbsp; auto_ptr&lt;CObjectIStream></font></tt>
<br><tt><font color="#008080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xml_in(CObjectIStream::Open("1001.xml",
eSerial_Xml));</font></tt><tt><font color="#008080"></font></tt>
<p><tt><font color="#008080">&nbsp;&nbsp;&nbsp; auto_ptr&lt;CObjectOStream></font></tt>
<br><tt><font color="#008080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; txt_out(CObjectOStream::Open("1001.asntxt",
eSerial_AsnText));</font></tt><tt><font color="#008080"></font></tt>
<p><tt><font color="#008080">&nbsp;&nbsp;&nbsp; CObjectStreamCopier txt_copier(*xml_in,
*txt_out);</font></tt>
<br><tt><font color="#008080">&nbsp;&nbsp;&nbsp; txt_copier.copy(CBiostruc::GetTypeInfo());</font></tt><tt><font color="#008080"></font></tt>
<p><tt><font color="#008080">&nbsp;&nbsp;&nbsp; auto_ptr&lt;CObjectOStream></font></tt>
<br><tt><font color="#008080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bin_out(CObjectOStream::Open("1001.asnbin",
eSerial_AsnBinary));</font></tt><tt><font color="#008080"></font></tt>
<p><tt><font color="#008080">&nbsp;&nbsp;&nbsp; CObjectStreamCopier bin_copier(*xml_in,
*bin_out);</font></tt>
<br><tt><font color="#008080">&nbsp;&nbsp;&nbsp; bin_copier.copy(CBiostruc::GetTypeInfo());</font></tt><tt><font color="#008080"></font></tt>
<p><tt><font color="#008080">&nbsp;&nbsp;&nbsp; return 0;</font></tt>
<br><tt><font color="#008080">}</font></tt><font color="#008080"></font>
<p>It is also possible to install type-specific <i>Copy</i> hooks. Like
the <i>Read</i> and
<i>Write()</i> methods, the <i>Copy</i> methods serve
as wrapper functions that define what occurs immediately before and after
the data is actually copied.
<p><a NAME="cback"></a>
<h3>
Type-specific I/O routines</h3>
Much of the functionality needed to read and write serializable objects
may be type-specific yet application-driven. Because the specializations
may vary with the application, it does not make sense to implement fixed
methods, yet we would like to achieve a similar kind of object-specific
behavior.
<p>To address these needs, the C++ Toolkit provides hook mechanisms, whereby
the needed functionality can be installed with the object's static class
<a href="typeinfo.html#ctypeinfo">type information</a> object. Such hooks
can be installed <i>globally</i>, where they will be applied on
<i>all</i>
streams where these events occur, or <i>locally</i>, where they will only
be applied to a selected stream.
<p>For any given object and specific stream, at most one read hook and
one write hook is "active". If <i>myObject</i> has a locally installed
read hook as well as a global read hook, then the locally installed hook
will override the global hook when a read occurs on the "local" stream.
Read events on all of the other "non-local" streams will of course, trigger
the globally installed hook. Designating multiple read/write hooks (both
local and global) for a selected object does not generate an error. Older
or less specific hooks are simply overridden by the more specific or most
recently installed hook.
<p><a NAME="readhooks"></a>
<h3>
The <i>Read</i> hook classes</h3>
All of the different contexts in which an object might be encountered on
an input stream can be reduced to four cases:
<ol>
<li>
as a stand-alone object</li>

<li>
as a data member of a containing object</li>

<li>
as a variant of a <i>choice</i> object</li>

<li>
as an element of a container</li>
</ol>
Hooks can be installed for each of the first three of these contexts, depending
on the desired level of specificity. Corresponding to these contexts, three
abstract base classes provide the foundations for deriving new <i>Read</i>
hooks:
<ul>
<li>
<i>CReadObjectHook</i></li>

<li>
<i>CReadClassMemberHook</i></li>

<li>
<i>CReadChoiceVariantHook</i></li>
</ul>
The mechanisms for installing read hooks for container elements impose
very different requirements on the implementation, and are described in
another section.
<p>Each of these base hook classes exists only to define a pure virtual
<i>Read</i>
method, which can then be implemented (in a derived subclass) to install
the desired type of read hook. If the goal is to apply the new
<i>Read</i>
method in <i>all</i> contexts, then the new hook should be derived from
the <i>CReadObjectHook</i> class, and registered with the object's static
type information object. For example, to install a new
<i>CReadObjectHook</i>
for a
<i>CBioseq</i>, one might use:
<pre><font color="#008080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CBioseq::GetTypeInfo()->SetGlobalReadObjectHook(myReadBioseqHook);</font></pre>
Alternatively, if the desired behavior is to trigger the specialized <i>Read</i>
method only when the object occurs as a data member of a particular containing
class, then the new hook should be derived from the <i>CReadClassMemberHook</i>,
and registered with that member's type information object:
<pre><font color="#008080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CBioseq::GetTypeInfo()->FindMember("Seq-inst")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ->SetGlobalReadClassMemberHook(myReadSeqinstHook);</font></pre>
Similarly, one can install a read hook that will only be triggered when
the object occurs as a choice variant:
<pre><font color="#008080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CSeq_entry::GetTypeInfo()->FindVariant("Bioseq")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ->SetGlobalReadChoiceVariantHook(myReadBioseqHook);</font></pre>
The new hook classes for these examples should be derived from <i>CReadObjectHook</i>,
<i>CReadClassMemberHook</i>,
and <i>CReadChoiceVariantHook</i>, respectively. In the first case, all
occurrences of <i>CBioseq</i> on any input stream will trigger the new
<i>Read</i>
method. In contrast, the last case installs this new <i>Read</i> method
to be triggered only when the <i>CBioseq</i> occurs as a choice variant
in a <i>CSeq_entry</i> object.
<p>All of the virtual <i>Read</i> methods take two arguments: a <i>CObjectIStream</i>
and a reference to a <i><a href="typeinfo.html#objinfo">CObjectInfo</a></i>.
For example, the <i>CReadObjectHook</i> class declares the <i>ReadObject()</i>
method as:
<pre><font color="#008080">&nbsp;&nbsp;&nbsp;&nbsp; virtual void ReadObject(CObjectIStream&amp; in,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const CObjectInfo&amp; object) = 0;</font></pre>
The <i>ReadClassMember</i> and <i>ReadChoiceVariant</i> hooks differ from
the <i>ReadObject</i> hook class, in that the second argument to the virtual
<i>Read</i>
method is an iterator, pointing to the object type information for a data
member or choice variant respectively.
<p>&nbsp;In summary, to install a read hook for an object type:
<ol>
<li>
derive a new class from the appropriate hook class:</li>

<ul>
<li>
if the target object occurs in any context, use the <i>CReadObjectHook</i>
class.</li>

<li>
if the target object occurs as a data member, use the <i>CReadClassMemberHook</i>
class.</li>

<li>
if the target object occurs as a choice variant, use the <i>CReadChoiceVariant
Hook</i> class.</li>
</ul>

<li>
implement the virtual <i>Read</i> method for the new class.</li>

<li>
install the hook, using the <i>SetGlobalReadHook()</i> or <i>SetLocalReadHook()</i>
method defined in</li>

<ul>
<li>
<i>CObjectTypeInfo</i> for a <i>CReadObjectHook</i></li>

<li>
<i>CMemberInfo</i> for a <i>CReadClassMemberHook</i></li>

<li>
<i>CVariantInfo</i> for a <i>CReadChoiceVariantHook</i></li>
</ul>
</ol>
For a good example of using a <i>CReadClassMemberHook</i> object, see the
<i><a href="../lxr/source/src/objects/asn2asn/asn2asn.cpp">asn2asn.cpp</a></i>
demo program.
<p><a NAME="writehooks"></a>
<h3>
The <i>Write</i> hook classes</h3>
The <i>Write</i> hook classes parallel the <i>Read</i> hook classes, and
again, we have three base classes:
<ul>
<li>
<i>CWriteObjectHook</i></li>

<li>
<i>CWriteClassMemberHook</i></li>

<li>
<i>CWriteChoiceVariantHook</i></li>
</ul>
These classes define the pure virtual methods:
<pre><font color="#008080">CWriteObjectHook::WriteObject(CObjectOStream&amp;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const CConstObjectInfo&amp; object) = 0;

CWriteClassMemberHook::WriteClassMember(CObjectOStream&amp;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const CConstObjectInfoMI&amp; member) = 0;

CWriteChoiceVariantHook::WriteChoiceVariant(CObjectOStream&amp;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const CConstObjectInfoCV&amp; variant) = 0;</font></pre>
Like the read hooks, your derived write hooks can be installed by invoking
the
<i>SetGlobalWriteObjectHook()</i> or <i>SetLocalWriteObjectHook()</i>
methods for the appropriate type information objects. Corresponding to
the examples for read hooks then, we would have:
<pre><font color="#008080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CBioseq::GetTypeInfo()->SetGlobalWriteObjectHook(myWriteBioseqHook);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CBioseq::GetTypeInfo()->FindMember("Seq-inst")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ->SetGlobalWriteClassMemberHook(myWriteSeqinstHook);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CSeq_entry::GetTypeInfo()->FindVariant("Bioseq")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ->SetGlobalWriteChoiceVariantHook(myWriteBioseqHook);</font></pre>
The <i><a href="../lxr/source/src/objects/asn2asn/asn2asn.cpp">asn2asn.cpp</a></i>
demo program also demonstrates the usage of the <i>CWriteClassMemberHook</i>
class.
<p><a NAME="copyhooks"></a>
<h3>
The <i>Copy</i> hook classes</h3>
As with the <i>Read</i> and <i>Write</i> hook classes, there are three
base classes which define the following <i>Copy</i> methods:
<pre><font color="#008080">CCopyObjectHook::CopyObject(CObjectStreamCopier&amp;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const CConstObjectInfo&amp; object) = 0;

CCopyClassMemberHook::CopyClassMember(CObjectStreamCopier&amp;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const CConstObjectInfoMI&amp; member) = 0;

CCopyChoiceVariantHook::CopyChoiceVariant(CObjectStreamCopier&amp;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const CConstObjectInfoCV&amp; variant) = 0;</font></pre>
Newly derived copy hooks can be installed by invoking the <i>SetGlobalCopyObjectHook()</i>
or
<i>SetLocalCopyObjectHook()</i> methods for the appropriate type information
objects.
<p><i><a href="../index.html">up&nbsp;</a></i>&nbsp;&nbsp; <a href="asn.html"><i>next</i>&nbsp;</a>
<hr>
<table BORDER=0 CELLSPACING=0 WIDTH="100%" >
<tr>
<td>
<address>
<a href="mailto:zimmerma@ncbi.nlm.nih.gov">Diane Zimmerman</a></address>
</td>

<td><!-- <td align=center><i>$Revision$</i></td> --></td>

<td ALIGN=RIGHT><i>$Date$</i></td>
</tr>
</table>
<!-- NOTES:

- Skip(TTypeInfo)
- CopyObject(TTypeInfo, CObjectStreamCopier&);

- omitted versions of Read*, Skip* that use TTypeInfo args in the descrip
-->
</body>
</html>
