<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
  <title> Traversing an ASN.1 Data Structure. </title>
</head>
<body BGCOLOR="white">

<h1> Traversing an ASN.1 Data Structure </h1>
<ul>
  <li> <a href="#locateClass"> Locating the Class Definitions </a>
  <li> <a href="#accessMember"> Accessing and Referencing Data Members </a>
  <li> <a href="#example"> Traversing an ASN.1 Biostruc </a>
  <li> <a href="#iterate"> Iterating Over Containers </a>
</ul>

<a name="locateClass"> <h3> Locating the Class Definitions </h3>
In order to traverse an ASN data object, you must first become familiar with 
the class structures and access functions which implement the object. The
example provided here involves an ASN.1 Biostruc type which is implemented
by class <i>CBiostruc.</i> <p>

The first question is: how do I locate the class definitions implementing the object
to be traversed? As mentioned previously, the source browser is of little help in this case, as the
compiled object classes are not registered in the C++ tree.  The <i>include</i> and
<i>src</i> directories are available for browsing however, in <a
href="/netopt/ncbi_tools/c++/include/objects"> <i> $NCBI/c++/include/objects </a> </i>and
<A href = "/netopt/ncbi_tools/c++/src/objects"> <i>$NCBI/c++/src/objects</a></i>. <p>

Because we are using a <i>Biostruc</i>, the first place to search is in the <i>mmdb </i>
include directories.  In the <i>mmdb1</i> directory, we find two classes: 
<a href="/netopt/ncbi_tools/c++/include/objects/mmdb1/Biostruc.hpp"> <i> Biostruc.hpp</i> </a> and
<a href="/netopt/ncbi_tools/c++/include/objects/mmdb1/Biostruc_Base.hpp"> <i> Biostruc_Base.hpp</i></a>.
As implied by the class names, <i>CBiostruc</i> inherits from <i>CBiostruc_Base</i>.  The <i> base</i>
class is where you must look for the definitions and access functions you will be using. However, it
is the inherited class (<i>CBiostruc.hpp</i>) that should be <i>#included</i> in your source files, 
and which should be instantiated by your local program variable. The inherited class's header file 
will include the base header file for you. <p>

<a name="accessMember"> <h3> Accessing and Referencing Data Members </h3>
Removing some of the implementation details of the base class, we find the <i>CBiostruc_Base</i> class 
has essentially the following structure:

<font color = "#000080"> 
<pre>
class CBiostruc_Base : public NCBI_NS_NCBI::CObject
{
public:

    // type definitions 

    typedef NCBI_NS_STD::list< NCBI_NS_NCBI::CRef< ::CBiostruc_id > > TId;
    typedef NCBI_NS_STD::list< NCBI_NS_NCBI::CRef< ::CBiostruc_descr > > TDescr;
    typedef NCBI_NS_STD::list< NCBI_NS_NCBI::CRef< ::CBiostruc_feature_set > > TFeatures;
    typedef NCBI_NS_STD::list< NCBI_NS_NCBI::CRef< ::CBiostruc_model > > TModel;
    typedef ::CBiostruc_graph TChemical_graph;

    // Get() members 

    const TId& GetId(void) const;
    const TDescr& GetDescr(void) const;
    const TChemical_graph& GetChemical_graph(void) const;
    const TFeatures& GetFeatures(void) const;
    const TModel& GetModel(void) const;

    // Set() members

    TId& SetId(void);
    TDescr& SetDescr(void);
    TChemical_graph& SetChemical_graph(void);
    TFeatures& SetFeatures(void);
    TModel& SetModel(void);

private:
    TId m_Id;
    TDescr m_Descr;
    TChemical_graph m_Chemical_graph;
    TFeatures m_Features;
    TModel m_Model;
};
</pre>
<font color = black>
With the exception of the structure's chemical graph, each of the class's private
data members is actually a <i>list</i> of references (pointers), as specified by
the type definitions. Specifically, <i> NCBI_NS_STD</i> is an alias for the <i>std</i>
namespace, so the lists are standard STL list containers whose arguments specify what
type of elements the list will hold. For example, <i>TId</i> is a list of <i>NCBI_NS_NCBI::CRef</i>
objects, where each <i>CRef</i> object points to a <i>CBiostruc_id</i>. <p>

The <i>CRef</i> class is defined in <a href="/netopt/ncbi_tools/c++/include/corelib/ncbiobj.hpp"> 
<i>corelib/ncbiobj.hpp</i></a>, and
is a template class specifically designed for capturing the parent/child relation for
entities such as <i>Cbiostruc</i> and its <i>Cbiostruc_ids</i>. The derefencing operator
applied to an element of this list, <i>*listElt</i>, will by this definition return a
<i>CBiostruc_id</i>.  Because the <i>CRef</i> class is defined in the <i> NCBI_NS_NCBI</i>
namespace, the scope operator is used to refer to it. The scope operator without a prefix
refers to the scope that is "just one level up" - i.e. the set of prevailing definitions
prior to entering the current class scope. Thus <i>::CBiostruc_id</i> refers to the class
definition occurring at the <i>same</i> level as <i>CBiostruc</i>, while
<i>CBiostruc::TId</i>, references the list type definition we have been discussing here.
<p>
In summary, each of the above <i>list</i> type definitions defines an STL list of 
pointers to the specified innermost <i>::type</i>. Thus the call to <i>GetId()</i>
returns a list which must then be iterated over and dereferenced to get the 
individual id objects. In contrast, the function <i>GetChemicalGraph()</i> returns the
object directly, as it does not involve a list or a <i>CRef</i>. <p>

In general, all objects in the NCBI libraries will have a similar structure: a set of private 
data members and a set of <i> GetXxx()</i> and <i> SetXxx()</i> member functions to access
and modify ("mutate") these data. In addition, most classes, including <i>CBiostruc</i>, have 
<i>IsSetXxx()</i> and <i>ResetXxx()</i> functions to validate and clear the data members
respectively. 

<a name="example"> <h3> Traversing an ASN.1 Biostruc </h3> 
The program <a href="traverse_cpp.html"><i>traverseBS.cpp</i></a> demonstrates
how one might read an ASN.1 data file and iterate over the components of the resulting object. 
This example opens an ASN.1 Biostruc file on a text input stream and stores the information
in a <i>CBiostruc</i>. The overloaded <i>Visit()</i> function is then used to recursively examine
<i>CBiostruc bs</i> and its components.<p>

<a href="traverse_cpp.html#visitBS">
<i>Visit(bs)</i></a> simply calls <i>Visit()</i> on each of its data members, where the data members are
accessed using <i>bs.GetXxx()</i>.  The information needed to write each of these functions -
the data member types and member function signatures - is contained in the respective header
files. For example, consulting <i>Biostruc_Base.hpp</i>, we learn that the structure's 
descriptor list can be accessed using <i>GetDescr()</i>, and that the type returned is a 
list of pointers to descriptors:
<font color = "#000080">
<pre>
     typedef NCBI_NS_STD::list< NCBI_NS_NCBI::CRef< ::CBiostruc_descr > > TDescr;
     const TDescr& GetDescr(void) const;
</pre>
<font color = black>

Consulting <i>Biostruc_desc_Base.hpp</i> in turn, we learn that this class has a <i>choice 
state</i> defining the type of value stored there as well as the method that should be
used to access that value. This leads to an implementation of 
<a href="traverse_cpp.html#visitDscr"> <i>Visit(CBiostruc::TDescr DescrList)</i></a>
that uses an iterator over its list argument and a switch statement over the 
current descriptor's choice state. 

<a name="iterate"> <h3>  Iterating Over Containers </h3> 

Most of the <i>Visit()</i> functions implemented here rely on iterators to
walk through a list of objects. The general syntax for using an iterator is:

<font color = "#000080">
<pre>
  for (ContainerType::IteratorType i = ContainerName.begin();
       i != ContainerName.end(); ++i ) {

    ObjectType ObjectName = *i;
    // ...
  }
</pre>
<font color = black>

Dereferencing the iterator is required, as the iterator is essentially 
a pointer that traverses consecutive elements of the container.
For example, to iterate over the list of descriptors in the Biostruc, we use
a container of type <i>CBiostruc::TDescr</i>, and an iterator of type <i>const_iterator</i>
to ensure that the data is not mutated in the body of the loop. Because the descriptor
list contains pointers (<i>CRefs</i>) to objects, we will actually need to dereference <i>twice</i>
to get to the objects themselves. 

<font color = "#000080">
<pre>
  for ( CBiostruc::TDescr::const_iterator i = descList.begin();
        i != descList.end(); ++i ) {

    const CBiostruc_descr& thisDescr = **i;
    // ...
  }
</pre>
<font color = black>

In traversing the descriptor list in this example, we handled each type of descriptor with an explicit
case statement. In fact however, we really only visit those descriptors whose types have 
string representations: <i>TName, TPdb_comment</i>, and <i>TOther_comment</i>. The other two 
descriptor types, <i>THistory</i> and <i>TAttribute</i>, are objects that are "visited" 
recursively, but the associated visit functions are not actually implemented (see
<a href="traverse_hpp.html"> traverseBS.hpp</a>). <p>

An alternative to this approach would have been to use an iterator that only visits those
items in a container satisfying a specified type, in this case, <i>strings</i>. 

for ( CTypeIterator<string> i = Begin(descList); i; ++i ) {} *i;

<p>
</body>

<font color = "#008000"> ?? Add something about not trying to modify the hpp files 
or specialize classes?? <font color = black><p>

<a href="asn.html"> <i> previous</i> </a>

</html>
	 <hr>
	 <table border=0 width="100%" cellspacing=0>
		<tr>
		  <td><address><a href="mailto:zimmerma@ncbi.nlm.nih.gov">Diane Zimmerman</a></address></td>
		  <!-- <td align=center><i>$Revision$</i></td> -->
		  <td align=right><i>$Date$</i></td>
	 </table>
