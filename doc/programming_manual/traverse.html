<!--#set var="TITLE" value="Traversing a Data Structure" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->

<h1>
Traversing a Data Structure</h1>

<ul>
<li>
<a href="#locateClass">Locating the Class Definitions</a></li>

<li>
<a href="#accessMember">Accessing and Referencing Data Members</a></li>

<li>
<a href="#example">Traversing a Biostruc</a></li>

<li>
<a href="#iterate">Iterating Over Containers</a></li>
</ul>
<a NAME="locateClass"></a>
<h3>
Locating the Class Definitions</h3>
In general, traversing through a class object requires that you first become
familiar with the internal class structure and member access functions
for that object.&nbsp; In this section we consider how you can access this
information in the source files, and apply it.&nbsp; The example provided
here involves a <i>Biostruc</i> type which is implemented by class <i><a href="/home/zimmerma/internal/c++/doc/docxx/CBiostruc.html">CBiostruc,</a></i>and
its base (parent) class, <a href="/home/zimmerma/internal/c++/doc/docxx/CBiostruc_Base.html"><i>CBiostruc_Base</i>.</a>
<p>The first question is: how do I locate the class definitions implementing
the object to be traversed? There are now two source browsers which you
can use. To obtain a synopsis of the class, you can search the <a href="../docxx/index.html">index
</a>or
the <a href="../docxx/HIER.html">class hierarchy </a>of the <i>Doc++</i>
browser and follow a link to the class. For example, a synopsis of the
<i><a href="../docxx/CBiostruc.html">CBiostruc</a></i>
class is readily available. From this page, you can also access the relevant
source files archived by the <i>LXR</i> browser, by following the <i><a href="../lxr/ident?i=CBiostruc">Locate
CBiostruc</a></i> link. Alternatively, you may want to access the <i>LXR</i>
engine directly by using the <i><a href="../lxr/ident?i=CBiostruc">Identifier
search</a></i> tool.
<p>Because we wish to determine which headers to include, the synopsis
displayed by the <i><a href="../lxr/ident?i=CBiostruc">Identifier
search </a></i>tool is most useful. There we find a single header file,
<i><a href="../lxr/source/include/objects/mmdb1/Biostruc.hpp">Biostruc.hpp</a>,
</i>listed
as defining the class. Accordingly, this is the header file we must include.
The <i>CBiostruc</i> class inherits from the <i>CBiostruc_Base</i> class
however, and we will need to consult that file as well to understand the
internal structure of the <i>CBiostruc</i> class. Following a link to the
parent class from the class hierarchy browser, we find the definition of
the <i><a href="../docxx/CBiostruc_Base.html">CBiostruc_Base</a></i> class.
<p>This is where we must look for the definitions and access functions
we will be using. However, it is the <i>derived</i> "user" class (<i>CBiostruc</i>)
whose header should be
<i>#include</i>'d in your source files, and which
should be instantiated by your local program variable.&nbsp; For a more
general discussion of the relationship between the base parent objects
and their derived <i>user</i> classes, see <i><a href="objects.html#base">Working
with the serializable object classes.</a></i>
<p><a NAME="accessMember"></a>
<h3>
Accessing and Referencing Data Members</h3>
Omitting some of the low-level details of the base class, we find the <i>CBiostruc_Base</i>
class has essentially the following structure:
<pre>class CBiostruc_Base : public CObject
{
public:
&nbsp;&nbsp;&nbsp; // type definitions&nbsp;
&nbsp;&nbsp;&nbsp; typedef list&lt; CRef&lt;CBiostruc_id> > TId;
&nbsp;&nbsp;&nbsp; typedef list&lt; CRef&lt;CBiostruc_descr> > TDescr;
&nbsp;&nbsp;&nbsp; typedef list&lt; CRef&lt;CBiostruc_feature_set> > TFeatures;
&nbsp;&nbsp;&nbsp; typedef list&lt; CRef&lt;CBiostruc_model> > TModel;
&nbsp;&nbsp;&nbsp; typedef CBiostruc_graph TChemical_graph;

&nbsp;&nbsp;&nbsp; // Get() members&nbsp;
&nbsp;&nbsp;&nbsp; const TId&amp; GetId(void) const;
&nbsp;&nbsp;&nbsp; const TDescr&amp; GetDescr(void) const;
&nbsp;&nbsp;&nbsp; const TChemical_graph&amp; GetChemical_graph(void) const;
&nbsp;&nbsp;&nbsp; const TFeatures&amp; GetFeatures(void) const;
&nbsp;&nbsp;&nbsp; const TModel&amp; GetModel(void) const;

&nbsp;&nbsp;&nbsp; // Set() members
&nbsp;&nbsp;&nbsp; TId&amp; SetId(void);
&nbsp;&nbsp;&nbsp; TDescr&amp; SetDescr(void);
&nbsp;&nbsp;&nbsp; TChemical_graph&amp; SetChemical_graph(void);
&nbsp;&nbsp;&nbsp; TFeatures&amp; SetFeatures(void);
&nbsp;&nbsp;&nbsp; TModel&amp; SetModel(void);

private:
&nbsp;&nbsp;&nbsp; TId m_Id;
&nbsp;&nbsp;&nbsp; TDescr m_Descr;
&nbsp;&nbsp;&nbsp; TChemical_graph m_Chemical_graph;
&nbsp;&nbsp;&nbsp; TFeatures m_Features;
&nbsp;&nbsp;&nbsp; TModel m_Model;
};</pre>

<font color="#000000">With the exception of the structure's chemical graph,
each of the class's private data members is actually a <i>list</i> of references
(pointers), as specified by the type definitions. For example, <i>TId</i>
is a list of <i><a href="cref.html#cref">CRef</a></i> objects, where each
<i>CRef</i>
object points to a <i><a href="../docxx/CBiostruc_id.html">CBiostruc_id</a></i>.
The <i>CRef</i></font><font color="#000080"> </font><font color="#000000">class</font><font color="#000080">
i</font><font color="#000000">s a type of smart pointer used to hold a
pointer to a reference-counted object. The dereferencing operator, when applied
to a (dereferenced) iterator pointing to an <i>element</i> of <i>CBiostruc::TId</i>,
e.g. <i>**CRef_i</i>, will return a <i>CBiostruc_id</i>. Thus, the call
to <i>GetId()</i> returns a list which must then be iterated over and dereferenced
to get the individual <i>CBiostruc_id</i> objects. In contrast, the function
<i>GetChemicalGraph()</i>
returns the object directly, as it does not involve a <i>list</i> or a
<i>CRef</i>.</font>
<p><font color="#000000">The <i>GetXxx()</i> and <i>SetXxx()</i> member
functions define the user interface to the class, providing methods to
access and modify ("mutate") private data. In addition, most classes, including
<i>CBiostruc</i>,
have <i>IsSetXxx()</i> and <i>ResetXxx()</i> methods to validate and clear
the data members, respectively</font><font color="#000080">.</font>
<p><a NAME="example"></a>
<h3>
<font color="#000000">Traversing a Biostruc</font></h3>
<font color="#000000">The program <i><a href="traverse_cpp.html">traverseBS.cpp</a></i>
demonstrates how one might load a serial data file and iterate over the
components of the resulting object. This example reads from a text ASN.1
Biostruc file and stores the information into a <i>CBiostruc</i> object
in memory. The overloaded <i>Visit()</i> function is then used to recursively
examine the object
<i>CBiostruc bs</i> and its components.</font>
<p><font color="#000000"><i><a href="traverse_cpp.html#visitBS">Visit(bs)</a></i>
simply calls <i>Visit()</i> on each of the
<i>CBiostruc</i> data members,
which are accessed using <i>bs.GetXxx()</i>. The information needed to
write each of these functions - the data member types and member function
signatures - is contained in the respective header files. For example,
looking at
<i><a href="../lxr/source/include/objects/mmdb1/Biostruc_.hpp#L65">Biostruc_.hpp</a></i>,
we learn that the structure's descriptor list can be accessed using <i>GetDescr()</i>,
and that the type returned is a list of pointers to descriptors:</font>

<pre>
typedef list&lt; CRef&lt;CBiostruc_descr> > TDescr;
const TDescr&amp; GetDescr(void) const;
</pre>

<font color="#000000">Consulting the base class for <i><a href="../lxr/source/include/objects/mmdb1/Biostruc_descr_.hpp#L62">CBiostruc_desc</a></i>
in turn, we learn that this class has a <i>choice state</i> defining the
type of value stored there as well as the method that should be used to
access that value. This leads to an implementation of <i><a href="traverse_cpp.html#visitDscr">Visit(CBiostruc::TDescr
DescrList)</a></i> that uses an iterator over its list argument and a switch
statement over the current descriptor's choice state.&nbsp;</font><a NAME="iterate"></a>
<h3>
<font color="#000000">Iterating Over Containers</font></h3>
<font color="#000000">Most of the <i>Visit()</i> functions implemented
here rely on standard STL iterators to walk through a list of objects.
The general syntax for using an iterator is:</font>

<pre>
ContainerType ContainerName;

for (ContainerType::IteratorType i = ContainerName.begin();
    i != ContainerName.end(); ++i) {

    ObjectType ObjectName = *i;
    // ...
}
</pre>
<font color="#000000">Dereferencing the iterator is required, as the iterator
behaves like a pointer that traverses consecutive elements of the container.
For example, to iterate over the list of descriptors in the <i>Biostruc</i>,
we use a container of type <i>CBiostruc::TDescr</i>, and an iterator of
type
<i>const_iterator</i> to ensure that the data is not mutated in the
body of the loop. Because the descriptor list contains pointers (<i><a href="cref.html#cref">CRefs</a></i>)
to objects, we will actually need to dereference <i>twice</i> to get to
the objects themselves.</font>

<pre>
for (CBiostruc::TDescr::const_iterator i = descList.begin(); 
     i != descList.end(); ++i) {

    const CBiostruc_descr&amp; thisDescr = **i;
    // ...
}
</pre>
<font color="#000000">In traversing the descriptor list in this example,
we handled each type of descriptor with an explicit <i>case</i> statement.
In fact, however, we really only visit those descriptors whose types have
string representations: <i>TName, TPdb_comment</i>, and
<i>TOther_comment</i>.
The other two descriptor types, <i>THistory</i> and
<i>TAttribute</i>,
are objects that are "visited" recursively, but the associated visit functions
are not actually implemented (see <i><a href="traverse_hpp.html">traverseBS.hpp</a></i>).</font>
<p><font color="#000000">The NCBI C++ Toolkit provides a rich and powerful
<a href="iterators.html">set
of iterators</a> for various application needs. An alternative to using
the above <i>switch</i> statement to visit elements of the descriptor list
would have been to use an NCBI<i> <a href="iterators.html#stdType">CStdTypeIterator</a></i>
that only visits strings. For example, we could implement the Visit function
on a <i>CBiostruc::TDescr</i> as follows:</font>

<pre>
void Visit (const CBiostruc::TDescr&amp; descList)
{
    for (CBiostruc::TDescr::const_iterator i1 = descList.begin();
        i1 != descList.end(); ++i1) {

        for (CStdTypeConstIterator&lt;string> i = ConstBegin(**i1); i; ++i) {
            cout &lt;&lt; *i &lt;&lt; endl;
        }
    }
}
</pre>

<font color="#000000">In this example, the iterator will skip over all
but the string data members.</font><font color="#000000"></font>
<p><font color="#000000">The <i>CStdTypeIterator </i></font>is one of several
iterators which makes use of an object's <i>type information</i> to implement
the desired functionality. We began this section by positing that the traversal
of an object requires an <i>a priori
</i>knowledge of that object's internal
structure.&nbsp; This is not strictly true however, if type information
for the object is also available. An object's type information specifies
the class layout, inheritance relations, data member names, and various
other attributes such as size, which are independent of specific instances.
<font color="#000000">All of the C++ type iterators described in <i><a href="iterators.html">The
NCBI C++ Toolkit Iterators</a></i> section utilize type information, which
is the topic of the next section: <i><a href="typeinfo.html">Runtime Object
Type Information</a></i>.</font>
<p><i><a href="../index.html">up</a></i><font color="#000000">&nbsp;&nbsp;&nbsp;
</font><i><a href="typeinfo.html">next</a></i><!--i><a href=".html">next&nbsp;</a></i-->
<p>
<hr>
<table BORDER=0 CELLSPACING=0 WIDTH="100%" >
<tr>
<td>
<address>
<a href="mailto:zimmerma@ncbi.nlm.nih.gov">Diane Zimmerman</a></address>
</td>

<td><!-- <td align=center><i>$Revision$</i></td> --></td>

<td ALIGN=RIGHT><i>$Date$</i></td>
</tr>
</table>

<!--#include virtual="../ssi/footer.shtml" -->
