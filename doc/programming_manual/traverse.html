<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
  <title> Traversing an ASN.1 Data Structure. </title>
</head>
<body BGCOLOR="white">

<h1> Traversing an ASN.1 Data Structure </h1>
<ul>
  <li> <a href="#locateClass"> Locating the Class Definitions </a>
  <li> <a href="#accessMember"> Accessing and Referencing Data Members </a>
  <li> <a href="#example"> Traversing an ASN.1 Biostruc </a>
  <li> <a href="#iterate"> Iterating Over Containers </a>
</ul>

<a name="locateClass"> <h3> Locating the Class Definitions </h3>
In order to traverse an ASN data object, you must first become familiar with 
the class structures and access functions which implement the object. The
example provided here involves an ASN.1 Biostruc type which is implemented
by class <i>CBiostruc.</i> <p>

The first question is: how do I locate the class definitions implementing the object
to be traversed? There are now two source browsers which you can use. To obtain a
synopsis of the class, you can search the 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/index.html">
index </a> or the 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/HIER.html">
class hierarchy </a>
of the <i>Doc++</i> browser and follow a link to the class. For example, a synopsis of the
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/CBiostruc.html">
<i>CBiostruc</i></a> class is readily available. 

From this page, you can also access the relevant source files archived by the <i>LXR</i>
browser, 
by following the 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=CBiostruc">
<i>Locate CBiostruc</i></a> link.  
Alternatively, you may want to access the <i>LXR</i> engine directly by using the 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=CBiostruc">
<i>Identifier search</i></a> tool. <p>

Because we wish to determine which headers to include, the synopsis displayed by the 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident">
<i>Identifier search </i></a> tool is most useful. There we find a single header file,
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/source/include/objects/mmdb1/Biostruc.hpp#L59">
<i> Biostruc.hpp </i></a> listed as defining the class at line 59. Accordingly, this is
the header file we must include. The <i>CBiostruc</i> class inherits from the <i>CBiostruc_Base</i> class
however, and we will need to consult that file as well to understand the internal structure
of the <i>CBiostruc</i> class. Following a link to the parent class from the class hierarchy browser, 
we find the definition of the 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/CBiostruc_Base.html">
<i>CBiostruc_Base</i></a> class.
<p>

This is where we must look for the definitions and access functions we will be using. However,
it is the inherited class (defined in <i>CBiostruc.hpp</i>) whose header should be
<i>#include</i>'d in your source files, and which should be instantiated by your local program
variable. The inherited class's header file will include the base header file for you. <p>

More generally, the base (auto-generated) classes should <i>never</i> be instantiated or
accessed directly in an application.  The relation between these two files and the classes they
define reflects a general design used in developing the object libraries: the base class files
are generated by 
<a href="http://sunweb.ncbi.nlm.nih.gov:6224/IEB/corelib/cpp/tools/datatool/datatool.html">
<i>datatool</i></a> according to the ASN.1 specifications in the <i>src/objects</i>
directories; the inherited class files are intended for developers who are extending these
classes to support features above and beyond the ASN.1 specifications. The purpose of this
design is to insulate the developers as much as possible from changes to the underlying
specifications. These inherited classes are not intended however, for the general programmer's
modification, as they entail library dependencies. <p>

<a name="accessMember"> <h3> Accessing and Referencing Data Members </h3>
Removing some of the implementation details of the base class, we find the <i>CBiostruc_Base</i> class 
has essentially the following structure:

<font color = "#000080"> 
<pre>
class CBiostruc_Base : public CObject
{
public:
    // type definitions 
    typedef list&lt; CRef&lt;CBiostruc_id&gt; &gt; TId;
    typedef list&lt; CRef&lt;CBiostruc_descr&gt; &gt; TDescr;
    typedef list&lt; CRef&lt;CBiostruc_feature_set&gt; &gt; TFeatures;
    typedef list&lt; CRef&lt;CBiostruc_model&gt; &gt; TModel;
    typedef CBiostruc_graph TChemical_graph;

    // Get() members 
    const TId& GetId(void) const;
    const TDescr& GetDescr(void) const;
    const TChemical_graph& GetChemical_graph(void) const;
    const TFeatures& GetFeatures(void) const;
    const TModel& GetModel(void) const;

    // Set() members
    TId& SetId(void);
    TDescr& SetDescr(void);
    TChemical_graph& SetChemical_graph(void);
    TFeatures& SetFeatures(void);
    TModel& SetModel(void);

private:
    TId m_Id;
    TDescr m_Descr;
    TChemical_graph m_Chemical_graph;
    TFeatures m_Features;
    TModel m_Model;
};
</pre>
<font color = black>

With the exception of the structure's chemical graph, each of the class's private
data members is actually a <i>list</i> of references (pointers), as specified by
the type definitions. For example, <i>TId</i> is a list of 
<a href="cref.html#cref"><i>CRef</i></a>
objects, where each <i>CRef</i> object points to a 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/CBiostruc_id.html">
<i>CBiostruc_id</i></a>. 

The <i>CRef</i></a> class is a type of smart pointer used to hold a pointer
to a reference-counted object.  The derefencing operator, when applied to a
(dereferenced) iterator
pointing to an <i>element</i>
of <i>CBiostruc::TId</i>, e.g. <i>**CRef_i</i>, will return a <i>CBiostruc_id</i>.  

Thus, the call to <i>GetId()</i> returns a list which must then be iterated
over and dereferenced to get the individual <i>CBiostruc_id</i> objects. In contrast,
the function <i>GetChemicalGraph()</i> returns the object directly, as
it does not involve a list or a <i>CRef</i>. <p>

In general, all objects in the NCBI libraries will have a similar structure: a set of private 
data members and a set of <i> GetXxx()</i> and <i> SetXxx()</i> member functions to access
and modify ("mutate") these data. In addition, most classes, including <i>CBiostruc</i>, have 
<i>IsSetXxx()</i> and <i>ResetXxx()</i> functions to validate and clear the data members
respectively. 

<a name="example"> <h3> Traversing an ASN.1 Biostruc </h3> 
The program <a href="traverse_cpp.html"><i>traverseBS.cpp</i></a> demonstrates
how one might load an ASN.1 data file and iterate over the components of the resulting object. 
This example reads from a text ASN.1 Biostruc file and stores the information
into  a <i>CBiostruc</i> object in memory. The overloaded <i>Visit()</i> function 
is then used to recursively examine the object
<i>CBiostruc bs</i> and its components.<p>

<a href="traverse_cpp.html#visitBS">
<i>Visit(bs)</i></a> simply calls <i>Visit()</i> on each of the
<i>CBiostruc</i> data members, and the data members are
accessed using <i>bs.GetXxx()</i>.  The information needed to write each of these functions -
the data member types and member function signatures - is contained in the respective header
files. For example, looking at
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/source/include/objects/mmdb1/Biostruc_.hpp#L65">
<i>Biostruc_.hpp</i></a>, we learn that the structure's 
descriptor list can be accessed using <i>GetDescr()</i>, and that the type returned is a 
list of pointers to descriptors:
<font color = "#000080">
<pre>
     typedef list&lt; CRef&lt;CBiostruc_descr&gt; &gt; TDescr;
     const TDescr& GetDescr(void) const;
</pre>
<font color = black>

Consulting the base class for 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/source/include/objects/mmdb1/Biostruc_descr_.hpp#L62">
<i>CBiostruc_desc</i></a> in turn, we learn that this class has a <i>choice 
state</i> defining the type of value stored there as well as the method that should be
used to access that value. This leads to an implementation of 
<a href="traverse_cpp.html#visitDscr"> <i>Visit(CBiostruc::TDescr DescrList)</i></a>
that uses an iterator over its list argument and a switch statement over the 
current descriptor's choice state. 

<a name="iterate"> <h3>  Iterating Over Containers </h3> 

Most of the <i>Visit()</i> functions implemented here rely on standard STL iterators to
walk through a list of objects. The general syntax for using an iterator is:

<font color = "#000080">
<pre>
  ContainerType ContainerName;

  for (ContainerType::IteratorType i = ContainerName.begin();
       i != ContainerName.end(); ++i) {

    ObjectType ObjectName = *i;
    // ...
  }
</pre>
<font color = black>

Dereferencing the iterator is required, as the iterator is essentially 
a pointer that traverses consecutive elements of the container.
For example, to iterate over the list of descriptors in the Biostruc, we use
a container of type <i>CBiostruc::TDescr</i>, and an iterator of type <i>const_iterator</i>
to ensure that the data is not mutated in the body of the loop. Because the descriptor
list contains pointers (<a href="cref.html#cref"><i>CRefs</i></a>) to objects, we will 
actually need to dereference <i>twice</i> to get to the objects themselves. 

<font color = "#000080">
<pre>
  for (CBiostruc::TDescr::const_iterator i = descList.begin();
       i != descList.end(); ++i) {

    const CBiostruc_descr& thisDescr = **i;
    // ...
  }
</pre>
<font color = black>

In traversing the descriptor list in this example, we handled each type of descriptor with
an explicit <i>case</i> statement. In fact, however, we really only visit those
descriptors whose types have string representations: <i>TName, TPdb_comment</i>, and
<i>TOther_comment</i>. The other two descriptor types, <i>THistory</i> and
<i>TAttribute</i>, are objects that are "visited" recursively, but the associated visit
functions are not actually implemented (see <a href="traverse_hpp.html">
<i>traverseBS.hpp</a></i>). <p>


The NCBI C++ Toolkit provides a rich and powerful set of iterators for various application
needs.  An alternative to using the above <i>switch</i> statement to visit elements of the
descriptor list would have been to use an NCBI <i>type</i> iterator that only visits
strings. For example, we could implement the Visit function on a <i>CBiostruc::TDescr</i>
as follows:

<font color = "#000080">
<pre>
void Visit (const CBiostruc::TDescr& descList) { 

    for (CBiostruc::TDescr::const_iterator i1 = descList.begin();
         i1 != descList.end(); ++i1) {

        for (CStdTypeConstIterator&lt;string&gt; i = ConstBegin(**i1); i; ++i) {
            cout << *i << endl;
        }
    }
}
</pre>
<font color = black>
In this example, the iterator will skip over all but the string data members. For a complete
discussion of the iterator classes available in the NCBI C++ Toolkit, see 
<a href="iterators.html"> The NCBI C++ Toolkit Iterators</a>.
<p>

<p>
</body>

<a href="asn.html"> <i> previous</i> </a>
&nbsp;&nbsp;&nbsp;
<a href="../index.html"> <i> up </i> </a>
&nbsp;&nbsp;&nbsp;
<a href="notyet.html"> <i> next </i> </a>

</html>
	 <hr>
	 <table border=0 width="100%" cellspacing=0>
		<tr>
		  <td><address><a href="mailto:zimmerma@ncbi.nlm.nih.gov">Diane Zimmerman</a></address></td>
		  <!-- <td align=center><i>$Revision$</i></td> -->
		  <td align=right><i>$Date$</i></td>
	 </table>
