<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title> Developing CGI applications </title>
  </head>
  <body bgcolor = white>
    <h1>Developing CGI applications  </h1>

<ul>
  <li> <a href="#overview"> Overview of the CGI classes </a>
  <li> <a href="#ccgiapp"> The CCgiApplication class </a>
  <li> <a href="#cncbires"> The CNcbiResource and CNcbiCommand classes </a>
  <li> <a href="#ccgireq"> The CCgiRequest class </a>
  <li> <a href="#ccgires"> The CCgiResponse class </a>
  <li> <a href="#ccgicoo"> The CCgiCookie class </a>
  <li> <a href="#cookies"> The CCgiCookies class </a>
  <li> <a href="#ccgictx"> The CCgiContext class </a>
  <li> <a href="#xmpl"> Example code using the CGI classes </a>
</ul>

Although CGI programs are generally run as web applications with HTML interfaces, this section of
the Programming Manual places emphasis on the CGI side of things, omitting HTML details of the
implementation where possible. Similarly, the section on <a href="webpgs.html"> <i>Generating web
pages</i></a> focuses largely on the usage of HTML components independent of CGI details. The two
branches of the NCBI C++ Toolkit hierarchy are all but independent of one another - with but one
explicit hook between them: the constructors for HTML <a href="webpgs.html#page"> page</a>
components accept a <i>CCgiApplication</i> as an optional argument. This <i>CCgiApplication</i>
argument provides the HTML page component with access to all of the CGI objects used in the
application. <p>

Further discussion of combining a CGI application with the HTML classes can be found in the section
on <a href="htmlcgi.html"> <i>An example web-based CGI application</i></a>. The focus in this chapter is on
the CGI classes only.  For additional information about the CGI classes, the reader is also referred
to the discussion of
<a href="../libs/cgi.html">
<i>NCBI C++ CGI Classes</i></a> in the Reference Manual.

<a name="overview"> <h3> Overview of the CGI classes </h3>
Figure 1 illustrates the layered design of the CGI classes. 

<center><img SRC="cgi.gif"> <br> Figure 1</center><br>

This design is best described by starting with a consideration of the capabilities 
one might need to implement a CGI program, including:

<ul>
  <li> A way to retrieve and store the current values of environment variables
  <li> A means of retrieving and interpreting the client's query request string
  <li> Mechanisms to service and respond to the requested query
  <li> Methods and data structures to obtain, store, modify, and send cookies
  <li> A way to set/reset the context of the application (for Fast-CGI)
</ul>

The <i>CCgiContext</i> class unifies these diverse capabilities under one aggregate
structure. As their names suggest, the <i>CCgiRequest</i> class receives and parses the
request, and the <i>CCgiResponse</i> class outputs the response on
an output stream. All incoming <i>CCgiCookie</i>s are also parsed and stored by the
<i>CCgiRequest</i> object, and the outgoing cookies are sent along with the response
by the <i>CCgiResponse</i> object. The request is actually processed by the application's
<i>CNcbiResource</i>.  The list of <i>CNcbiCommand</i>s stored with that resource object are
scanned to find a matching command, which is then executed. <p>

The <i>CCgiContext</i> object, which is a <i>friend</i> to the <i>CCgiApplication</i>
class, orchestrates this sequence of events in coordination with the application
object. The same application may be run in many different contexts, but the
<i>resource</i> and defined set of <i>commands</i> are invariant. What changes with each
context is the request and its associated response.
<p>

The <i>CCgiApplication</i> class is a specialization of <i>CNcbiApplication</i>.  Figure 2
illustrates the adaptation of the <i>Init()</i> and <i>Run</i> member functions inherited from the
<i>CNCbiApplication</i> class to the requirements of CGI programming. Although the application is
<i>contained</i> in the context, it is the application which creates and initializes each context in
which it participates. The program arguments and environmental variables are passed along to the
context, where they will be stored, thus freeing the application to be restarted in a new context,
as in Fast-CGI.

<center><img SRC="cgirun.gif"> <br> Figure 2</center><p>

The application's <i>ProcessRequest</i> member function is an abstract function that
must be implemented for each application project. In most cases, this
function will access the query and the environment variables via the <i>CCgiContext</i>, 
using <i>ctx.GetRequest()</i> and <i>ctx.GetConfig()</i>. The application may then
service the request using its resource's <i>HandleRequest()</i> method. The context's 
response object can then be used to send an appropriate response. <p>

These classes are described in more detail below, along with abbreviated synopses of the
class definitions. These are included here to provide a conceptual framework and are not
intended as reference materials. For example, constructor and destructor declarations that
operate on void arguments, and <i>const</i> methods that duplicate <i>non-const</i>
declarations are generally not included here. Certain virtual functions and data members
that have no meaning outside of a web application are also omitted. For complete
definitions, refer to the header files via the source browsers.

<a name="ccgiapp"> 
<a href="../docxx/CCgiApplication.html">
<h3> The CCgiApplication class </h3></a>
As mentioned, the <i>CCgiApplication </i> class implements its own version of 
<a href="../lxr/ident?i=Init">
<i>Init()</i></a>, where it instantiates a <a href="#cncbires"><i>CNcbiResource</i></a> object using 
<i>LoadResource()</i>. 
<a href="../lxr/ident?i=Run">
<i>Run</i></a> is no longer a pure virtual
function in this subclass, and its implementation now calls <i>CreateContext(),
ProcessRequest()</i>, and <i>CCgiContext::GetResponse()</i>. The <i>CCgiApplication</i> 
class does <i>not</i> have
a <i>CCgiContext</i> data member, since the application object can participate in multiple
<i>CCgiContext</i>s. Instead, a local variable in each <i>Run()</i> invocation stores a pointer to the 
context created there. The <i>LoadServerContext()</i> member function is used in web applications such 
as the <a href="../tools.html#ref_TableTools"> <i>query</i></a> program, where it is necessary
to store more complex run-time data with the context object. The <i>CCgiServerContext</i>
object returned by this function is stored as a data member of a <i>CCgiContext</i>, and is
application-specific.

<font color = "#000080"> <pre>
class CCgiApplication : public CNcbiApplication
{
    friend class CCgiContext;

public:
    
    void Init(void); 
    void Exit(void); 
    int Run(void);

    CNcbiResource& GetResource(void);
    virtual int ProcessRequest(CCgiContext&) = 0;
    CNcbiResource* LoadResource(void);
    virtual CCgiServerContext* LoadServerContext(CCgiContext& context);

    bool RunFastCGI(unsigned def_iter=3);

protected:

    CCgiContext* CreateContext(CNcbiArguments*, CNcbiEnvironment*,
                               CNcbiIstream*, CNcbiOstream*);

private:
    auto_ptr&lt;CNcbiResource> m_resource;
};
</pre></font>

If the program was <i>not</i> compiled as a Fast-CGI application (or the environment does
not support Fast-CGI), then 
<a href="../lxr/ident?i=RunFastCGI">
<i> RunFastCGI()</i></a> will return <i>false</i>. Otherwise, a "Fast-CGI loop" will be
iterated over <i>def_iter</i> times, with the initialization methods and
<i>ProcessRequest()</i> function being executed on each iteration. The value returned by
<i> RunFastCGI()</i> in this case is <i>true</i>.  <i>Run()</i> first calls <i>
RunFastCGI()</i>, and if that returns <i>false</i>, the application is run as a plain CGI
program.

<a name="cncbires">
<a href="../docxx/CNcbiResource.html">
<h3> The CNcbiResource</a> and 
<a href="../docxx/CNcbiCommand.html">
CNcbiCommand</a> classes </h3>

The resource class is at the heart of the application, and it is here that the program's
functionality is defined. The single argument to the resource class's constructor is a <a
href="applic.html#CNcbiRegistry"><i>CNcbiRegistry</i></a> object, which defines data
paths, resources, and possibly environmental variables for the application. This
information is stored in the resource class's data member, <i>m_config</i>. The only other
data member is a
<a href="../lxr/ident?i=TCmdList">
<i>TCmdList</i></a> (a list of <i>CNcbiCommand</i>s) called <i>m_cmd</i>.

<font color = "#000080"> <pre>
class CNcbiResource
{
public:

    CNcbiResource(CNcbiRegistry& config);

    CNcbiRegistry&	  GetConfig(void);
    const TCmdList&	  GetCmdList(void) const;
    virtual CNcbiCommand* GetDefaultCommand(void) const = 0;
    virtual const CNcbiResPresentation* GetPresentation(void) const;

    void AddCommand(CNcbiCommand* command);
    virtual void HandleRequest(CCgiContext& ctx);

protected:   

    CNcbiRegistry& m_config;  
    TCmdList m_cmd;
};CNcbiDbPresentatio
</pre> </font>

The <i>AddCommand()</i> method is used when a resource is being initialized, to add
commands to the command list.  Given a <i>CCgiRequest</i> object defined in a particular
context <i>ctx</i>, 
<a href="../lxr/ident?i=HandleRequest">
<i>HandleRequest(ctx)</i></a> compares entries in the context's request to
commands in <i>m_cmd</i>. The first command in <i>m_cmd</i> which <i>matches</i>
an entry in the request is then executed (see
below), and the request is considered "handled". If desired, a default command can
be installed which will execute when no matching command is found. The default
command is defined by implementing the pure virtual function <i>GetDefaultCommand()</i>.
The <a href="../docxx/CNcbiResPresentation.html">
<i>CNcbiResPresentation</i></a> class is an abstract base class, and the member function,
<i>GetPresentation()</i>, returns 0. It is provided as a hook for implementing interfaces
between information resources (e.g. databases) and CGI applications.

<font color = "#000080"> <pre>
class CNcbiCommand
{
public:

    CNcbiCommand(CNcbiResource& resource);

    virtual CNcbiCommand* Clone(void) const = 0; 
    virtual string GetName() const = 0;
<!-- SKIPPED    virtual CNCBINode* GetLogo(const CCgiContext&) const { return 0; } -->
<!-- SKIPPED    virtual string GetLink(CCgiContext& ctx) const = 0; -->
    virtual void Execute(CCgiContext& ctx) = 0;
    virtual bool IsRequested(const CCgiContext& ctx) const;

protected:

    virtual string GetEntry() const = 0;
    CNcbiResource& GetResource() const { return m_resource; }

private:

    CNcbiResource& m_resource;
};
</pre> </font>

<i>CNcbiCommand</i> is an abstract base class: its only data member is a reference to the
resource it belongs to, and most of its methods - with the exception of
<i>GetResource()</i> and <i>IsRequested()</i> - are pure virtual functions.
<i>IsRequested()</i> examines the <i>key=value</i> entries stored with the context's
request object. When an entry is found where <i>key==GetEntry()</i> and
<i>value==GetName()</i>, <i>IsRequested()</i> returns <i>true</i>.
<p>

The resource's <i>HandleRequest()</i> method iterates over its command list, calling
<i>CNcbiCommand::IsRequested()</i> until the first match between a command and a request
entry is found.  When <i>IsRequested()</i> returns <i>true</i>, the command is <i>cloned</i>,
and the cloned command is then <i>executed</i>.  Both the <i>Execute()</i> and <i>Clone</i>
methods are pure virtual functions which must be implemented by the user.

<a name="ccgireq"> 
<a href="../docxx/CCgiRequest.html">
<h3> The CCgiRequest class </h3></a>

<i>The CCgiRequest</i> class serves as an interface between the user's query and the CGI
program. Arguments to the constructor include a <i>CNcbiArguments</i> object, a
<i>CNcbiEnvironment</i> object, and a <i>CNcbiIstream</i> object. The class
constructors do little other than invoke <i>CCgiRequest::x_Init()</i>, where
the actual initialization takes place. <p>

<i>x_Init()</i> begins by examining the environment argument, and if it is <i>NULL</i>,
<i>m_OwnEnv</i> (an <i>auto_ptr</i>) is reset to a dummy environment. Otherwise,
<i>m_OwnEnv</i> is reset to the passed environment, making the request object the
effective owner of that environment. The environment is then used to cache network
information as "gettable" properties. Cached properties include:

<ul>
  <li> server properties such as the server name, gateway interface, and server port
  <li> client properties (the remote host and remote address) 
  <li> client data properties (content type and content length of the request)
  <li> request properties including the request method, query string, and path information
  <li> authentication information such as the remote user and remote identity
  <li> standard HTTP properties (from the HTTP header) 
</ul>
These properties are keyed to an enumeration named 
<a href="../docxx/ECgiProp.html">
<i>ECgiProp</i></a>, and can be retrieved using the request object's <i>GetProperty()</i>
member function.  For example, <i>GetProperty(eCgi_HttpCookie)</i> is used to access
cookies from the HTTP Header, and <i> GetProperty(eCgi_RequestMethod)</i> is used to
determine where the query string should be read from. <p>

<font color="red">NOTE:</font> 

Setting <i>$QUERY_STRING without</i> also setting <i>$REQUEST_METHOD</i> will result in a
failure by <i>x_init()</i> to read the input query.

<i>x_init()</i> first looks for the definition of <i>$REQUEST_METHOD</i>, and
depending on if it is <i>GET</i> or <i>POST</i>, reads the query from the environment or the
input stream respectively. 

If the environment does not define <i>$REQUEST_METHOD</i>, then <i>x_Init()</i> will
try to read the query string from the command line only. 

<font color = "#000080"> <pre>
class CCgiRequest {
public:

    CCgiRequest(const CNcbiArguments*, const CNcbiEnvironment*,
		CNcbiIstream*, TFlags);

    static const string& GetPropertyName(ECgiProp prop);    
    const string& GetProperty(ECgiProp prop) const;         
    size_t GetContentLength(void) const;
    const CCgiCookies& GetCookies(void) const;
    const TCgiEntries& GetEntries(void) const;
    static SIZE_TYPE ParseEntries(const string& str, TCgiEntries& entries);

private:

    void x_Init(const CNcbiArguments*, const CNcbiEnvironment*,
		CNcbiIstream*, TFlags);

    const CNcbiEnvironment*    m_Env;
    auto_ptr&lt;CNcbiEnvironment> m_OwnEnv;
    TCgiEntries m_Entries;
    CCgiCookies m_Cookies;
};  
</pre> </font>
This abbreviated definition of the <i>CCgiRequest</i> class highlights its primary
functionalities:
<ol>
<li> to parse and store the &lt;<i>key=value</i>> pairs contained in the query
string (stored in <i>m_Entries</i>)
<li> to parse and store the cookies contained in the HTTP header (stored in 
<i>m_Cookies</i>)
</ol>
As implied by the "T" prefix,
<a href="../lxr/ident?i=TCgiEntries">
<i>TCgiEntries</i></a> is a type defintion, and defines <i>m_Entries</i> to be an STL
multimap of <i>&lt;string,string></i> pairs. The <i>CCgiCookies</i> class (described <a
href="#cookies"> below</a>) contains an STL set of <a
href="#ccgicoo"><i>CCgiCookie</i></a>, and implements an interface to this set.<p>

<a name="ccgires"> 
<a href="../docxx/CCgiResponse.html">
<h3> The CCgiResponse class </h3></a>

The <i>CCgiResponse</i> class provides an interface to the program's output
stream (usually <i>cout</i>) - which is the sole argument to the constructor for <i>CCgiResponse</i>.
The output stream can be accessed by the program using <i>CCgiResponse::GetOutput()</i>, which
returns a pointer to the output stream, or, using <i>CCgiResponse::out()</i>, which returns 
a reference to that stream. <p>

In addition to implementing controlled access to the output stream, the primary function
of the response class is to generate appropriate HTML headers that will precede the rest
of the response. For example, a typical sequence in the implementation of a particular
command's execute function might be:

<font color = "#000080"> <pre>
MyCommand::Execute(CCgiContext& ctx) 
{
    // ... generate the output and store it in MyOutput

    ctx.GetResponse().WriteHeader();
    ctx.GetResponse().out() << MyOutput;
    ctx.GetResponse.out() << "&lt;/body>&lt/html>" << endl;
    ctx.GetResponse.Flush();
}
</pre></font>
Any cookies that are to be sent with the response are included in the headers
generated by the response object.<p> 

Two member functions are provided for outputting HTML headers: <i>WriteHeader()</i>
and <i>WriteHeader(CNcbiOstream&)</i>. The second of these is for writing
to a specified stream other than the default stream stored with the response object.
Thus, <i>WriteHeader(out())</i> is equivalent to <i>WriteHeader()</i>. <p>

The <i>WriteHeader()</i> function begins by invoking <i>IsRawCgi()</i> to 
see if the application is a 
<a href="http://absolut.banki.hu/~asoka/www.mcp.com/818640000/0-7897/0-7897-0740-3/ch4.htm#NonParsedHeaders">
<i>non-parsed header</i></a> program. If so, then the
first header put on the output stream is an HTTP status line, taken from the
private static data member, <i>sm_HTTPStatusDefault</i>. Next, unless the content
type has been set by the user (using <i>SetContentType()</i>), a default content 
line is written, using <i>sm_ContentTypeDefault</i>. Any cookies stored in 
<i>m_Cookies</i> are then written, followed by any additional headers stored
with the request in <i>m_HeaderValues</i>. Finally, a new line is written
to separate the body from the headers. 


<font color = "#000080"> <pre>
class CCgiResponse {
public:

    CCgiResponse(CNcbiOstream* out = 0);

    void SetRawCgi(bool raw);
    bool IsRawCgi(void) const;
    void SetHeaderValue(const string& name, const string& value);
    void SetHeaderValue(const string& name, const tm& value);
    void RemoveHeaderValue(const string& name);
    void SetContentType(const string &type);
    string GetHeaderValue(const string& name) const;
    bool HaveHeaderValue(const string& name) const;
    string GetContentType(void) const;

    CCgiCookies& Cookies(void);		        // Get cookies set
    CNcbiOstream* SetOutput(CNcbiOstream* out); // Set default output stream
    CNcbiOstream* GetOutput(void) const;        // Query output stream
    CNcbiOstream& out(void) const;	        // Conversion to ostream to enable <<
    void Flush() const;			        

    CNcbiOstream& WriteHeader(void) const;      // Write HTTP response header
    CNcbiOstream& WriteHeader(CNcbiOstream& out) const;

protected:

    typedef map&lt;string, string> TMap;
    static const string sm_ContentTypeName;
    static const string sm_ContentTypeDefault;
    static const string sm_HTTPStatusDefault;
    bool m_RawCgi;
    CCgiCookies m_Cookies;
    TMap m_HeaderValues;       // Additional header lines in alphabetical order
    CNcbiOstream* m_Output;    // Default output stream
};
</font></pre>

<a name="ccgicoo"> 
<a href="../docxx/CCgiCookie.html">
<h3> The CCgiCookie class </h3></a>

The traditional means of maintaining state information when servicing a multi-step request
has been to include <i>hidden</i> input elements in the query strings passed to subsequent
URLs. The newer preferred method uses 
<a href="http://home.netscape.com/newsref/std/cookie_spec.html">
HTTP cookies</a>, which 
provide the server access to client-side state information stored with the client.
The cookie is a text string consisting of four key=value pairs:

<ul>
  <li> name (required)
  <li> expires (optional)
  <li> domain (optional)
  <li> path (optional)
</ul>

The <i>CCgiCookie</i> class provides means of creating, modifying,
and sending cookies. The constructor requires at least two arguments, specifying the
<i>name</i> and <i>value</i> of the cookie, along with the optional <i>domain</i> and
<i>path</i> arguments. Format errors in the arguments to the constructor (see <a
href="#appendix"> Appendix</a>) will cause the invalid argument to be thrown. 
The <i>CCgiCookie::Write(CNcbiOstream&)</i> member function creates a <i>Set-Cookie</i>
directive using its private data members, and places the resulting string on the specified
output stream:<p>

Set-Cookie: <i>m_Name=m_Value</i>; expires=<i>m_Expires</i>; path=<i>m_Path</i>; 
domain=<i>m_Domain</i>; <i>m_Secure</i>

<p>As with the constructor, and in compliance with the proposed standard 
(<a href="ftp://ftp.isi.edu/in-notes/rfc2109.txt">RFC 2109</a>), only the
name and value are mandatory in the directive.

<font color = "#000080"> <pre>
class CCgiCookie {
public:

    CCgiCookie(const string& name, const string& value,
               const string& domain = NcbiEmptyString,
               const string& path   = NcbiEmptyString);

    const string& GetName(void) const;

    CNcbiOstream& Write(CNcbiOstream& os) const;

    void Reset(void);		
    void CopyAttributes(const CCgiCookie& cookie);
    void SetValue  (const string& str);
    void SetDomain (const string& str);
    void SetPath   (const string& str);
    void SetExpDate(const tm& exp_date);
    void SetSecure (bool secure);     

    const string& GetValue  (void) const;
    const string& GetDomain (void) const;
    const string& GetPath   (void) const;
    string        GetExpDate(void) const;
    bool GetExpDate(tm* exp_date) const;
    bool GetSecure(void)          const;

    bool operator&lt;(const CCgiCookie& cookie) const;
    typedef const CCgiCookie* TCPtr;
    struct PLessCPtr {
        bool operator() (const TCPtr& c1, const TCPtr& c2) const {
            return (*c1 < *c2);
        }
    };

private:
    string m_Name;
    string m_Value;
    string m_Domain;
    string m_Path;
    tm     m_Expires;
    bool   m_Secure;
};
</font></pre>


With the exception of <i>m_Name</i>, all of the cookie's data members can be reset using
the <i>SetXxx(), Reset()</i>, and <i>CopyAttributes()</i> member functions; <i>m_Name</i> is
non-mutable. As with the constructor, format errors in the arguments to these functions
will cause the invalid argument to be thrown. By default, <i>m_Secure</i> is
<i>false</i>. The <i>GetXxx()</i> methods return the stored value for that attribute or,
if no value has been set, a reference to <i>NcbiEmptyString</i>. <i>GetExpDate(tm*)</i>
returns <i>false</i> if no expiration date was previously set. Otherwise, <i>tm</i> is
reset to <i>m_Expire</i>, and <i>true</i> is returned.

<a name="cookies"> 
<a href="../docxx/CCgiCookies.html">
<h3> The CCgiCookies class </h3></a>

The <i>CCgiCookies</i> class provides an interface to an STL set of <i>CCgiCookie</i>s
(<i>m_Cookies</i>). Each cookie in the set is uniquely identified by its name, domain, and
path values, and is stored in ascending order using the <i>CCgiCookie::PLessCPtr</i>
struct.  Two constructors are provided, allowing the user to initialize <i>m_Cookies</i>
to either an empty set or a set of <i>N</i> new cookies created from the string
"name1=value1; name2=value2; ...; nameN=valuenN".
Many of the operations on a <i>CCgiCookies</i> object involve iterating over the set,
and the class's type definitions support these activities by
providing built-in iterators and a typedef for the set, <i>TSet</i>. <p>

The <i>Add()</i> methods provide a variety of options for creating and adding new cookies to the set. 
As with the constructor, a single string of name-value pairs may be used to create and add <i>N</i> 
cookies to the set at once. Previously created cookies can also be added to the set individually or 
as sets. Similarly, the <i>Remove()</i> methods allow individual cookies or sets of cookies (in the
specified range) to be removed. All of the remove functions destroy the removed cookies when
<i>destroy==true</i>. <i>CCgiCookies::Write(CNcbiOstream&)</i> iteratively invokes the <i>CCgiCookie::Write()</i> 
on each element. 

<font color = "#000080"> <pre>
class CCgiCookies {
public:
    typedef set&lt;CCgiCookie*, CCgiCookie::PLessCPtr>  TSet;
    typedef TSet::iterator         TIter;
    typedef TSet::const_iterator   TCIter;
    typedef pair&lt;TIter,  TIter>    TRange;
    typedef pair&lt;TCIter, TCIter>   TCRange;

    CCgiCookies(void);		     // create empty set of cookies
    CCgiCookies(const string& str);  // str = "name1=value1; name2=value2; ..."
    bool Empty(void) const;

    CCgiCookie* Add(const string& name, const string& value,
                    const string& domain = NcbiEmptyString,
                    const string& path   = NcbiEmptyString);

    CCgiCookie* Add(const CCgiCookie& cookie);  
    void Add(const CCgiCookies& cookies); 
    void Add(const string& str);		// "name1=value1; name2=value2; ..."

    CCgiCookie* Find(const string& name, const string& domain, const string& path);
    CCgiCookie* Find(const string& name, TRange*  range=0);

    bool Remove(CCgiCookie* cookie, bool destroy=true);
    size_t Remove(TRange& range, bool destroy=true);
    size_t Remove(const string& name, bool destroy=true);
    void Clear(void);

    CNcbiOstream& Write(CNcbiOstream& os) const;

private:
    TSet m_Cookies;
};  
</font></pre>

<a name="ccgictx">
<a href="../docxx/CCgiContext.html">
<h3> The CCgiContext class </h3></a> As depicted in <a href="#overview"> Figure 1</a>, a
<i>CCgiContext</i> object contains an application object, a request object, and a response
object, corresponding to its data members <i>m_app, m_request</i>, and
<i>m_response</i>. Additional data members include a string encoding the URL for the context
(<i>m_selfURL</i>), a message buffer (<i>m_lmsg</i>), and a <i>CCgiServerContext</i>. These
last three data members are only used in complex web applications such as the <a
href="../tools.html#ref_TableTools"> <i>query</i></a> program, where it is necessary to store
more complex run-time data with the context object.  The message buffer is essentially an STL
list of string objects whose class definition 
(<a href="../lxr/ident?i=CCtxMsgString"><i>CCtxMsgString</i></a>)
includes a <i>Write()</i> output function. <i>GetServCtx()</i> returns <i>m_srvCtx</i> if it
has been defined and otherwise, calls the application's
<i>CCgiApplication::LoadServerContext()</i> to obtain it.

<font color = "#000080"> <pre>
class CCgiContext
{
public:
    CCgiContext(CCgiApplication&        app,
                const CNcbiArguments*   args = 0,
                const CNcbiEnvironment* env  = 0,
                CNcbiIstream*           inp  = 0,
                CNcbiOstream*           out  = 0);

    const CCgiApplication& GetApp(void) const;
    CNcbiRegistry&	   GetConfig(void);
    CCgiRequest&	   GetRequest(void);
    CCgiResponse&	   GetResponse(void);
    const string&	   GetSelfURL(void) const;
    CNcbiResource&	   GetResource(void);
    CCgiServerContext&	   GetServCtx(void);

    CNcbiOstream& PrintMsg(CNcbiOstream& os);	// output all msgs in m_lmsg to os
    void PutMsg(const string& msg);		// add message to m_lmsg
    void PutMsg(CCtxMsg* msg);			// add message to m_lmsg
    bool EmptyMsg(void);			// true iff m_lmsg is empty
    void ClearMsg(void);			// delete all messages in m_lmsg

    string GetRequestValue(const string& name) const;    
    void AddRequestValue(const string& name, const string& value);
    void RemoveRequestValues(const string& name);
    void ReplaceRequestValue(const string& name, const string& value);

private:

    CCgiApplication&	  m_app;
    auto_ptr&lt;CCgiRequest> m_request;  
    CCgiResponse	  m_response; 
    mutable string	  m_selfURL;
    list&lt;CCtxMsg*>        m_lmsg;		// message buffer

    auto_ptr&lt;CCgiServerContext> m_srvCtx;	// defined by CCgiApplication::LoadServerContext()

    friend class CCgiApplication;
}; 
</font></pre>

<a name=xmpl> <h3>Example code using the CGI classes</h3>
The <a href="../tools.html#ref_TableTools"> <i>hello</i></a> program demonstrates a 
simple application that combines the NCBI C++ Toolkit's CGI and HTML classes. 
<a href="cgi_cpp.html"><i>justcgi.cpp</i></a> is an adaptation of
that program, stripped of all HTML references with additional request-processing added.
<p>
The application defines two classes of commands:<p>

<table border=1 width=400 cellspacing=1>
  <caption></caption>
  <tr><th>class</th><th><i>GetEntry()</i></th><th><i>GetName()</i></th> </tr>
  <tr><td> CHelloBasicCommand </td> <td> cmd1 </td> <td> init </td> </tr>
  <tr><td> CHelloReplyCommand </td> <td> cmd2 </td> <td> reply </td> </tr>
</table>
<p>
Executing <pre>./cgi 'cmd1=init&cmd2=reply'</pre> results in execution of only <i>cmd1</i>,
as does executing <pre>./cgi 'cmd2=reply&cmd1=init'</pre> The commands are matched in the
order that they are registered with the resource - not according to the order in which
they occur in the request. The assumption is that only the first entry (if any) in the query 
actually specifies a command, and that the remaining entries provide optional arguments 
to that command. 
The <a href="make_cgi.html"> Makefile</a> for this example links
to both the <i>xncbi</i> and <i>xcgi</i> libraries. 
Additional examples using the CGI classes can be found in 
<a href="../lxr/source/src/cgi/test/">
<i>src/cgi/test</i></a>.

<a name=appendix> <h3>Appendix</h3>
<h4> Restrictions on arguments to the <i>CCgiCookie</i> constructor </h4>
<table border=1 width=550 cellspacing=1>
  <caption></caption>
  <tr><th>Field</th><th>Restrictions</th> </tr>
  <tr><td> name (required)  </td> <td> no spaces; must be printable ASCII; cannot contain = , or ; </tr>
  <tr><td> value (required) </td> <td> no spaces; must be printable ASCII; cannot contain , or ; </tr>
  <tr><td> domain (optional)</td> <td> no spaces; must be printable ASCII; cannot contain , or ; </tr>
  <tr><td> path  (optional) </td> <td> case-sensitive </tr>

</table>
<p>

   </body>
<a href="exceptions.html"> <i> previous</i> </a>
&nbsp;&nbsp;&nbsp;
<a href="../index.html"> <i> up </i> </a>
&nbsp;&nbsp;&nbsp;
<a href="webpgs.html"> <i> next</i> </a>
</html>

	 <hr>
	 <table border=0 width="100%" cellspacing=0>
		<tr>
		  <td><address><a href="mailto:zimmerma@ncbi.nlm.nih.gov">Diane Zimmerman</a></address></td>
		  <!-- <td align=center><i>$Revision$</i></td> -->
		  <td align=right><i>$Date$</i></td>
	 </table>
