<!--#set var="TITLE" value="Adding methods to serial objects" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->

<h1>Adding methods to serial objects</h1>

<ul>
  <li> <a href="#intro"> Introduction </a>
  <li> <a href="#environ"> Setting up the work environment </a>
  <li> <a href="#xmpl"> An example </a>
</ul>

<a name="intro"></a> <h3> Introduction </h3>

Each of the objects defined in the <i>objects/</i> subdirectories has both a <i>user</i> and
a <i>base</i> class definition. For example, the header file for the user class
<a href ="../docxx/CSeq_entry.html"> <i>CSeq_entry</i></a> is defined in <a href =
"../lxr/source/include/objects/seqset/Seq_entry.hpp">
<i>include/objects/seqset/Seq_entry.hpp</i></a>. This user class is derived from 
<a href ="../docxx/CSeq_entry_Base.html"> <i>CSeq_entry_Base</i></a>, whose header file is in the
same subdirectory. The file name for a base class is obtained by appending an underscore to the file name,
e.g., <a href =
"../lxr/source/include/objects/seqset/Seq_entry_.hpp">
<i>include/objects/seqset/Seq_entry_.hpp</i></a>.<p>

The user classes are provided for the development of extensions to the base classes of
serial objects generated by <i>datatool</i>. Thus, if a method must be added to the
<i>CSeq_entry</i> class, then that method should be added to <i>Seq_entry.hpp</i> - 
<strong> not </strong> to the base class. Once the new method has been added, it will be
necessary to re-compile the library in which that class is defined. <p>

To use this new method, you must ensure that the application's build refers to this newly built
library -  not to the current "public" library for that module. This is not a problem, if
you have checked out the entire C++ Toolkit tree and are <a href="inside_tree.html"><i>
Working within the C++ source tree</i></a>. In general however, it is preferable to work 
independently in a checked-out subtree. <p>

A description of how to do this in general can be found in <a href="sub_tree.html"><i>Working
Independently In a C++ Subtree</i></a>. The explanation provided there is intended for work outside
the <i>objects</i> directories however, as setting up your environment in this case is a bit more
complicated.  The next section describes how you can work independently in your own checked-out
<i>objects</i> subdirectories, and provides a script for setting things up.
<p>

<a name="environ"></a><h3> Setting up the work environment </h3>
Here is an outline of the steps required to set things up:
<ol>
<li> Create a new directory to work in, and <i>cd</i> to that directory.<p>
<li> Check out the <i>objects</i> modules (into this new directory) using the <i>import_project.sh</i> script.<p>
<li> For each module that has dependencies with the module you will be working on, do the following:<p>
<ul>
<li> <i>cd</i> to that module's <i>src</i> directory and generate the <i>Makefiles</i> using the <i>new_module.sh</i> script.<p>
<li> from the root of your working directory, update the makefiles of that module using the <i>import_project.sh</i> script.<p>
<li> build the new library for that module, using <i>make -f Makefile.*_lib</i>.
</ul>
<p>
   For example, to add a new method to the <i>CSeq_id</i> class, the set of affected modules
   includes <i>seq, seqalign, seqblock, seqfeat, seqloc,</i> and <i>seqres</i>, as all of these 
   modules use each other. Thus, the three steps outlined here must be executed for each of the 
   associated <i>src</i> subdirectories.<p>
   
<li> Create a new subdirectory for your application ("<i>appname</i>") which will use the new libraries, 
     using the <i>new_project.sh</i> script. This will create a subdirectory named <i>appname</i>, which
     contains a Makefile named <i>Makefile.appname_app</i>. This Makefile should then be edited 
     to replace the default definitions of the include and library paths.<p>

<li> Once you have written the source file for your application, it can be built using
     <i> make -f Makefile.appname_app</i>.
</ol>

The following script will do this for you:
<font color = "#008080"><pre>
#! /bin/sh

modules='seq seqres seqloc seqalign seqfeat seqblock seqset'
config=GCC-Debug

echo "**** Create a new working directory named 'Work' and cd to it:"

mkdir Work; cd Work

echo "**** Check out the objects directories with imported makefiles:"

$NCBI/c++/scripts/import_project.sh objects $NCBI/c++/$config/build

echo "**** Generate sources in each subdirectory:"

for m in $modules; do
    ( cd internal/c++/src/objects/$m; $NCBI/c++/scripts/new_module.sh; )
done

echo "**** Generated custom makefiles in each subdirectory:"

for m in $modules; do
    $NCBI/c++/scripts/import_project.sh objects/$m $NCBI/c++/$config/build;
done

echo "**** Build object libraries in each subdirectory:"

for m in $modules; do
    ( cd internal/c++/src/objects/$m; make -f Makefile.*_lib; );
done

echo "**** Create a directory for the new application:"

$NCBI/c++/scripts/new_project.sh testmod app $NCBI/c++/$config/build

echo "**** Edit the application's makefile:"

cd testmod

sed "s/LOCAL_CPPFLAGS = -I./LOCAL_CPPFLAGS = -I..\/internal\/c++\/include\//" 
    Makefile.testmod_app > tmp
</pre>
<tt class=code>
sed "s/LIB        = xncbi/LIB = seqset seq seqres seqloc seqalign seqfeat seqblock pub medline biblio general xser xncbi/" tmp > tmp2
	</tt><pre>
NEWLIBS=../internal/c++/src/objects

cat >tmp <<EOF
LDFLAGS  = -L$NEWLIBS/seq -L$NEWLIBS/seqalign -L$NEWLIBS/seqblock -L$NEWLIBS/seqfeat -L$NEWLIBS/seqloc \
 -L$NEWLIBS/seqres -L$NEWLIBS/seqset $(ORIG_LDFLAGS)
LIBS = $(NCBI_C_LIBPATH) $(NCBI_C_ncbi) $(ORIG_LIBS)
EOF

cat tmp2 tmp > Makefile.testmod_app

rm tmp*
</pre></font>
<p>
<a name="xmpl"></a><h3> An example </h3>
As a simple example, we defined the following new methods:

<ul><i>
<li> void CSeq_entry::Describe(int) const;
<li> void CBioseq_set::Describe(int) const;
<li> void CBioseq::Describe(void) const;
<li> void CSeq_id::Describe(void) const;
<li> void CSeq_inst::myGetLength() const;
</i></ul>

where the relationship between these classes is:
<pre>
CSeq_entry contains CHOICE of CBioseq or CBioseq_set 
  CBioseq_set contains a list&lt; CRef&lt;CSeq_entry&gt; &gt;
  CBioseq contains CSeq_inst and list&lt; CRef&lt;CSeq_id> >
</pre>

The methods' declarations (above) are added to the header files for the <i>user</i> classes,
<i>Seq_entry.hpp, Bioseq_set.hpp, Bioseq.hpp, Seq_inst.hpp, </i> and <i>Seq_id.hpp</i>, in the
<i>include/objects</i> subdirectories <i>seqset, seq,</i> and <i>seqloc</i> respectively. The
implementations are then added to the <i>user</i> classes <i>*.cpp</i> files.

<font color = red><pre>// added to src/objects/seqset/Bioseq_set.cpp</pre></font><pre>
void CBioseq_set::Describe(int n) const 
{
  for ( list< CRef< CSeq_entry> >::const_iterator i = GetSeq_set().begin();
  	i != GetSeq_set().end(); ++i)
    (**i).Describe(n);
}

</pre><font color = red><pre>// added to src/objects/seqset/Seq_entry.cpp</pre></font><pre>
void CSeq_entry::Describe(int n) const 
{
  switch (Which()) {
  case e_Seq:
    GetSeq().Describe();
    break;

  case e_Set:
    GetSet().Describe(n+1);
    break;

  case e_not_set:
    cout << "nothing selected \n";
  }
}

</pre><font color = red><pre>// added to src/objects/seq/BioSeq.cpp</pre></font><pre>
void CBioseq::Describe() const
{
    list< CRef< CSeq_id> > ids = GetId();

    for (list< CRef< CSeq_id> >::const_iterator id = ids.begin();
         id != ids.end(); ++id ) {

      (*id)->Describe();
    }

    GetInst().myGetLength();
    cout << endl;
}

</pre><font color = red><pre>// added to src/objects/seq/Seq_inst.cpp</pre></font><pre>
void CSeq_inst::myGetLength() const 
{
  cout << "myGetLength: " << GetLength();
}

</pre><font color = red><pre>// added to src/objects/seqloc/Seq_id.cpp</pre></font><pre>
void CSeq_id::Describe (void) const
{
  cout << SelectionName(Which()) << ' ';

  switch (Which()) {

  // try to print accession for selected choice type

  case e_Genbank:
    cout << GetGenbank().GetName() << " " << GetGenbank().GetAccession();
    break;

  case e_Embl:
    cout << GetEmbl().GetName() << " " << GetEmbl().GetAccession();
    break;
  
  // etc.
  }
}
</pre>
<p>
Note that each of these object modules' libraries must now be re-compiled to 
include the newly defined methods. The application which uses these methods 
might then look something like:

<pre>
int main(int argc, char* argv[])
{
  ifstream tmp(argv[1]);
  string type;
  tmp >> type;
  tmp.close();

  auto_ptr<CObjectIStream>
    in(CObjectIStream::Open(argv[1], eSerial_AsnText));

  if (type.compare("Seq-entry") == 0) {
    CSeq_entry seqent;
    *in >> seqent;
    seqent.Describe(0);
  }

  else if (type.compare("Bioseq-set") == 0) {
    CBioseq_set seqset;
    *in >> seqset;
    seqset.Describe(0);
  }

  else {
    cout << "type " << type << " not handled\n";
  }
}
</pre>

<a href="usrtypeinfo.html"> <i> previous</i> </a>
&nbsp;&nbsp;&nbsp;
<a href="../index.html"> <i> up </i> </a>
&nbsp;&nbsp;&nbsp;
<!-- a href=".html"> <i> next</i> </a-->

	 <hr>
	 <table border=0 width="100%" cellspacing=0>
		<tr>
		  <td><address><a href="mailto:zimmerma@ncbi.nlm.nih.gov">Diane Zimmerman</a></address></td>
		  <!-- <td align=center><i>$Revision$</i></td> -->
		  <td align=right><i>$Date$</i></td>
	 </table>

<!--#include virtual="../ssi/footer.shtml" -->
