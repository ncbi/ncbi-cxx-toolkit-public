<!--#set var="TITLE" value="Exception handling in the NCBI C++ Toolkit" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->

<a href="../lxr/source/include/corelib/ncbiexpt.hpp"><h1>Exception handling </a> in the NCBI C++ Toolkit</h1>

<ul>
  <li> <a href="#macro"> Macros for standard C++ exception handling</a>
  <li> <a href="#errno"> The CErrnoException Class </a>
  <li> <a href="#parse"> The CParseException Class </a>
  <li> <a href="#tracex"> Exception Tracing </a>
  <li> <a href="../libs/err_msg.html#ref_Exception"> Reference Manual pages</a>
</ul>

<a name="macro"></a>
<h3> Macros for standard C++ exception handling</h3>

The C++ <i>throw()</i> statement provides a mechanism for specifying the types of exceptions that
may be thrown by a function. Functions that do <i>not</i> include a <i>throw()</i> statement in
their declaration can throw any type of exception, but where the <i>throw()</i> statement <i>is</i>
used, undeclared exception types that are thrown will cause <i>std::unexpected()</i> to be raised.
Various compilers handle these events differently, and the first two macros listed below,
(<i>THROWS(()), THROWS_NONE</i>), are provided to support platform-independent exception
specifications.<p>

<table border=1 cellspacing=1>
  <caption></caption>
  <tr>
	 <th>Macro</th>
	 <th>C++ Equivalent </th>
	 <th>Synopsis </th>
  </tr>

  <tr>
	 <td><i>THROWS((types)) </i></td>
    <td><i> throw (types)  </i></td>
	 <td> Defines the type of exceptions thrown by the given function. <i>types</i> may be a single
	 object type or a comma delimited list.    </td>
  </tr>

  <tr>
	 <td><i> THROWS_NONE </i></td>
    <td><i> throw ()    </i></td>
	 <td> Specifies that the given function throws no exceptions.     </td>
  </tr>

  <tr>
	 <td><i>STD_CATCH(message)</i></td>
	 <td><i> catch(std::exception)</i></td>
	 <td> Provides uniform handling of all exceptions derived from <i>std::exception</i>. </td>
  </tr>

  <tr>
	 <td><i> STD_CATCH_ALL(message)</i></td>
	 <td><i> catch(...)</i></td>
	 <td> Applies <i>STD_CATCH()</i> to <i>std::exception</i> derived objects;
	 catches non-standard exceptions and generates an "Unknown exception" message.
    </td>
  </tr>
</table>
<p>

The <i> catch</i> macros provide uniform, routine exception handling with minimal effort from the
programmer.  We provide a convenient <i>STD_CATCH()</i> macro to print formatted messages to the
application's <a href="diag.html"> <i> diagnostic stream</i></a>. For example, if <i> F() </i>
throws an exception of the form:

<center> <tt> throw std::runtime_error(</tt><i>throw-msg</i>)</center> <br>

then 
<pre>
		try {F();}
		STD_CATCH(catch-msg);
</pre>
will generate a message of the form:<p>

<center> <tt> Error: [</tt><i>catch-msg</i><tt>] Exception: </tt><i>throw-msg</i></center><br>

In this example, the generated message starts with the <i>Error</i> tag, as that is the <a
href="diag.html#severity"> severity level</a> for the default diagnostic stream.  User-defined
classes that are derived from <i>std::exception</i> will be treated uniformly in the same
manner. The <i>throw</i> clause in this case creates a new instance of
<i>std::runtime_error</i> whose data member <i>desc</i> is initialized to
<i>throw-msg</i>. When the exception is then caught, the exception's member function
<i>what()</i> can be used to retrieve that message.<p>

The <i>STD_CATCH_ALL</i> macro catches all exceptions. If however, the exception
caught is <i>not</i> derived from <i>std::exception</i>, then the <i>catch</i> clause cannot
assume that <i>what()</i> has been defined for this object, and a default message is generated:<p>

<center> <tt> Error: [</tt><i>catch-msg</i><tt>] Exception: Unknown exception </tt></center><p>

<a name="errno"></a>
<a href="../docxx/CErrnoException.html"><h3> The CErrnoException Class </h3></a>
The <i>CErrnoException</i> class is derived from <i>std::runtime_error</i>, and in addition to the
<i>desc</i> string, has an <i>int</i> data member called <i>m_Errno</i>.  Like its parent class, 
its constructor takes a single string argument which will be stored in <i>desc</i>. The constructor
itself however, automagically adds information about the most recent error state as obtained via the 
global system variable <i>errno</i>:

<pre>
CErrnoException::CErrnoException(const string& what) THROWS_NONE
    : runtime_error(what + ": " + ::strerror(errno)), m_Errno(errno)
{
}
</pre>

<a name="parse"></a>
<a href="../docxx/CParseException.html"><h3> The CParseException Class </h3></a>
Similar to <i>CErrnoException</i>, the <i>CParseException</i> class is derived from 
<i>std::runtime_error</i>, and includes an additional <i>int</i> data member, in this
case called <i>m_Pos</i>. This class was specifically defined to support complex parsing tasks,
and its constructor requires that positional information be supplied along with the message
to be caught. Thus the call to instantiate a <i>CParseException</i> object is:  
<i>CParseException(msg, position)</i>.

<a name="tracex"></a>
<h3> Exception Tracing </h3>

Knowing exactly where an exception first occurs can be very useful for debugging purposes. Standard
C++ exception handling mechanisms do not have access to this information, but a set of
<i>THROW*_TRACE()</i> macros defined in the NCBI C++ Toolkit combine exception handling with <a
href="diag.html#trace"> <i>trace</i></a> mechanisms to provide such information.<p>

The most commonly used of these macros, <i>THROW1_TRACE(class_name, init_arg)</i>, instantiates
an exception object of type <i>class_name</i> using <i>init_arg</i> to initialize it. The definition of this
macro is:

<pre>
#define THROW1_TRACE(class_name, init_arg) \
    throw NCBI_NS_NCBI::DbgPrint(__FILE__, __LINE__, \
        class_name(init_arg), #class_name)
</pre>

From the <i>throw()</i> statement here, we see that the object actually being thrown by this macro
is the value returned by <a href="../lxr/ident?i=DbgPrint">DbgPrint</a>().
<i>DbgPrint()</i> in turn calls 
<a href="../lxr/ident?i=DbgPrint"><i>DoDbgPrint</i></a>().
The latter is an overloaded function that simply creates a diagnostic stream and writes the file name,
line number, and the exception's <i>what()</i> message to that stream. The exception object
(which is of type <i>class_name</i>) is then the value returned by <i>DbgPrint</i>.<p>

More generally, three sets of <i>THROW*_TRACE</i> macros are defined:

<ul><font color="#000080">
 <li><i> THROW0_TRACE(exception_object) </i>
 <li><i> THROW0p_TRACE(exception_object) </i>
 <li><i> THROW0np_TRACE(exception_object) </i>
</font><font color="#008080">
 <li><i> THROW1_TRACE(exception_class, exception_arg) </i>
 <li><i> THROW1p_TRACE(exception_class, exception_arg)</i>
 <li><i> THROW1np_TRACE(exception_class, exception_arg) </i>
</font><font color="#004080">
 <li><i> THROW_TRACE(exception_class, exception_args) </i>
 <li><i> THROWp_TRACE(exception_class, exception_args) </i>
 <li><i> THROWnp_TRACE(exception_class, exception_args) </i>
</font>
</ul>

The first three macros (<i>THROW0*_TRACE</i>) take a single argument, which may be a newly
constructed exception, as in: <p> <center><i>THROW0_TRACE(runtime_error("message"))</i></center><p>

or simply a <i>printable</i> object to be thrown, as in:

<p> <center> <i>THROW0_TRACE("print this message")</i> </center> <p>

The <i>THROW0_TRACE</i> macro accepts either an exception object or a string as the argument to be
thrown. The <i>THROW0p_TRACE</i> macro generalizes this functionality by accepting any
<i>printable</i> object, such as <i>complex(1,3)</i>, as its single argument.  Any object with a
defined output operator is, of course, printable.  The third macro generalizes this one step
further, and accepts aggregate arguments such as <i>vector&lt;T&gt;</i>, where <i>T</i> is a printable
object.  Note that in cases where the object to be thrown is not a <i>std::exception</i>,
you will need to use <i>STD_CATCH_ALL</i> or a custom catch to catch the thrown object. <p>

The remaining six macros accept two arguments: an "exception" class name and an initialization
argument, where both arguments are also passed to the trace message.  The class argument need not actually
be derived from <i>std::exception</i>, as the pre-processor simply uses the class name to construct
a new object of that type using the initialization argument.

All of the <i>THROW1*_TRACE</i> macros assume that there is a single initialization argument.  As in
the first three macros, <i>THROW1_TRACE()</i>, THROW1p_TRACE()</i> and <i>THROW1np_TRACE()</i>
specialize in different types of printable objects, ranging from exceptions and numeric and
character types, to aggregate and container types. <p>

The last three macros parallel the previous two sets of macros in their specializations, and
may be applied where the exception object's constructor takes multiple arguments. (See also the
discussion of <a href="../libs/err_msg.html#ref_Exception"><i>Exception handling</i></a> in the Reference Manual). 
<p>

It is also possible to specify that execution should abort immediately when an exception occurs. By
default, this feature is not activated, but the 
<a href="../lxr/ident?i=SetThrowTraceAbort">
<i>SetThrowTraceAbort()</i> </a> function can be used to activate it. Alternatively, you can turn it
on for the entire application by setting either the $ABORT_ON_THROW environment variable, or 
the application's registry ABORT_ON_THROW  entry (in the [DEBUG] section) to an arbitrary non-empty value.


<p>
<a href="diag.html"> <i> previous</i> </a>
&nbsp;&nbsp;&nbsp;
<a href="../index.html"> <i> up </i> </a>
&nbsp;&nbsp;&nbsp;
<a href="cref.html"> <i> next</i> </a>

	 <hr>
	 <table border=0 width="100%" cellspacing=0>
		<tr>
		  <td><address><a href="mailto:zimmerma@ncbi.nlm.nih.gov">Diane Zimmerman</a></address></td>
		  <!-- <td align=center><i>$Revision$</i></td> -->
		  <td align=right><i>$Date$</i></td>
	 </table>

<!--#include virtual="../ssi/footer.shtml" -->
