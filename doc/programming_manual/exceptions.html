<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>Exception handling in the NCBI C++ Toolkit</title>
  </head>
  <body bgcolor = white>
  <a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/source/include/corelib/ncbiexpt.hpp">
    <h1> Exception handling </a> in the NCBI C++ Toolkit </h1>

<ul>
  <li> <a href="#macro"> Macros for standard C++ exception handling</a>
  <li> <a href="#errno"> The CErrnoException Class </a>
  <li> <a href="#parse"> The CParseException Class </a>
  <li> <a href="#tracex"> Exception Tracing </a>
  <li> <a href="../libs/err_msg.html#ref_Exception"> Reference Manual pages</a>
</ul>

<a name="macro"> <h3> Macros for standard C++ exception handling</h3>

The following preprocessor macros have been defined in the NCBI C++ Toolkit to support 
standard C++ exception handling:<p>

<table border=1 cellspacing=1>
  <caption></caption>
  <tr>
	 <th>Macro</th>
	 <th>C++ Equivalent </th>
	 <th>Synopsis </th>
  </tr>

  <tr>
	 <td><i>THROWS((types)) </i></td>
    <td><i> throw (types)  </i></td>
	 <td> Defines the type of exceptions thrown by the given function. <i>types</i> may be a single
	 object type or a comma delimited list.    </td>
  </tr>

  <tr>
	 <td><i> THROWS_NONE </i></td>
    <td><i> throw ()    </i></td>
	 <td> Specifies that the given function throws no exceptions.     </td>
  </tr>

  <tr>
	 <td><i>STD_CATCH(message)</i></td>
	 <td><i> catch(std::exception)</i></td>
	 <td> Provides uniform handling of all exceptions derived from <i>std::exception</i>. </td>
  </tr>

  <tr>
	 <td><i> STD_CATCH_ALL(message)</i></td>
	 <td><i> catch(...)</i></td>
	 <td> Applies <i>STD_CATCH()</i> to <i>std::exception</i> derived objects;
	 catches non-standard exceptions and generates an "Unknown exception" message.
    </td>
  </tr>
</table>
<p>

C++ requires that all object types which may be thrown by an exception occurring inside a function
must be declared in that function's definition using the <i>throw</i> statement. Failure to do so
will cause <i>std::unexpected()</i> to be raised when an undeclared exception type is
thrown. Various compilers handle these events differently however, and the first two macros,
(<i>THROWS(()), THROWS_NONE</i>), support platform-independent exception specifications.<p>

The <i> catch</i> macros provide uniform, routine exception handling with minimal effort from
the programmer.  The <i>STD_CATCH()</i> macro prints formatted messages to the application's <a
href="diag.html"> <i> diagnostic stream</i></a>. For example, if <i> F() </i> throws an
exception of the form: 

<center> <tt> throw std::runtime_error(</tt><i>throw-msg</i>)</center> <br>

then 
<pre>
		try {F();}
		STD_CATCH(catch-msg);
</pre>
will generate a message of the form:<p>

<center> <tt> Error: [</tt><i>catch-msg</i><tt>] Exception: </tt><i>throw-msg</i></center><br>

In this example, the generated message starts with the <i>Error</i> tag, as that is the <a
href="diag.html#severity"> severity level</a> for the default diagnostic stream.  User-defined
classes that are derived from <i>std::exception</i> will be treated uniformly in the same
manner. The <i>throw</i> clause in this case creates a new instance of
<i>std::runtime_error</i> whose data member <i>desc</i> is initialized to
<i>throw-msg</i>. When the exception is then caught, the exception's member function
<i>what()</i> can be used to retrieve that message.<p>

The <i>STD_CATCH_ALL</i> macro catches all exceptions. If however, the exception
caught is <i>not</i> derived from <i>std::exception</i>, then the <i>catch</i> clause cannot
assume that <i>what()</i> has been defined for this object, and a default message is generated:<p>

<center> <tt> Error: [</tt><i>catch-msg</i><tt>] Exception: Unknown exception </tt></center><p>

<a name="errno"> <a href="../docxx/CErrnoException.html">
<h3> The CErrnoException Class </h3></a>
The <i>CErrnoException</i> class is derived from <i>std::runtime_error</i>, and in addition to the
<i>desc</i> string, has an <i>int</i> data member called <i>m_Errno</i>.  Like its parent class, 
its constructor takes a single string argument which will be stored in <i>desc</i>. The constructor
itself however, automagically adds information about the most recent error state as obtained via the 
global system variable <i>errno</i>:

<pre>
CErrnoException::CErrnoException(const string& what) THROWS_NONE
    : runtime_error(what + ": " + ::strerror(errno)), m_Errno(errno)
{
}
</pre>

<a name="parse"> <a href="../docxx/CParseException.html">
<h3> The CParseException Class </h3></a>
Similar to <i>CErrnoException</i>, the <i>CParseException</i> class is derived from 
<i>std::runtime_error</i>, and includes an additional <i>int</i> data member, in this
case called <i>m_Pos</i>. This class was specifically defined to support complex parsing tasks,
and its constructor requires that positional information be supplied along with the message
to be caught. Thus the call to instantiate a <i>CParseException</i> object is:  
<i>CParseException(msg, position)</i>.

<a name="tracex"> <h3> Exception Tracing </h3>
Knowing exactly where an exception first occurs can often provide critical information
during develpment. Standard C++ exception handling mechanisms do not have access to this
information, but a set of <i>THROW*_TRACE()</i> macros defined in the NCBI C++ Toolkit combine
exception handling with <a href="diag.html#trace"> <i>trace</i></a> mechanisms to provide such
information.<p>

The most commonly used of these macros, <i>THROW1_TRACE(class_name, init_arg) </i>, instantiates
an object of type <i>class_name</i> using <i>init_arg</i> to initialize it. When this newly
created object is thrown, detailed trace information specifying the file and line number where
the exception was raised is then generated on the diagnostic stream. <p>

More generally, three sets of <i>THROW*_TRACE</i> macros are defined:

<ul><font color="#000080">
 <li><i> THROW0_TRACE(exception_object) </i>
 <li><i> THROW0p_TRACE(exception_object) </i>
 <li><i> THROW0np_TRACE(exception_object) </i>
</font><font color="#008080">
 <li><i> THROW1_TRACE(exception_class, exception_arg) </i>
 <li><i> THROW1p_TRACE(exception_class, exception_arg)</i>
 <li><i> THROW1np_TRACE(exception_class, exception_arg) </i>
</font><font color="#004080">
 <li><i> THROW_TRACE(exception_class, exception_args) </i>
 <li><i> THROWp_TRACE(exception_class, exception_args) </i>
 <li><i> THROWnp_TRACE(exception_class, exception_args) </i>
</font>
</ul>

The first three macros (<i>THROW0*_TRACE</i>) take a single argument, which may be a newly
constructed exception, as in: <p> <center><i>THROW0_TRACE(runtime_error("message"))</i></center><p>

or simply a <i>printable</i> object to be thrown, as in:

<p> <center> <i>THROW0_TRACE("print this message")</i> </center> <p>

The <i>THROW0_TRACE</i> macro accepts either an exception object or a string as the argument to be
thrown. The <i>THROW0p_TRACE</i> macro generalizes this functionality by accepting any
<i>printable</i> object, such as <i>complex(1,3)</i>, as its single argument.  Any object with a
defined output operator is, of course, printable.  The third macro generalizes this one step
further, and accepts aggregate arguments such as <i>vector&lt;T&gt;</i>, where <i>T</i> is a printable
object.  Note that in cases where the object to be thrown is not a <i>std::exception</i> however,
you will need to use <i>STD_CATCH_ALL</i> or a custom catch to catch the thrown object. <p>

The remaining six macros accept two arguments: an "exception" class name and an initialization
argument, where both arguments are also passed to the trace message.  The class argument need not actually
be derived from <i>std::exception</i>, as the pre-processor simply uses the class name to construct
a new object of that type using the initialization argument.

All of the <i>THROW1*_TRACE</i> macros assume that there is a single initialization argument.  As in
the first three macros, <i>THROW1_TRACE()</i>, THROW1p_TRACE()</i> and <i>THROW1np_TRACE()</i>
specialize in different types of printable objects, ranging from exceptions and numeric and
character types, to aggregate and container types. <p>

The last three macros parallel the previous two sets of macros in their specializations, and
may be applied where the exception object's constructor takes multiple arguments. (See also the
discussion of <a href="../libs/err_msg.html#ref_Exception">Exception handling</a> in the Reference Manual). 
<p>

It is also possible to specify that execution should abort immediately when an exception occurs. By
default, this feature is not activated, but the 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=SetThrowTraceAbort">
<i>SetThrowTraceAbort()</i> </a> function can be used to activate it. Alternatively, you can turn it
on for the entire application by setting either the $ABORT_ON_THROW environment variable, or 
the application's registry ABORT_ON_THROW  entry (in the [DEBUG] section) to an arbitrary non-empty value.



<p>  </body>
<a href="diag.html"> <i> previous</i> </a>
&nbsp;&nbsp;&nbsp;
<a href="../index.html"> <i> up </i> </a>
&nbsp;&nbsp;&nbsp;
<a href="typeinfo.html"> <i> next</i> </a>
</html>

	 <hr>
	 <table border=0 width="100%" cellspacing=0>
		<tr>
		  <td><address><a href="mailto:zimmerma@ncbi.nlm.nih.gov">Diane Zimmerman</a></address></td>
		  <!-- <td align=center><i>$Revision$</i></td> -->
		  <td align=right><i>$Date$</i></td>
