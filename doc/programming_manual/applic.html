<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
  <title>A Simple Application Project</title>
</head>
<body BGCOLOR=white>
<h1> Writing a Simple Application Project </h1>

This page describes what you will need to know to write the simplest possible
NCBI application using the C++ Toolkit and libraries. The program simply 
prints a message to the screen.  Following this exercise however, will introduce
you to the foundation classes of the library.

<ul>
  <li> <a href="#using"> Using the NCBI Application Class </a>
  <li> <a href="#creating"> Creating the Application Class </a>
  <li> <a href="#inside"> Inside the Application Class </a>
</ul>

<a name="using">
<h3> Using the NCBI Application Class </h3>

Five fundamental classes form the foundation of the C++ toolkit and more generally, the C++
libraries at NCBI:

<ul>
 <li> class <a href="#CNcbiApplication"> CNcbiApplication</a>
 <li> class <a href="#CNcbiArguments"> CNcbiArguments</a>
 <li> class <a href="#CNcbiEnvironment"> CNcbiEnvironment</a>
 <li> class <a href="#CNcbiRegistry"> CNcbiRegistry</a>
 <li> class <a href="#CNcbiDiag"> CNcbiDiag</a>
</ul>

<a name="CNcbiApplication">

<a href="../docxx/CNcbiApplication.html">
<i>CNcbiApplication </i></a> is an abstract class used to define the basic functionality and
behavior of an NCBI application. Because this application class effectively supercedes the
C-style <i>main()</i> function, minimally, it must provide the same functionality, i.e.

<ul>
 <li> A mechanism to execute the actual application
 <li> A data structure for holding program arguments ("argv")
 <li> A data structure for holding environmental variables
</ul>

In addition, the application class provides the same features previously implemented in 
the C Toolkit, namely:
<ul>
 <li> Mechanisms for specifiying where, when, and how errors should be reported
 <li> Methods for reading, modifying, and writing information in the
				application's registry (configuration) file
</ul>

The mechansim to execute the application is provided by <i>CNcbiApplication</i>'s member
function <i>Run()</i> - which you must write your own implementation of. The <i>Run()</i> function
will be automatically invoked by <i>CNcbiApplication::AppMain()</i>, 
after it has initialized its
<i> CNcbiArguments, CNcbiEnvironment, CNcbiRegistry</i>, and <i> CNcbiDiag</i> data members.<p>

<a name="CNcbiArguments"> The 
<a href="../docxx/CNcbiArguments.html">
<i> CNcbiArguments </i></a> class provides a data structure for holding the application's
command-line arguments, along with methods for accessing and modifying these.  The data
structure is a simple C++ vector of strings. Thus access to it is implemented by member
functions using the built-in [] operator for arrays and vectors. Four additional class member
functions support retrieval and modification of the program name (intitially
<i>argv</i>[0]). <p>

<a name="CNcbiEnvironment"> Similarly, the 
<a href="../docxx/CNcbiEnvironment.html">
<i> CNcbiEnvironment </i></a> class provides a data structure for
storing, accessing, and modifying the environment variables accessed by the C library
routine <i>getenv()</i>. In this case the data structure is an associative array - a
C++ map container, that allows <i>[]</i> access with string rather than integer indexes. <p>

<a name="CNcbiRegistry"> The
<a href="../docxx/CNcbiRegistry.html">
<i> CNcbiRegistry </i></a> class is used to store, access, and modify runtime
information read from a configuration file. Previously, these files were by convention named
".*rc" files on <i> unix </i> systems. The convention for all platforms now is to name such
files <i>*.ini</i> (where * is by default the application name). <p>

Like the environment class, the registry class uses map structures to associate keys with
values. A configuration file entails more structure than environment variables however, as
the key-value pairs must be associated with specific sections. Accordingly, the registry
class's main data structure uses a map of maps, where the "containing" map is indexed by
sections while the "contained" map is indexed by keywords. <p>

<a name="CNcbiDiag"> The
<a href="../docxx/CNcbiDiag.html">
<i> CNcbiDiag </i></a> class implements much of the functionality of the NCBI C Toolkit error
processing mechanisms. Each instance of <i>CNcbiDiag</i> has a private buffer to
handle a <i>single</i> message, along with private severity level and post flags and their
associated get/set methods.<p>

The <i>CNcbiDiag</i> message buffer is initialized when the class is first instantiated. Additional
information can then be appended to the message using the overloaded stream operator <i><<</i>. Messages
can then be terminated explicitly using <i>CNcbiDiag's</i> stream manipulator <i>Endm</i>, or implicitly,
when the <i>CNcbiDiag</i> object exits scope. When the message is finally posted, a user-installed
callback function may be invoked to handle the message. The default is to post errors to <i>stderr</i>,
with the action determined by the severity level of the message. See also the discussion in the Reference Manual
section on <a href="../libs/err_msg.html#ref_Message"> message posting</a> for a more in-depth coverage.
<p>
<a name="creating">
<h3> Creating a Simple Application Class </h3>

<b>Step 1.</b> Define a subclass of the <i> CNcbiApplication </i> class.<p>

Because <i> CNcbiApplication::Run() </i> is defined as a pure virtual function, the class
cannot be used directly. Instead, you must first define a subclass which inherits from the
application class, and include an implementation of <i> Run() </i> in the subclass. <p>

Define the subclass in a header file, and in the subclass declaration, declare
<i>Run()</i> to be a virtual function:

<font color = "#008080"> 
<pre>
// File name: justApp.hpp

#ifndef NCBI_APP__HPP
#define NCBI_APP__HPP
#include &lt;corelib/ncbiapp.hpp&gt;

BEGIN_NCBI_SCOPE		

class CTestApp : public CNcbiApplication {
public:
    virtual int Run ();
};

END_NCBI_SCOPE

#endif // NCBI_APP__HPP
</pre>
<font color = black> 

<b>Step 2.</b> Define <i> main()</i> in the <i>*.cpp </i> file where you instantiate your
application subclass. <p>

Inside <i>main()</i>, instantiate your application subclass, and call its inherited function,
<i>AppMain()</i>. This file is also a good place to put the implementation of the
<i>Run()</i> function. Enclose the <i> Run() </i> implementation with <i> BEGIN_NCBI_SCOPE
</i> and <i> END_NCBI_SCOPE </i> statements, and precede <i>main() </i>(as well as any other 
code using the NCBI C++ Toolkit) with a <i>
USING_NCBI_SCOPE </i> statement: 

<font color = "#008080"> 
<pre>
// file justApp.cpp

#include "justApp.hpp"

BEGIN_NCBI_SCOPE

int CTestApp::Run() {
    cout << "Executing CTestApp::Run()!" << endl;
    return 0;
}

END_NCBI_SCOPE

USING_NCBI_SCOPE;

int main(int argc, const char* argv[]) 
{
    CTestApp theTestApp;
    return theTestApp.AppMain(argc, argv);
}

</pre>
<font color = black> 
<b>Step 3.</b> Assuming you have done all of this work in a project directory called 
"justApp", and have already run the <i>new_project.sh</i> script to create the makefile, you are
now ready to build your first application using:
<p>
<center><pre>make -f Makefile.justApp_app </pre></center>
<p>
The <i> SCOPE</i> statements are actually macros defined in 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/source/include/corelib/ncbistl.hpp">
<i>include/corelib/ncbistl.hpp</i></a>: 
<font color = "#000080"><pre>
#define BEGIN_NCBI_SCOPE namespace NCBI_NS_NCBI {
#define END_NCBI_SCOPE }
#define USING_NCBI_SCOPE using namespace NCBI_NS_NCBI
</pre> <font color = black>

All code occurring between the <i>BEGIN</i> and <i> END</i> statements will be added to a
namespace called <i>NCBI_NS_NCBI</i>. The <i>USING</i> macro allows you to access everything
currently defined in the namespace without requiring the :: scope operator.



<a name="inside">
<h3> Inside the NCBI Application Class </h3>

To review what we've done so far:

<ol>
 <li> We defined a subclass of  <i>CNcbiApplication </i> with an implementation of <i>Run()</i>.
 <li> We created an instance of this class in <i>main()</i>.
 <li> We invoked the class member function <i> AppMain()</i>, and passed <i>argc, argv[]</i> to it.
</ol>

Here is a somewhat simplified view of the application class's definition:
<font color = "#008080"> 
<xmp>
class CNcbiApplication {
public:

    int AppMain (int argc, char **argv, char **envp,
	         EAppDiagStream diag, char* config, string& name);

    virtual void Init();     
    virtual int  Run ();  
    virtual void Exit();     
    CNcbiArguments&   GetArguments();
    CNcbiEnvironment& GetEnvironment();
    CNcbiRegistry&    GetConfig();

protected:

    bool SetupDiag  (EAppDiagStream diag);
    bool LoadConfig (CNcbiRegistry& reg, const string* conf);

private:

    static CNcbiApplication*   m_Instance;  
    auto_ptr<CNcbiArguments>   m_Args;      
    auto_ptr<CNcbiEnvironment> m_Environ;   
    auto_ptr<CNcbiRegistry>    m_Config;    
    auto_ptr<CNcbiOstream>     m_DiagStream;
};
</xmp>
<font color = black> 
As you can see, the constituents of the class are themselves embedded classes, and are
defined as private data members. The <i> GetXxx() </i> functions in the application class
provide access to these private members, while the members themselves implement methods to
modify their contents.<p>

The protected function <i> SetupDiag() </i> corresponds to the NCBI C toolkit functions used to
set up error posting. This function defines the output stream for error messages, along with
default severity levels.  <i> LoadConfig() </i> reads the program's <i>.ini </i> configuration
file to load the application's parameters into the registry's map structures.<p>

With the creation of an instance of the <i>CTestApp</i> class in <i> main()</i>, the constructor for
the class is automatically invoked. Because <i>CTestApp</i> is a subclass of <i>
CNcbiApplication</i>, that constructor is inherited from the parent class. The
constructor simply resets (clears) the values of the private data members, and sets
<i>m_Instance</i> to point to the newly created object.<p>

The <i> AppMain() </i> function is also inherited from the parent class. Although this
function accepts up to six arguments, this example passes only the first two, with missing
values supplied by defaults.  <i> AppMain() </i> begins by resetting the internal data
members with the actual values provided by the arguments of <i>main()</i>. Once these internal data
structures have been loaded,  <i> AppMain() </i> calls the virtual functions 
<i> Init(), Run (), </i> and <i> Exit() </i> in succession to execute the application. <p>

The <i> Init() </i> and <i> Exit() </i> virtual functions are provided as places for developers to
add their own methods for specific applications. As this example does not require any
additional initialization/termination, these two functions simply return. The <i> Run() </i>
method prints out the message defined in <i>justApp.cpp</i> and exits.
<p>

As exemplified here, source files which utilize the <i>NCBIApplication</i> class must
<i>#include</i> the header file where that class is defined, <i>corelib/ncbiapp.hpp</i>, in the
<i>include</i> directory.  This header file in turn includes <i>corelib/ncbistd.hpp</i>, which
should <i>always</i> be <i>#included</i>. <p>

</body>
<a href="../index.html"> <i> up </i> </a>
&nbsp;&nbsp;&nbsp;
<a href="cref.html"> <i> next </i> </a>
</html>


	 <hr>
	 <table border=0 width="100%" cellspacing=0>
		<tr>
		  <td><address><a href="mailto:zimmerma@ncbi.nlm.nih.gov">Diane Zimmerman</a></address></td>
		  <!-- <td align=center><i>$Revision$</i></td> -->
		  <td align=right><i>$Date$</i></td>
	 </table>
