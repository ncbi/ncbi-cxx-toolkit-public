<!--#set var="TITLE" value="A Simple Application Project" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->

<h1>Writing a Simple Application Project</h1>

<ul>
<li>
<a href="#using">Using the NCBI Application Class</a></li>

<li>
<a href="#creating">Creating the Application Class</a></li>

<li>
<a href="#inside">Inside the Application Class</a></li>
</ul>
This page describes what you will need to know to write the simplest possible
application using the C++ Toolkit. The program simply prints a message
to the screen. Following this exercise however, will introduce you to the
foundation classes of the library.
<p><a NAME="using"></a>
<h3>
Using the NCBI Application Class</h3>
Five fundamental classes form the foundation of the C++ Toolkit:
<ul>
<li>
class <a href="#CNcbiApplication">CNcbiApplication</a></li>

<li>
class <a href="#CNcbiArguments">CNcbiArguments</a>&nbsp; (see also <a href="argdescr.html">CArgDescriptions,
CArgs, ...</a>)</li>

<li>
class <a href="#CNcbiEnvironment">CNcbiEnvironment</a></li>

<li>
class <a href="#CNcbiRegistry">CNcbiRegistry</a></li>

<li>
class <a href="#CNcbiDiag">CNcbiDiag</a></li>
</ul>
<a NAME="CNcbiApplication"></a><i><a href="../docxx/CNcbiApplication.html">CNcbiApplication</a></i>
is an abstract class used to define the basic functionality and behavior
of an NCBI application. Because this application class effectively supercedes
the <i>C</i>-style <i>main()</i> function, minimally, it must provide the
same functionality, i.e.
<ul>
<li>
A mechanism to execute the actual application</li>

<li>
A data structure for holding program command-line arguments ("argv")</li>

<li>
A data structure for holding environmental variables</li>
</ul>
In addition, the application class provides the same features previously
implemented in the C Toolkit, namely:
<ul>
<li>
Mechanisms for specifying where, when, and how errors should be reported</li>

<li>
Methods for reading, accessing, modifying, and writing information in the
application's registry (configuration) file</li>

<li>
Methods to describe, and then automatically parse, validate and access
program command-line arguments, and to generate the<i>USAGE</i> message</li>
</ul>
The mechansim to execute the application is provided by <i>CNcbiApplication</i>'s
member function <i>Run()</i> - which you must write your own implementation
of. The <i>Run()</i> function will be automatically invoked by <i>CNcbiApplication::AppMain()</i>,
after it has initialized its
<i>CNcbiArguments, CNcbiEnvironment, CNcbiRegistry</i>,
and <i>CNcbiDiag</i> data members.
<p><a NAME="CNcbiArguments"></a>The <i><a href="../docxx/CNcbiArguments.html">CNcbiArguments</a></i>
class provides a data structure for holding the application's command-line
arguments, along with methods for accessing and modifying these. Access
to the argument values is implemented using the built-in <i>[ ]</i> operator
. For example, the first argument in <i>argv</i> (following the program
name) can be retrieved using the
<i>CNcbiApplication::GetArguments()</i>
method, as:
<br>
<pre>string arg1_value = GetArguments()[1];</pre>
<br>Here,
<i>GetArguments()</i> returns the <i>CNcbiArguments</i> object,
whose argument values can then be retrieved using the <i>[ ]</i> operator.
Four additional <i>CNcbiArgument</i> member functions support retrieval
and modification of the program name (initially <i>argv</i>[0]). A helper
class, described in <i><a href="argdescr.html">Parsing, validating, and
accessing command line arguments</a></i>, supports the generation of
<i>USAGE</i>
messages and the imposition of constraints on the values of the input arguments.
<p><a NAME="CNcbiEnvironment"></a>The <i><a href="../docxx/CNcbiEnvironment.html">CNcbiEnvironment</a></i>
class provides a data structure for storing, accessing, and modifying the
environment variables accessed by the C library routine <i>getenv()</i>.
For example, to retrieve the value of environment variable <b>PATH</b>:
<br><pre>string arg1_value = GetEnvironment().Get("PATH");</pre>
<p><a NAME="CNcbiRegistry"></a>The
<i><a href="registry.html">CNcbiRegistry</a></i>
class is used to load, access, modify and store runtime information read
from a configuration file. Previously, these files were by convention named
<i>.*rc</i>
files on
<i>UNIX
</i>systems. The convention for all platforms now is to
name such files
<i>*.ini</i> (where * is by default the application name).
<p><a NAME="CNcbiDiag"></a>The
<i><a href="diag.html">CNcbiDiag
</a></i>class
implements much of the functionality of the NCBI C Toolkit error processing
mechanisms. Each instance of <i>CNcbiDiag</i> has a private buffer to handle
a <i>single</i> message, along with private severity level and post flags
and their associated get/set methods. A CNcbiDiag object has the look and
feel of an output stream; its member functions and friends include output
operators <i>>></i> and format manipulators. The default is to post errors
to <i>stderr</i>, with the action determined by the severity level of the
message, however user can provide another stream to post to, or create
an arbitrary callback to do the job, or just ignore all diagnostics. See
also <i><a href="diag.html">Diagnostic Streams </a></i>in this manual,
as well as the discussion in the Reference Manual section on <i><a href="../libs/err_msg.html#ref_Message">message
posting</a></i>.
<p><a NAME="creating"></a>
<h3>
Creating a Simple Application Class</h3>
<b>Step 1.</b> Define a subclass of the <i>CNcbiApplication </i>class.
<p>Because <i>CNcbiApplication::Run() </i>is defined as a pure virtual
function, the class cannot be used directly. Instead, you must first define
a subclass which inherits from <i>CNcbiApplication</i>, and implement
<i>Run()
</i>in
the subclass.
<p>Define the subclass in a header file, and in the subclass declaration,
declare
<i>Run()</i> to be a virtual function:
<pre>
// File name: justApp.hpp

#ifndef JUST_APP__HPP
#define JUST_APP__HPP
#include &lt;corelib/ncbiapp.hpp>

BEGIN_NCBI_SCOPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

class CTestApp : public CNcbiApplication
{
public:
&nbsp;&nbsp;&nbsp; virtual int Run(void);
};

END_NCBI_SCOPE

#endif /* JUST_APP__HPP */</pre>

<p><br><b>Step 2.</b> Define <i>main()</i> in the
<i>*.cpp</i> file where you instantiate your application subclass.
<p>Inside <i>main()</i>, instantiate your application
subclass, and call its inherited function,
<i>AppMain()</i>. This file
is also a good place to put the implementation of the
<i>Run()</i> function.
Enclose the <i>Run() </i>implementation with <i>BEGIN_NCBI_SCOPE
</i>and
<i>END_NCBI_SCOPE
</i>statements,
and precede <i>main() </i>(as well as any other code using the NCBI C++
Toolkit) with a <i>USING_NCBI_SCOPE </i>statement:
<pre>
// file justApp.cpp

#include "justApp.hpp"

BEGIN_NCBI_SCOPE

int CTestApp::Run() {
&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Executing CTestApp::Run()!" &lt;&lt; endl;
&nbsp;&nbsp;&nbsp; return 0;
}

END_NCBI_SCOPE</pre>

<pre>USING_NCBI_SCOPE;

int main(int argc, const char* argv[])&nbsp;
{
&nbsp;&nbsp;&nbsp; CTestApp theTestApp;
&nbsp;&nbsp;&nbsp; return theTestApp.AppMain(argc, argv);
}
</pre>

<b>Step 3.</b> Assuming you have done all of this
work in a project directory called "justApp", and have already run the
<i><a href="outside_tree.html">new_project.sh</a></i>
script to create the makefile, you are now ready to build your first application
using:
<pre>make -f Makefile.justApp_app</pre>
The <i>SCOPE</i> statements are actually macros defined
in <i><a href="../lxr/source/include/corelib/ncbistl.hpp">include/corelib/ncbistl.hpp</a></i>:
<pre>#define BEGIN_NCBI_SCOPE namespace NCBI_NS_NCBI {
#define END_NCBI_SCOPE }
#define USING_NCBI_SCOPE using namespace NCBI_NS_NCBI</pre>
All code occurring between the <i>BEGIN</i> and <i>END</i>
statements will be added to a namespace called <i>NCBI_NS_NCBI</i>. The
<i>USING</i>
macro allows you to access everything currently defined in the namespace
without requiring the :: scope operator.
<p>A more elaborate example, <i><a href="applic_cpp.html">applic.cpp</a></i>,
combines the usage of the <i>CNcbiApplication</i> class with the&nbsp;<i>
CArgDescriptions</i>, <i>CArgs, </i>and
<i>CNcbiDiag</i> classes. For a
more realistic usage of these classes, see also the test program, <i><a href="../lxr/source/src/objects/asn2asn/asn2asn.cpp">asn2asn.cpp</a></i>.
<p><a NAME="inside"></a>
<h3>Inside the NCBI Application Class</h3>
To review what we've done so far:
<ol>
<li>
We defined a subclass of <i>CNcbiApplication </i>with
an implementation of <i>Run()</i>.</li>

<li>
We created an instance of this class in <i>main()</i>.</li>

<li>
In <i>main()</i>, we invoked the class member function
<i>AppMain()</i>,
and passed <i>argc, argv[ ]</i> to it.</li>
</ol>
Here is a somewhat simplified view of the application
class's definition:
<pre>
class CNcbiApplication
{
public:
   int AppMain (int argc, const char **argv, const char **envp,
   EAppDiagStream diag, const char* config, const string&amp; name);
  
   virtual void Init();
   virtual int  Run () = 0;
   virtual void Exit();

   CNcbiArguments&amp;   GetArguments();
   CNcbiEnvironment&amp; GetEnvironment();
   CNcbiRegistry&amp;    GetConfig();

protected:
   virtual bool SetupDiag_AppSpecific(void);
   virtual bool LoadConfig(CNcbiRegistry&amp; reg, const string* conf);
   .............
};
</pre>
The protected virtual function <i>SetupDiag_AppSpecific()</i>
can be redefined to setup error posting specific for your application.
<i>SetupDiag_AppSpecific()</i>
will be called inside <i>AppMain()</i> by default if the error posting
has not been setup already. Also, if you pass
<b>diag</b>=<i>eDS_AppSpecific</i>
to <i>AppMain()</i>, then <i>SetupDiag_AppSpecific()</i> will be called
for sure, regardless of the error posting setup that was active before
the <i>AppMain()</i> call.
<p>The protected virtual function <i>LoadConfig()
</i>reads
the program's <i>.ini </i>configuration file to load the application's
parameters into the registry. The default implementation of <i>LoadConfig()</i>
expects to find a configuration file named
<i>progname.ini</i>, and will
generate a warning to the user if no such file is found.
<p><a NAME="appmain"></a>
<br>The <i>AppMain() </i>function is also inherited
from the parent class. Although this function accepts up to six arguments,
this example passes only the first two, with missing values supplied by
defaults. The remaining four arguments specify:
<ul>
<li>
(#3) a NULL-terminated array of '\0'-terminated
character strings from which the environment variables can be read</li>

<li>
(#4) how to setup a diagnostic stream for message posting</li>

<li>
(#5) the name of a <i>.ini</i> configuration
file (will use program name with suffix <i>.ini</i> by default)</li>

<li>
(#6) a program name (to be used in lieu of <i>argv[0]</i>)</li>
</ul>
In order to avoid the display of a warning message when no configuration file is present, the
<i>.ini</i>
file should be explicitly specified as <i>NULL (zero)</i>, as in:
<p><pre>AppMain (argc, argv, envp, diag_stream, 0, progname);</pre>

<p><i>AppMain() </i>begins by resetting the internal
data members with the actual values provided by the arguments of <i>main()</i>.
Once these internal data structures have been loaded, <i>AppMain() </i>calls
the virtual functions <i>Init(), Run(), </i>and <i>Exit() </i>in succession
to execute the application.
<p>The <i>Init() </i>and <i>Exit() </i>virtual functions
are provided as places for developers to add their own methods for specific
applications. As this example does not require any additional initialization/termination,
these two functions simply return. The <i>Run() </i>method prints out the
message defined in <i>justApp.cpp</i> and exits.
<p>As exemplified here, source files which utilize
the <i>CNcbiApplication</i> class must
<i>#include</i> the header file
where that class is defined, <i>corelib/ncbiapp.hpp</i>, in the
<b><i>include/</i></b>
directory. This header file in turn includes <i>corelib/ncbistd.hpp</i>,
which should <i>always</i> be <i>#include</i>'d.
<p><i><a href="../index.html">up&nbsp;</a></i> <i><a href="argdescr.html">next&nbsp;</a></i>
<hr>
<table BORDER=0 CELLSPACING=0 WIDTH="100%" >
<tr>
<td>
<address>
<a href="mailto:zimmerma@ncbi.nlm.nih.gov">Diane Zimmerman</a></address>
</td>

<td><!-- <td align=center><i>$Revision$</i></td> --></td>

<td ALIGN=RIGHT><i>$Date$</i></td>
</tr>

<tr>
<td>
<address>
<a href="mailto:vakatov@ncbi.nlm.nih.gov">Denis Vakatov</a></address>
</td>
</tr>
</table>

<!--#include virtual="../ssi/footer.shtml" -->
