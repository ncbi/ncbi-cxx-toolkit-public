<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.75 [en] (X11; U; SunOS 5.7 sun4u) [Netscape]">
   <title>A Simple Application Project</title>
</head>
<body bgcolor="#FFFFFF">

<h1>
Writing a Simple Application Project</h1>
This page describes what you will need to know to write the simplest possible
NCBI application using the C++ Toolkit and libraries. The program simply
prints a message to the screen. Following this exercise however, will introduce
you to the foundation classes of the library.
<ul>
<li>
<a href="#using">Using the NCBI Application Class</a></li>

<li>
<a href="#creating">Creating the Application Class</a></li>

<li>
<a href="#inside">Inside the Application Class</a></li>
</ul>
<a NAME="using"></a>
<h3>
Using the NCBI Application Class</h3>
Five fundamental classes form the foundation of the C++ toolkit:
<ul>
<li>
class <a href="#CNcbiApplication">CNcbiApplication</a></li>

<li>
class <a href="#CNcbiArguments">CNcbiArguments</a></li>

<li>
class <a href="#CNcbiEnvironment">CNcbiEnvironment</a></li>

<li>
class <a href="#CNcbiRegistry">CNcbiRegistry</a></li>

<li>
class <a href="#CNcbiDiag">CNcbiDiag</a></li>
</ul>
<a NAME="CNcbiApplication"></a><i><a href="../docxx/CNcbiApplication.html">CNcbiApplication
</a></i>is
an abstract class used to define the basic functionality and behavior of
an NCBI application. Because this application class effectively supercedes
the C-style <i>main()</i> function, minimally, it must provide the same
functionality, i.e.
<ul>
<li>
A mechanism to execute the actual application</li>

<li>
A data structure for holding program arguments ("argv")</li>

<li>
A data structure for holding environmental variables</li>
</ul>
In addition, the application class provides the same features previously
implemented in the C Toolkit, namely:
<ul>
<li>
Mechanisms for specifiying where, when, and how errors should be reported</li>

<li>
Methods for reading, modifying, and writing information in the application's
registry (configuration) file</li>
</ul>
The mechansim to execute the application is provided by <i>CNcbiApplication</i>'s
member function <i>Run()</i> - which you must write your own implementation
of. The <i>Run()</i> function will be automatically invoked by <i>CNcbiApplication::AppMain()</i>,
after it has initialized its
<i>CNcbiArguments, CNcbiEnvironment, CNcbiRegistry</i>,
and <i>CNcbiDiag</i> data members.
<p><a NAME="CNcbiArguments"></a>The <i><a href="../docxx/CNcbiArguments.html">CNcbiArguments
</a></i>class
provides a data structure for holding the application's command-line arguments,
along with methods for accessing and modifying these. The data structure
is a simple C++ vector of strings. Thus access to it is implemented by
member functions using the built-in [] operator for arrays and vectors.
For example, the first argument in <i>argv</i> (following the program name)
can be retrieved using the
<i>CNcbiApplication::GetArguments()</i> method,
as: <i>GetArguments()[1]</i>. Here,
<i>GetArguments()</i> returns the <i>CNcbiArguments</i>
object, whose argument values can then be retrieved using the <i>[]</i>
operator. Four additional <i>CNcbiArgument</i> member functions support
retrieval and modification of the program name (intitially <i>argv</i>[0]).
A helper class, described in <i><a href="argdescr.html">Parsing, validating,
and accessing command line arguments</a></i>, supports the generation of
<i>usage</i>
messages and the imposition of constraints on the values of the input arguments.
<p><a NAME="CNcbiEnvironment"></a>The <i><a href="../docxx/CNcbiEnvironment.html">CNcbiEnvironment
</a></i>class
provides a data structure for storing, accessing, and modifying the environment
variables accessed by the C library routine <i>getenv()</i>. In this case
the data structure is an associative array - a C++ map container, that
allows <i>[]</i> access with string rather than integer indexes.
<p><a NAME="CNcbiRegistry"></a>The
<i><a href="../docxx/CNcbiRegistry.html">CNcbiRegistry
</a></i>class
is used to store, access, and modify runtime information read from a configuration
file. Previously, these files were by convention named ".*rc" files on
<i>unix
</i>systems. The convention for all platforms now is to name such files
<i>*.ini</i> (where * is by default the application name).
<p>Like the environment class, the registry class uses map structures to
associate keys with values. A configuration file entails more structure
than environment variables however, as the key-value pairs must be associated
with specific sections. Accordingly, the registry class's main data structure
uses a map of maps, where the "containing" map is indexed by sections while
the "contained" map is indexed by keywords.
<p><a NAME="CNcbiDiag"></a>The
<i><a href="../docxx/CNcbiDiag.html">CNcbiDiag
</a></i>class
implements much of the functionality of the NCBI C Toolkit error processing
mechanisms. Each instance of <i>CNcbiDiag</i> has a private buffer to handle
a <i>single</i> message, along with private severity level and post flags
and their associated get/set methods.
<p>&nbsp;The <i>CNcbiDiag</i> message buffer is initialized when the class
is first instantiated. Additional information can then be appended to the
message using the overloaded stream operator
<i>&lt;&lt;</i>. Messages
can then be terminated explicitly using <i>CNcbiDiag's</i> stream manipulator
<i>Endm</i>,
or implicitly, when the <i>CNcbiDiag</i> object exits scope. When the message
is finally posted, a user-installed callback function may be invoked to
handle the message. The default is to post errors to <i>stderr</i>, with
the action determined by the severity level of the message. See also <i><a href="diag.html">Diagnostic
Streams </a></i>in this manual, as well as the discussion in the Reference
Manual section on <i><a href="../libs/err_msg.html#ref_Message">message
posting</a></i>.
<p><a NAME="creating"></a>
<h3>
Creating a Simple Application Class</h3>
<b>Step 1.</b> Define a subclass of the <i>CNcbiApplication </i>class.
<p>&nbsp;Because <i>CNcbiApplication::Run() </i>is defined as a pure virtual
function, the class cannot be used directly. Instead, you must first define
a subclass which inherits from the application class, and include an implementation
of <i>Run() </i>in the subclass.
<p>Define the subclass in a header file, and in the subclass declaration,
declare
<i>Run()</i> to be a virtual function:
<pre><font color="#008080">// File name: justApp.hpp

#ifndef NCBI_APP__HPP
#define NCBI_APP__HPP
#include &lt;corelib/ncbiapp.hpp>

BEGIN_NCBI_SCOPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

class CTestApp : public CNcbiApplication {
public:
&nbsp;&nbsp;&nbsp; virtual int Run ();
};

END_NCBI_SCOPE

#endif // NCBI_APP__HPP</font></pre>
<font color="#000000"><b>Step 2.</b> Define <i>main()</i> in the <i>*.cpp
</i>file
where you instantiate your application subclass.</font>
<p><font color="#000000">Inside <i>main()</i>, instantiate your application
subclass, and call its inherited function,
<i>AppMain()</i>. This file
is also a good place to put the implementation of the
<i>Run()</i> function.
Enclose the <i>Run() </i>implementation with <i>BEGIN_NCBI_SCOPE
</i>and
<i>END_NCBI_SCOPE
</i>statements,
and precede <i>main() </i>(as well as any other code using the NCBI C++
Toolkit) with a <i>USING_NCBI_SCOPE </i>statement:</font>
<pre><font color="#008080">// file justApp.cpp

#include "justApp.hpp"

BEGIN_NCBI_SCOPE

int CTestApp::Run() {
&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Executing CTestApp::Run()!" &lt;&lt; endl;
&nbsp;&nbsp;&nbsp; return 0;
}

END_NCBI_SCOPE

USING_NCBI_SCOPE;

int main(int argc, const char* argv[])&nbsp;
{
&nbsp;&nbsp;&nbsp; CTestApp theTestApp;
&nbsp;&nbsp;&nbsp; return theTestApp.AppMain(argc, argv);
}</font>

</pre>
<font color="#000000"><b>Step 3.</b> Assuming you have done all of this
work in a project directory called "justApp", and have already run the
<i>new_project.sh</i>
script to create the makefile, you are now ready to build your first application
using:</font>
<center><pre><font color="#000000">make -f Makefile.justApp_app</font></pre></center>
<font color="#000000">The <i>SCOPE</i> statements are actually macros defined
in <i><a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/source/include/corelib/ncbistl.hpp">include/corelib/ncbistl.hpp</a></i>:</font>
<pre><font color="#000080">#define BEGIN_NCBI_SCOPE namespace NCBI_NS_NCBI {
#define END_NCBI_SCOPE }
#define USING_NCBI_SCOPE using namespace NCBI_NS_NCBI</font></pre>
<font color="#000000">All code occurring between the <i>BEGIN</i> and <i>END</i>
statements will be added to a namespace called <i>NCBI_NS_NCBI</i>. The
<i>USING</i>
macro allows you to access everything currently defined in the namespace
without requiring the :: scope operator.</font>
<p><font color="#000000">&nbsp;A more elaborate example, <i><a href="applic_cpp.html">applic.cpp</a></i>,
combines the usage of the <i>CNcbiApplication</i> class with the&nbsp;<i>
CArgDescriptions</i>, <i>CArgs, </i>and
<i>CNcbiDiag</i> classes. For a
more realistic usage of these classes, see also the test program, <i><a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/source/src/objects/asn2asn/asn2asn.cpp">asn2asn.cpp</a></i>.&nbsp;</font><a NAME="inside"></a>
<h3>
<font color="#000000">Inside the NCBI Application Class</font></h3>
<font color="#000000">To review what we've done so far:</font>
<ol>
<li>
<font color="#000000">We defined a subclass of <i>CNcbiApplication </i>with
an implementation of <i>Run()</i>.</font></li>

<li>
<font color="#000000">We created an instance of this class in <i>main()</i>.</font></li>

<li>
<font color="#000000">We invoked the class member function <i>AppMain()</i>,
and passed <i>argc, argv[]</i> to it.</font></li>
</ol>
<font color="#000000">Here is a somewhat simplified view of the application
class's definition:</font>
<pre><font color="#008080">class CNcbiApplication {
public:

&nbsp;&nbsp;&nbsp; int AppMain (int argc, char **argv, char **envp,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EAppDiagStream diag, char* config, string&amp; name);

&nbsp;&nbsp;&nbsp; virtual void Init();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; virtual int&nbsp; Run ();&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; virtual void Exit();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; CNcbiArguments&amp;&nbsp;&nbsp; GetArguments();
&nbsp;&nbsp;&nbsp; CNcbiEnvironment&amp; GetEnvironment();
&nbsp;&nbsp;&nbsp; CNcbiRegistry&amp;&nbsp;&nbsp;&nbsp; GetConfig();

protected:

&nbsp;&nbsp;&nbsp; bool SetupDiag&nbsp; (EAppDiagStream diag);
&nbsp;&nbsp;&nbsp; bool LoadConfig (CNcbiRegistry&amp; reg, const string* conf);

private:

&nbsp;&nbsp;&nbsp; static CNcbiApplication*&nbsp;&nbsp; m_Instance;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; auto_ptr&lt;CNcbiArguments>&nbsp;&nbsp; m_Args;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; auto_ptr&lt;CNcbiEnvironment> m_Environ;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; auto_ptr&lt;CNcbiRegistry>&nbsp;&nbsp;&nbsp; m_Config;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; auto_ptr&lt;CNcbiOstream>&nbsp;&nbsp;&nbsp;&nbsp; m_DiagStream;
};</font></pre>
<font color="#000000">As you can see, the constituents of the class are
themselves embedded classes, and are defined as private data members. The&nbsp;<i>
GetXxx()&nbsp;</i> functions in the application class provide access to
these private members, while the members themselves implement methods to
modify their contents.The protected function <i>SetupDiag() </i>corresponds
to the NCBI C toolkit functions used to set up error posting. This function
defines the output stream for error messages, along with default severity
levels. <i>LoadConfig() </i>reads the program's <i>.ini </i>configuration
file to load the application's parameters into the registry's map structures.&nbsp;
By default, the application expects to find a configuration file named
<i>progname.ini</i>,
and will generate a warning to the user if no such file is found.&nbsp;
This default behavior however, can be modified by the arguments provided
to the <i>AppMain() </i>method, as described below.</font>
<p><font color="#000000">With the creation of an instance of the
<i>CTestApp</i>
class in <i>main()</i>, the constructor for the class is automatically
invoked. Because <i>CTestApp</i> is a subclass of <i>CNcbiApplication</i>,
that constructor is inherited from the parent class. The constructor simply
resets (clears) the values of the private data members, and sets
<i>m_Instance</i>
to point to the newly created object.</font>
<p><font color="#000000">The <i>AppMain() </i>function is also inherited
from the parent class. Although this function accepts up to six arguments,
this example passes only the first two, with missing values supplied by
defaults. The remaining four arguments specify (1) a string from which
environment variable settigs can be read, (2) a diagnostic stream for message
posting, (3) the name of a <i>.ini</i> configuration file, and (4) a program
name (to be used in lieu of <i>argv[0]</i>). </font><font color="#008080">I</font><font color="#003300">n
order to avoid the display of a warning message when no configuration file
is present, the <i>.ini</i> file should be explicitly specified as <i>NULL</i>,
as in:</font><font color="#008080"></font>
<center>
<p><i><font color="#008080">AppMain (argc, argv, envp, diag_stream, NULL,
progname);</font></i></center>

<p><font color="#000000"><i>AppMain() </i>begins by resetting the internal
data members with the actual values provided by the arguments of <i>main()</i>.
Once these internal data structures have been loaded, <i>AppMain() </i>calls
the virtual functions <i>Init(), Run (), </i>and <i>Exit() </i>in succession
to execute the application.</font>
<p><font color="#000000">The <i>Init() </i>and <i>Exit() </i>virtual functions
are provided as places for developers to add their own methods for specific
applications. As this example does not require any additional initialization/termination,
these two functions simply return. The <i>Run() </i>method prints out the
message defined in <i>justApp.cpp</i> and exits.</font>
<p><font color="#000000">As exemplified here, source files which utilize
the <i>NCBIApplication</i> class must
<i>#include</i> the header file where
that class is defined, <i>corelib/ncbiapp.hpp</i>, in the
<i>include</i>
directory. This header file in turn includes <i>corelib/ncbistd.hpp</i>,
which should <i>always</i> be <i>#included</i>.</font>
<p><font color="#000000"><i><a href="../index.html">up&nbsp;</a></i>&nbsp;

<i><a href="argdescr.html">next&nbsp;</a></i></font>
<hr>
<table BORDER=0 CELLSPACING=0 WIDTH="100%" >
<tr>
<td>
<address>
<a href="mailto:zimmerma@ncbi.nlm.nih.gov">Diane Zimmerman</a></address>
</td>

<td><!-- <td align=center><i>$Revision$</i></td> --></td>

<td ALIGN=RIGHT><i>$Date$</i></td>
</tr>
</table>

</body>
</html>
