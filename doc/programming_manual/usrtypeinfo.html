<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.75 [en] (X11; U; SunOS 5.7 sun4u) [Netscape]">
   <title>User-defined type information</title>
</head>
<body bgcolor="#FFFFFF">

<h1>
User-defined type information</h1>

<ul>
<li>
<a href="#introduction">Introduction</a></li>

<li>
<a href="#macros">Installing a <i>GetTypeInfo()</i> function: the <i>BEGIN_/END_</i>
macros</a></li>

<li>
<a href="#addm">Specifying internal structure and class inheritance: the
<i>ADD_</i> macros</a></li>
</ul>
<a NAME="introduction"></a>
<h3>
Introduction</h3>
Object type information, as it is used in the NCBI C++ Toolkit, is defined
in the section on <i><a href="typeinfo.html">Runtime Object Type Information</a></i>.
As described there, all of the classes and constructs defined in the serial
<i>include</i> and <i>src</i> directories have a static implementation
of a <i>GetTypeInfo()</i> function that yields a <i><a href="typeinfo.html#ctypeinfo">CTypeInfo</a></i>
for the object of interest. In this section, we describe how type information
can also be generated and accessed for user-defined types. We begin with
a review of some of the basic notions intoduced in the previous discussion.
<p>The type information for a class is stored outside any instances of
that class, in a statically created <i><a href="typeinfo.html#ctypeinfo">CTypeInfo</a></i>
object. A <i>class</i>'s type information includes the class layout, inheritance
relations, external alias, and various other attributes that are independent
of specific instances. In addition, the type information object provides
an interface to the class's data members.
<p>&nbsp;Limited type information is also available for primitive data
types, enumerations, containers, and pointers. The type information for
a primitive type specifies that it is an <i>int, float,</i> or
<i>char</i>,
etc., and whether or not that element is signed. Enumerations are a special
kind of primitive type, whose type information specifies its enumeration
values and named elements. Type information for containers can specify
both the type of container and the type of elements. The type information
for a pointer provides convenient methods of access to the type information
for the type pointed to.
<p>&nbsp;For all types, the type information is encoded in a static <i>CTypeInfo</i>
object, which is then accessed by all instances of a given type using a
<i><a href="../lxr/ident?i=GetTypeInfo">GetTypeInfo()</a></i>
function. For <i>class</i> types, this function is implemented as a static
method for the class. For non class types, <i>GetTypeInfoXxx()</i> is implemented
as a static global function, where <i>Xxx</i> is a unique suffix generated
from the type's name. With the first invocation of <i>GetTypeInfo()</i>
for a given type, the static <i>CTypeInfo</i> object is created, which
then persists (local to the function <i>GetTypeInfo()</i>) throughout execution.
Subsequent calls to <i>GetTypeInfo()</i> simply return a pointer to this
statically created local object.
<p>In order to make type information about <i>user-defined</i> classes
accessible to your application, the user-defined classes must also implement
a static <i>GetTypeInfo()</i> method. A set of preprocessor <a href="#macros">macros</a>
is available, which greatly simplifies this effort. A pre-requisite to
using these macros however, is that the class definition must include the
following line:
<p><a NAME="cdcl"></a>
<center><pre>DECLARE_INTERNAL_TYPE_INFO();</pre></center>
This pre-processor macro will generate the following in-line statement
in the class definition:
<center><pre>static const NCBI_NS_NCBI::CTypeInfo* GetTypeInfo(void);</pre></center>
As with class objects, there must be some means of declaring the type information
function for an enumeration prior to using the macros which implement that
function. Given an enumeration named <i>EMyEnum</i>,
<center><i>DECLARE_ENUM_INFO(EMyEnum)</i></center>
will generate the following declaration:
<center><pre>const CEnumeratedTypeValues* GetTypeInfo_enum_EMyEnum(void);</pre></center>
The <i>DECLARE_ENUM_INFO()</i> macro should appear in the header file where
the enumeration is defined, immediately following the definition. The <i>DECLARE_INTERNAL_ENUM_INFO</i>
macro is intended for usage with internal class definitions, as in:
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class ClassWithEnum {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enum EMyEnum {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DECLARE_INTERNAL_ENUM_INFO(EMyEnum);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</pre>
The C++ Toolkit also allows one to provide type information for legacy
C style <i>struct</i> and
<i>choice</i> elements defined in the C Toolkit.
The mechanisms used to implement this are mentioned but not described in
detail here, as it is not likely that newly-defined types will be in these
categories.&nbsp;<a NAME="macros"></a>
<h3>
Installing a <i>GetTypeInfo()</i> function: the <i>BEGIN_/END_</i> macros</h3>
Several pre-processor macros are available for the installation of the
<i>GetTypeInfo()</i> functions for different types. Table 1 lists six <i>BEGIN_NAMED_*_INFO</i>
macros, along with a description of the type of object each can be applied
to and its expected arguments. Each macro in Table 1 has a corresponding
<i>END_*_INFO</i> macro definition.
<p>&nbsp;The first four macros in Table 1 apply to C++ objects. The <i>DECLARE_INTERNAL_TYPE_INFO()</i>
macro
<b>must</b> appear in the class definition's public section. These
macros take two
<i>string</i> arguments:
<ul>
<li>
an external alias for the type, and</li>

<li>
the internal C++ symbolic class name.</li>
</ul>
<a NAME="alias"></a>The external alias is required for serializable objects
whose external name differs from the internal C++ class name. For example,
the external object names specified in the ASN.1 modules (in
<i>src/objects</i>)
are prefixed with the letter "C" in the corresponding C++ class names (e.g.,
<i>Bioseq</i>
versus <i>CBioseq</i>). Each of the "named" macros in Table 1 has a corresponding
"unnamed" macro which accepts the (unquoted) symbolic class name as one
of its arguments, and generates a call to the corresponding "named" macro
using a quoted string. For example,
<i>BEGIN_CLASS_INFO</i> is defined
as:
<pre><font color="#000080">#define BEGIN_CLASS_INFO(ClassName) \
&nbsp;&nbsp;&nbsp; BEGIN_NAMED_CLASS_INFO(#ClassName, ClassName)</font></pre>
The next two macros implement global, uniquely named functions which provide
access to type information for C++ enumerations; the resulting functions
are named <i>GetTypeInfo_enum_[EnumName]</i>. The <i>DECLARE_ENUM_INFO()</i>
or <i>DECLARE_ENUM_INFO_IN()</i> macro should be used in these cases to
declare the <i>GetTypeInfo*()</i> functions.
<p>&nbsp;The usage of these six macros generally takes the following form:
<pre><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp; BEGIN_*_INFO(ClassName)
&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADD_*(MemberName);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADD_*(memberName);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp; END_*_INFO</font></pre>
That is, the <i>BEGIN/END</i> macros are used to generate the function's
signature and enclosing block, and various <i>ADD_*</i> macros are applied
to add information about internal members and class relations.
<table BORDER WIDTH="100%" >
<tr>
<th>Macro name</th>

<th>Used for</th>

<th>Arguments</th>
</tr>

<tr>
<td><a href="#class">BEGIN_NAMED_CLASS_INFO</a></td>

<td>Non-abstract class object</td>

<td>ClassAlias, ClassName</td>
</tr>

<tr>
<td><a href="#abstr">BEGIN_NAMED_ABSTRACT_CLASS_INFO</a></td>

<td>Abstract class object</td>

<td>ClassAlias, ClassName</td>
</tr>

<tr>
<td><a href="#derive">BEGIN_NAMED_DERIVED_CLASS_INFO</a></td>

<td>Derived subclass object</td>

<td>ClassAlias, ClassName, BaseClassName</td>
</tr>

<tr>
<td><a href="#choice">BEGIN_NAMED_CHOICE_INFO</a></td>

<td>C++ class choice object</td>

<td>ClassAlias, ClassName</td>
</tr>

<tr>
<td><a href="#enum">BEGIN_NAMED_ENUM_INFO</a></td>

<td>Enum object</td>

<td>EnumAlias, EnumName, IsInteger</td>
</tr>

<tr>
<td><a href="#enum_in">BEGIN_NAMED_ENUM_IN_INFO</a></td>

<td>internal Enum object</td>

<td>EnumAlias, CppContext, EnumName, IsInteger</td>
</tr>

<caption ALIGN=BOTTOM>Table 1</caption>
</table>

<ul>
<li>
<a NAME="class"></a><i><a href="../lxr/ident?i=BEGIN_NAMED_CLASS_INFO">BEGIN_NAMED_CLASS_INFO(ClassAlias,
ClassName)</a></i></li>

<br><i><a href="../lxr/ident?i=BEGIN_CLASS_INFO">BEGIN_CLASS_INFO(ClassName)</a></i>
<br>These macros should be used on classes that do not contain any pure
virtual functions. For example, the <i>GetTypeInfo()</i> method for the
<i><a href="iterators.html#CPerson">CPerson</a></i> class (used in the
chapter on iterators) can be implemented as:
<pre><font color="#000080">BEGIN_NAMED_CLASS_INFO("CPerson", CPerson)
{
&nbsp;&nbsp;&nbsp; ADD_NAMED_STD_MEMBER("m_Name", m_Name);
&nbsp;&nbsp;&nbsp; ADD_NAMED_STD_MEMBER("m_Addr", m_Addr);
&nbsp;&nbsp;&nbsp; ADD_NAMED_MEMBER("m_NextDoor", m_NextDoor, POINTER, (CLASS, (CPerson)));
}
END_CLASS_INFO</font></pre>
<font color="#000000">or, equivalently, as:</font>
<pre><font color="#000080">BEGIN_CLASS_INFO(CPerson)
{
&nbsp;&nbsp;&nbsp; ADD_STD_MEMBER(m_Name);
&nbsp;&nbsp;&nbsp; ADD_STD_MEMBER(m_Addr);
&nbsp;&nbsp;&nbsp; ADD_MEMBER(m_NextDoor, POINTER, (CLASS, (CPerson)));
}
END_CLASS_INFO</font></pre>
<font color="#000000">Here, the <i>CPerson</i> class has two <i>string</i>
data members, <i>m_Name</i> and
<i>m_Addr</i>, as well as a pointer to
an object of the same type (<i>CPerson*</i>). All built-in C++ types such
as <i>int, float, string</i> etc., use the <i>ADD_NAMED_STD_MEMBER</i>
or <i>ADD_STD_MEMBER</i> macros. These and other macros used to add members
are defined in <a href="#addm">Table 2</a>.</font>
<li>
<a NAME="abstr"></a><font color="#000000"><i><a href="../lxr/ident?i=BEGIN_NAMED_ABSTRACT_CLASS_INFO">BEGIN_NAMED_ABSTRACT_CLASS_INFO(ClassAlias,
ClassName)</a></i></font></li>

<br><i><font color="#000000"><a href="../lxr/ident?i=BEGIN_ABSTRACT_CLASS_INFO">BEGIN_ABSTRACT_CLASS_INFO(ClassName)</a></font></i>
<br><font color="#000000">These macros must be used on abstract base classes
which contain pure virtual functions. Because these abstract classes cannot
be instantiated, special handling is required in order to install their
static <i>GetTypeInfo()</i> methods.</font>
<p><font color="#000000">For example, suppose the classes <i>CA</i> and
<i>CB</i> are derived from an abstract base class,
<i>CBase</i>. In order
to be able to apply a <i><a href="iterators.html#typeIt">CTypeIterator</a>&lt;CBase></i>
that will visit all objects of type <i>CA</i> and
<i>CB</i>, we must implement
the <i>GetTypeInfo()</i> method on that abstract class. The
<i>ABSTRACT_CLASS_INFO</i>
macros do this for us:</font>
<pre><font color="#000080">BEGIN_ABSTRACT_CLASS_INFO(CBase)
{
&nbsp; // ... data member definitions for abstract base class

&nbsp; ADD_SUB_CLASS (CA);
&nbsp; ADD_SUB_CLASS (CB);
}
END_ABSTRACT_CLASS_INFO</font></pre>
<font color="#000000">The <i><a href="../lxr/ident?i=ADD_SUB_CLASS">ADD_SUB_CLASS</a></i>
macro provides the class inheritance information for all objects - its
usage is <i>not</i> restricted to abstract classes. However, each class
listed as a subclass by these macros must also use the DERIVED_CLASS macros
defined below. Failure to define these hierarchical relations in the
<i>GetTypeInfo()</i>
macros will not lead to compile-time errors, but the iterator will
<i>not</i>
recognize these objects as instances of the parent class.</font>
<li>
<a NAME="derive"></a><i><font color="#000000"><a href="../lxr/ident?i=BEGIN_NAMED_DERIVED_CLASS_INFO">BEGIN_NAMED_DERIVED_CLASS_INFO(ClassAlias,
ClassName, BaseClassName)</a></font></i></li>

<br><i><font color="#000000"><a href="../lxr/ident?i=BEGIN_DERIVED_CLASS_INFO">BEGIN_DERIVED_CLASS_INFO(ClassName,
BaseClassName)</a></font></i>
<br><font color="#000000">These macros should be used on derived subclasses
whose parent classes also have the
<i>GetTypeInfo()</i> method implemented.
Data members inherited from parent classes should not be included in the
derived class type information.</font>
<pre><font color="#000080">BEGIN_DERIVED_CLASS_INFO(CA, CBase)
{
&nbsp; // ... data members in CA not inherited from CBase
}
END_DERIVED_CLASS_INFO

BEGIN_DERIVED_CLASS_INFO(CB, CBase)
{
&nbsp; // ... data members in CB not inherited from CBase
}
END_DERIVED_CLASS_INFO</font></pre>
<font color="#FF0000">NOTE:</font><font color="#000000"> The type information
for classes derived directly from <i>CObject</i> does
<i>not</i> however,
follow this protocol. In this special case, although the class is derived
from <i>CObject</i>, you should <i>not</i> use the <i>DERIVED_CLASS</i>
macros to implement
<i>GetTypeInfo()</i>, but instead use the usual <i>BEGIN_CLASS_INFO</i>
macro. <i>CObject</i>'s have a slightly different interface to their type
information (see <i><a href="../lxr/ident?i=CObjectGetTypeInfo">CObjectGetTypeInfo</a></i>),
and apply these macros differently.</font>
<li>
<a NAME="choice"></a><i><font color="#000000"><a href="../lxr/ident?i=BEGIN_NAMED_CHOICE_INFO">BEGIN_NAMED_CHOICE_INFO(ClassAlias,
ClassName)</a></font></i></li>

<br><i><font color="#000000"><a href="../lxr/ident?i=BEGIN_CHOICE_INFO">BEGIN_CHOICE_INFO(ClassName)</a></font></i>
<br><font color="#000000">These macros install <i>GetTypeInfo()</i> for
C++ <i>choice</i> objects, which are implemented as C++ classes. See <i><a href="choice.html">Choice
objects in the C++ Toolkit</a></i> for a description of C++ <i>choice</i>
objects. Each of the choice variants occurs as a data member in the class,
and the macros used to add choice variants (<i><a href="../lxr/ident?i=ADD_NAMED_CHOICE_VARIANT">ADD_NAMED_*_CHOICE_VARIANT</a></i>)
are used similarly to those which add data members to classes (see discussion
of the <i><a href="#addm">ADD*</a></i> macros below).</font>
<li>
<a NAME="enum"></a><i><font color="#000000"><a href="../lxr/ident?i=BEGIN_NAMED_ENUM_INFO">BEGIN_NAMED_ENUM_INFO(EnumAlias,
EnumName, IsInteger)</a></font></i></li>

<br><i><font color="#000000"><a href="../lxr/ident?i=BEGIN_ENUM_INFO">BEGIN_ENUM_INFO(EnumName,
IsInteger)</a></font></i>
<br><font color="#000000">In addition to the two arguments used by the
<i>BEGIN_*_INFO</i> macros for classes, a Boolean argument (<i>IsInteger</i>)
indicates whether or not the enumeration includes arbitrary integer values
or only those explicitly specified.</font>
<p><font color="#000000">Example usage:</font>
<pre><font color="#000080">// hpp file:
enum EMyEnum {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eZero = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eOne,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eTwo,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eTen = 10
};

// cpp file:
BEGIN_ENUM_INFO(EMyEnum, false)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADD_ENUM_VALUE("zero", eZero);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADD_ENUM_VALUE("one", eOne);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADD_ENUM_VALUE("two", eTwo);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADD_ENUM_VALUE("ten", eTen);
}
END_ENUM_INFO</font></pre>
<font color="#000000">Enumerated values are specified with the <i>ADD_ENUM_VALUE</i>
macro. As a result of executing the above macro, a global function named
<i>GetTypeInfo_enum_EMyEnum()</i> will be implemented.</font>
<br>&nbsp;
<br>&nbsp;
<li>
<a NAME="enum_in"></a><i><font color="#000000"><a href="../lxr/ident?i=BEGIN_NAMED_ENUM_IN_INFO">BEGIN_NAMED_ENUM_IN_INFO(EnumAlias,
CppContext, EnumName, IsInteger)</a></font></i></li>

<br><i><font color="#000000"><a href="../lxr/ident?i=BEGIN_ENUM_IN_INFO">BEGIN_ENUM_IN_INFO(CppContext,
EnumName, IsInteger)</a></font></i>
<br><font color="#000000">These macros also implement the type information
functions for C++ enumerations --but in this case, the enumeration is defined
outside the scope where the macro is applied, so a <i>context</i> argument
is required. This new argument, <i>CppContext</i>, specifies the C++ class
name or external namespace where the enumeration is defined.</font>
<p><font color="#000000">&nbsp;The <i>CppContext</i> argument should be
postfixed with the scope operator (::). For example, if
<i>EMyEnum</i>
is itself defined in <i>CMyClass</i>, then we would use the following macros
in the
<i>*.cpp</i> file:</font>
<pre><font color="#000080">BEGIN_ENUM_IN_INFO(CMyClass::, EMyEnum, false)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADD_ENUM_VALUE("zero", eZero);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADD_ENUM_VALUE("one", eOne);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADD_ENUM_VALUE("two", eTwo);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADD_ENUM_VALUE("ten", eTen);
}
END_ENUM_IN_INFO</font></pre>
</ul>
<font color="#000000">Again, when using the above macros to install type
information, the corresponding class definitions
<i>must</i> include a
declaration of the static class member function <i>GetTypeInfo()</i> in
the class's public section. The <i>DECLARE_INTERNAL_TYPE_INFO()</i> macro
is provided to ensure that the declaration of this method is correct. Similarly,
the <i>DECLARE_INTERNAL_ENUM_INFO</i> and
<i>DECLARE_ENUM_INFO</i> macros
should be used in the header files where enumerations are defined. The
<i>DECLARE_ASN_TYPE_INFO</i> and <i>DECLARE_ASN_CHOICE_INFO</i> macros
can be used to declare the type information functions for C-style structs
and choice nodes.</font>
<p><a NAME="addm"></a>
<h3>
<font color="#000000">Specifying internal structure and class inheritance:
the <i>ADD_</i> macros</font></h3>
<font color="#000000">Information about internal class structure and inheritance
is specified using the <i>ADD_*</i> macros. Again, each macro has both
a "named" and "unnamed" implementation. The arguments to all of the ADD_NAMED_*
macros begin with the external alias and C++ name of the item to be added.</font>
<p><font color="#000000">The ADD_* macros that take <i>only</i> an alias
and a name require that the <i>type</i> being added must be either a built-in
type or a type defined by the name argument. When adding a
<i>CRef</i>
data member to a class or choice object however, the class referenced by
the <i>CRef</i> must be made explicit with the <i>RefClass</i> argument,
which is the C++ class name for the type pointed to.</font>
<p><font color="#000000">Similarly, when adding an enumerated data member
to a class, the enumeration itself must be explictly named. For example,
if class <i>CMyClass</i> contains a data member <i>m_MyEnumVal</i> of type
<i>EMyEnum</i>, then the BEGIN_NAMED_CLASS_INFO macro for <i>CMyClass</i>
should contain the statement:</font>
<center>
<p><font color="#000000">ADD_ENUM_MEMBER (m_MyEnumVal, EMyEnum);</font></center>

<p><font color="#000000">or, equivalently:</font>
<center>
<p><font color="#000000">ADD_NAMED_ENUM_MEMBER ("m_MyEnumVal", m_MyEnumVal,
EMyEnum);</font></center>

<p><font color="#000000">or, to define a "custom" (non-default) external
alias:</font>
<center>
<p><font color="#000000">ADD_NAMED_ENUM_MEMBER ("m_CustomAlias", m_MyEnumVal,
EMyEnum);</font></center>

<p><font color="#000000">Here, <i>EMyEnum</i> is defined in the same namespace
and scope as <i>CMyClass</i>. Alternatively, if the enumeration is defined
in a different class or namespace (and therefore, then the ADD_ENUM_IN_MEMBER
macro must be used:</font>
<center>
<p><font color="#000000">ADD_ENUM_IN_MEMBER (m_MyEnumVal, COtherClassName::,
EMyEnum);</font></center>

<p><font color="#000000">In this example, <i>EMyEnum</i> is defined in
a class named <i>COtherClassName</i>. The
<i>CppContext</i> argument (defined
here as <i>COtherClassName::</i>) acts as a scope operator, and can also
be used to specify an alternative namespace. The ADD_NAMED_ENUM_CHOICE_VARIANT
and ADD_NAMED_ENUM_IN_CHOICE_VARIANT macros are used similarly to provide
information about enumerated choice options. The <i>ADD_ENUM_VALUE</i>
macro is used to add enumerated values to the enumeration itself, as demonstrated
in the above example of the <a href="#enum">BEGIN_NAMED_ENUM_INFO</a> macro.</font>
<br>&nbsp;
<br>&nbsp;
<table BORDER WIDTH="100%" >
<tr>
<th>Macro name</th>

<th>Usage</th>

<th>Arguments</th>
</tr>

<tr>
<td>ADD_NAMED_STD_MEMBER&nbsp;</td>

<td>Add a standard data member to a class</td>

<td>MemberAlias, MemberName</td>
</tr>

<tr>
<td>ADD_NAMED_CLASS_MEMBER&nbsp;</td>

<td>Add an internal class member to a class</td>

<td>MemberAlias, MemberName</td>
</tr>

<tr>
<td>ADD_NAMED_SUB_CLASS&nbsp;</td>

<td>Add a derived subclass to a class</td>

<td>SubClassAlias, SubClassName</td>
</tr>

<tr>
<td>ADD_NAMED_REF_MEMBER&nbsp;</td>

<td>Add a <i>CRef</i> data member to a class</td>

<td>MemberAlias, MemberName, RefClass</td>
</tr>

<tr>
<td>ADD_NAMED_ENUM_MEMBER&nbsp;</td>

<td>Add an enumerated data member to a class</td>

<td>MemberAlias, MemberName, EnumName</td>
</tr>

<tr>
<td>ADD_NAMED_ENUM_IN_MEMBER&nbsp;</td>

<td>Add an externally defined enumerated data member to a class</td>

<td>MemberAlias, MemberName, CppContext, EnumName</td>
</tr>

<tr>
<td>ADD_NAMED_MEMBER&nbsp;</td>

<td>Add a data member of the type specified by <i>TypeMacro</i> to a class</td>

<td>MemberAlias, MemberName, TypeMacro, TypeMacroArgs&nbsp;</td>
</tr>

<tr>
<td>ADD_NAMED_STD_CHOICE_VARIANT</td>

<td>Add a standard variant type to a C++ choice object&nbsp;</td>

<td>VariantAlias, VariantName</td>
</tr>

<tr>
<td>ADD_NAMED_REF_CHOICE_VARIANT</td>

<td>Add a <i>CRef</i> variant to a C++ choice object&nbsp;</td>

<td>VariantAlias, VariantName, RefClass</td>
</tr>

<tr>
<td>ADD_NAMED_ENUM_CHOICE_VARIANT&nbsp;</td>

<td>Add an enumeration variant to a C++ choice object&nbsp;</td>

<td>VariantAlias, VariantName, EnumName</td>
</tr>

<tr>
<td>ADD_NAMED_ENUM_IN_CHOICE_VARIANT&nbsp;</td>

<td>Add an enumeration variant to a C++ choice object&nbsp;</td>

<td>VariantAlias, VariantName, CppContext, EnumName</td>
</tr>

<tr>
<td>ADD_NAMED_CHOICE_VARIANT&nbsp;</td>

<td>Add a variant of the type specified by <i>TypeMacro</i> to a C++ choice
object</td>

<td>VariantAlias, VariantName, TypeMacro, TypeMacroArgs&nbsp;</td>
</tr>

<tr>
<td>ADD_ENUM_VALUE</td>

<td>Add a named enumeration value to an <i>enum</i></td>

<td>EnumValName, Value&nbsp;</td>
</tr>

<caption ALIGN=BOTTOM>Table 2</caption>
</table>
The most complex macros by far are those which use the <i>TypeMacro</i>
and <i>TypeMacroArgs</i> arguments:
<i>ADD(_NAMED)_MEMBER</i> and <i>ADD(_NAMED)_CHOICE_VARIANT</i>.
These macros are more open-ended and allow for more complex specifications.
We have already seen one example of using a macro of this type, in the
implementation of the
<i>GetTypeInfo()</i> method for <i>CPerson</i>:
<br>&nbsp;
<center>
<p>ADD_MEMBER(m_NextDoor, POINTER, (CLASS, (CPerson)));</center>

<p>The <i>ADD_MEMBER</i> and <i>ADD_CHOICE_VARIANT</i> macros always take
at least two arguments:
<ol>
<li>
the internal member (variant) name</li>

<li>
the definition of the member's (variant's) type</li>
</ol>
Depending on the (second) <i>TypeMacro</i> argument, additional arguments
may or may not be needed. In this example, the <i>TypeMacro</i> is <i>POINTER</i>,
which <i>does</i> require additional arguments. The <i>TypeMacroArgs</i>
here specify that <i>m_NextDoor</i> is a pointer to a <i>class</i> type
whose C++ name is <i>CPerson</i>.
<p>&nbsp;More generally, the remaining arguments depend on the value of
<i>TypeMacro</i>, as these parameters complete the type definition. The
possible strings which can occur as <i>TypeMacro</i>, along with the additional
arguments required for that type, are given in Table 3.
<br>&nbsp;
<br>&nbsp;
<center><table BORDER=0 WIDTH="500" >
<tr>
<th>TypeMacro</th>

<th>TypeMacroArgs&nbsp;</th>
</tr>

<tr>
<td>CLASS&nbsp;</td>

<td>(ClassName)&nbsp;</td>
</tr>

<tr>
<td>STD&nbsp;</td>

<td>(C++ type)&nbsp;</td>
</tr>

<tr>
<td>StringStore&nbsp;</td>

<td>()&nbsp;</td>
</tr>

<tr>
<td>null&nbsp;</td>

<td>()&nbsp;</td>
</tr>

<tr>
<td>ENUM&nbsp;</td>

<td>(EnumType, EnumName)&nbsp;</td>
</tr>

<tr>
<td>POINTER&nbsp;</td>

<td>(Type,Args)&nbsp;</td>
</tr>

<tr>
<td>STL_multiset&nbsp;</td>

<td>(Type,Args)&nbsp;</td>
</tr>

<tr>
<td>STL_set&nbsp;</td>

<td>(Type,Args)&nbsp;</td>
</tr>

<tr>
<td>STL_multimap&nbsp;</td>

<td>(KeyType,KeyArgs,ValueType,ValueArgs)&nbsp;</td>
</tr>

<tr>
<td>STL_map&nbsp;</td>

<td>(KeyType,KeyArgs,ValueType,ValueArgs)&nbsp;</td>
</tr>

<tr>
<td>STL_list&nbsp;</td>

<td>(Type,Args)&nbsp;</td>
</tr>

<tr>
<td>STL_list_set&nbsp;</td>

<td>(Type,Args)&nbsp;</td>
</tr>

<tr>
<td>STL_vector&nbsp;</td>

<td>(Type,Args)&nbsp;</td>
</tr>

<tr>
<td>STL_CHAR_vector&nbsp;</td>

<td>(C++ Char type)&nbsp;</td>
</tr>

<tr>
<td>STL_auto_ptr&nbsp;</td>

<td>(Type,Args)</td>
</tr>

<tr>
<td>CHOICE&nbsp;</td>

<td>(Type,Args)&nbsp;</td>
</tr>

<caption ALIGN=BOTTOM>Table 3</caption>
</table></center>

<p>The <i>ADD_MEMBER</i> macro generates a call to the corresponding <i>ADD_NAMED_MEMBER</i>
macro as follows:
<pre><font color="#000080">#define ADD_MEMBER(MemberName,TypeMacro,TypeMacroArgs) \
&nbsp;&nbsp;&nbsp;&nbsp; ADD_NAMED_MEMBER(#MemberName,MemberName,TypeMacro,TypeMacroArgs)</font></pre>
Some examples of using the ADD_MEMBER macro are:
<pre><font color="#000080">&nbsp;&nbsp; ADD_MEMBER(m_X);
&nbsp;&nbsp; ADD_MEMBER(m_A, STL_auto_ptr, (CLASS, (ClassName)));
&nbsp;&nbsp; ADD_MEMBER(m_B, STL_CHAR_vector, (char));
&nbsp;&nbsp; ADD_MEMBER(m_C, STL_vector, (STD, (int)));
&nbsp;&nbsp; ADD_MEMBER(m_D, STL_list, (CLASS, (ClassName)));
&nbsp;&nbsp; ADD_MEMBER(m_E, STL_list, (POINTER, (CLASS, (ClassName))));
&nbsp;&nbsp; ADD_MEMBER(m_F, STL_map, (STD, (long), STD, (string)));</font></pre>
Similarly, the <i>ADD_CHOICE_VARIANT</i> macro generates a call to the
corresponding <i>ADD_NAMED_CHOICE_VARIANT</i> macro. These macros add type
information for the <a href="choice.html"><i>choice</i> object's variants.</a>

<p>
<a href="typeinfo.html"><i>previous</i></a>&nbsp;&nbsp;
<i><a href="../index.html">up&nbsp;</a></i>&nbsp;&nbsp;
<a href="iterators.html"><i>next</i></a>&nbsp;&nbsp;
<hr>
<table BORDER=0 CELLSPACING=0 WIDTH="100%" >
<tr>
<td>
<address>
<a href="mailto:zimmerma@ncbi.nlm.nih.gov">Diane Zimmerman</a></address>
</td>

<td><!-- <td align=center><i>$Revision$</i></td> --></td>

<td ALIGN=RIGHT><i>$Date$</i></td>
</tr>
</table>

</body>
</html>
