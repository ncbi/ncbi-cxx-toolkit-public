<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>Naming conventions, Indentation and Bracing</title>
  </head>

  <body>
	 <h1>Naming conventions, Indentation and Bracing</h1>

<i>
"In My Egotistical Opinion, most people's C programs should be indented
 six feet downward and covered with dirt."
</i>
-- Blair P. Houghton

	 <p>
		Nevertheless, here goes:

	 <ul>
		<li> <a href="#ref_Naming">Naming conventions</a>
	 <ul>
		<li> <a href="#ref_NamingCPP">Preprocessor Define/Macro</a>
		<li> <a href="#ref_NamingTypes">Type Names</a>
		<li> <a href="#ref_NamingConst">Constants</a>
		<li> <a href="#ref_NamingCVar">Class member variables</a>
		<li> <a href="#ref_NamingCFunc">Class member functions</a>
		<li> <a href="#ref_NamingStaticFunc">Module static functions</a>
	 </ul>
	 <li> <a href="#ref_Prefix">Name prefixing and/or the use of namespaces</a>
	 <li> <a href="#ref_Scope">Use of the NCBI name scope</a>
	 <li> <a href="#ref_Indent">Code indentation and bracing</a>
	 <li> <a href="#ref_Class">Class declaration</a>
	 <li> <a href="#ref_FunctionDecl">Function declaration</a>
	 <li> <a href="#ref_FunctionDef">Function definition</a> </ul>


	 <br></br>

	 <a name="ref_Naming">
    <h2> Naming conventions </h2>

    <table border=1 cellspacing=0>

      <tr><th>Synopsis</th><th>Example</th></tr>

		<a name="ref_NamingCPP">
      <tr><th colspan=2 align=left>
				&nbsp;&nbsp;&nbsp;Preprocessor Define/Macro</th></tr>
      <tr><td><i>MACRO_NAME</i></td><td>#define MY_DEFINE 12345</td></tr>
      <tr><td><i>macro_arg_name</i></td><td>#define MY_MACRO(x, y) (((x) + 1) < (y))</td></tr>

		<a name="ref_NamingTypes">
      <tr><th colspan=2 align=left>
				&nbsp;&nbsp;&nbsp;Type Names</th></tr>
      <tr><td><i><b>C</b>ClassTypeName</i></td><td>
				class CMyClass { ..... };</td></tr>
      <tr><td><i><b>S</b>StructTypeName</i></td><td>
				struct SMyStruct { ..... };</td></tr>
      <tr><td><i><b>U</b>UnionTypeName</i></td><td>
				union UMyUnion { ..... };</td></tr>
      <tr><td><i><b>E</b>EnumTypeName</i></td><td>
				enum EMyEnum { ..... };</td></tr>
      <tr><td><i><b>F</b>FunctionTypeName</i></td><td>
				void (*FMyFunc)(void) { ..... };</td></tr>
      <tr><td><i><b>P</b>PredicateName</i></td><td>
				struct PMyPred { bool operator() (..... , .....); };</td></tr>
      <tr><td><i><b>T</b>AuxiliaryTypedef <a href="#ref_AuxType">(see also)</a></i></td>
			 <td>typedef map&lt;int,string&gt; TMapIntStr;</td></tr>
      <tr><td><i><b>T</b>Iterator<b>I</b></i></td>
			 <td>typedef list&lt;int&gt;::iterator TListI;</td></tr>
      <tr><td><i><b>T</b>ConstIterator<b>CI</b></i></td>
			 <td>typedef set&lt;string&gt;::const_iterator TSetCI;</td></tr>
      <tr><td><i><b>N</b>Namespace <a href="#ref_Prefix">(see also)</a></i></td><td>
				namespace NMyNamespace { ..... } </td></tr>

		<a name="ref_NamingConst">
      <tr><th colspan=2 align=left>
				&nbsp;&nbsp;&nbsp;Constants</th></tr>
      <tr><td><i><b>k</b>ConstantName</i></td><td>
				const int kMyConst = 123;</td></tr>
      <tr><td><i><b>e</b>EnumConstantName</i></td>
			 <td>enum EMyEnum { <br>
				&nbsp;&nbsp;&nbsp;&nbsp; eMyEnum1 = 11, <br>
				&nbsp;&nbsp;&nbsp;&nbsp; eMyEnum2 = 22, <br>
				&nbsp;&nbsp;&nbsp;&nbsp; eMyEnum3 = 33 <br>
				};</td></tr>

      <tr><td><i><b>f</b>FlagConstantName</i></td>
			 <td>enum EMyFlagEnum { <br>
				&nbsp;&nbsp;&nbsp;&nbsp; fMyFlag1 = 0x1, <br>
				&nbsp;&nbsp;&nbsp;&nbsp; fMyFlag2 = 0x2 <br>
				};</td></tr>

		<a name="ref_NamingCVar">
      <tr><th colspan=2 align=left>
				&nbsp;&nbsp;&nbsp;Class member variables</th></tr>
      <tr><td><i><b>m_</b>ClassMemberName</i></td><td>
				class C { short m_MyClassData; }</td></tr>
      <tr><td><i><b>sm_</b>ClassStaticMemberName</i></td><td>
				class C { static double sm_MyClassStaticData; }</td></tr>

		<a name="ref_NamingCFunc">
      <tr><th colspan=2 align=left>
				&nbsp;&nbsp;&nbsp;Class member functions</th></tr>
      <tr><td><i>Func</i></td><td>bool MyFunc(void);</td></tr>

		<a name="ref_NamingStaticFunc">
      <tr><th colspan=2 align=left>
				&nbsp;&nbsp;&nbsp;Module static functions</th></tr>
      <tr><td><i><b>s_</b>StaticFunc</b></td><td>
				static char s_MyStaticFunc(void);</td></tr>

	 </table>

	 <a name="ref_AuxType">

	 <p>
	 (*) The auxiliary typedefs(like <i><b>T</b>AuxiliaryTypedef</i>) are usually
	 used for an ad-hoc type mappings(especially when using templates) and
	 not when a real type definition takes place.


	 <br></br> <br></br>

	 <a name="ref_Prefix">
    <h2>Name prefixing and/or the use of namespaces</h2>

	 In addition to the above naming conventions that highlights the
	 nature and/or the scope of things, one should also consider the use
	 of prefixes (or namespaces) in order to:
	 <ul>
		<li> avoid name conflicts
		<li> indicate the package which the thing belongs to
	 </ul>
	 E.g. it will always be a good idea to name your new base
	 class(for some package <i>"Foo"</i>) <i>"C<b>Foo</b>Object"</i> rather
	 than just <i>"CObject"</i>. -- And the same is true for all other
	 things from this package, so name the constants <i>"k<b>Foo</b>Someconst"</i>,
	 types <i>"T<b>Foo</b>Sometype"</i>, etc.

	 <p>
	 It is decided that we usually do not use C++ namespaces (other than
    the NCBI-wide namespace "ncbi::") in NCBI.
	 <p>
	 One can emulate a sort of namespace by putting the things into a
	 structure or class scope, like
    <i>"struct N<b>Foo</b>Globals { .....;  void SomeFunc(int); ... };"</i>.
	 Then just use an explicit prefix when referencing these things, e.g. call
    <i>"N<b>Foo</b>Globals::SomeFunc(5)"</i>.
	 This approach can be useful to group and prefix a set of global functions.
	 As for classes, etc. it is still better to use simple prefixes
	 (as described above) instead.


	 <br></br> <br></br>

	 <a name="ref_Scope">
    <h2>Use of the NCBI name scope</h2>

	 <i>&lt;ncbistl.hpp&gt;</i>

	 <p>
	 All NCBI-made API must be put into the single namespace.
	 For this reason, there are two preprocessor macros,
	 <i>BEGIN_NCBI_SCOPE</i> and <i>END_NCBI_SCOPE</i>,
	 that must embrace <b>all</b> NCBI C++ API code -- both declarations
	 and definitions(see <a href="new_mod.html">examples </a>).
	 Inside these "brackets", all <i>"std::"</i> and <i>"ncbi::"</i> scope prefixes
	 can(and must!) be omitted. Safely.

	 <p>
	 For the code that does not define new API but merely <b>uses</b>
	 NCBI C++ API, there is a macro <i>USING_NCBI_SCOPE</i>
	 (semicolon-terminated) that makes all <b>"std"</b>- and
	 <b>"ncbi"</b>-related types and protos be visible by default,
	 without the explicit scope specification
	 (<i>"std::"</i> and <i>"ncbi::"</i> prefixes, respectively).

	 <p>
	 Use macro <i>NCBI_USING_NAMESPACE_STD</i>(semicolon-terminated)
	 if you want make visible only <b>"std"</b>-related code, without the
	 <b>"ncbi"</b>-related one.


	 <br></br> <br></br>

	 <a name="ref_Indent">
    <h2>Code indentation and bracing </h2>

		  <b>4-space indentation only</b>!
		  Tabulation symbol <b>must not</b> be used for indentation.

	 <p>
		Try not to cross the "standard page boundary" of <b>80</b>
		symbols.

	 <p>
		In <i>if, for, while, do, switch, case</i>, etc. and
		type definition statements:
    <pre>
if (...) {
    .....;
} else if (...) {
    .....;
} else {
    .....;
}

for|while (...) {
    .....;
}

do {
    .....;
} while (...);

switch (...) {
case ...: {
    .....;
    break;
}
} // switch

class|struct|union <[C|S|U]TypeName> {
    .....;
};

try {
    .....;
} catch (exception& e) {
    .....;
}
    </pre>



	 <a name="ref_Class">
    <h2>Class declaration</h2>

	 <pre>
class CFooClass {
public:
    // Constructors and Destructor (they are usually public)
    CFooClass(bool init_bool=true);
    CFooClass(int  init_int);
    ~CFooClass(void);

    // Members and Methods
    // (NOTE:  the use of public data members is strictly discouraged!)
    int   m_PublicData;
    float PublicFunc(void);

protected:
    double m_ProtectedData;
    static int ProtectedFunc(char ch);

private:
    int    m_PrivateData;
    double PrivateFunc(int some_int=123);

    // Friends
    friend bool  SomeFriendFunc(void);
    friend class CSomeFriendClass;
private:
    // Prohibit default initialization and assignment -- e.g. when the
    // member-by-member copying is dangerous
    CFooClass(const CFooClass&) { _TROUBLE; }
    CFooClass& operator=(const CFooClass&) { _TROUBLE;  return *this; }
};
	 </pre>


	 <a name="ref_FunctionDecl">
    <h2>Function declaration</h2>

	 <pre>
// Explain here what MyFunc1() does, and what it returns
int MyFunc1(void);

// Explain here what MyFunc2() does, and what it returns
bool MyFunc2
(double  arg1,      // short description of "arg1"
 string& arg2,      // short description of "arg2"
 long    arg3 = 12  // short description of "arg3"
 );
	 </pre>


	 <a name="ref_FunctionDef">
    <h2>Function definition</h2>

	 <pre>
bool MyFunc2
(double  arg1,
 string& arg2,
 long    arg3)
{
    .......
    .......
    return true;
}


// For static function, put all comments on what the function does
// and what it returns right here, at the point of the function definition
static long s_MyFunc3(void)
{
    .......
    .......
}
	 </pre>



	 <hr>
	 <table border=0 width="100%" cellspacing=0>
		<tr>
		  <td><address><a href="mailto:vakatov@ncbi.nlm.nih.gov">Denis Vakatov</a></address></td>
		  <td align=right>($Revision$)</td></tr>
	 </table>
  </body>
</html>
