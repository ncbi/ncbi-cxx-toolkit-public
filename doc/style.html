<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>Naming conventions, Identation and Bracing</title>
  </head>

  <body>
	 <h1>Naming conventions, Identation and Bracing</h1>

	 <ul>
		<li> <a href="#ref_Naming">Naming conventions</a>
	 <ul>
		<li> <a href="#ref_NamingCPP">Preprocessor Define/Macro</a>
		<li> <a href="#ref_NamingTypes">Type Names</a>
		<li> <a href="#ref_NamingConst">Constants</a>
		<li> <a href="#ref_NamingVar">Class member variables</a>
		<li> <a href="#ref_NamingFunc">Functions</a>
	 </ul>
	 <li> <a href="#ref_Prefix">Name prefixing and/or the use of quasi-namespaces</a>
	 <li> <a href="#ref_Scope">Use of the NCBI name scope</a>
	 <li> <a href="#ref_Indent">Code indentation and bracing</a>
	 <li> <a href="#ref_Class">Class declaration</a> </ul>


	 <br></br>

	 <a name="ref_Naming">
    <h2> Naming conventions </h2>

    <table border=1 cellspacing=0>

      <tr><th>Synopsis</th><th>Example</th></tr>

		<a name="ref_NamingCPP">
      <tr><th>Preprocessor Define/Macro</th></tr>
      <tr><td><i>MACRO_NAME</i></td><td>#define MY_DEFINE 12345</td></tr>
      <tr><td><i>macro_arg_name</i></td><td>#define MY_MACRO(x, y) ((x + 1) < (y))</td></tr>

		<a name="ref_NamingTypes">
      <tr><th>Type Names</th></tr>
      <tr><td><i><b>C</b>ClassTypeName</i></td><td>class CMyClass { ..... };</td></tr>
      <tr><td><i><b>S</b>StructTypeName</i></td><td>struct SMyStruct { ..... };</td></tr>
      <tr><td><i><b>U</b>UnionTypeName</i></td><td>union UMyUnion { ..... };</td></tr>
      <tr><td><i><b>E</b>EnumTypeName</i></td><td>enum EMyEnum { ..... };</td></tr>
      <tr><td><i><b>F</b>FunctionTypeName</i></td><td>void (*FMyFunc)(void) { ..... };</td></tr>
      <tr><td><i><b>T</b>AuxiliaryTypedef <a href="#ref_AuxType">(see also)</a></i></td><td>typedef map&lt;int,string&gt; TMapIntStr;</td></tr>
      <tr><td><i><b>N</b>QuasiNamespace <a href="#ref_Prefix">(see also)</a></i></td><td>struct NMyNamespace { ..... }; </td></tr>

		<a name="ref_NamingConst">
      <tr><th>Constants</th></tr>
      <tr><td><i><b>k</b>ConstantName</i></td><td>const Int2 kMyConst;</td></tr>
      <tr><td><i><b>e</b>EnumConstantName</i></td>
	<td>enum EMyEnum { <br>
	     &nbsp;&nbsp;&nbsp;&nbsp; eMyEnum1 = 11, <br>
	      &nbsp;&nbsp;&nbsp;&nbsp; eMyEnum2 = 22, <br>
		&nbsp;&nbsp;&nbsp;&nbsp; eMyEnum3 = 33 <br>
		  };</td></tr>

		<a name="ref_NamingVar">
      <tr><th>Class member variables</th></tr>
      <tr><td><i><b>m_</b>ClassMemberName</i></td><td>class X { Int1 m_MyClassData; }</td></tr>
      <tr><td><i><b>sm_</b>ClassStaticMemberName</i></td><td>class X { static Int4 sm_MyClassStaticData; }</td></tr>

		<a name="ref_NamingFunc">
      <tr><th>Functions</th></tr>
      <tr><td><i>(starts from capital)</i></td><td>Int2 MyFunc(void);</td></tr>

	 </table>

	 <a name="ref_AuxType">

	 <p>
	 (*) The auxiliary typedefs(like <i><b>T</b>AuxiliaryTypedef</i>) are usually
	 used for an ad-hoc type mappings(especially when using templates) and
	 not when a real type definition takes place.


	 <br></br> <br></br>

	 <a name="ref_Prefix">
    <h2>Name prefixing and/or the use of quasi-namespaces</h2>

	 In addition to the above naming conventions that highlights the
	 nature and/or the scope of things, one should also consider the use
	 of prefixes(or quasi-namespaces) in order to:
	 <ul>
		<li> avoid name conflicts
		<li> indicate the package which the thing belongs to
	 </ul>
	 E.g. it will always be a good idea to name your new base
	 class(for some package <i>"Foo"</i>) <i>"C<b>Foo</b>Object"</i> rather
	 than just <i>"CObject"</i>. -- And the same is true for all other
	 things from this package, so name the constants <i>"k<b>Foo</b>Someconst"</i>,
	 types <i>"T<b>Foo</b>Sometype"</i>, etc.

	 <p>
	 It is decided that we do not use the C++ namespaces in NCBI.
	 <p>
	 However, one can emulate a namespace by putting the things into a
	 structure or class scope, like
    <i>"struct N<b>Foo</b>Globals { .....;  void SomeFunc(int); ... };"</i>.
	 Then just use an explicit prefix when referencing these things, e.g. call
    <i>"N<b>Foo</b>Globals::SomeFunc(5)"</i>.
	 Usually, this approach is useful for global functions.
	 As for classes, etc. it is still better to use simple prefixes
	 (as described above) instead.


	 <br></br> <br></br>

	 <a name="ref_Scope">
    <h2>Use of the NCBI name scope</h2>

	 <i>&lt;ncbistl.hpp&gt;</i>

	 <p>
	 All NCBI-made API must be put into the single namespace.
	 For this reason, there are two preprocessor macros,
	 <i>BEGIN_NCBI_SCOPE</i> and <i>END_NCBI_SCOPE</i>,
	 that must embrace <b>all</b> NCBI C++ API code -- both declarations
	 and definitions(see <a href="new_mod.html">examples </a>).
	 Inside these "brackets", all <i>"std::"</i> and <i>"ncbi::"</i> scope prefixes
	 can(and must!) be omitted. Safely.

	 <p>
	 For the code that does not define new API but merely <b>uses</b>
	 NCBI C++ API, there is a macro <i>USING_NCBI_SCOPE</i>
	 (semicolon-terminated) that makes all <b>"std"</b>- and
	 <b>"ncbi"</b>-related types and protos be visible by default,
	 without the explicit scope specification
	 (<i>"std::"</i> and <i>"ncbi::"</i> prefixes, respectively).

	 <p>
	 Use macro <i>NCBI_USING_NAMESPACE_STD</i>(semicolon-terminated)
	 if you want make visible only <b>"std"</b>-related code, without the
	 <b>"ncbi"</b>-related one.


	 <br></br> <br></br>

	 <a name="ref_Indent">
    <h2>Code indentation and bracing </h2>

    4-spaces indentation only;  tabulation symbol should not be used
	 for indentation.

<p></p>
	 In "if", "for", "while", "do", "switch", "case", etc. and
    type definition statements:
    <pre>
if (...) {
    .....;
} else if (...) {
    .....;
} else {
    .....;
}

if|for|do|while (...) {
    .....;
}

switch (...) {
    case ...: {
        .....;
        break;
    }
}

class|struct|union <[C|S|U]TypeName> {
    .....;
};

    </pre>



	 <a name="ref_Class">
    <h2>Class declaration</h2>

	 <pre>
class CFooClass {
public:
    // Constructors and Destructor (they are usually public)
    CFooClass(bool init_bool=true);
    CFooClass(int  init_int);
    ~CFooClass(void);

    // Members and Methods
    // (NOTE:  the use of public data members is strictly discouraged!)
    int   m_PublicData;
    float PublicFunc(void);

protected:
    double m_ProtectedData;
    static int ProtectedFunc(char ch);

private:
    int    m_PrivateData;
    double PrivateFunc(int some_int=123);

    // Friends
    friend bool  SomeFriendFunc(void);
    friend class CSomeFriendClass;
private:
    // Prohibit default initialization and assignment -- e.g. when the
    // member-by-member copying is dangerous
    CFooClass(const CFooClass&) { _TROUBLE; }
    CFooClass& operator=(const CFooClass&) { _TROUBLE;  return *this; }
};
	 </pre>


	 <hr>
	 <table border=0 width="100%" cellspacing=0>
		<tr>
		  <td><address><a href="mailto:vakatov@ncbi.nlm.nih.gov">Denis Vakatov</a></address></td>
		  <td align=right>($Revision$)</td></tr>
	 </table>
  </body>
</html>
