<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
  <title>Starting new C++ project</title>
</head>

<body>
<h1>Starting new C++ project</h1>

<ul>
  <li> <a href="#ref_Checkout">
    Retrieve NCBI C++ source tree from CVS</a>
  <li> <a href="#ref_Structure">
    CVS tree structure of NCBI C++ projects</a>
  <li> <a href="#ref_Create">
    Creating a CVS directory for a new C++ project</a>
  <li> <a href="#ref_Makefile">
    Project makefiles and sub-projects</a>
  <ul>
    <li> <a href="#ref_MakeMeta">
    <i>Meta-makefiles</i> (to provide multiple and/or recursive builds)</a>
    <li> <a href="#ref_MakeProj">
    Project makefiles</a>
    <ul>
      <li> <a href="#ref_MakeProjMk">
        Configured tools, flags and paths for the whole build tree
        (<b><i>Makefile.mk</i></b>)</a>
      <li> <a href="#ref_MakeProjLib">
        Customized makefile to build a library</a>
      <li> <a href="#ref_MakeProjApp">
        Customized makefile to build an application</a>
      <li> <a href="#ref_MakeProjUsr">
        User-defined makefile to build... whatever</a>
      <li> <a href="#ref_MakeProjTarget">
        Standard build targets(<b>all, clean, purge</b>) in makefiles</a>
    </ul>
  </ul>
  <li> <a href="#ref_Outside">
    Developing a project(lib, application) outside of the NCBI C++ tree</a>
    <ul>
      <li> <a href="#ref_OutsideImport">
           <b><i>import_project.sh</i></b> -- project from the NCBI C++ tree
           </a>
      <li> <a href="#ref_OutsideCreate">
           <b><i>new_project.sh</i></b> -- project only using the NCBI C++ tree
           </a>
      <li> <a href="#ref_OutsideHello">
           <b><i>hello.sh</i></b> -- a simple demo CGI application HELLO
           </a>
    </ul>
  <li> <a href="mkfiles.html">
    A real-life example of the NCBI C++ makefile hierarchy
   (project <i><b>corelib/</b></i>)</a>
</ul>

<p>
<br>
<a name="ref_Checkout"></a>
<h2>Retrieve NCBI C++ source tree from CVS</h2>

<p>
You can checkout the whole NCBI C++ source tree from CVS to you local
directory(e.g. <b><i>foo/c++/</i></b>) just by running:
<pre>
cd foo
cvs checkout -d c++ internal/c++
</pre>

<p>
However, the whole NCBI C++ tree is very big because it contains a lot
of internal user projects. There are also numerous platform-specific
files (and even whole sub-trees) which you will never need if you
work on other platforms.

<br>
To help one to retrieve the sources which are suitable for your
platform, there are auxiliary scripts <b><i>scripts/cvs_core.sh</i></b></a> and
<b><i>scripts/cvs_core_msvc.bat</i></b> to checkout only core (basic and portable)
NCBI C++ toolkit sources.

<p>
For the detailed info on the CVS utility see
<a href="http://www.cs.utah.edu/csinfo/texinfo/cvs/cvs_toc.html">
  CVS online manual</a> or run commands <i>"man cvs"</i> or <i>"cvs -H"</i> on
your workstation.


<p>
<br>
<a name="ref_Structure"></a>
<h2>CVS tree structure of NCBI C++ projects</h2>

<p>
(For the overall NCBI C++ CVS tree structure see in
<a href="config.html#ref_Source">NCBI C++ source code repository</a>.)

<p>
The standard CVS location for NCBI C++/STL projects is
<i><b>$CVSROOT/internal/c++/</b></i>. Public header files
(<i>*.hpp, *.inl</i>) of all projects are located below
the <i><b>$CVSROOT/internal/c++/include/</b></i> directory.
<i><b>$CVSROOT/internal/c++/src/</b></i> directory has just the same
hierarchy of subdirectories as <i><b>.../include/</b></i>, and its
very top level contains:

<ul>
  <li> Templates of generic makefiles (<b><i>Makefile.*.in</i></b>):
    <ul>
      <li> <b><i>Makefile.in</i></b> -- makefile to perform a recursive
        build in all project subdirectories
      <li> <b><i>Makefile.meta.in</i></b> -- to be included to all makefiles
        that provide both local and recursive builds
      <li> <b><i>Makefile.lib.in</i></b> -- to be included to all makefiles
        that perform a "standard" library build
      <li> <b><i>Makefile.lib.tmpl.in</i></b> -- serve as a template for the
        project <i>customized makefiles</i> (<b><i>Makefile.*.lib[.in]</i></b>) that perform
        a "standard" library build
      <li> <b><i>Makefile.app.in</i></b> -- to be included to all makefiles
        that perform a "standard" application build
      <li> <b><i>Makefile.lib.tmpl.in</i></b> -- serve as a template for the
        project <i>customized makefiles</i> (<b><i>Makefile.*.app[.in]</i></b>) that perform
        a "standard" application build
    </ul>

  <p>
    <li> Tree of project directories, each contains:
      <ul>
        <li> <b><i>*.cpp, *.hpp, *.inl</i></b> --
          project's source files and private headers
        <li> <b><i>Makefile.in</i></b> --
          a <a href="#ref_MakeMeta"><i>meta-makefile</i></a>
          to specify which local projects (described in <i>Makefile.*.in</i>)
          and sub-projects(located in the project subdirectories) must be built
        <li> <b><i>Makefile.*.lib[.in], Makefile.*.app[.in]</i></b> --
          <i>customized makefiles</i> to build a library or an application
        <li> <b><i>Makefile.*[.in]</i></b> -- "free style" makefiles
        <li> sub-project directories (if any)
      </ul>
</ul>


<br>
<a name="ref_Create"></a>
<h2>Creating source and include CVS dirs for a new C++ project</h2>

<p>
To create your new project(e.g. "bar_proj") directories in the
NCBI C++ CVS tree (assuming that the whole NCBI C++ has been
<a href="#ref_Checkout">checked out</a>
to directory <b><i>foo/c++/</i></b>):<pre>
cd foo/c++/include && mkdir bar_proj && cvs add -m "Project Bar" bar_proj
cd foo/c++/src     && mkdir bar_proj && cvs add -m "Project Bar" bar_proj
</pre>

Now you can <a href="new_mod.html">add</a> and edit your project C++
files in there.

<p>
NOTE: remember to add this new project directory to <i>$(SUB_PROJ)</i>
list of the upper level <a href="#ref_MakeMeta"><i>meta-makefile</i></a>
configurable template
(e.g., for this particular case, to <b><i>foo/c++/src/Makefile.in</i></b>).


<p>
<br>
<a name="ref_Makefile"></a>
<h2>Project makefiles and sub-projects</h2>

<a name="ref_MakeMeta"></a>
<h3>Meta-makefiles (to provide multiple and/or recursive builds)</h3>

All projects from the NCBI C++ hierarchy are tied together by a
set of <i>meta-makefiles</i> which present in all project source directories
and provide a uniform and easy way to perform both local and recursive
builds. 

A typical <i>meta-makefile</i> template(e.g. <i><b>Makefile.in</b></i> in your
<b><i>foo/c++/src/bar_proj/</i></b> dir) looks like that:
<pre>
USR_PROJ = bar_u1 bar_u2 ...  # Makefile.bar_u1,     Makefile.bar_u1     ...
LIB_PROJ = bar_l1 bar_l2 ...  # Makefile.bar_l1.lib, Makefile.bar_l1.lib ...
APP_PROJ = bar_a1 bar_l2 ...  # Makefile.bar_a1.app, Makefile.bar_a1.app ...
SUB_PROJ = app sub_proj1 sub_proj2

srcdir = @srcdir@
include @builddir@/Makefile.meta
</pre>

The mandatory <i>"srcdir = @srcdir@ ; include @builddir@/Makefile.meta"</i>
provides build rules for the following standard targets:
<ul>
  <li> <a href="#ref_MakeProjTarget"><b>all</b></a>:
    <ul>
		<li> run <i>"make  -f {Makefile.*} all"</i> for the makefiles with
		  the suffixes enlisted in macro <b>USR_PROJ</b>: <pre>
make -f Makefile.bar_u1 all
make -f Makefile.bar_u2 all
...... </pre>
		<li> build library(ies) using attributes defined in the
		  <i>customized makefiles</i> <b>Makefile.*.lib</b> with the suffixes
        enlisted in macro <b>LIB_PROJ</b>
		  <li> build application(s) using attributes defined in the
		  <i>customized makefiles</i> <b>Makefile.*.app</b> with the suffixes
        enlisted in macro <b>APP_PROJ</b>
    </ul>
  <li> <a href="#ref_MakeProjTarget"><b>all_r</b></a> --
	 first do target <b>all</b>, then run <i>"make  all_r"</i>
	 in all subdirectories enlisted in <i>$(SUB_PROJ)</i>: <pre>
cd bar_test       &&  make -f Makefile all_r
cd bar_sub_proj1  &&  make -f Makefile all_r
...... </pre>
  <li> <a href="#ref_MakeProjTarget"><b>clean, clean_r</b></a> --
	 run just the same makefiles but with targets <b>clean</b> and <b>clean_r</b>
    (rather than <b>all</b> and <b>all_r</b>), respectively
  <p>
  <li> <a href="#ref_MakeProjTarget"><b>purge, purge_r</b></a> --
	 .....with targets <b>purge</b> and <b>purge_r</b>, respectively
</ul>


<p>
<br>
<a name="ref_MakeProj"></a>
<h3>Project makefiles</h3>

Just like <b><i>Makefile.meta.in</i></b> configurable template is used to ease
and standatize the writing of
<a href="#ref_MakeMeta"><i>meta-makefiles</i></a>, so there are templates
to help in the creation of "regular" project makefiles to build
a library or an application. These auxiliary template makefiles
are <b><i>Makefile.mk.in</i></b>, <b><i>Makefile.lib.in</i></b>,
<b><i>Makefile.app.in</i></b>, <b><i>Makefile.lib.tmpl.in</i></b> and
<b><i>Makefile.app.tmpl.in</i></b>. The <b><i>configure</i></b>'d versions of
them get put to the very top of a <i>build tree</i>.


<p>
<br>
<a name="ref_MakeProjMk"></a>
<h3><i>Configured tools, flags, and paths for the whole build tree (<b>Makefile.mk</b>)</i></h3>

<b><i>Makefile.mk</i></b> is silently included at the very beginning of the
<i>customized makefiles</i> used to build
<a href="#ref_MakeProjLib">libraries</a> and
<a href="#ref_MakeProjApp">applications</a>.

<p>
<b><i>Makefile.mk</i></b> defines the following makefile macros obtained
during the configuration process:

<br></br>
<a name="ref_TableFlags">
<table border=1 cellspacing=0>
<caption>Flags</caption>
  <tr>
	 <th>Macro</th>
	 <th><a href="config.html#ref_TableToolsAndFlags">Source</a></th>
	 <th><a href="config.html#ref_StdBuildRules">Synopsis</a></th>
  </tr>

  <tr>
	 <td><b>CFLAGS</b></td>
	 <td><i>$CFLAGS</i></td>
	 <td>C compiler flags</td>
  </tr>

  <tr>
	 <td><b>CXXFLAGS</b></td>
	 <td><i>$CXXFLAGS</i></td>
	 <td>C++ compiler flags</td>
  </tr>

  <tr>
	 <td><b>CPPFLAGS</b></td>
	 <td><i>$CPPFLAGS</i></td>
	 <td>C/C++ preprocessor flags</td>
  </tr>

  <tr>
	 <td><b>LDFLAGS</b></td>
	 <td><i>$LDFLAGS</i></td>
	 <td>Linker flags</td>
  </tr>
</table>


<br></br>
<a name="ref_TableThirdParty">
<table border=1 cellspacing=0>
<caption>System and third-party packages</caption>
  <tr>
	 <th>Macro</th>
	 <th><a href="config.html#ref_TableLocalization1">Source</a></th>
	 <th>Synopsis</th>
  </tr>

  <tr>
	 <td><b>LIBS</b></td>
	 <td><i>$LIBS</i></td>
	 <td>Default libraries to link with</td>
  </tr>

  <tr>
	 <td><b>THREAD_LIBS</b></td>
	 <td><i>$THREAD_LIBS</i></td>
	 <td>Thread library</td>
  </tr>

  <tr>
	 <td><b>NETWORK_LIBS</b></td>
	 <td><i>$NETWORK_LIBS</i></td>
	 <td>Network library</td>
  </tr>

  <tr>
	 <td><b>SYBASE_INCLUDE</b></td>
	 <td><i>$SYBASE_INCLUDE</i></td>
	 <td>SYBASE headers</td>
  </tr>

  <tr>
	 <td><b>SYBASE_LIBS</b></td>
	 <td><i>$SYBASE_LIBS</i></td>
	 <td>SYBASE libraries</td>
  </tr>

  <tr>
	 <td><b>FASTCGI_INCLUDE</b></td>
	 <td><i>$FASTCGI_INCLUDE</i></td>
	 <td>Fast-CGI headers</td>
  </tr>

  <tr>
	 <td><b>FASTCGI_LIBS</b></td>
	 <td><i>$FASTCGI_LIBS</i></td>
	 <td>Fast-CGI libraries</td>
  </tr>

  <tr>
	 <td><b>NCBI_C_INCLUDE</b></td>
	 <td><i>$NCBI_C_INCLUDE</i></td>
	 <td>NCBI C toolkit headers</td>
  </tr>

  <tr>
	 <td><b>NCBI_C_LIBPATH</b></td>
	 <td><i>$NCBI_C_LIBPATH</i></td>
	 <td>Path to the NCBI C toolkit libraries</td>
  </tr>

  <tr>
	 <td><b>NCBI_C_ncbi</b></td>
	 <td><i>$NCBI_C_ncbi</i></td>
	 <td>NCBI C CoreLib</td>
  </tr>

  <tr>
	 <td><b>NCBI_SSSDB_INCLUDE</b></td>
	 <td><i>$NCBI_SSSDB_INCLUDE</i></td>
	 <td>NCBI SSS DB headers</td>
  </tr>

  <tr>
	 <td><b>NCBI_SSSDB_LIBS</b></td>
	 <td><i>$NCBI_SSSDB_LIBS</i></td>
	 <td>NCBI SSS DB libraries</td>
  </tr>

  <tr>
	 <td><b>NCBI_PM_PATH</b></td>
	 <td><i>$NCBI_PM_PATH</i></td>
	 <td>Path to the PubMed package</td>
  </tr>
</table>


<br></br>
<a name="ref_TablePath">
<table border=1 cellspacing=0>
<caption>Useful paths to some <i>source</i> and <i>build</i> tree directories
</caption>
  <tr>
	 <th>Macro</th>
	 <th>Source</th>
	 <th>Synopsis</th>
  </tr>

  <tr>
	 <td><b>top_srcdir</b></td>
	 <td><i>@top_srcdir@</i></td>
	 <td>Path to the whole NCBI C++ package</td>
  </tr>

  <tr>
	 <td><b>srcdir</b></td>
	 <td><i>@srcdir@</i></td>
	 <td>Directory in the <i>source tree</i> that corresponds to the
        directory (<i><b>./</b></i>) in the <i>build tree</i> where the
        build is currently going on
    </td>
  </tr>

  <tr>
	 <td><b>includedir</b></td>
	 <td><i>@includedir@</i></td>
	 <td>Top include directory in the <i>source tree</i></td>
  </tr>

  <tr>
	 <td><b>exec_prefix</b></td>
	 <td><i>@exec_prefix@</i></td>
	 <td>Path to the whole <i>build tree</i></td>
  </tr>

  <tr>
	 <td><b>builddir</b></td>
	 <td><i>@builddir@</i></td>
	 <td>Top build directory inside the <i>build tree</i></td>
  </tr>

  <tr>
	 <td><b>incdir</b></td>
	 <td><i>@incdir@</i></td>
	 <td>Top include directory inside the <i>build tree</i></td>
  </tr>

  <tr>
	 <td><b>libdir</b></td>
	 <td><i>@libdir@</i></td>
	 <td>Libraries built inside the <i>build tree</i></td>
  </tr>

  <tr>
	 <td><b>bindir</b></td>
	 <td><i>@bindir@</i></td>
	 <td>Executables built inside the <i>build tree</i></td>
  </tr>
</table>


<br></br>
<a name="ref_TableTools">
<table border=1 cellspacing=0>
<caption>Compiler, Linker, and other Tools</caption>
  <tr>
	 <th>Macro</th>
	 <th><a href="config.html#ref_TableToolsAndFlags">Source</a></th>
	 <th><a href="config.html#ref_StdBuildRules">Synopsis</a></th>
  </tr>

  <tr>
	 <td><b>CC</b></td>
	 <td><i>$CC</i></td>
	 <td>C compiler</td>
  </tr>

  <tr>
	 <td><b>CXX</b></td>
	 <td><i>$CXX</i></td>
	 <td>C++ compiler</td>
  </tr>

  <tr>
	 <td><b>LINK</b></td>
	 <td><i>$CXX</i></td>
	 <td>Linker (C++-aware)</td>
  </tr>

  <tr>
	 <td><b>CPP</b></td>
	 <td><i>$CPP</i></td>
	 <td>C preprocessor</td>
  </tr>

  <tr>
	 <td><b>CXXCPP</b></td>
	 <td><i>$CXXCPP</i></td>
	 <td>C++ preprocessor</td>
  </tr>

  <tr>
	 <td><b>AR</b></td>
	 <td><i>$AR</i></td>
	 <td>Library archiver</td>
  </tr>

  <tr>
	 <td><b>STRIP</b></td>
	 <td><i>$STRIP</i></td>
	 <td>Tool to strip symbolic info from binaries</td>
  </tr>

  <tr>
	 <td><b>RM</b></td>
	 <td><i>rm -f</i></td>
	 <td>Remove file(s)</td>
  </tr>

  <tr>
	 <td><b>RMDIR</b></td>
	 <td><i>rm -rf</i></td>
	 <td>Remove file(s) and directory(ies) recursively</td>
  </tr>

  <tr>
	 <td><b>COPY</b></td>
	 <td><i>cp -p</i></td>
	 <td>Copy file (preserving the modification time)</td>
  </tr>

  <tr>
	 <td><b>BINCOPY</b></td>
	 <td><i>@BINCOPY@</i></td>
	 <td>Copy a library or an executable -- but only if it was changed</td>
  </tr>
</table>



<p>
<br>
<a name="ref_MakeProjLib"></a>
<h3><i>Customized makefile to build a library</i></h3>

Here is an example of a <i>customized makefile</i> to build
library <i><b>libxmylib.a</b></i> from two source files
<i><b>xmy_src1.cpp</b></i> and <i><b>xmy_src2.c</b></i>, and one
pre-compiled object file <i><b>some_obj1.o</b></i>.
To make the example even more realistic, we assume that the said
source files include headers from the NCBI C Toolkit.<pre>
File Makefile.xmylib.lib:

LIB      = xmylib
LIBOBJ   = xmy_src1 xmy_src2
LOBJ     = some_obj1
CFLAGS   = $(ORIG_CFLAGS)   -abc -DFOOBAR_NOT_CPLUSPLUS
CXXFLAGS = $(ORIG_CXXFLAGS) -xyz
CPPFLAGS = $(ORIG_CPPFLAGS) -UFOO -DP1_PROJECT -I$(NCBI_C_INCLUDE)</pre>

<ul>
  <li> Compile <i><b>xmy_src1.cpp</b></i> using C++ compiler <b>CXX</b> with
       flags <b>CXXFLAGS CPPFLAGS</b> (which are the
       original C++ and preprocessor flags, <b>ORIG_*FLAGS</b>,
       plus some additional flags specified by user)
  <li> Compile <i><b>xmy_src2.c</b></i> using C compiler <b>CC</b> with
       flags <b>CFLAGS CPPFLAGS</b> (which are the
       original C and preprocessor flags, <b>ORIG_*FLAGS</b>,
       plus some additional flags specified by user)
  <li> Using <b>AR</b> and <b>RANLIB</b>, compose
       library <i><b>libxmylib.a</b></i> from the resultant object files,
       plus pre-compiled <i><b>some_obj1.o</b></i>.
  <li> Copy <i><b>libxmylib.a</b></i> to the
       top-level <b><i>lib/</i></b> directory of
       <i>build tree</i> (for the later use by other projects)
</ul>

This <i>customized makefile</i> should be referenced as <i><b>xmylib</b></i> in the
<b>LIB_PROJ</b> macro of relevant
<a href="#ref_MakeMeta"><i>meta-makefile</i></a>. As usual,
<a href="#ref_MakeProjMk"><i>Makefile.mk</i></a> will be
implicitely included.

<p>
NOTE: this file is used to build both <i>static</i>
and <a href="config.html#ref_DLL"><i>dynamic</i></a> library.


<p>
<br>
<a name="ref_MakeProjApp"></a>
<h3><i>Customized makefile to build an application</i></h3>

Here is an example of a <i>customized makefile</i> to build
application <i><b>my_exe</b></i> from three source files,
<i><b>my_main.cpp</b></i>, <i><b>my_src1.cpp</b></i>,
and <i><b>my_src2.c</b></i>.
To make the example even more realistic, we assume that the said
source files include headers from the NCBI SSS DB packages,
and the target executable uses NCBI C++ libraries
<a href="#ref_MakeProjLib"><i><b>libxmylib.a</b></i></a> and
<i><b>libxncbi.a</b></i>, plus
NCBI SSS DB, SYBASE, and system network libraries.<pre>
File Makefile.my_exe.app:

APP      = my_exe
OBJ      = my_main my_src1 my_src2
LIB      = xmylib xncbi
CPPFLAGS = $(ORIG_CPPFLAGS) $(NCBI_SSSDB_INCLUDE)
LIBS     = $(NCBI_SSSDB_LIBS) $(SYBASE_LIBS) $(NETWORK_LIBS) $(ORIG_LIBS)</pre>

<ul>
  <li> Compile <i><b>my_main.cpp</b></i> and <i><b>my_src1.cpp</b></i>
    using C++ compiler <b>CXX</b> with flags <b>CPPFLAGS</b>
    (<a href="#ref_Note1">*</a>)
  <li> Compile <i><b>my_src2.c</b></i> using C compiler <b>CC</b> with
    flags <b>CPPFLAGS</b>
    (<a href="#ref_Note1">*</a>)
  <li> Using <b>CXX</b> as a linker, build an executable
    <i><b>my_exe</b></i> from object files
    <b><i>my_main.o, my_src1.o, my_src2.o</i></b>, NCBI C++ Toolkit libraries
    <a href="#ref_MakeProjLib"><i><b>libxmylib.a</b></i></a> and
    <i><b>libxncbi.a</b></i>, and NCBI SSS DB, SYBASE,
    and system network libraries
    (<a href="#ref_Note1">*</a>)
  <li> Copy the library to top-level <b><i>lib/</i></b> directory of
    the <i>build tree</i> (for later use by other projects)
</ul>

<a name="ref_Note1"></a>
<i><b>(*)</b></i>
as we did not redefine <b>CFLAGS</b>, <b>CXXFLAGS</b>, <b>LDFLAGS</b>,
so their default values <b>ORIG_*FLAGS</b> (obtained during the <i>build
tree</i> <a href="config.html#ref_Configure">configuration</a>) will be
<a href="config.html#ref_StdBuildRules">used</a>.

<p>
This <i>customized makefile</i> should be referenced as <i><b>my_exe</b></i> in the
<b>APP_PROJ</b> macro of relevant
<a href="#ref_MakeMeta"><i>meta-makefile</i></a>. Note also, that the
<a href="#ref_MakeProjMk"><i>Makefile.mk</i></a> will be
implicitely included.


<p>
<br>
<a name="ref_MakeProjUsr"></a>
<h3><i>User-defined makefile to build... whatever</i></h3>

<p>
In some cases, we may need more functionality than the <i>customized makefiles</i>
(designed to build libraries and applications) can provide.

<p>
So, if you have a "regular" non-customized <i>user makefile</i>, and
you want to make with it, then you must enlist this <i>user makefile</i>
in the <b>USR_PROJ</b> macro of the project's
<a href="#ref_MakeMeta"><i>meta-makefile</i></a>.

<p>
Now, during the project build (and before any <i>customized makefiles</i>
are processed), your makefile will be called with one of the 
<a href="#ref_MakeProjTarget">standard make targets</a> from the
project's build directory. Additionally,
<a href="#ref_TablePath"><b>builddir</b></a> and
<a href="#ref_TablePath"><b>srcdir</b></a> macro will be passed
to your makefile (via the <b>make</b> command line).

<p>
In most cases, it is necessary to know your "working environment", i.e.
tools, flags and paths (those that you use in your <i>customized makefiles</i>).
This can be easily done by including
<a href="#ref_MakeProjMk"><i>Makefile.mk</i></a> to your makefile.

<p>
Shown below is a real-life example of a <i>user makefile</i>:
<ul>
  <li> build an auxiliary application using <i>customized makefiles</i>
    <i><b>Makefile.hc_gen_obj.app</b></i> (this part is a tricky one...)
  <li> use the resultant application <i><b>$(bindir)/hc_gen_obj</b></i>
    to generate source an header files <i><b>humchrom_dat.[ch]</b></i>
    from data file <i><b>humchrom.dat</b></i>
  <li> carefully, using script <i><b>$(top_srcdir)/scripts/if_diff.sh</b></i>
    to check if they really different, replace previous versions
    of <i><b>humchrom_dat.[ch]</b></i> (if any) by the new (just generated)
    ones
</ul>

And, of course, it provides build rules for all
<a href="#ref_MakeProjTarget">standard make targets</a>.

<pre>
File $(top_srcdir)/src/internal/humchrom/Makefile.hc_gen_obj:

# Build a code generator for hard-coding the chrom data into an obj file
# Generate header and source "humchrom_dat.[ch]" from data file "humchrom.dat"
# Deploy the header to the compiler-specific include dir
# Compile source code
#################################

include $(builddir)/Makefile.mk

BUILD__HC_GEN_OBJ = $(MAKE) -f "$(builddir)/Makefile.app.tmpl" srcdir="$(srcdir)" TMPL="hc_gen_obj" $(MFLAGS)


all_r: all
all: build_hc_gen_obj humchrom_dat.dep

purge_r: purge
purge:   x_clean
	$(BUILD__HC_GEN_OBJ) purge

clean_r: clean
clean:   x_clean
	$(BUILD__HC_GEN_OBJ) clean
x_clean:
	-rm -f humchrom_dat.h
	-rm -f humchrom_dat.c

build_hc_gen_obj:
	$(BUILD__HC_GEN_OBJ) all

humchrom_dat.dep: $(srcdir)/data/humchrom.dat $(bindir)/hc_gen_obj
	-cp -p humchrom_dat.c humchrom_dat.save.c
	$(bindir)/hc_gen_obj -d $(srcdir)/data/humchrom.dat -f humchrom_dat
	$(top_srcdir)/scripts/if_diff.sh "mv" humchrom_dat.h $(incdir)/humchrom_dat.h
	-rm humchrom_dat.h
	$(top_srcdir)/scripts/if_diff.sh "mv" humchrom_dat.c humchrom_dat.save.c
	mv humchrom_dat.save.c humchrom_dat.c
	touch humchrom_dat.dep
</pre>


<p>
<br>
<a name="ref_MakeProjTarget"></a>
<h2>Standard build targets(<b>all, clean, purge</b>) in makefiles</h2>

<ul>
  <li> <b>all</b> -- compile object modules specified in the
  <i>"$(OBJ)"</i> macro, and use them to build library <i>"$(LIB)"</i> or
  application <i>"$(APP)"</i>;  then copy the resultant lib/app to the
  <a href="#ref_TablePath"><b>libdir/bindir</b></a> directory, respectively
  <li> <b>clean</b> -- remove all object modules and lib/app
  that have been built by <b>all</b>
  <li> <b>purge</b> -- do <b>clean</b>, and then remove the copy
  of lib/app from the <a href="#ref_TablePath"><b>libdir/bindir</b></a> directory
</ul>

Naturally, the <i>customized makefiles</i> will not make a difference between
recursive(<b>all_r, clean_r, purge_r</b>) and non-recursive(<b>all, clean, purge</b>)
targets -- because the recursion and multiple build is
entirely up to the <a href="#ref_MakeMeta"><i>meta-makefiles</i></a>.


<p>
<br>
<a name="ref_Outside"></a>
<h2>Developing a project(lib, application) outside of the NCBI C++ tree</h2>

NOTE:  in NCBI, you can use scripts located in the pre-built NCBI C++
toolkit directory <b><i>$NCBI/c++/scripts/.</i></b>

<p>
<br>
<a name="ref_OutsideImport"></a>
<h3><b><i>scripts/import_project.sh &lt;cvs_tree_path&gt; [builddir]</i></b></h3>

<p>
In many cases, you work on your own project which <b>is a part</b> of the
NCBI C++ tree, and you do not want to checkout, update and rebuild
the whole NCBI C++ tree. -- Instead, you just want to use headers and
libraries of the pre-built NCBI C++ toolkit to build your project.

<p>
Shell script <b><i>import_project.sh</i></b> will checkout
your project's source and include directories from CVS, and it will create
a (temporary) makefile based on the project's <i>customized makefile</i>.
This makefile will also contain a reference to the pre-built NCBI C++ toolkit.

<p>
For
<a href="new_project.import.session">
EXAMPLE</a>:
<br>&nbsp;&nbsp;&nbsp;
<b>
   import_project.sh hello
</b>
<br>
will checkout the whole <b>hello</b> demo project from the NCBI C++ tree
(<b><i>$CVSROOT/internal/c++/src/hello/</i></b>), and create
makefile <b><i>Makefile.hello_app</i></b> from the project's
<i>customized makefile</i> <b><i>Makefile.hello.app</i></b>.
Now you can just go to the created working directory
<b><i>internal/c++/src/hello/</i></b> and build demo application
<b>hello.cgi</b> using:
<br>&nbsp;&nbsp;&nbsp;
<b>
   make -f Makefile.hello_app
</b>

<p>
<br>
<a name="ref_OutsideCreate"></a>
<h3><b><i>scripts/new_project.sh &lt;name&gt; lib|app [builddir]</i></b> </h3>

<p>
This script will help you to write a makefile for a new, out-of-scratch
project which uses NCBI C++ (and probably NCBI C) toolkit.
You will just have to slightly edit the resultant makefile to:
<ul>
  <li> specify the name of your library (or application)
  <li> specify the list of source files going to it
  <li> modify some preprocessor, compiler, etc.  flags, if needed
  <li> modify the set of additional libraries to link to it
       (if it's an application), if needed
</ul>


<p>
For
<a href="new_project.create.session">
EXAMPLE</a>:

<br> &nbsp;&nbsp;&nbsp;
<b>
   new_project.sh foo lib
</b>
<br>
will create a model makefile <b><i>Makefile.foo_lib</i></b> to build
a library using tools and flags hard-coded in
<b><i>$NCBI/c++/Debug/build/Makefile.mk</i></b>,
and headers from <b><i>$NCBI/c++/include/</i></b>.
Now, after specifying the library name, list of source files, etc.,
you can just go to the created working directory
<b><i>foo/</i></b> and build your library using:
<br> &nbsp;&nbsp;&nbsp;
<b>
   make -f Makefile.foo_lib
</b>

<br>
You can easily change the active version of NCBI C++ toolkit
by manually setting variable <b>$(builddir)</b> in
<b><i>Makefile.foo_lib</i></b> to the desired toolkit path, e.g.:
<br> &nbsp;&nbsp;&nbsp;
<b><i>builddir = $(NCBI)/c++/GCC-Release/build</i></b>


<p>
<br>
<a name="ref_OutsideHello"></a>
<h3><b><i>scripts/hello.sh</i></b> </h3>

<p>
This script to:
<ul>
  <li> retrieve the demo CGI application project HELLO
  <li> create a standalone makefile to build it
  <li> build HELLO application using this makefile
  <li> run HELLO application
</ul>
It will produce file <b><i>hello.html</i></b> containing a model
HTTP response. For more info on the HELLO CGI project see
in section
<i><a href="tools.html">NCBI C++ tools and applications</a> /
<a href="tools/hello/hello.html">HELLO.CGI -- a demo CGI application (NCBI C++)</a></i>.


<br></br>
<hr>
<table border=0 width="100%" cellspacing=0>
  <tr>
    <td><address><a href="mailto:vakatov@ncbi.nlm.nih.gov">Denis Vakatov</a></address></td>
<!-- <td align=center><i>$Revision$</i></td> -->
    <td align=right>($Date$)</td></tr>
</table>
  </body>
</html>
