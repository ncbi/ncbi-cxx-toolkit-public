<!--#set var="TITLE" value="Starting a new C++ project" -->
<!--#set var="DOCROOT" value="." -->
<!--#include virtual="./ssi/header.shtml" -->

<h1>Starting a new C++ project</h1>

<ul>
  <li> <a href="#ref_Checkout">
    Retrieve NCBI C++ source tree from CVS</a>
  <li> <a href="#ref_Structure">
    CVS tree structure of NCBI C++ projects</a>
  <li> <a href="#ref_Create">
    Creating a CVS directory for a new C++ project</a>
  <li> <a href="#ref_Makefile">
    Project makefiles and sub-projects</a>
  <ul>
    <li> <a href="#ref_MakeMeta">
    <i>Meta-makefiles</i> (to provide multiple and/or recursive builds)</a>
    <li> <a href="#ref_Expendable">
      <i>Expendable</i> projects</a>
    <li> <a href="#ref_MakeProj">
    Project makefiles</a>
    <ul>
      <li> <a href="#ref_MakeProjMk">
        Configured tools, flags and paths for the whole build tree
        (<b><i>Makefile.mk</i></b>)</a>
      <li> <a href="#ref_MakeProjLib">
        Customized makefile to build a library</a>
      <li> <a href="#ref_MakeProjApp">
        Customized makefile to build an application</a>
      <li> <a href="#ref_MakeProjUsr">
        User-defined makefile to build... whatever</a>
      <li> <a href="#ref_MakeProjTarget">
        Standard build targets(<b>all, clean, purge</b>) in makefiles</a>
      <li> <a href="#ref_Packages">
        List of optional packages, features and projects</a>
    </ul>
  </ul>
  <li> <a href="#ref_Outside">
    Developing a project(lib, application) outside of the NCBI C++ tree</a>
    <ul>
      <li> <a href="#ref_OutsideImport">
           <b><i>import_project.sh</i></b> -- project from the NCBI C++ tree
           </a>
      <li> <a href="#ref_OutsideCreate">
           <b><i>new_project.sh</i></b> -- project only using the NCBI C++ tree
           </a>
      <li> <a href="#ref_OutsideHello">
           <b><i>hello.sh</i></b> -- a simple demo CGI application HELLO
           </a>
    </ul>
  <li> <a href="mkfiles.html">
    A real-life example of the NCBI C++ makefile hierarchy
   (project <i><b>corelib/</b></i>)</a>
</ul>

<p>
<br>
<a name="ref_Checkout"></a>
<h2>Retrieve NCBI C++ source tree from CVS</h2>

<p>
You can checkout the whole NCBI C++ source tree from CVS to your local
directory (<i>e.g.</i>, <b><i>foo/c++/</i></b>) just by running:
<pre>
cd foo
cvs checkout -d c++ internal/c++
</pre>

<p>
However, the whole NCBI C++ tree is very big because it contains a lot
of internal user projects. There are also numerous platform-specific
files (and even whole sub-trees) which you will never need unless you
work on other platforms.

<br>
To help one to retrieve the sources which are suitable for your
platform, there are auxiliary scripts
<b><i>scripts/cvs_core.sh</i></b> and
<b><i>scripts/cvs_core_msvc.bat</i></b> to checkout only core (basic
and portable) NCBI C++ toolkit sources.

<p>
For the detailed info on the CVS utility see <a
href="http://www.cs.utah.edu/csinfo/texinfo/cvs/cvs_toc.html">the CVS
online manual</a> or run the commands <i>"man cvs"</i> or <i>"cvs
--help"</i> on your workstation.


<p>
<br>
<a name="ref_Structure"></a>
<h2>CVS tree structure of NCBI C++ projects</h2>

<p>
(For the overall NCBI C++ CVS tree structure see
<a href="config.html#ref_Source">the NCBI C++ source code repository</a>.)

<p>
The standard CVS location for NCBI C++/STL projects is
<i><b>$CVSROOT/internal/c++/</b></i>. Public header files
(<i>*.hpp, *.inl</i>) of all projects are located below
the <i><b>$CVSROOT/internal/c++/include/</b></i> directory.
<i><b>$CVSROOT/internal/c++/src/</b></i> directory has just the same
hierarchy of subdirectories as <i><b>.../include/</b></i>, and its
very top level contains:

<ul>
  <li> Templates of generic makefiles (<b><i>Makefile.*.in</i></b>):
    <ul>
      <li> <b><i>Makefile.in</i></b> -- makefile to perform a recursive
        build in all project subdirectories
      <li> <b><i>Makefile.meta.in</i></b> -- included by all makefiles
        that provide both local and recursive builds
      <li> <b><i>Makefile.lib.in</i></b> -- included by all makefiles
        that perform a "standard" library build, when building only
        static libraries.
      <li> <b><i>Makefile.dll.in</i></b> -- included by all makefiles
        that perform a "standard" library build, when building only
        shared libraries.
      <li> <b><i>Makefile.both.in</i></b> -- included by all makefiles
        that perform a "standard" library build, when building both
        static and shared libraries.
      <li> <b><i>Makefile.lib.tmpl.in</i></b> -- serves as a template
        for the project <i>customized makefiles</i>
        (<b><i>Makefile.*.lib[.in]</i></b>) that perform a "standard"
        library build
      <li> <b><i>Makefile.app.in</i></b> -- included by all makefiles
        that perform a "standard" application build
      <li> <b><i>Makefile.lib.tmpl.in</i></b> -- serves as a template
        for the project <i>customized makefiles</i>
        (<b><i>Makefile.*.app[.in]</i></b>) that perform a "standard"
        application build
	  <li> <b><i>Makefile.rules.in,
        Makefile.rules_with_autodep.in</i></b> -- instructions for
        building object files; included by most other makefiles
	  <li> <b><i>Makefile.mk.in</i></b> -- included by all makefiles;
        sets a lot of configuration variables
    </ul>

  <p>
    <li> Tree of project directories, each contains:
      <ul>
        <li> <b><i>*.cpp, *.hpp, *.inl</i></b> --
          project's source files and private headers
        <li> <b><i>Makefile.in</i></b> --
          a <a href="#ref_MakeMeta"><i>meta-makefile</i></a>
          to specify which local projects (described in <i>Makefile.*.in</i>)
          and sub-projects(located in the project subdirectories) must be built
        <li> <b><i>Makefile.*.lib[.in], Makefile.*.app[.in]</i></b> --
          <i>customized makefiles</i> to build a library or an application
        <li> <b><i>Makefile.*[.in]</i></b> -- "free style" makefiles
        <li> sub-project directories (if any)
      </ul>
</ul>


<br>
<a name="ref_Create"></a>
<h2>Creating source and include CVS dirs for a new C++ project</h2>

<p>
To create your new project (<i>e.g.</i>, "bar_proj") directories in the
NCBI C++ CVS tree (assuming that the whole NCBI C++ has been
<a href="#ref_Checkout">checked out</a>
to directory <b><i>foo/c++/</i></b>):<pre>
cd foo/c++/include && mkdir bar_proj && cvs add -m "Project Bar" bar_proj
cd foo/c++/src     && mkdir bar_proj && cvs add -m "Project Bar" bar_proj
</pre>

Now you can <a href="new_mod.html">add</a> and edit your project C++
files in there.

<p>
NOTE: remember to add this new project directory to the <i>$(SUB_PROJ)</i>
list of the upper level <a href="#ref_MakeMeta"><i>meta-makefile</i></a>
configurable template (<i>e.g.</i>, for this particular case, to
<b><i>foo/c++/src/Makefile.in</i></b>).


<p>
<br>
<a name="ref_Makefile"></a>
<h2>Project makefiles and sub-projects</h2>

<a name="ref_MakeMeta"></a>
<h3>Meta-makefiles (to provide multiple and/or recursive builds)</h3>

All projects from the NCBI C++ hierarchy are tied together by a set of
<i>meta-makefiles</i> which are present in all project source
directories and provide a uniform and easy way to perform both local
and recursive builds.

A typical <i>meta-makefile</i> template(e.g. <i><b>Makefile.in</b></i> in your
<b><i>foo/c++/src/bar_proj/</i></b> dir) looks like that:
<pre>
USR_PROJ = bar_u1 bar_u2 ...  # Makefile.bar_u1,     Makefile.bar_u1     ...
LIB_PROJ = bar_l1 bar_l2 ...  # Makefile.bar_l1.lib, Makefile.bar_l1.lib ...
APP_PROJ = bar_a1 bar_l2 ...  # Makefile.bar_a1.app, Makefile.bar_a1.app ...
SUB_PROJ = app sub_proj1 sub_proj2

srcdir = @srcdir@
include @builddir@/Makefile.meta
</pre>

The mandatory <i>"srcdir = @srcdir@ ; include @builddir@/Makefile.meta"</i>
provides build rules for the following standard targets:
<ul>
  <li> <a href="#ref_MakeProjTarget"><b>all</b></a>:
    <ul>
		<li> run <i>"make  -f {Makefile.*} all"</i> for the makefiles
		  with the suffixes listed in macro <b>USR_PROJ</b>: <pre>
make -f Makefile.bar_u1 all
make -f Makefile.bar_u2 all
...... </pre>
		<li> build libraries using attributes defined in the
		  <i>customized makefiles</i> <b>Makefile.*.lib</b>
		  with the suffixes listed in macro <b>LIB_PROJ</b>
		<li> build application(s) using attributes defined in the
		  <i>customized makefiles</i> <b>Makefile.*.app</b> with the
		  suffixes listed in macro <b>APP_PROJ</b>
    </ul>
  <li> <a href="#ref_MakeProjTarget"><b>all_r</b></a> --
	 first make target <b>all</b>, then run <i>"make all_r"</i>
	 in all subdirectories enlisted in <i>$(SUB_PROJ)</i>: <pre>
cd bar_test       &&  make -f Makefile all_r
cd bar_sub_proj1  &&  make -f Makefile all_r
...... </pre>
  <li> <a href="#ref_MakeProjTarget"><b>clean, clean_r</b></a> --
	 run just the same makefiles but with targets <b>clean</b> and
	 <b>clean_r</b> (rather than <b>all</b> and <b>all_r</b>), respectively
  <li> <a href="#ref_MakeProjTarget"><b>purge, purge_r</b></a> --
	 .....with targets <b>purge</b> and <b>purge_r</b>, respectively
</ul>

<p>
<br>
<a name="ref_Expendable"></a>
<h3>Expendable projects</h3>
By default, failure of any project will cause make to exit immediately.
Although this behavior can save a lot of time, it is not always
desirable.  One way to avoid it is to run <tt>make -k</tt> rather than
<tt>make</tt>, but then major problems affecting a large portion of
the build will still waste a lot of time.

<p>
Consequently, the toolkit's build system supports an alternative
approach: <a href="#ref_MakeMeta"><i>meta-makefiles</i></a> can define
<i>expendable</i> projects which should be built if possible but are
allowed to fail without interrupting the build.  The way to do this is
to list such projects in <b>EXPENDABLE_*_PROJ</b> rather than <b>*_PROJ</b>.


<p>
<br>
<a name="ref_MakeProj"></a>
<h3>Project makefiles</h3>

Just like the configurable template <b><i>Makefile.meta.in</i></b> is
used to ease and standardize the writing of <a
href="#ref_MakeMeta"><i>meta-makefiles</i></a>, so there are templates
to help in the creation of "regular" project makefiles to build a
library or an application. These auxiliary template makefiles are
<b><i>Makefile.mk.in</i></b>, <b><i>Makefile.lib.in</i></b>,
<b><i>Makefile.dll.in</i></b>, <b><i>Makefile.both.in</i></b>,
<b><i>Makefile.app.in</i></b>, <b><i>Makefile.lib.tmpl.in</i></b>,
<b><i>Makefile.app.tmpl.in</i></b>, <b><i>Makefile.rules.in</i></b>,
and <b><i>Makefile.rules_with_autodep.in</i></b>.  The
<b><i>configure</i></b>'d versions of them get put at the very top of
a <i>build tree</i>.


<p>
<br>
<a name="ref_MakeProjMk"></a>
<h3><i>Configured tools, flags, and paths for the whole build tree (<b>Makefile.mk</b>)</i></h3>

<b><i>Makefile.mk</i></b> is silently included at the very beginning of the
<i>customized makefiles</i> used to build
<a href="#ref_MakeProjLib">libraries</a> and
<a href="#ref_MakeProjApp">applications</a>.

<p>
<b><i>Makefile.mk</i></b> defines the following makefile macros obtained
during the configuration process:

<br></br>
<a name="ref_TableFlags"></a>
<table border=1 cellspacing=0>
<caption>Flags</caption>
  <tr>
	 <th>Macro</th>
	 <th><a href="config.html#ref_TableToolsAndFlags">Source</a></th>
	 <th><a href="config.html#ref_StdBuildRules">Synopsis</a></th>
  </tr>

  <tr>
	 <td><b>CFLAGS</b></td>
	 <td><i>$CFLAGS</i></td>
	 <td>C compiler flags</td>
  </tr>

  <tr>
	 <td><b>CXXFLAGS</b></td>
	 <td><i>$CXXFLAGS</i></td>
	 <td>C++ compiler flags</td>
  </tr>

  <tr>
	 <td><b>CPPFLAGS</b></td>
	 <td><i>$CPPFLAGS</i></td>
	 <td>C/C++ preprocessor flags</td>
  </tr>

  <tr>
	 <td><b>LDFLAGS</b></td>
	 <td><i>$LDFLAGS</i></td>
	 <td>Linker flags</td>
  </tr>

  <tr>
     <td><b>STATIC</b></td>
	 <td><i>@STATIC@</i></td>
	 <td>Library suffix to force static linkage (see
	 <a href="#ref_MakeProjApp">below</a>)</td>
  </tr>
</table>


<br></br>
<a name="ref_TableThirdParty"></a>
<table border=1 cellspacing=0>
<caption>System and third-party packages</caption>
  <tr>
	 <th>Macro</th>
	 <th><a href="config.html#ref_TableLocalization1">Source</a></th>
	 <th>Synopsis</th>
  </tr>

  <tr>
	 <td><b>LIBS</b></td>
	 <td><i>$LIBS</i></td>
	 <td>Default libraries to link with</td>
  </tr>

  <tr>
	 <td><b>THREAD_LIBS</b></td>
	 <td><i>$THREAD_LIBS</i></td>
	 <td>Thread library <i>(system)</i></td>
  </tr>

  <tr>
	 <td><b>NETWORK_LIBS</b></td>
	 <td><i>$NETWORK_LIBS</i></td>
	 <td>Network library <i>(system)</i></td>
  </tr>

  <tr>
	 <td><b>MATH_LIBS</b></td>
	 <td><i>$MATH_LIBS</i></td>
	 <td>Math library <i>(system)</i></td>
  </tr>

  <tr>
	 <td><b>KSTAT_LIBS</b></td>
	 <td><i>$KSTAT_LIBS</i></td>
	 <td>KSTAT library <i>(system)</i></td>
  </tr>

  <tr>
	 <td><b>RPCSVC_LIBS</b></td>
	 <td><i>$RPCSVC_LIBS</i></td>
	 <td>RPCSVC library <i>(system)</i></td>
  </tr>

  <tr>
	 <td><b>SYBASE_INCLUDE</b></td>
	 <td><i>$SYBASE_INCLUDE</i></td>
	 <td>SYBASE headers</td>
  </tr>

  <tr>
	 <td><b>SYBASE_LIBS</b></td>
	 <td><i>$SYBASE_LIBS</i></td>
	 <td>SYBASE libraries</td>
  </tr>

  <tr>
	 <td><b>FASTCGI_INCLUDE</b></td>
	 <td><i>$FASTCGI_INCLUDE</i></td>
	 <td>Fast-CGI headers</td>
  </tr>

  <tr>
	 <td><b>FASTCGI_LIBS</b></td>
	 <td><i>$FASTCGI_LIBS</i></td>
	 <td>Fast-CGI libraries</td>
  </tr>

  <tr>
	 <td><b>NCBI_C_INCLUDE</b></td>
	 <td><i>$NCBI_C_INCLUDE</i></td>
	 <td>NCBI C toolkit headers</td>
  </tr>

  <tr>
	 <td><b>NCBI_C_LIBPATH</b></td>
	 <td><i>$NCBI_C_LIBPATH</i></td>
	 <td>Path to the NCBI C Toolkit libraries</td>
  </tr>

  <tr>
	 <td><b>NCBI_C_ncbi</b></td>
	 <td><i>$NCBI_C_ncbi</i></td>
	 <td>NCBI C CoreLib</td>
  </tr>

  <tr>
	 <td><b>NCBI_SSS_INCLUDE</b></td>
	 <td><i>$NCBI_SSS_INCLUDE</i></td>
	 <td>NCBI SSS headers</td>
  </tr>

  <tr>
	 <td><b>NCBI_SSS_LIBPATH</b></td>
	 <td><i>$NCBI_SSS_LIBPATH</i></td>
	 <td>Path to NCBI SSS libraries</td>
  </tr>

  <tr>
	 <td><b>NCBI_PM_PATH</b></td>
	 <td><i>$NCBI_PM_PATH</i></td>
	 <td>Path to the PubMed package</td>
  </tr>

  <tr>
	 <td><b>ORBACUS_LIBPATH</b></td>
	 <td><i>$ORBACUS_LIBPATH</i></td>
	 <td>Path to the ORBacus CORBA libraries</td>
  </tr>

  <tr>
	 <td><b>ORBACUS_INCLUDE</b></td>
	 <td><i>$ORBACUS_LIBPATH</i></td>
	 <td>Path to the ORBacus CORBA headers</td>
  </tr>
</table>


<br></br>
<a name="ref_TablePath"></a>
<table border=1 cellspacing=0>
<caption>Path to some <i>source</i> and <i>build</i> tree directories
</caption>
  <tr>
	 <th>Macro</th>
	 <th>Source</th>
	 <th>Synopsis</th>
  </tr>

  <tr>
	 <td><b>top_srcdir</b></td>
	 <td><i>@top_srcdir@</i></td>
	 <td>Path to the whole NCBI C++ package</td>
  </tr>

  <tr>
	 <td><b>srcdir</b></td>
	 <td><i>@srcdir@</i></td>
	 <td>Directory in the <i>source tree</i> that corresponds to the
        directory (<i><b>./</b></i>) in the <i>build tree</i> where the
        build is currently going on
    </td>
  </tr>

  <tr>
	 <td><b>includedir</b></td>
	 <td><i>@includedir@</i></td>
	 <td>Top include directory in the <i>source tree</i></td>
  </tr>

  <tr>
	 <td><b>exec_prefix</b></td>
	 <td><i>@exec_prefix@</i></td>
	 <td>Path to the whole <i>build tree</i></td>
  </tr>

  <tr>
	 <td><b>builddir</b></td>
	 <td><i>@builddir@</i></td>
	 <td>Top build directory inside the <i>build tree</i></td>
  </tr>

  <tr>
	 <td><b>incdir</b></td>
	 <td><i>@incdir@</i></td>
	 <td>Top include directory inside the <i>build tree</i></td>
  </tr>

  <tr>
	 <td><b>libdir</b></td>
	 <td><i>@libdir@</i></td>
	 <td>Libraries built inside the <i>build tree</i></td>
  </tr>

  <tr>
	 <td><b>bindir</b></td>
	 <td><i>@bindir@</i></td>
	 <td>Executables built inside the <i>build tree</i></td>
  </tr>

  <tr>
	 <td><b>status_dir</b></td>
	 <td><i>@status_dir@</i></td>
	 <td>Configuration status files</i></td>
  </tr>
</table>


<br></br>
<a name="ref_TableTools"></a>
<table border=1 cellspacing=0>
<caption>Compiler, Linker, and other development Tools</caption>
  <tr>
	 <th>Macro</th>
	 <th><a href="config.html#ref_TableToolsAndFlags">Source</a></th>
	 <th><a href="config.html#ref_StdBuildRules">Synopsis</a></th>
  </tr>

  <tr>
	 <td><b>CC</b></td>
	 <td><i>$CC</i></td>
	 <td>C compiler</td>
  </tr>

  <tr>
	 <td><b>CXX</b></td>
	 <td><i>$CXX</i></td>
	 <td>C++ compiler</td>
  </tr>

  <tr>
	 <td><b>LINK</b></td>
	 <td><i>$CXX</i></td>
	 <td>Linker (C++-aware)</td>
  </tr>

  <tr>
	 <td><b>CPP</b></td>
	 <td><i>$CPP</i></td>
	 <td>C preprocessor</td>
  </tr>

  <tr>
	 <td><b>CXXCPP</b></td>
	 <td><i>$CXXCPP</i></td>
	 <td>C++ preprocessor</td>
  </tr>

  <tr>
	 <td><b>AR</b></td>
	 <td><i>$AR</i></td>
	 <td>Library archiver</td>
  </tr>

  <tr>
	 <td><b>STRIP</b></td>
	 <td><i>$STRIP</i></td>
	 <td>Tool to strip symbolic info from binaries</td>
  </tr>

  <tr>
	 <td><b>RM</b></td>
	 <td><i>rm -f</i></td>
	 <td>Remove file(s)</td>
  </tr>

  <tr>
	 <td><b>RMDIR</b></td>
	 <td><i>rm -rf</i></td>
	 <td>Remove file(s) and directory(ies) recursively</td>
  </tr>

  <tr>
	 <td><b>COPY</b></td>
	 <td><i>cp -p</i></td>
	 <td>Copy file (preserving the modification time)</td>
  </tr>

  <tr>
	 <td><b>BINCOPY</b></td>
	 <td><i>@BINCOPY@</i></td>
	 <td>Copy a library or an executable -- but only if it was changed</td>
  </tr>

  <tr>
     <td><b>LN_S</b></td>
	 <td><i>@LN_S</i></td>
	 <td>Make a symbolic link if possible; otherwise, hard-link or copy</td>
  <tr>
</table>



<p>
<br>
<a name="ref_MakeProjLib"></a>
<h3><i>Customized makefile to build a library</i></h3>

Here is an example of a <i>customized makefile</i> to build
library <i><b>libxmylib.a</b></i> from two source files
<i><b>xmy_src1.cpp</b></i> and <i><b>xmy_src2.c</b></i>, and one
pre-compiled object file <i><b>some_obj1.o</b></i>.
To make the example even more realistic, we assume that the said
source files include headers from the NCBI C Toolkit.<pre>
File Makefile.xmylib.lib:

LIB      = xmylib
LIBOBJ   = xmy_src1 xmy_src2
LOBJ     = some_obj1
REQUIRES = xrequirement
CFLAGS   = $(ORIG_CFLAGS)   -abc -DFOOBAR_NOT_CPLUSPLUS
CXXFLAGS = $(ORIG_CXXFLAGS) -xyz
CPPFLAGS = $(ORIG_CPPFLAGS) -UFOO -DP1_PROJECT -I$(NCBI_C_INCLUDE)</pre>

<ul>
  <li> Skip building this library if <tt>xrequirement</tt>
       (<a href="#ref_Packages">an optional package or project</a>)
       is disabled or unavailable
  <li> Compile <i><b>xmy_src1.cpp</b></i> using the C++ compiler
       <b>$(CXX)</b> with the flags <b>$(CXXFLAGS) $(CPPFLAGS)</b>
       (which are the original C++ and preprocessor flags,
       <b>$(ORIG_*FLAGS)</b>, plus some additional flags specified by
       the user)
  <li> Compile <i><b>xmy_src2.c</b></i> using the C compiler <b>CC</b>
       with the flags <b>$(CFLAGS) $(CPPFLAGS)</b> (which are the
       original C and preprocessor flags, <b>$(ORIG_*FLAGS)</b>,
       plus some additional flags specified by the user)
  <li> Using <b>$(AR)</b> and <b>$(RANLIB)</b> [<b>$(LINK_DLL)</b> if
       building a shared library], compose the
       library <i><b>libxmylib.a</b></i> [<i><b>libxmylib.so</b></i>]
       from the resultant object files, plus the pre-compiled object file
       <i><b>some_obj1.o</b></i>.
  <li> Copy <i><b>libxmylib.*</b></i> to the
       top-level <b><i>lib/</i></b> directory of the
       <i>build tree</i> (for the later use by other projects)
</ul>

This <i>customized makefile</i> should be referred to as
<i><b>xmylib</b></i> in the <b>LIB_PROJ</b> macro of the relevant
<a href="#ref_MakeMeta"><i>meta-makefile</i></a>. As usual,
<a href="#ref_MakeProjMk"><i>Makefile.mk</i></a> will be
implicitly included.

<p>
This <i>customized makefile</i> can be used to build both <i>static</i>
and <a href="config.html#ref_DLL"><i>dynamic (DLL)</i></a> versions of
the library. <br>
To encourage its build as a <i>DLL</i> on the capable
platforms, you can explicitly specify:
<pre>LIB_OR_DLL = dll</pre>
or
<pre>LIB_OR_DLL = both</pre>
Conversely, if you want the library be always built as <i>static</i>, specify:
<pre>LIB_OR_DLL = lib</pre>


<p>
<br>
<a name="ref_MakeProjApp"></a>
<h3><i>Customized makefile to build an application</i></h3>

Here is an example of a <i>customized makefile</i> to build the
application <i><b>my_exe</b></i> from three source files,
<i><b>my_main.cpp</b></i>, <i><b>my_src1.cpp</b></i>,
and <i><b>my_src2.c</b></i>.
To make the example even more realistic, we assume that the said
source files include headers from the NCBI SSS DB packages,
and the target executable uses the NCBI C++ libraries
<a href="#ref_MakeProjLib"><i><b>libxmylib.*</b></i></a> and
<i><b>libxncbi.*</b></i>, plus
NCBI SSS DB, SYBASE, and system network libraries.  We assume further
that the user would prefer to link statically against libxmylib if
building the toolkit as both shared and static libraries
(<i><b>configure --with-dll --with-static ...</b></i>), but is fine
with a shared libxncbi.
<pre>
File Makefile.my_exe.app:

APP      = my_exe
OBJ      = my_main my_src1 my_src2
LIB      = xmylib$(STATIC) xncbi
REQUIRES = xrequirement
CPPFLAGS = $(ORIG_CPPFLAGS) $(NCBI_SSSDB_INCLUDE)
LIBS     = $(NCBI_SSSDB_LIBS) $(SYBASE_LIBS) $(NETWORK_LIBS) $(ORIG_LIBS)</pre>

<ul>
  <li> Skip building this library if xrequirement
       (<a href="#ref_Packages">an optional package or project</a>)
       is disabled or unavailable
  <li> Compile <i><b>my_main.cpp</b></i> and <i><b>my_src1.cpp</b></i>
    using the C++ compiler <b>$(CXX)</b> with the flags <b>$(CPPFLAGS)</b>
    (<a href="#ref_Note1">*</a>)
  <li> Compile <i><b>my_src2.c</b></i> using the C compiler
    <b>$(CC)</b> with the flags <b>$(CPPFLAGS)</b>
    (<a href="#ref_Note1">*</a>)
  <li> Using <b>$(CXX)</b> as a linker, build an executable
    <i><b>my_exe</b></i> from the object files
    <b><i>my_main.o, my_src1.o, my_src2.o</i></b>, NCBI C++ Toolkit libraries
    <a href="#ref_MakeProjLib"><i><b>libxmylib.a</b></i></a> and
    <i><b>libxncbi.*</b></i>, and NCBI SSS DB, SYBASE, and system
    network libraries (<a href="#ref_Note1">*</a>)
  <li> Copy the application to the top-level <b><i>bin/</i></b> directory of
    the <i>build tree</i> (for later use by other projects)
</ul>

<a name="ref_Note1"></a>
<i><b>(*)</b></i>
Since we did not redefine <b>CFLAGS</b>, <b>CXXFLAGS</b>, or <b>LDFLAGS</b>,
their default values <b>ORIG_*FLAGS</b> (obtained during the <i>build
tree</i> <a href="config.html#ref_Configure">configuration</a>) will be
<a href="config.html#ref_StdBuildRules">used</a>.

<p>
This <i>customized makefile</i> should be referred to as
<i><b>my_exe</b></i> in the <b>APP_PROJ</b> macro of the relevant
<a href="#ref_MakeMeta"><i>meta-makefile</i></a>. Note also, that the
<a href="#ref_MakeProjMk"><i>Makefile.mk</i></a> will be implicitly
included.


<p>
<br>
<a name="ref_MakeProjUsr"></a>
<h3><i>User-defined makefile to build... whatever</i></h3>

<p>
In some cases, we may need more functionality than the <i>customized
makefiles</i> (designed to build libraries and applications) can provide.

<p>
So, if you have a "regular" non-customized <i>user makefile</i>, and
you want to make from it, then you must enlist this <i>user makefile</i>
in the <b>USR_PROJ</b> macro of the project's
<a href="#ref_MakeMeta"><i>meta-makefile</i></a>.

<p>
Now, during the project build (and before any <i>customized makefiles</i>
are processed), your makefile will be called with one of the 
<a href="#ref_MakeProjTarget">standard make targets</a> from the
project's build directory. Additionally, the
<a href="#ref_TablePath"><b>builddir</b></a> and
<a href="#ref_TablePath"><b>srcdir</b></a> macros will be passed
to your makefile (via the <b>make</b> command line).

<p>
In most cases, it is necessary to know your "working environment";
<i>i.e.</i>, tools, flags and paths (those that you use in your
<i>customized makefiles</i>).  This can be easily done by including <a
href="#ref_MakeProjMk"><i>Makefile.mk</i></a> in your makefile.

<p>
Shown below is a real-life example of a <i>user makefile</i>:
<ul>
  <li> build an auxiliary application using the <i>customized makefile</i>
    <i><b>Makefile.hc_gen_obj.app</b></i> (this part is a tricky one...)
  <li> use the resultant application <i><b>$(bindir)/hc_gen_obj</b></i>
    to generate the source and header files <i><b>humchrom_dat.[ch]</b></i>
    from the data file <i><b>humchrom.dat</b></i>
  <li> use the script <i><b>$(top_srcdir)/scripts/if_diff.sh</b></i>
    to replace the previous copies (if any) of humchrom_dat.[ch] with
    the newly generated versions if and only if the new versions are
    different (or there were no old versions).
</ul>

And, of course, it provides build rules for all the
<a href="#ref_MakeProjTarget">standard make targets</a>.

<pre>
File $(top_srcdir)/src/internal/humchrom/Makefile.hc_gen_obj:

# Build a code generator for hard-coding the chrom data into an obj file
# Generate header and source "humchrom_dat.[ch]" from data file "humchrom.dat"
# Deploy the header to the compiler-specific include dir
# Compile source code
#################################

include $(builddir)/Makefile.mk

BUILD__HC_GEN_OBJ = $(MAKE) -f "$(builddir)/Makefile.app.tmpl" \
srcdir="$(srcdir)" TMPL="hc_gen_obj" $(MFLAGS)


all_r: all
all: build_hc_gen_obj humchrom_dat.dep

purge_r: purge
purge:   x_clean
	$(BUILD__HC_GEN_OBJ) purge

clean_r: clean
clean:   x_clean
	$(BUILD__HC_GEN_OBJ) clean
x_clean:
	-rm -f humchrom_dat.h
	-rm -f humchrom_dat.c

build_hc_gen_obj:
	$(BUILD__HC_GEN_OBJ) all

humchrom_dat.dep: $(srcdir)/data/humchrom.dat $(bindir)/hc_gen_obj
	-cp -p humchrom_dat.c humchrom_dat.save.c
	$(bindir)/hc_gen_obj -d $(srcdir)/data/humchrom.dat -f humchrom_dat
	$(top_srcdir)/scripts/if_diff.sh "mv" humchrom_dat.h $(incdir)/humchrom_dat.h
	-rm humchrom_dat.h
	$(top_srcdir)/scripts/if_diff.sh "mv" humchrom_dat.c humchrom_dat.save.c
	mv humchrom_dat.save.c humchrom_dat.c
	touch humchrom_dat.dep
</pre>


<p>
<br>
<a name="ref_MakeProjTarget"></a>
<h2>Standard build targets (<b>all, clean, purge</b>) in makefiles</h2>

<ul>
  <li> <b>all</b> -- compile the object modules specified in the
  <i>"$(OBJ)"</i> macro, and use them to build the library
  <i>"$(LIB)"</i> or the application <i>"$(APP)"</i>; then copy the
  resultant lib/app to the <a
  href="#ref_TablePath"><b>libdir/bindir</b></a> directory,
  respectively
  <li> <b>clean</b> -- remove all object modules and libs/apps
  that have been built by <b>all</b>
  <li> <b>purge</b> -- do <b>clean</b>, and then remove the copy
  of the libs/apps from the <a
  href="#ref_TablePath"><b>libdir/bindir</b></a> directory.
</ul>

Naturally, the <i>customized makefiles</i> will not distinguish
between recursive (<b>all_r, clean_r, purge_r</b>) and
non-recursive (<b>all, clean, purge</b>) targets -- because the
recursion and multiple build is entirely up to the <a
href="#ref_MakeMeta"><i>meta-makefiles</i></a>.


<p>
<br>
<a name="ref_Packages"></a>
<h2>List of optional packages, features and projects</h2>
Here are the keywords you can list in REQUIRES in a customized
<a href="#ref_MakeProjApp">application</a> or
<a href="#ref_MakeProjLib">library</a> makefile, along with the corresponding
<a href="config.html#ref_ProhibitPackage">configure options</a>:

<p>

<table border=1 cellspacing=0>
 <tr>
  <th>Keyword</th>
  <th align=left>Optional...</th>
  <th>Configure option(s)</th>
 </tr>

 <tr>
  <th> </th>
  <th>...package</th>
  <th></th>
 </tr>

 <tr>
  <td><b>Sybase</b></td>
  <td>Sybase libraries</td>
  <td><i>--without-sybase, --with-sybase-local(=DIR)</i></td>
 </tr>

 <tr>
  <td><b>Fast-CGI</b></td>
  <td>Fast-CGI library</td>
  <td><i>--without-fastcgi</i></td>
 </tr>

 <tr>
  <td><b>wxWindows</b></td>
  <td>wxWindows</td>
  <td><i>--without-wxwin, --with-wxwin=DIR</i></td>
 </tr>

 <tr>
  <td><b>C-Toolkit</b></td>
  <td>NCBI C Toolkit</td>
  <td><i>--without-ncbi-c</i></td>
 </tr>


 <tr>
  <td><b>SSSDB</b></td>
  <td>NCBI SSS DB library</td>
  <td><i>--without-sssdb, --without-sss</i></td>
 </tr>

 <tr>
  <td><b>SSSUTILS</b></td>
  <td>NCBI SSS UTILS library</td>
  <td><i>--without-sssutils, --without-sss</i></td>
 </tr>

 <tr>
  <td><b>GEO</b></td>
  <td>NCBI GEO libraries</td>
  <td><i>--without-geo</i></td>
 <tr>

 <tr>
  <td><b>SP</b></td>
  <td>SP libraries</td>
  <td><i>--without-sp</i></td>
 <tr>

 <tr>
  <td><b>PubMed</b></td>
  <td>NCBI PubMed libraries</td>
  <td><i>--without-pubmed</i></td>
 <tr>

 <tr>
  <td><b>ORBacus</b></td>
  <td>ORBacus CORBA</td>
  <td><i>--without-orbacus, --with-orbacus=DIR</i></td>
 </tr>

 <tr>
  <th> </th>
  <th>...feature</th>
  <th> </th>
 </tr>

 <tr>
  <td><b>MT</b></td>
  <td>multithreading is available</td>
  <td><i>--with-mt</i></td>
 </tr>

 <tr>
  <th> </th>
  <th>...project(s)</th>
  <th> </th>
 </tr>

 <tr>
  <td><b>serial</b></td>
  <td>ASN.1/XML serialization library and datatool</td>
  <td><i>--without-serial</i></td>
 </tr>

 <tr>
  <td><b>ctools</b></td>
  <td>projects based on the NCBI C toolkit</td>
  <td><i>--without-ctools</i></td>
 </tr>

 <tr>
  <td><b>gui</b></td>
  <td>projects that use the wxWindows GUI package</td>
  <td><i>--without-gui</i></td>
 </tr>

 <tr>
  <td><b>objects</b></td>
  <td>libraries to serialize ASN.1/XML objects</td>
  <td><i>--with-objects</i></td>
 </tr>

 <tr>
  <td><b>app</b></td>
  <td>standalone applications like ID1_FETCH</td>
  <td><i>--with-app</i></td>
 </tr>

 <tr>
  <td><b>internal</b></td>
  <td>all internal projects</td>
  <td><i>--with-internal</i></td>
 </tr>

 <tr>
  <td><b>local_lbsm</b></td>
  <td>IPC with locally running LBSMD</td>
  <td><i>--without-local-lbsm</i></td>
 </tr>
</table>


<p>
<br>
<a name="ref_Outside"></a>
<h2>Developing a project (lib, application) outside of the NCBI C++ tree</h2>

NOTE:  in NCBI, you can use the scripts located in the pre-built NCBI C++
toolkit directory <b><i>$NCBI/c++/scripts/.</i></b>

<p>
<br>
<a name="ref_OutsideImport"></a>
<h3><b><i>scripts/import_project.sh &lt;cvs_tree_path&gt; [builddir]</i></b></h3>

<p>
In many cases, you work on your own project which <b>is a part</b> of the
NCBI C++ tree, and you do not want to check out, update and rebuild
the whole NCBI C++ tree. -- Instead, you just want to use headers and
libraries of the pre-built NCBI C++ Toolkit to build your project.

<p>
The shell script <b><i>import_project.sh</i></b> will checkout
your project's source and include directories from CVS, and it will create
a (temporary) makefile based on the project's <i>customized makefile</i>.
This makefile will also contain a reference to the pre-built NCBI C++ toolkit.

<p>
For <a href="new_project.import.session">EXAMPLE</a>:
<br>&nbsp;&nbsp;&nbsp;
<b>
   import_project.sh hello
</b>
<br>
will check out the whole <b>hello</b> demo project from the NCBI C++ tree
(<b><i>$CVSROOT/internal/c++/src/hello/</i></b>), and create a
makefile <b><i>Makefile.hello_app</i></b> that uses the project's
<i>customized makefile</i> <b><i>Makefile.hello.app</i></b>.
Now you can just go to the created working directory
<b><i>internal/c++/src/hello/</i></b> and build the demo application
<b>hello.cgi</b> using:
<br>&nbsp;&nbsp;&nbsp;
<b>
   make -f Makefile.hello_app
</b>

<p>
<br>
<a name="ref_OutsideCreate"></a>
<h3><b><i>scripts/new_project.sh &lt;name&gt; lib|app [builddir]</i></b> </h3>

<p>
This script will help you to write a makefile for a new, from-scratch
project which uses the NCBI C++ toolkit (and probably the C toolkit as
well).  You will just have to slightly edit the resultant makefile to:
<ul>
  <li> specify the name of your library (or application)
  <li> specify the list of source files going to it
  <li> modify some preprocessor, compiler, etc.  flags, if needed
  <li> modify the set of additional libraries to link to it
       (if it's an application), if needed
</ul>


<p>
For <a href="new_project.create.session"> EXAMPLE</a>:

<br> &nbsp;&nbsp;&nbsp;
<b>
   new_project.sh foo lib
</b>
<br>
will create a model makefile <b><i>Makefile.foo_lib</i></b> to build
a library using tools and flags hard-coded in
<b><i>$NCBI/c++/Debug/build/Makefile.mk</i></b>,
and headers from <b><i>$NCBI/c++/include/</i></b>.
Now, after specifying the library name, list of source files, etc.,
you can just go to the created working directory
<b><i>foo/</i></b> and build your library using:
<br> &nbsp;&nbsp;&nbsp;
<b>
   make -f Makefile.foo_lib
</b>

<br>
You can easily change the active version of NCBI C++ toolkit
by manually setting variable <b>$(builddir)</b> in
<b><i>Makefile.foo_lib</i></b> to the desired toolkit path, e.g.:
<br> &nbsp;&nbsp;&nbsp;
<b><i>builddir = $(NCBI)/c++/GCC-Release/build</i></b>


<p>
<br>
<a name="ref_OutsideHello"></a>
<h3><b><i>scripts/hello.sh</i></b> </h3>

<p>
This script will:
<ul>
  <li> retrieve the demo CGI application project HELLO
  <li> create a standalone makefile to build it
  <li> build HELLO application using this makefile
  <li> run HELLO application
</ul>
It will produce the file <b><i>hello.html</i></b> containing a model
HTTP response. For more info on the HELLO CGI project see
in section
<i><a href="tools.html">NCBI C++ tools and applications</a> /
<a href="tools/hello/hello.html">HELLO.CGI -- a demo CGI application (NCBI C++)</a></i>.


<br></br>
<hr>
<table border=0 width="100%" cellspacing=0>
  <tr>
    <td><address><a href="mailto:vakatov@ncbi.nlm.nih.gov">Denis Vakatov</a></address></td>
<!-- <td align=center><i>$Revision$</i></td> -->
    <td align=right>($Date$)</td></tr>
</table>

<!--#include virtual="./ssi/footer.shtml" -->
