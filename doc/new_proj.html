<!-- $Id$ -->
<!--#set var="TITLE" value="NCBI C++ Toolkit:  New Projects" -->
<!--#set var="HEADING" value="Starting New Projects" -->
<!--#set var="DOCROOT" value="." -->
<!--#include virtual="./ssi/header.shtml" -->

<p></p>
<a name="ref_Checkout"></a>
The following assumes that you have all of the necessary Toolkit components.
If you need to obtain part or all of the Toolkit's source tree, consult the
<a href="download.html#ref_FTP">FTP instructions</a> or <a href="cvs.html">CVS checkout
procedures</a>.   Please visit the <a href="get_started.html"><i>Getting Started</i></a> page for a broad
overview of the NCBI C++ Toolkit and its use.


<ul>

  <li> <a href="#ref_ProjectStructure">
    New Projects:  Location and File Structure</a>
  <li> <a href="#ref_Structure">
    Projects and the Toolkit's CVS Tree Structure</a>
  <li> <a href="#ref_Create">
    Creating a CVS directory for a new C++ project</a>
  <li><a href="#ref_NewModule">
    Starting New Modules</a>
  <li> <a href="#ref_Makefile">
    Project makefiles and sub-projects</a>
  <ul>
    <li> <a href="#ref_MakeMeta">
    <i>Meta-makefiles</i> (to provide multiple and/or recursive builds)</a>
    <li> <a href="#ref_Expendable">
      <i>Expendable</i> projects</a>
    <li> <a href="#ref_MakeProj">
    Project makefiles</a>
    <ul>
      <li> <a href="#ref_MakeProjMk">
        Configured tools, flags and paths for the whole build tree
        (<b><i>Makefile.mk</i></b>)</a>
      <li> <a href="#ref_MakeProjLib">
        Customized makefile to build a library</a>
      <li> <a href="#ref_MakeProjApp">
        Customized makefile to build an application</a>
      <li> <a href="#ref_MakeProjUsr">
        User-defined makefile to build... whatever</a>
      <li> <a href="#ref_MakeProjTarget">
        Standard build targets(<b>all, clean, purge</b>) in makefiles</a>
      <li> <a href="#ref_Packages">
        List of optional packages, features and projects</a>
    </ul>
  </ul>
  <li> <a href="#ref_Outside">
    New Project (lib, application) Development Aids</a>
    <ul>
      <li> <a href="#ref_OutsideImport">
           <b><tt>import_project.sh</tt></b> -- prepare a new project that lives in an NCBI C++ subtree
           </a>
      <li> <a href="#ref_OutsideCreate">
           <b><tt>new_project.sh</tt></b> -- prepare a new project that only links to the NCBI C++ tree
           </a>
      <li> <a href="#ref_OutsideHello">
           <b><tt>hello.sh</tt></b> -- a simple demo CGI application HELLO
           </a>
    </ul>
  <li> <a href="mkfiles.html">
    A real-life example of the NCBI C++ makefile hierarchy
   (project <tt><b>corelib/</b></tt>)</a>
</ul>

<hr>

<p></p>
<a name="ref_ProjectStructure"></a>
<h2> New Projects:  Location and File Structure </h2>
Before creating the new project, you must decide if you need to work within a C++ source tree
(or subtree) or merely need to link with the Toolkit libraries and work in a separate directory.
The later case is simpler and allows you to work independently in a private directory, but
it is not an option if the Toolkit source, headers, or <i>Makefiles</i> are to be directly
used or altered during the new project's development.

<ul>
    <li><a href="programming_manual/inside_tree.html">Work in the Full Toolkit Source Tree</a></li>
    <li><a href="programming_manual/sub_tree.html">Work in a Toolkit Subtree</a></li>
    <li><a href="programming_manual/outside_tree.html">Work in a Separate Directory</a></li>
</ul>

<p></p>
<p>
Regardless of where you build your new project, it must adopt and maintain
a particular structure.  Specifically,
each project's <a href="lxr/source/src/"><i>source tree</i></a> relative to $NCBI<tt>/c++</tt>
should contain:
<ul>
    <li> <b><i>include/*.hpp</i></b> --  project's public headers
    <li> <b><i>src/*.{cpp, hpp}</i></b> --  project's source files and private headers
    <li> <b><i>src/Makefile.in</i></b> -- a <a href="new_proj.html#ref_MakeMeta"><i>meta-makefile</i></a>
          template to specify which local projects (described in <i>Makefile.*.in</i>)
          and sub-projects (located in the project subdirectories) must be built
    <li> <b><i>src/Makefile.&lt;project_name&gt;.{lib, app}[.in]</i></b> -- one or more <i>customized makefiles</i> to build a library or an application
    <li> <b><i>src/Makefile.*[.in]</i></b> -- "free style" makefiles (if any)
    <li> sub-project directories (if any)
</ul>

<!--
<a name="ref_Basics"></a>
<h4> NCBI C++ Toolkit Basics</h4>

<ul>
  <li>
  <a href="programming_manual/applic.html">Writing a simple application project</a></li>

  <li>
  <a href="programming_manual/argdescr.html">Using the CArgDescriptions class</a></li>

  <li>
  <a href="programming_manual/registry.html">The CNcbiRegistry class</a></li>

  <li>
  <a href="programming_manual/diag.html">Diagnostic Streams</a></li>

  <li>
  <a href="programming_manual/exceptions.html">Exception handling in the NCBI C++ Toolkit</a></li>

  <li>
  <a href="programming_manual/cref.html">Smart pointers: <i>auto_ptr&lt;></i> and <i>CRef&lt;></i> template classes</a></li>
</ul>
-->

<hr>

<p>
<br>
<a name="ref_Structure"></a>
<h2>Projects and the Toolkit's CVS Tree Structure</h2>

<font size=-1>
(For the overall NCBI C++ CVS tree structure see
<a href="config.html#ref_Source">the configuration page</a>; see the
<a href="download.html">download page</a> for source acquisition information
and <a href="cvs.html">CVS details</a>.)
</font>

<p>
Even if you work outside of the C++ tree, it is necessary to understand
how the Toolkit uses <i>makefiles</i>, <i>meta-makefiles</i>, and <i>makefile templates</i>,
and the CVS tree structure.

<p>
The standard CVS location for NCBI C++/STL projects is
<i><b>$CVSROOT/internal/c++/</b></i>. Public header files
(<i>*.hpp, *.inl</i>) of all projects are located below
the <i><b>$CVSROOT/internal/c++/include/</b></i> directory.
<i><b>$CVSROOT/internal/c++/src/</b></i> directory has just the same
hierarchy of subdirectories as <i><b>.../include/</b></i>, and its
very top level contains:

<ul>
  <li> Templates of generic makefiles (<b><i>Makefile.*.in</i></b>):
    <ul>
      <li> <b><i>Makefile.in</i></b> -- makefile to perform a recursive
        build in all project subdirectories
      <li> <b><i>Makefile.meta.in</i></b> -- included by all makefiles
        that provide both local and recursive builds
      <li> <b><i>Makefile.lib.in</i></b> -- included by all makefiles
        that perform a "standard" library build, when building only
        static libraries.
      <li> <b><i>Makefile.dll.in</i></b> -- included by all makefiles
        that perform a "standard" library build, when building only
        shared libraries.
      <li> <b><i>Makefile.both.in</i></b> -- included by all makefiles
        that perform a "standard" library build, when building both
        static and shared libraries.
      <li> <b><i>Makefile.lib.tmpl.in</i></b> -- serves as a template
        for the project <i>customized makefiles</i>
        (<b><i>Makefile.*.lib[.in]</i></b>) that perform a "standard"
        library build
      <li> <b><i>Makefile.app.in</i></b> -- included by all makefiles
        that perform a "standard" application build
      <li> <b><i>Makefile.lib.tmpl.in</i></b> -- serves as a template
        for the project <i>customized makefiles</i>
        (<b><i>Makefile.*.app[.in]</i></b>) that perform a "standard"
        application build
	  <li> <b><i>Makefile.rules.in,
        Makefile.rules_with_autodep.in</i></b> -- instructions for
        building object files; included by most other makefiles
	  <li> <b><i>Makefile.mk.in</i></b> -- included by all makefiles;
        sets a lot of configuration variables
    </ul>

  <p>
  <li> The contents of each project are detailed <a href="#ref_ProjectStructure">above</a>.
      If your project is to become part of the Toolkit tree, you need to ensure that
      all <i>makefiles</i> and <i>Makefile*.in</i> templates are available so the
      master <i>makefiles</i> can properly
      configure and build it (see <a href="new_proj.html#ref_Makefile">"Project Makefiles and Sub-Projects"</a> below).
      You will also need to <a href="#ref_Create">prepare CVS directories</a>
      to hold the new source and header files.</li>

</ul>


<br>
<a name="ref_Create"></a>
<h2>Creating source and include CVS dirs for a new C++ project</h2>

<p>
To create your new project (<i>e.g.</i>, "bar_proj") directories in the
NCBI C++ CVS tree to directory <b><i>foo/c++/</i></b>):

<pre>
    cd foo/c++/include && mkdir bar_proj && cvs add -m "Project Bar" bar_proj
    cd foo/c++/src     && mkdir bar_proj && cvs add -m "Project Bar" bar_proj
</pre>

Now you can <a href="new_mod.html">add</a> and edit your project C++
files in there.

<p>
NOTE: remember to add this new project directory to the <i>$(SUB_PROJ)</i>
list of the upper level <a href="#ref_MakeMeta"><i>meta-makefile</i></a>
configurable template (<i>e.g.</i>, for this particular case, to
<b><i>foo/c++/src/Makefile.in</i></b>).


<p>
<br>
<a name="ref_NewModule"></a>
<h2> Starting New Modules </h2>

<p></p>
Projects consist of modules, which are most often a pair of source (*.cpp)
and header (*.hpp) files.  To help create new modules, template source &amp; header files
may be used, or you may modify the sample code generated by the script
<a href="scripts_usage.html#ref_New_ProjectUsage"><tt>new_project.sh</tt></a>.
See the <a href="new_mod.html">new modules page</a> for details.


<p>
<br>
<a name="ref_Makefile"></a>
<h2>Project makefiles and sub-projects</h2>

<a name="ref_MakeMeta"></a>
<h3>Meta-makefiles (to provide multiple and/or recursive builds)</h3>

All projects from the NCBI C++ hierarchy are tied together by a set of
<i>meta-makefiles</i> which are present in all project source
directories and provide a uniform and easy way to perform both local
and recursive builds.

A typical <i>meta-makefile</i> template(e.g. <i><b>Makefile.in</b></i> in your
<b><i>foo/c++/src/bar_proj/</i></b> dir) looks like that:
<pre>
    # Makefile.bar_u1, Makefile.bar_u1 ...
    USR_PROJ = bar_u1 bar_u2 ...
    # Makefile.bar_l1.lib, Makefile.bar_l1.lib ...
    LIB_PROJ = bar_l1 bar_l2 ...
    # Makefile.bar_a1.app, Makefile.bar_a1.app ...
    APP_PROJ = bar_a1 bar_l2 ...
    SUB_PROJ = app sub_proj1 sub_proj2
    srcdir = @srcdir@
    include @builddir@/Makefile.meta
</pre>

The mandatory <i>"srcdir = @srcdir@ ; include @builddir@/Makefile.meta"</i>
provides build rules for the following standard targets:
<ul>
  <li> <a href="#ref_MakeProjTarget"><b>all</b></a>:
    <ul>
		<li> run <i>"make  -f {Makefile.*} all"</i> for the makefiles
		  with the suffixes listed in macro <b>USR_PROJ</b>: <pre>
make -f Makefile.bar_u1 all
make -f Makefile.bar_u2 all
...... </pre>
		<li> build libraries using attributes defined in the
		  <i>customized makefiles</i> <b>Makefile.*.lib</b>
		  with the suffixes listed in macro <b>LIB_PROJ</b>
		<li> build application(s) using attributes defined in the
		  <i>customized makefiles</i> <b>Makefile.*.app</b> with the
		  suffixes listed in macro <b>APP_PROJ</b>
    </ul>
  <li> <a href="#ref_MakeProjTarget"><b>all_r</b></a> --
	 first make target <b>all</b>, then run <i>"make all_r"</i>
	 in all subdirectories enlisted in <i>$(SUB_PROJ)</i>: <pre>
cd bar_test       &&  make -f Makefile all_r
cd bar_sub_proj1  &&  make -f Makefile all_r
...... </pre>
  <li> <a href="#ref_MakeProjTarget"><b>clean, clean_r</b></a> --
	 run just the same makefiles but with targets <b>clean</b> and
	 <b>clean_r</b> (rather than <b>all</b> and <b>all_r</b>), respectively
  <li> <a href="#ref_MakeProjTarget"><b>purge, purge_r</b></a> --
	 .....with targets <b>purge</b> and <b>purge_r</b>, respectively
</ul>

<p>
<br>
<a name="ref_Expendable"></a>
<h3>Expendable projects</h3>
By default, failure of any project will cause make to exit immediately.
Although this behavior can save a lot of time, it is not always
desirable.  One way to avoid it is to run <tt>make -k</tt> rather than
<tt>make</tt>, but then major problems affecting a large portion of
the build will still waste a lot of time.

<p>
Consequently, the toolkit's build system supports an alternative
approach: <a href="#ref_MakeMeta"><i>meta-makefiles</i></a> can define
<i>expendable</i> projects which should be built if possible but are
allowed to fail without interrupting the build.  The way to do this is
to list such projects in <b>EXPENDABLE_*_PROJ</b> rather than <b>*_PROJ</b>.


<p>
<br>
<a name="ref_MakeProj"></a>
<h3>Project makefiles</h3>

Just like the configurable template <b><i>Makefile.meta.in</i></b> is
used to ease and standardize the writing of <a
href="#ref_MakeMeta"><i>meta-makefiles</i></a>, so there are templates
to help in the creation of "regular" project makefiles to build a
library or an application. These auxiliary template makefiles are
<b><i>Makefile.mk.in</i></b>, <b><i>Makefile.lib.in</i></b>,
<b><i>Makefile.dll.in</i></b>, <b><i>Makefile.both.in</i></b>,
<b><i>Makefile.app.in</i></b>, <b><i>Makefile.lib.tmpl.in</i></b>,
<b><i>Makefile.app.tmpl.in</i></b>, <b><i>Makefile.rules.in</i></b>,
and <b><i>Makefile.rules_with_autodep.in</i></b>.  The
<b><i>configure</i></b>'d versions of them get put at the very top of
a <i>build tree</i>.


<p>
<br>
<a name="ref_MakeProjMk"></a>
<h3><i>Configured tools, flags, and paths for the whole build tree (<b>Makefile.mk</b>)</i></h3>

<b><i>Makefile.mk</i></b> is silently included at the very beginning of the
<i>customized makefiles</i> used to build
<a href="#ref_MakeProjLib">libraries</a> and
<a href="#ref_MakeProjApp">applications</a>.

<p>
<b><i>Makefile.mk</i></b> defines the following makefile macros obtained
during the configuration process:

<br></br>
<a name="ref_TableFlags"></a>
<table border=1 cellspacing=0>
<caption>Flags</caption>
  <tr>
	 <th>Macro</th>
	 <th><a href="config.html#ref_TableToolsAndFlags">Source</a></th>
	 <th><a href="config.html#ref_StdBuildRules">Synopsis</a></th>
  </tr>

  <tr>
	 <td><b>CFLAGS</b></td>
	 <td><i>$CFLAGS</i></td>
	 <td>C compiler flags</td>
  </tr>

  <tr>
	 <td><b>FAST_CFLAGS</b></td>
	 <td><i>$FAST_CFLAGS</i></td>
	 <td><a href="#ref_MakeProjMk_FAST">(*)</a>
			 C compiler flags to generate faster code
    </td>
  </tr>

  <tr>
	 <td><b>CXXFLAGS</b></td>
	 <td><i>$CXXFLAGS</i></td>
	 <td>C++ compiler flags</td>
  </tr>

  <tr>
	 <td><b>FAST_CXXFLAGS</b></td>
	 <td><i>$FAST_CXXFLAGS</i></td>
	 <td><a href="#ref_MakeProjMk_FAST">(*)</a>
			 C++ compiler flags to generate faster code</td>
  </tr>

  <tr>
	 <td><b>CPPFLAGS</b></td>
	 <td><i>$CPPFLAGS</i></td>
	 <td>C/C++ preprocessor flags</td>
  </tr>

  <tr>
	 <td><b>LDFLAGS</b></td>
	 <td><i>$LDFLAGS</i></td>
	 <td>Linker flags</td>
  </tr>

  <tr>
     <td><b>STATIC</b></td>
	 <td><i>@STATIC@</i></td>
	 <td>Library suffix to force static linkage (see
	 <a href="#ref_MakeProjApp">below</a>)</td>
  </tr>
</table>

<br></br>
<a name="ref_MakeProjMk_FAST"></a>
(*) The values of user-specified environment variables
    <i>$FAST_CFLAGS, $FAST_CXXFLAGS</i> will substitute the regular
    optimization flag <tt>-O</tt> (or <tt>-O2</tt>, etc.).
    For example, if in the environment:
    <i>$FAST_CXXFLAGS</i><tt>=-fast -speedy</tt> and
    <i>$CXXFLAGS</i>=<tt>-warn -O3 -std</tt>, then in makefile:
    <b>$(FAST_CXXFLAGS)</b><tt>=-warn -fast -speedy -std</tt>.


<br></br>
<a name="ref_TableThirdParty"></a>
<table border=1 cellspacing=0>
<caption>System and third-party packages</caption>
  <tr>
	 <th>Macro</th>
	 <th><a href="config.html#ref_TableLocalization1">Source</a></th>
	 <th>Synopsis</th>
  </tr>

  <tr>
	 <td><b>LIBS</b></td>
	 <td><i>$LIBS</i></td>
	 <td>Default libraries to link with</td>
  </tr>

  <tr>
	 <td><b>THREAD_LIBS</b></td>
	 <td><i>$THREAD_LIBS</i></td>
	 <td>Thread library <i>(system)</i></td>
  </tr>

  <tr>
	 <td><b>NETWORK_LIBS</b></td>
	 <td><i>$NETWORK_LIBS</i></td>
	 <td>Network library <i>(system)</i></td>
  </tr>

  <tr>
	 <td><b>MATH_LIBS</b></td>
	 <td><i>$MATH_LIBS</i></td>
	 <td>Math library <i>(system)</i></td>
  </tr>

  <tr>
	 <td><b>KSTAT_LIBS</b></td>
	 <td><i>$KSTAT_LIBS</i></td>
	 <td>KSTAT library <i>(system)</i></td>
  </tr>

  <tr>
	 <td><b>RPCSVC_LIBS</b></td>
	 <td><i>$RPCSVC_LIBS</i></td>
	 <td>RPCSVC library <i>(system)</i></td>
  </tr>

  <tr>
	 <td><b>SYBASE_INCLUDE</b></td>
	 <td><i>$SYBASE_INCLUDE</i></td>
	 <td>SYBASE headers</td>
  </tr>

  <tr>
	 <td><b>SYBASE_LIBS</b></td>
	 <td><i>$SYBASE_LIBS</i></td>
	 <td>SYBASE libraries</td>
  </tr>

  <tr>
	 <td><b>FASTCGI_INCLUDE</b></td>
	 <td><i>$FASTCGI_INCLUDE</i></td>
	 <td>Fast-CGI headers</td>
  </tr>

  <tr>
	 <td><b>FASTCGI_LIBS</b></td>
	 <td><i>$FASTCGI_LIBS</i></td>
	 <td>Fast-CGI libraries</td>
  </tr>

  <tr>
	 <td><b>NCBI_C_INCLUDE</b></td>
	 <td><i>$NCBI_C_INCLUDE</i></td>
	 <td>NCBI C toolkit headers</td>
  </tr>

  <tr>
	 <td><b>NCBI_C_LIBPATH</b></td>
	 <td><i>$NCBI_C_LIBPATH</i></td>
	 <td>Path to the NCBI C Toolkit libraries</td>
  </tr>

  <tr>
	 <td><b>NCBI_C_ncbi</b></td>
	 <td><i>$NCBI_C_ncbi</i></td>
	 <td>NCBI C CoreLib</td>
  </tr>

  <tr>
	 <td><b>NCBI_SSS_INCLUDE</b></td>
	 <td><i>$NCBI_SSS_INCLUDE</i></td>
	 <td>NCBI SSS headers</td>
  </tr>

  <tr>
	 <td><b>NCBI_SSS_LIBPATH</b></td>
	 <td><i>$NCBI_SSS_LIBPATH</i></td>
	 <td>Path to NCBI SSS libraries</td>
  </tr>

  <tr>
	 <td><b>NCBI_PM_PATH</b></td>
	 <td><i>$NCBI_PM_PATH</i></td>
	 <td>Path to the PubMed package</td>
  </tr>

  <tr>
	 <td><b>ORBACUS_LIBPATH</b></td>
	 <td><i>$ORBACUS_LIBPATH</i></td>
	 <td>Path to the ORBacus CORBA libraries</td>
  </tr>

  <tr>
	 <td><b>ORBACUS_INCLUDE</b></td>
	 <td><i>$ORBACUS_LIBPATH</i></td>
	 <td>Path to the ORBacus CORBA headers</td>
  </tr>
</table>


<br></br>
<a name="ref_TablePath"></a>
<table border=1 cellspacing=0>
<caption>Path to some <i>source</i> and <i>build</i> tree directories
</caption>
  <tr>
	 <th>Macro</th>
	 <th>Source</th>
	 <th>Synopsis</th>
  </tr>

  <tr>
	 <td><b>top_srcdir</b></td>
	 <td><i>@top_srcdir@</i></td>
	 <td>Path to the whole NCBI C++ package</td>
  </tr>

  <tr>
	 <td><b>srcdir</b></td>
	 <td><i>@srcdir@</i></td>
	 <td>Directory in the <i>source tree</i> that corresponds to the
        directory (<i><b>./</b></i>) in the <i>build tree</i> where the
        build is currently going on
    </td>
  </tr>

  <tr>
	 <td><b>includedir</b></td>
	 <td><i>@includedir@</i></td>
	 <td>Top include directory in the <i>source tree</i></td>
  </tr>

  <tr>
	 <td><b>build_root</b></td>
	 <td><i>@build_root@</i></td>
	 <td>Path to the whole <i>build tree</i></td>
  </tr>

  <tr>
	 <td><b>builddir</b></td>
	 <td><i>@builddir@</i></td>
	 <td>Top build directory inside the <i>build tree</i></td>
  </tr>

  <tr>
	 <td><b>incdir</b></td>
	 <td><i>@incdir@</i></td>
	 <td>Top include directory inside the <i>build tree</i></td>
  </tr>

  <tr>
	 <td><b>libdir</b></td>
	 <td><i>@libdir@</i></td>
	 <td>Libraries built inside the <i>build tree</i></td>
  </tr>

  <tr>
	 <td><b>bindir</b></td>
	 <td><i>@bindir@</i></td>
	 <td>Executables built inside the <i>build tree</i></td>
  </tr>

  <tr>
	 <td><b>status_dir</b></td>
	 <td><i>@status_dir@</i></td>
	 <td>Configuration status files</i></td>
  </tr>
</table>


<br></br>
<a name="ref_TableTools"></a>
<table border=1 cellspacing=0>
<caption>Compiler, Linker, and other development Tools</caption>
  <tr>
	 <th>Macro</th>
	 <th><a href="config.html#ref_TableToolsAndFlags">Source</a></th>
	 <th><a href="config.html#ref_StdBuildRules">Synopsis</a></th>
  </tr>

  <tr>
	 <td><b>CC</b></td>
	 <td><i>$CC</i></td>
	 <td>C compiler</td>
  </tr>

  <tr>
	 <td><b>CXX</b></td>
	 <td><i>$CXX</i></td>
	 <td>C++ compiler</td>
  </tr>

  <tr>
	 <td><b>LINK</b></td>
	 <td><i>$CXX</i></td>
	 <td>Linker (C++-aware)</td>
  </tr>

  <tr>
	 <td><b>CPP</b></td>
	 <td><i>$CPP</i></td>
	 <td>C preprocessor</td>
  </tr>

  <tr>
	 <td><b>CXXCPP</b></td>
	 <td><i>$CXXCPP</i></td>
	 <td>C++ preprocessor</td>
  </tr>

  <tr>
	 <td><b>AR</b></td>
	 <td><i>$AR</i></td>
	 <td>Library archiver</td>
  </tr>

  <tr>
	 <td><b>STRIP</b></td>
	 <td><i>$STRIP</i></td>
	 <td>Tool to strip symbolic info from binaries</td>
  </tr>

  <tr>
	 <td><b>RM</b></td>
	 <td><i>rm -f</i></td>
	 <td>Remove file(s)</td>
  </tr>

  <tr>
	 <td><b>RMDIR</b></td>
	 <td><i>rm -rf</i></td>
	 <td>Remove file(s) and directory(ies) recursively</td>
  </tr>

  <tr>
	 <td><b>COPY</b></td>
	 <td><i>cp -p</i></td>
	 <td>Copy file (preserving the modification time)</td>
  </tr>

  <tr>
	 <td><b>BINCOPY</b></td>
	 <td><i>@BINCOPY@</i></td>
	 <td>Copy a library or an executable -- but only if it was changed</td>
  </tr>

  <tr>
     <td><b>LN_S</b></td>
	 <td><i>@LN_S</i></td>
	 <td>Make a symbolic link if possible; otherwise, hard-link or copy</td>
  <tr>
</table>



<p>
<br>
<a name="ref_MakeProjLib"></a>
<h3><i>Customized makefile to build a library</i></h3>

Here is an example of a <i>customized makefile</i> to build
library <i><b>libxmylib.a</b></i> from two source files
<i><b>xmy_src1.cpp</b></i> and <i><b>xmy_src2.c</b></i>, and one
pre-compiled object file <i><b>some_obj1.o</b></i>.
To make the example even more realistic, we assume that the said
source files include headers from the NCBI C Toolkit.

<pre>
    File Makefile.xmylib.lib:

    LIB      = xmylib
    SRC      = xmy_src1 xmy_src2
    OBJ      = some_obj1
    REQUIRES = xrequirement
    CFLAGS   = $(ORIG_CFLAGS)   -abc -DFOOBAR_NOT_CPLUSPLUS
    CXXFLAGS = $(FAST_CXXFLAGS) -xyz
    CPPFLAGS = $(ORIG_CPPFLAGS) -UFOO -DP1_PROJECT -I$(NCBI_C_INCLUDE)
</pre>

<ul>
  <li> Skip building this library if <tt>xrequirement</tt>
       (<a href="#ref_Packages">an optional package or project</a>)
       is disabled or unavailable
  <li> Compile <i><b>xmy_src1.cpp</b></i> using the C++ compiler
       <b>$(CXX)</b> with the flags <b>$(FAST_CXXFLAGS)  -xyz $(CPPFLAGS)</b>,
       which are the C++ flags for faster code, some additional flags
       specified by the user, and original preprocessor flags
  <li> Compile <i><b>xmy_src2.c</b></i> using the C compiler <b>CC</b>
       with the flags <b>$(CFLAGS) -abc -DFOOBAR_NOT_CPLUSPLUS $(CPPFLAGS)</b>,
       which are the original C flags, some additional flags
       specified by the user, and original preprocessor flags
  <li> Using <b>$(AR)</b> and <b>$(RANLIB)</b> [<b>$(LINK_DLL)</b> if
       building a shared library], compose the
       library <i><b>libxmylib.a</b></i> [<i><b>libxmylib.so</b></i>]
       from the resultant object files, plus the pre-compiled object file
       <i><b>some_obj1.o</b></i>.
  <li> Copy <i><b>libxmylib.*</b></i> to the
       top-level <b><i>lib/</i></b> directory of the
       <i>build tree</i> (for the later use by other projects)
</ul>

This <i>customized makefile</i> should be referred to as
<i><b>xmylib</b></i> in the <b>LIB_PROJ</b> macro of the relevant
<a href="#ref_MakeMeta"><i>meta-makefile</i></a>. As usual,
<a href="#ref_MakeProjMk"><i>Makefile.mk</i></a> will be
implicitly included.

<p>
This <i>customized makefile</i> can be used to build both <i>static</i>
and <a href="config.html#ref_DLL"><i>dynamic (DLL)</i></a> versions of
the library. <br>
To encourage its build as a <i>DLL</i> on the capable
platforms, you can explicitly specify:
<pre>    LIB_OR_DLL = dll</pre>
or
<pre>    LIB_OR_DLL = both</pre>
Conversely, if you want the library be always built as <i>static</i>, specify:
<pre>    LIB_OR_DLL = lib</pre>


<p>
<br>
<a name="ref_MakeProjApp"></a>
<h3><i>Customized makefile to build an application</i></h3>

Here is an example of a <i>customized makefile</i> to build the
application <i><b>my_exe</b></i> from three source files,
<i><b>my_main.cpp</b></i>, <i><b>my_src1.cpp</b></i>,
and <i><b>my_src2.c</b></i>.
To make the example even more realistic, we assume that the said
source files include headers from the NCBI SSS DB packages,
and the target executable uses the NCBI C++ libraries
<a href="#ref_MakeProjLib"><i><b>libxmylib.*</b></i></a> and
<i><b>libxncbi.*</b></i>, plus
NCBI SSS DB, SYBASE, and system network libraries.  We assume further
that the user would prefer to link statically against libxmylib if
building the toolkit as both shared and static libraries
(<i><b>configure --with-dll --with-static ...</b></i>), but is fine
with a shared libxncbi.
<pre>
    File Makefile.my_exe.app:

    APP      = my_exe
    SRC      = my_main my_src1 my_src2
    OBJ      = some_obj
    LIB      = xmylib$(STATIC) xncbi
    REQUIRES = xrequirement
    CPPFLAGS = $(ORIG_CPPFLAGS) $(NCBI_SSSDB_INCLUDE)
    LIBS     = $(NCBI_SSSDB_LIBS) $(SYBASE_LIBS) $(NETWORK_LIBS) $(ORIG_LIBS)
</pre>

<ul>
  <li> Skip building this library if xrequirement
       (<a href="#ref_Packages">an optional package or project</a>)
       is disabled or unavailable
  <li> Compile <i><b>my_main.cpp</b></i> and <i><b>my_src1.cpp</b></i>
    using the C++ compiler <b>$(CXX)</b> with the flags <b>$(CPPFLAGS)</b>
    (<a href="#ref_Note1">*</a>)
  <li> Compile <i><b>my_src2.c</b></i> using the C compiler
    <b>$(CC)</b> with the flags <b>$(CPPFLAGS)</b>
    (<a href="#ref_Note1">*</a>)
  <li> Using <b>$(CXX)</b> as a linker, build an executable
    <i><b>my_exe</b></i> from the object files
    <b><i>my_main.o, my_src1.o, my_src2.o</i></b>, the precompiled
    object file <b><i>some_obj.o</i></b>, NCBI C++ Toolkit libraries
    <a href="#ref_MakeProjLib"><i><b>libxmylib.a</b></i></a> and
    <i><b>libxncbi.*</b></i>, and NCBI SSS DB, SYBASE, and system
    network libraries (<a href="#ref_Note1">*</a>)
  <li> Copy the application to the top-level <b><i>bin/</i></b> directory of
    the <i>build tree</i> (for later use by other projects)
</ul>

<a name="ref_Note1"></a>
<i><b>(*)</b></i>
Since we did not redefine <b>CFLAGS</b>, <b>CXXFLAGS</b>, or <b>LDFLAGS</b>,
their default values <b>ORIG_*FLAGS</b> (obtained during the <i>build
tree</i> <a href="config.html#ref_Configure">configuration</a>) will be
<a href="config.html#ref_StdBuildRules">used</a>.

<p>
This <i>customized makefile</i> should be referred to as
<i><b>my_exe</b></i> in the <b>APP_PROJ</b> macro of the relevant
<a href="#ref_MakeMeta"><i>meta-makefile</i></a>. Note also, that the
<a href="#ref_MakeProjMk"><i>Makefile.mk</i></a> will be implicitly
included.


<p>
<br>
<a name="ref_MakeProjUsr"></a>
<h3><i>User-defined makefile to build... whatever</i></h3>

<p>
In some cases, we may need more functionality than the <i>customized
makefiles</i> (designed to build libraries and applications) can provide.

<p>
So, if you have a "regular" non-customized <i>user makefile</i>, and
you want to make from it, then you must enlist this <i>user makefile</i>
in the <b>USR_PROJ</b> macro of the project's
<a href="#ref_MakeMeta"><i>meta-makefile</i></a>.

<p>
Now, during the project build (and before any <i>customized makefiles</i>
are processed), your makefile will be called with one of the
<a href="#ref_MakeProjTarget">standard make targets</a> from the
project's build directory. Additionally, the
<a href="#ref_TablePath"><b>builddir</b></a> and
<a href="#ref_TablePath"><b>srcdir</b></a> macros will be passed
to your makefile (via the <b>make</b> command line).

<p>
In most cases, it is necessary to know your "working environment";
<i>i.e.</i>, tools, flags and paths (those that you use in your
<i>customized makefiles</i>).  This can be easily done by including <a
href="#ref_MakeProjMk"><i>Makefile.mk</i></a> in your makefile.

<p>
Shown below is a real-life example of a <i>user makefile</i>:
<ul>
  <li> build an auxiliary application using the <i>customized makefile</i>
    <i><b>Makefile.hc_gen_obj.app</b></i> (this part is a tricky one...)
  <li> use the resultant application <i><b>$(bindir)/hc_gen_obj</b></i>
    to generate the source and header files <i><b>humchrom_dat.[ch]</b></i>
    from the data file <i><b>humchrom.dat</b></i>
  <li> use the script <i><b>$(top_srcdir)/scripts/if_diff.sh</b></i>
    to replace the previous copies (if any) of humchrom_dat.[ch] with
    the newly generated versions if and only if the new versions are
    different (or there were no old versions).
</ul>

And, of course, it provides build rules for all the
<a href="#ref_MakeProjTarget">standard make targets</a>.

<pre>
    File $(top_srcdir)/src/internal/humchrom/Makefile.hc_gen_obj:

    # Build a code generator for hard-coding the chrom data into an obj file
    # Generate header and source "humchrom_dat.[ch]" from data file
    # "humchrom.dat"
    # Deploy the header to the compiler-specific include dir
    # Compile source code
    #################################

    include $(builddir)/Makefile.mk

    BUILD__HC_GEN_OBJ = $(MAKE) -f "$(builddir)/Makefile.app.tmpl" \
    srcdir="$(srcdir)" TMPL="hc_gen_obj" $(MFLAGS)


    all_r: all
    all: build_hc_gen_obj humchrom_dat.dep

    purge_r: purge
    purge:   x_clean
        $(BUILD__HC_GEN_OBJ) purge

    clean_r: clean
    clean:   x_clean
        $(BUILD__HC_GEN_OBJ) clean
    x_clean:
        -rm -f humchrom_dat.h
        -rm -f humchrom_dat.c

    build_hc_gen_obj:
        $(BUILD__HC_GEN_OBJ) all

    humchrom_dat.dep: $(srcdir)/data/humchrom.dat $(bindir)/hc_gen_obj
        -cp -p humchrom_dat.c humchrom_dat.save.c
        $(bindir)/hc_gen_obj -d $(srcdir)/data/humchrom.dat
            -f humchrom_dat
        $(top_srcdir)/scripts/if_diff.sh "mv" humchrom_dat.h
            $(incdir)/humchrom_dat.h
        -rm humchrom_dat.h
        $(top_srcdir)/scripts/if_diff.sh "mv" humchrom_dat.c
            humchrom_dat.save.c
        mv humchrom_dat.save.c humchrom_dat.c
        touch humchrom_dat.dep
</pre>


<p>
<br>
<a name="ref_MakeProjTarget"></a>
<h2>Standard build targets (<b>all, clean, purge</b>) in makefiles</h2>

<ul>
  <li> <b>all</b> -- compile the object modules specified in the
  <i>"$(OBJ)"</i> macro, and use them to build the library
  <i>"$(LIB)"</i> or the application <i>"$(APP)"</i>; then copy the
  resultant lib/app to the <a
  href="#ref_TablePath"><b>libdir/bindir</b></a> directory,
  respectively
  <li> <b>clean</b> -- remove all object modules and libs/apps
  that have been built by <b>all</b>
  <li> <b>purge</b> -- do <b>clean</b>, and then remove the copy
  of the libs/apps from the <a
  href="#ref_TablePath"><b>libdir/bindir</b></a> directory.
</ul>

Naturally, the <i>customized makefiles</i> will not distinguish
between recursive (<b>all_r, clean_r, purge_r</b>) and
non-recursive (<b>all, clean, purge</b>) targets -- because the
recursion and multiple build is entirely up to the <a
href="#ref_MakeMeta"><i>meta-makefiles</i></a>.


<p>
<br>
<a name="ref_Packages"></a>
<h2>List of optional packages, features and projects</h2>
Here are the keywords you can list in REQUIRES in a customized
<a href="#ref_MakeProjApp">application</a> or
<a href="#ref_MakeProjLib">library</a> makefile, along with the corresponding
<a href="config.html#ref_ProhibitPackage">configure options</a>:

<p>

<table border=1 cellspacing=0>
 <tr>
  <th>Keyword</th>
  <th align=left>Optional...</th>
  <th>Configure option(s)</th>
 </tr>

 <tr>
  <th> </th>
  <th>...package</th>
  <th></th>
 </tr>

 <tr>
  <td><b>Sybase</b></td>
  <td>Sybase libraries</td>
  <td><i>--without-sybase, --with-sybase-local(=DIR), --with-sybase-new</i></td>
 </tr>

 <tr>
  <td><b>Fast-CGI</b></td>
  <td>Fast-CGI library</td>
  <td><i>--without-fastcgi</i></td>
 </tr>

 <tr>
  <td><b>wxWindows</b></td>
  <td>wxWindows</td>
  <td><i>--without-wxwin, --with-wxwin=DIR</i></td>
 </tr>

 <tr>
  <td><b>C-Toolkit</b></td>
  <td>NCBI C Toolkit</td>
  <td><i>--without-ncbi-c</i></td>
 </tr>


 <tr>
  <td><b>SSSDB</b></td>
  <td>NCBI SSS DB library</td>
  <td><i>--without-sssdb, --without-sss</i></td>
 </tr>

 <tr>
  <td><b>SSSUTILS</b></td>
  <td>NCBI SSS UTILS library</td>
  <td><i>--without-sssutils, --without-sss</i></td>
 </tr>

 <tr>
  <td><b>GEO</b></td>
  <td>NCBI GEO libraries</td>
  <td><i>--without-geo</i></td>
 <tr>

 <tr>
  <td><b>SP</b></td>
  <td>SP libraries</td>
  <td><i>--without-sp</i></td>
 <tr>

 <tr>
  <td><b>PubMed</b></td>
  <td>NCBI PubMed libraries</td>
  <td><i>--without-pubmed</i></td>
 <tr>

 <tr>
  <td><b>ORBacus</b></td>
  <td>ORBacus CORBA</td>
  <td><i>--without-orbacus, --with-orbacus=DIR</i></td>
 </tr>

 <tr>
  <th> </th>
  <th>...feature</th>
  <th> </th>
 </tr>

 <tr>
  <td><b>MT</b></td>
  <td>multithreading is available</td>
  <td><i>--with-mt</i></td>
 </tr>

 <tr>
  <th> </th>
  <th>...project(s)</th>
  <th> </th>
 </tr>

 <tr>
  <td><b>serial</b></td>
  <td>ASN.1/XML serialization library and datatool</td>
  <td><i>--without-serial</i></td>
 </tr>

 <tr>
  <td><b>ctools</b></td>
  <td>projects based on the NCBI C toolkit</td>
  <td><i>--without-ctools</i></td>
 </tr>

 <tr>
  <td><b>gui</b></td>
  <td>projects that use the wxWindows GUI package</td>
  <td><i>--without-gui</i></td>
 </tr>

 <tr>
  <td><b>objects</b></td>
  <td>libraries to serialize ASN.1/XML objects</td>
  <td><i>--with-objects</i></td>
 </tr>

 <tr>
  <td><b>app</b></td>
  <td>standalone applications like ID1_FETCH</td>
  <td><i>--with-app</i></td>
 </tr>

 <tr>
  <td><b>internal</b></td>
  <td>all internal projects</td>
  <td><i>--with-internal</i></td>
 </tr>

 <tr>
  <td><b>local_lbsm</b></td>
  <td>IPC with locally running LBSMD</td>
  <td><i>--without-local-lbsm</i></td>
 </tr>
</table>


<p>
<br>
<a name="ref_Outside"></a>
<h2>New Project (lib, application) Development Aids</h2>

<i><b>NOTE</b></i>:  in NCBI, you can use the scripts located in the pre-built NCBI C++
toolkit directory <b><tt>$NCBI/c++/scripts/.</tt></b>

<p>
<br>
<a name="ref_OutsideImport"></a>
<h3><b><tt>scripts/import_project.sh &lt;cvs_tree_path&gt; [builddir]</tt></b></h3>

<dl>
    <dt>
    <dd>
In many cases, you work on your own project which <b>is a part</b> of the
NCBI C++ tree, and you do not want to check out, update and rebuild
the whole NCBI C++ tree. -- Instead, you just want to use headers and
libraries of the pre-built NCBI C++ Toolkit to build your project.

<p>
The shell script <b><tt>import_project.sh</tt></b> will checkout
your project's source and include directories from CVS, and it will create
a (temporary) makefile based on the project's <i>customized makefile</i>.
This makefile will also contain a reference to the pre-built NCBI C++ toolkit.

<p>
For example (<a href="scripts_usage.html#ref_Import_ProjectUsage">full usage</a>):


<pre>
    <a href="new_project.import.session"><b><tt>import_project.sh hello</tt></b></a>
</pre>


will check out the whole <b>hello</b> demo project from the NCBI C++ tree
(<b><tt>$CVSROOT/internal/c++/src/hello/</tt></b>), and create a
makefile <b><tt>Makefile.hello_app</tt></b> that uses the project's
<i>customized makefile</i> <b><tt>Makefile.hello.app</tt></b>.
Now you can just go to the created working directory
<b><tt>internal/c++/src/hello/</tt></b> and build the demo application
<b>hello.cgi</b> using:
<pre>
    <b>make -f Makefile.hello_app</b>
</pre>
</dl>

<p>
<br>
<a name="ref_OutsideCreate"></a>
<h3><b><tt>scripts/new_project.sh &lt;name&gt; &lt;type&gt; [builddir]</tt></b> </h3>

<dl>
    <dt>
    <dd>
This script will create a startup <i>makefile</i> for a new, from-scratch
project called "<tt>name</tt>" which uses the NCBI C++ Toolkit (and possibly the C Toolkit as
well).  For new libraries, <tt>type=lib</tt> while for new applications <tt>type=app</tt>.

<p></p>
Sample code will be included in the project directory for new applications.  Different samples
are available for <tt>type=app[/basic]</tt> (a command-line argument demo application based
on the <a href="libs.html#ref_SumXNCBI"><tt>corelib</tt></a> library),
<tt>type=app/cgi</tt> (for a <a href="libs.html#ref_SumXCGI">CGI or Fast-CGI</a> application),
<tt>type=app/objmgr</tt> (for an application using the <i>Object Manager</i>) and <tt>type=app/objects</tt>
(for an application using ASN.1 objects).

<p></p>
You will need to slightly edit the resultant <i>makefile</i> to:
<ul>
  <li> specify the name of your library (or application)
  <li> specify the list of source files going to it
  <li> modify some preprocessor, compiler, etc.  flags, if needed
  <li> modify the set of additional libraries to link to it
       (if it's an application), if needed
</ul>

<p>
For example (<a href="scripts_usage.html#ref_New_ProjectUsage">full usage</a>):

<pre>
    <a href="new_project.create.session"><b><tt>new_project.sh foo app/basic</tt></b></a>
</pre>


creates a model <i>makefile</i> <tt>Makefile.foo_app</tt> to build
an application using tools and flags hard-coded in <tt>$NCBI/c++/Debug/build/Makefile.mk</tt>,
and headers from <tt>$NCBI/c++/include/</tt>.  The file <tt>/tmp/foo/foo.cpp</tt> is
also created; you can either replace this with your own <tt>foo.cpp</tt> or modify its sample
code as required.

<p></p>
Now, after specifying the application name, list of source files, etc.,
you can just go to the created working directory <tt>foo/</tt> and build your application using:

<pre>
    make -f Makefile.foo_app
</pre>

<p>
You can easily change the active version of NCBI C++ Toolkit
by manually setting variable <b>$(builddir)</b> in the file
<tt>Makefile.foo_app</tt> to the desired Toolkit path, e.g.,
<tt>builddir = </tt>$(NCBI)/<tt>c++/GCC-Release/build</tt>
</dl>

<p>
<br>
<a name="ref_OutsideHello"></a>
<h3><b><tt>scripts/hello.sh</tt></b> </h3>

<dl>
    <dt>
    <dd>
This script will:
<ul>
  <li> retrieve the demo CGI application project HELLO
  <li> create a standalone makefile to build it
  <li> build HELLO application using this makefile
  <li> run HELLO application
</ul>
It will produce the file <tt>hello.html</tt> containing a model
HTTP response. For more info on the HELLO CGI project see
in section
<i><a href="tools.html">NCBI C++ tools and applications</a> /
<a href="tools/hello/hello.html">HELLO.CGI -- a demo CGI application (NCBI C++)</a></i>.
</dl>

<br></br>

<!--#include virtual="./ssi/navlinks.shtml" -->

<!-- Begin footer content -->

<table border=0 width="100%" cellspacing=0>
<script>
<!--
print_author('vakatov', 'Denis Vakatov', '$Date$', 'ncbi.nlm.nih.gov');
// -->
</script>
</table>

<!--#include virtual="./ssi/footer.shtml" -->
