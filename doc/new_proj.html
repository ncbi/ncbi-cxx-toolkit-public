<!-- $Id$ -->
<!--#set var="TITLE" value="NCBI C++ Toolkit:  New Projects" -->
<!--#set var="HEADING" value="Starting New Projects" -->
<!--#set var="DOCROOT" value="." -->
<!--#include virtual="./ssi/header.shtml" -->
<i><h1><font color="#FF0000"><span style="background-color: #FFFFFF">Warning: This HTML page is deprecated</span></font></h1>

All new changes are being made to the Toolkit Book
at the following locations:
<ul>
<li>
<i>Official Release:</i> <a href="http://www.ncbi.nlm.nih.gov/books/bv.fcgi?call=bv.View..ShowTOC&rid=toolkit.TOC&depth=2">
    C++ Toolkit Book</a>.
</li>
<li>
<i>Development Version:</i> <a href="http://xpubmed0.ncbi.nlm.nih.gov:5701/books/bv.fcgi?call=bv.View..ShowTOC&rid=toolkit.TOC&depth=2">

    C++ Toolkit Book (no search engine, accessible from inside NCBI only)</a>. </li> </ul> The Development Version is the most recent documentation before it becomes an Official Release. While the Development Version is the lastest version, it is accessible only from inside NCBI, and the search engine functionality is currently missing. Also, the location of the Development Version may change without warning! So it is suggested that you use the Official Release, and use the Development Version only when necessary.</p> </i>

<hr>
<!--EOW-->

<p></p>
<a name="ref_Checkout"></a>
The following assumes that you have all of the necessary Toolkit components.
If you need to obtain part or all of the Toolkit's source tree, consult the
<a href="download.html#ref_FTP">FTP instructions</a> or <a href="cvs.html">CVS checkout
procedures</a>.   Please visit the <a href="get_started.html">Getting Started</a> page for a broad
overview of the NCBI C++ Toolkit and its use.

<ul>
  <li> <a href="#ref_ProjectStructure">
    New Projects:  Location and File Structure</a>
  <li> <a href="#ref_Structure">
    Projects and the Toolkit's CVS Tree Structure</a>
  <li> <a href="#ref_Create">
    Creating a CVS directory for a new C++ project</a>
  <li><a href="#ref_NewModule">
    Starting New Modules</a>
  <li> <a href="#ref_MakeMeta">
    Meta-makefiles (allow for multiple and/or recursive builds)</a>
  <li> <a href="#ref_MakeProj">
    Project makefiles</a>
    <ul>
      <li> <a href="#ref_MakeProjLib">
        Customized makefile to build a library</a>
      <li> <a href="#ref_MakeProjApp">
        Customized makefile to build an application</a>
      <li> <a href="#ref_MakeProjUsr">
        User-defined makefile to build... whatever</a>
    </ul>
  <li> <a href="#ref_Outside">
    New Project (lib, application) Development Aids</a>
    <ul>
      <li> <a href="#ref_OutsideImport">
           <span class="ncbi_script">import_project.sh</span> -- prepare a new project that lives in an NCBI C++ subtree
           </a>
      <li> <a href="#ref_OutsideCreate">
           <span class="ncbi_script">new_project.sh</span> -- prepare a new project that only links to the NCBI C++ tree
           </a>
      <li> <a href="#ref_OutsideHello">
           <span class="ncbi_script">hello.sh</span> -- a simple demo CGI application HELLO
           </a>
    </ul>
  <li> <a href="mkfiles.html">
    A real-life example of the NCBI C++ makefile hierarchy
   (project <span class="ncbi_proj">corelib</span>)</a>
</ul>

<hr>

<p></p>
<a name="ref_ProjectStructure"></a>
<h2> New Projects:  Location and File Structure </h2>
Before creating the new project, you must decide if you need to work within a C++ source tree
(or subtree) or merely need to link with the Toolkit libraries and work in a separate directory.
The later case is simpler and allows you to work independently in a private directory, but
it is not an option if the Toolkit source, headers, or <span class="ncbi_term">makefiles</span> are to be directly
used or altered during the new project's development.

<ul>
    <li><a href="programming_manual/inside_tree.html">Work in the Full Toolkit Source Tree</a></li>
    <li><a href="programming_manual/sub_tree.html">Work in a Toolkit Subtree</a></li>
    <li><a href="programming_manual/outside_tree.html">Work in a Separate Directory</a></li>
</ul>

<p></p>
<p>
Regardless of where you build your new project, it must adopt and maintain
a particular structure.  Specifically,
each project's <a href="lxr/source/src/"><span class="ncbi_term">source tree</span></a> relative to <span class="ncbi_dir">$NCBI/c++</span>
should contain:
<ul>
    <li> <span class="ncbi_file">include/*.hpp</span> --  project's public headers
    <li> <span class="ncbi_file">src/*.{cpp, hpp}</span> --  project's source files and private headers
    <li> <span class="ncbi_file">src/Makefile.in</span> -- a <a href="#ref_MakeMeta"><span class="ncbi_term">meta-makefile</span></a>
          template to specify which local projects (described in <span class="ncbi_file">Makefile.*.in</span>)
          and sub-projects (located in the project subdirectories) must be built
    <li> <span class="ncbi_file">src/Makefile.&lt;project_name&gt;.{lib, app}[.in]</span> -- one or more <span class="ncbi_term">customized makefiles</span> to build a library or an application
    <li> <span class="ncbi_file">src/Makefile.*[.in]</span> -- "free style" makefiles (if any)
    <li> sub-project directories (if any)
</ul>

<hr>

<p>
<a name="ref_Structure"></a>
<h2>Projects and the Toolkit's CVS Tree Structure</h2>

<font size=-1>
(For the overall NCBI C++ CVS tree structure see
<a href="config.html#ref_Source">the configuration page</a>; see the
<a href="download.html">download page</a> for source acquisition information
and <a href="cvs.html">CVS details</a>.)
</font>

<p>
Even if you work outside of the C++ tree, it is necessary to understand
how the Toolkit uses <span class="ncbi_term">makefiles</span>, <span class="ncbi_term">meta-makefiles</span>, and <span class="ncbi_term">makefile templates</span>,
and the CVS tree structure.

<p>
The standard CVS location for NCBI C++/STL projects is
<span class="ncbi_cvs_path">$CVSROOT/internal/c++/</span>. Public header files
(<span class="ncbi_file">*.hpp, *.inl</span>) of all projects are located below
the <span class="ncbi_cvs_path">$CVSROOT/internal/c++/include/</span> directory.
<span class="ncbi_cvs_path">$CVSROOT/internal/c++/src/</span> directory has just the same
hierarchy of subdirectories as <span class="ncbi_dir">.../include/</span>, and its
very top level contains:

<ul>
  <li> Templates of generic makefiles (<span class="ncbi_file">Makefile.*.in</span>):
    <ul>
      <li> <span class="ncbi_file">Makefile.in</span> -- makefile to perform a recursive
        build in all project subdirectories
      <li> <span class="ncbi_file">Makefile.meta.in</span> -- included by all makefiles
        that provide both local and recursive builds
      <li> <span class="ncbi_file">Makefile.lib.in</span> -- included by all makefiles
        that perform a "standard" library build, when building only
        static libraries.
      <li> <span class="ncbi_file">Makefile.dll.in</span> -- included by all makefiles
        that perform a "standard" library build, when building only
        shared libraries.
      <li> <span class="ncbi_file">Makefile.both.in</span> -- included by all makefiles
        that perform a "standard" library build, when building both
        static and shared libraries.
      <li> <span class="ncbi_file">Makefile.lib.tmpl.in</span> -- serves as a template
        for the project <span class="ncbi_term">customized makefiles</span>
        (<span class="ncbi_file">Makefile.*.lib[.in]</span>) that perform a "standard"
        library build
      <li> <span class="ncbi_file">Makefile.app.in</span> -- included by all makefiles
        that perform a "standard" application build
      <li> <span class="ncbi_file">Makefile.lib.tmpl.in</span> -- serves as a template
        for the project <span class="ncbi_term">customized makefiles</span>
        (<span class="ncbi_file">Makefile.*.app[.in]</span>) that perform a "standard"
        application build
      <li> <span class="ncbi_file">Makefile.rules.in,
        Makefile.rules_with_autodep.in</span> -- instructions for
        building object files; included by most other makefiles
      <li> <span class="ncbi_file">Makefile.mk.in</span> -- included by all makefiles;
        sets a lot of configuration variables
    </ul>

  <p>
  <li> The contents of each project are detailed <a href="#ref_ProjectStructure">above</a>.
      If your project is to become part of the Toolkit tree, you need to ensure that
      all <span class="ncbi_term">makefiles</span> and <span class="ncbi_file">Makefile*.in</span> templates are available so the
      master <span class="ncbi_term">makefiles</span> can properly
      configure and build it (see "<a href="#ref_MakeMeta">Meta-Makefiles</a>" and "<a href="#ref_MakeProj">Project Makefiles"</a> below).
      You will also need to <a href="#ref_Create">prepare CVS directories</a>
      to hold the new source and header files.</li>

</ul>

<p>

<hr>

<br>
<a name="ref_Create"></a>
<h2>Creating source and include CVS dirs for a new C++ project</h2>

<p>
To create your new project (e.g., "bar_proj") directories in the
NCBI C++ CVS tree to directory <span class="ncbi_dir">foo/c++/</span>):

<blockquote>
<pre class="ncbi_code">
cd foo/c++/include && mkdir bar_proj && cvs add -m "Project Bar" bar_proj
cd foo/c++/src     && mkdir bar_proj && cvs add -m "Project Bar" bar_proj</pre></blockquote>

Now you can <a href="new_mod.html">add</a> and edit your project C++
files in there.

<p>
NOTE: remember to add this new project directory to the <span class="ncbi_make_var">$(SUB_PROJ)</span>
list of the upper level <a href="#ref_MakeMeta"><span class="ncbi_term">meta-makefile</span></a>
configurable template (e.g., for this particular case, to
<span class="ncbi_file">foo/c++/src/Makefile.in</span>).
<p>

<hr>

<p>
<a name="ref_NewModule"></a>
<h2> Starting New Modules </h2>

<p></p>
Projects consist of modules, which are most often a pair of source (*.cpp)
and header (*.hpp) files.  To help create new modules, template source &amp; header files
may be used, or you may modify the sample code generated by the script
<a href="scripts_usage.html#ref_New_ProjectUsage"><span class="ncbi_script">new_project.sh</span></a>.
See the <a href="new_mod.html">new modules page</a> for details.
<p>

<hr>

<p>
<a name="ref_MakeMeta"></a>
<h3>Meta-makefiles (to provide multiple and/or recursive builds)</h3>

All projects from the NCBI C++ hierarchy are tied together by a set of
<span class="ncbi_term">meta-makefiles</span> which are present in all project source
directories and provide a uniform and easy way to perform both local
and recursive builds.  See more detail on the <a href="makefiles.html">Working with Makefiles</a> page.

A typical <span class="ncbi_term">meta-makefile</span> template(e.g. <span class="ncbi_file">Makefile.in</span> in your
<span class="ncbi_dir">foo/c++/src/bar_proj/</span> dir) looks like that:
<blockquote><pre class="ncbi_code">
# Makefile.bar_u1, Makefile.bar_u2 ...
USR_PROJ = bar_u1 bar_u2 ...
# Makefile.bar_l1.lib, Makefile.bar_l2.lib ...
LIB_PROJ = bar_l1 bar_l2 ...
# Makefile.bar_a1.app, Makefile.bar_a2.app ...
APP_PROJ = bar_a1 bar_l2 ...
SUB_PROJ = app sub_proj1 sub_proj2
srcdir = @srcdir@
include @builddir@/Makefile.meta
</pre></blockquote>

This template separately specifies instructions for user, library and application
projects, along with a set of three sub-projects that can be made.
The mandatory final two lines <span class="ncbi_code">"srcdir = @srcdir@ ; include @builddir@/Makefile.meta"</span>
define the <a href="makefiles.html#ref_MakefilesTargets">standard build targets</a>.
<p>

<hr>

<p>
<a name="ref_Makefile"></a>
<a name="ref_MakeProj"></a>
<h3>Project makefiles</h3>

Just like the configurable template <span class="ncbi_file">Makefile.meta.in</span> is
used to ease and standardize the writing of <a
href="#ref_MakeMeta"><span class="ncbi_term">meta-makefiles</span></a>, so there are templates
to help in the creation of "regular" project makefiles to build a
library or an application. These auxiliary template makefiles are
described on the "<a href="makefiles.html#ref_MakefilesHier">Working with Makefiles</a>" page
and listed <a href="#ref_Structure">above</a>.  The
<span class="ncbi_script">configure</span>'d versions of these templates get put at the very top of
a <span class="ncbi_term">build tree</span>.
<p>

In addition to the <span class="ncbi_term">meta-makefile</span> that must be defined for each project,
a <span class="ncbi_term">customized makefile</span> <span class="ncbi_file">Makefile.&lt;project_name&gt;.[app|lib]</span>
must also be provided.  The following three sections give
examples of <span class="ncbi_term">customized makefiles</span> for a <a href="#ref_MakeProjLib">library</a> and an
<a href="#ref_MakeProjApp">application</a>, along
with a case where a <a href="#ref_MakeProjUsr">user-defined</a> <span class="ncbi_term">makefile</span> is required.
<p>

You have great latitude in specifying optional packages, features and projects in
<span class="ncbi_term">makefiles</span>.  The macro <span class="ncbi_make_var">REQUIRES</span> in the examples is one way to
allows you access them.  See the "<span class="ncbi_term">Working with Makefiles</span><!--NCBI_MARK-->"
page for a <a href="makefiles.html#ref_Packages">complete list</a>; the configuration
page gives the corresponding <a href="config.html#ref_ProhibitPackage">configure options</a>.


<p><br>
<a name="ref_MakeProjLib"></a>
<h4>Example 1:  Customized makefile to build a library</h4>

<dl>
    <dt>
    <dd>
Here is an example of a <span class="ncbi_term">customized makefile</span> to build
library <span class="ncbi_lib">libxmylib.a</span> from two source files
<span class="ncbi_file">xmy_src1.cpp</span> and <span class="ncbi_file">xmy_src2.c</span>, and one
pre-compiled object file <span class="ncbi_file">some_obj1.o</span>.
To make the example even more realistic, we assume that the said
source files include headers from the NCBI C Toolkit.

<blockquote>
    File Makefile.xmylib.lib:
<pre class="ncbi_code">
LIB      = xmylib
SRC      = xmy_src1 xmy_src2
OBJ      = some_obj1
REQUIRES = xrequirement
CFLAGS   = $(ORIG_CFLAGS)   -abc -DFOOBAR_NOT_CPLUSPLUS
CXXFLAGS = $(FAST_CXXFLAGS) -xyz
cppFLAGS = $(ORIG_cppFLAGS) -UFOO -DP1_PROJECT -I$(NCBI_C_INCLUDE)
</pre></blockquote>

<ul>
  <li> Skip building this library if <span class="ncbi_value">xrequirement</span>
       (<a href="makefiles.html#ref_Packages">an optional package or project</a>)
       is disabled or unavailable
  <li> Compile <span class="ncbi_file">xmy_src1.cpp</span> using the C++ compiler
       <span class="ncbi_env">$(CXX)</span> with the flags <span class="ncbi_make_flag">$(FAST_CXXFLAGS) -xyz $(cppFLAGS)</span>,
       which are the C++ flags for faster code, some additional flags
       specified by the user, and original preprocessor flags
  <li> Compile <span class="ncbi_file">xmy_src2.c</span> using the C compiler <span class="ncbi_env">$(CC)</span>
       with the flags <span class="ncbi_make_flag">$(CFLAGS) -abc -DFOOBAR_NOT_CPLUSPLUS $(cppFLAGS)</span>,
       which are the original C flags, some additional flags
       specified by the user, and original preprocessor flags
  <li> Using <span class="ncbi_env">$(AR)</span> and <span class="ncbi_env">$(RANLIB)</span> [<span class="ncbi_env">$(LINK_DLL)</span> if
       building a shared library], compose the
       library <span class="ncbi_lib">libxmylib.a</span> [<span class="ncbi_lib">libxmylib.so</span>]
       from the resultant object files, plus the pre-compiled object file
       <span class="ncbi_file">some_obj1.o</span>.
  <li> Copy <span class="ncbi_lib">libxmylib.*</span> to the
       top-level <span class="ncbi_dir">lib/</span><!--NCBI_MARK--> directory of the
       <span class="ncbi_term">build tree</span> (for the later use by other projects)
</ul>
<p>
This <span class="ncbi_term">customized makefile</span> should be referred to as
<span class="ncbi_proj">xmylib</span> in the <span class="ncbi_make_var">LIB_PROJ</span> macro of the relevant
<a href="#ref_MakeMeta"><span class="ncbi_term">meta-makefile</span></a>. As usual,
<a href="makefiles.html#ref_MakeProjMk"><span class="ncbi_file">Makefile.mk</span></a> will be
implicitly included.

<p>
This <span class="ncbi_term">customized makefile</span> can be used to build both <span class="ncbi_term">static</span>
and <a href="config.html#ref_DLL"><span class="ncbi_term">dynamic (DLL)</span></a> versions of
the library. <br>
To encourage its build as a <span class="ncbi_term">DLL</span> on the capable
platforms, you can explicitly specify:
<pre class="ncbi_code">    LIB_OR_DLL = dll</pre>
or
<pre class="ncbi_code">    LIB_OR_DLL = both</pre>
Conversely, if you want the library be always built as <span class="ncbi_term">static</span>, specify:
<pre class="ncbi_code">    LIB_OR_DLL = lib</pre>
</dl>


<p><br>
<a name="ref_MakeProjApp"></a>
<h4>Example 2:  Customized makefile to build an application</h4>

<dl>
    <dt>
    <dd>
Here is an example of a <span class="ncbi_term">customized makefile</span> to build the
application <span class="ncbi_app">my_exe</span> from three source files,
<span class="ncbi_file">my_main.cpp</span>, <span class="ncbi_file">my_src1.cpp</span>,
and <span class="ncbi_file">my_src2.c</span>.
To make the example even more realistic, we assume that the said
source files include headers from the NCBI SSS DB packages,
and the target executable uses the NCBI C++ libraries
<a href="#ref_MakeProjLib"><span class="ncbi_lib">libxmylib.*</span></a> and
<span class="ncbi_lib">libxncbi.*</span>, plus
NCBI SSS DB, SYBASE, and system network libraries.  We assume further
that the user would prefer to link statically against libxmylib if
building the toolkit as both shared and static libraries
(<span class="ncbi_cmd">configure --with-dll --with-static ...</span>), but is fine
with a shared libxncbi.
<blockquote>
File Makefile.my_exe.app:
<pre class="ncbi_code">
APP      = my_exe
SRC      = my_main my_src1 my_src2
OBJ      = some_obj
LIB      = xmylib$(STATIC) xncbi
REQUIRES = xrequirement
cppFLAGS = $(ORIG_cppFLAGS) $(NCBI_SSSDB_INCLUDE)
LIBS     = $(NCBI_SSSDB_LIBS) $(SYBASE_LIBS) $(NETWORK_LIBS) $(ORIG_LIBS)
</pre></blockquote>

<ul>
  <li> Skip building this library if xrequirement
       (<a href="makefiles.html#ref_Packages">an optional package or project</a>)
       is disabled or unavailable
  <li> Compile <span class="ncbi_file">my_main.cpp</span> and <span class="ncbi_file">my_src1.cpp</span>
    using the C++ compiler <span class="ncbi_env">$(CXX)</span> with the flags <span class="ncbi_make_var">$(cppFLAGS)</span>
    (<a href="#ref_Note1">*</a>)
  <li> Compile <span class="ncbi_file">my_src2.c</span> using the C compiler
    <span class="ncbi_env">$(CC)</span> with the flags <span class="ncbi_make_var">$(cppFLAGS)</span>
    (<a href="#ref_Note1">*</a>)
  <li> Using <span class="ncbi_env">$(CXX)</span> as a linker, build an executable
    <span class="ncbi_app">my_exe</span> from the object files
    <span class="ncbi_file">my_main.o, my_src1.o, my_src2.o</span>, the precompiled
    object file <span class="ncbi_file">some_obj.o</span>, NCBI C++ Toolkit libraries
    <a href="#ref_MakeProjLib"><span class="ncbi_lib">libxmylib.a</span></a> and
    <span class="ncbi_lib">libxncbi.*</span>, and NCBI SSS DB, SYBASE, and system
    network libraries (<a href="#ref_Note1">*</a>)
  <li> Copy the application to the top-level <span class="ncbi_dir">bin/</span> directory of
    the <span class="ncbi_term">build tree</span> (for later use by other projects)
</ul>
<p>

<a name="ref_Note1"></a>
<span class="ncbi_note">(*)</span>
Since we did not redefine <span class="ncbi_make_var">CFLAGS</span>, <span class="ncbi_make_var">CXXFLAGS</span>, or <span class="ncbi_make_var">LDFLAGS</span>,
their default values <span class="ncbi_make_var">ORIG_*FLAGS</span> (obtained during the <span class="ncbi_term">build
tree</span> <a href="config.html#ref_Configure">configuration</a>) will be
<a href="config.html#ref_StdBuildRules">used</a>.

<p>
This <span class="ncbi_term">customized makefile</span> should be referred to as
<span class="ncbi_app">my_exe</span> in the <span class="ncbi_make_var">APP_PROJ</span> macro of the relevant
<a href="#ref_MakeMeta"><span class="ncbi_term">meta-makefile</span></a>. Note also, that the
<a href="makefiles.html#ref_MakeProjMk"><span class="ncbi_file">Makefile.mk</span></a> will be implicitly
included.
</dl>


<p><br>
<a name="ref_MakeProjUsr"></a>
<h4>Example 3: User-defined makefile to build... whatever</h4>

<dl>
    <dt>
    <dd>
In some cases, we may need more functionality than the <span class="ncbi_term">customized
makefiles</span> (designed to build libraries and applications) can provide.

<p>
So, if you have a "regular" non-customized <span class="ncbi_term">user makefile</span>, and
you want to make from it, then you must enlist this <span class="ncbi_term">user makefile</span>
in the <span class="ncbi_make_var">USR_PROJ</span> macro of the project's
<a href="#ref_MakeMeta"><span class="ncbi_term">meta-makefile</span></a>.

<p>
Now, during the project build (and before any <span class="ncbi_term">customized makefiles</span>
are processed), your makefile will be called with one of the
<a href="makefiles.html#ref_MakeProjTarget">standard make targets</a> from the
project's build directory. Additionally, the
<a href="makefiles.html#ref_TablePath"><span class="ncbi_make_var">builddir</span></a> and
<a href="makefiles.html#ref_TablePath"><span class="ncbi_make_var">srcdir</span></a> macros will be passed
to your makefile (via the <span class="ncbi_util">make</span> command line).

<p>
In most cases, it is necessary to know your "working environment";
i.e., tools, flags and paths (those that you use in your
<span class="ncbi_term">customized makefiles</span>).  This can be easily done by including
<a href="makefiles.html#ref_MakeProjMk"><span class="ncbi_file">Makefile.mk</span></a> in your makefile.

<p>
Shown below is a real-life example of a <span class="ncbi_term">user makefile</span>:
<ul>
  <li> build an auxiliary application using the <span class="ncbi_term">customized makefile</span>
    <span class="ncbi_file">Makefile.hc_gen_obj.app</span> (this part is a tricky one...)
  <li> use the resultant application <span class="ncbi_file">$(bindir)/hc_gen_obj</span>
    to generate the source and header files <span class="ncbi_file">humchrom_dat.[ch]</span>
    from the data file <span class="ncbi_file">humchrom.dat</span>
  <li> use the script <span class="ncbi_script">$(top_srcdir)/scripts/if_diff.sh</span>
    to replace the previous copies (if any) of <span class="ncbi_file">humchrom_dat.[ch]</span> with
    the newly generated versions if and only if the new versions are
    different (or there were no old versions).
</ul>

And, of course, it provides build rules for all the
<a href="makefiles.html#ref_MakeProjTarget">standard make targets</a>.

<blockquote>
<pre class="ncbi_code">
File $(top_srcdir)/src/internal/humchrom/Makefile.hc_gen_obj:

# Build a code generator for hard-coding the chrom data into
# an obj file
# Generate header and source "humchrom_dat.[ch]" from data
# file "humchrom.dat"
# Deploy the header to the compiler-specific include dir
# Compile source code
#################################

include $(builddir)/Makefile.mk

BUILD__HC_GEN_OBJ = $(MAKE) -f "$(builddir)/Makefile.app.tmpl" \
srcdir="$(srcdir)" TMPL="hc_gen_obj" $(MFLAGS)


all_r: all
all: build_hc_gen_obj humchrom_dat.dep

purge_r: purge
purge:   x_clean
    $(BUILD__HC_GEN_OBJ) purge

clean_r: clean
clean:   x_clean
    $(BUILD__HC_GEN_OBJ) clean
x_clean:
    -rm -f humchrom_dat.h
    -rm -f humchrom_dat.c

build_hc_gen_obj:
    $(BUILD__HC_GEN_OBJ) all

humchrom_dat.dep: $(srcdir)/data/humchrom.dat $(bindir)/hc_gen_obj
    -cp -p humchrom_dat.c humchrom_dat.save.c
    $(bindir)/hc_gen_obj -d $(srcdir)/data/humchrom.dat
        -f humchrom_dat
    $(top_srcdir)/scripts/if_diff.sh "mv" humchrom_dat.h
        $(incdir)/humchrom_dat.h
    -rm humchrom_dat.h
    $(top_srcdir)/scripts/if_diff.sh "mv" humchrom_dat.c
       humchrom_dat.save.c
    mv humchrom_dat.save.c humchrom_dat.c
    touch humchrom_dat.dep
</pre>
</dl>

<hr>
<p>
<a name="ref_Outside"></a>
<h2>New Project (lib, application) Development Aids</h2>

<span class="ncbi_note">NOTE</span>:  in NCBI, you can use the scripts located in the pre-built NCBI C++
toolkit directory <span class="ncbi_dir">$NCBI/c++/scripts/.</span>

<p>
<a name="ref_OutsideImport"></a>
<h3><span class="ncbi_cmd">scripts/import_project.sh &lt;cvs_tree_path&gt; [builddir]</span></h3>

<dl>
    <dt>
    <dd>
In many cases, you work on your own project which <em>is a part</em> of the
NCBI C++ tree, and you do not want to check out, update and rebuild
the whole NCBI C++ tree. -- Instead, you just want to use headers and
libraries of the pre-built NCBI C++ Toolkit to build your project.

<p>
The shell script <span class="ncbi_script">import_project.sh</span> will checkout
your project's source and include directories from CVS, and it will create
a (temporary) makefile based on the project's <span class="ncbi_term">customized makefile</span>.
This makefile will also contain a reference to the pre-built NCBI C++ toolkit.

<p>
For example (<a href="scripts_usage.html#ref_Import_ProjectUsage">full usage</a>):

<pre class="ncbi_cmd">
    <a href="new_project.import.session">import_project.sh hello</a>
</pre>


will check out the whole <span class="ncbi_proj">hello</span> demo project from the NCBI C++ tree
(<span class="ncbi_dir">$CVSROOT/internal/c++/src/hello/</span>), and create a
makefile <span class="ncbi_file">Makefile.hello_app</span> that uses the project's
<span class="ncbi_term">customized makefile</span> <span class="ncbi_file">Makefile.hello.app</span>.
Now you can just go to the created working directory
<span class="ncbi_dir">internal/c++/src/hello/</span> and build the demo application
<span class="ncbi_app">hello.cgi</span> using:
<pre class="ncbi_cmd">
    make -f Makefile.hello_app
</pre>
</dl>

<p>
<a name="ref_OutsideCreate"></a>
<h3><span class="ncbi_cmd">scripts/new_project.sh &lt;name&gt; &lt;type&gt; [builddir]</span></h3>

<dl>
    <dt>
    <dd>
This script will create a startup <span class="ncbi_term">makefile</span> for a new, from-scratch
project called "<span class="ncbi_proj">name</span>" which uses the NCBI C++ Toolkit (and possibly the C Toolkit as
well).  For new libraries, <span class="ncbi_value">type=lib</span> while for new applications <span class="ncbi_value">type=app</span>.

<p></p>
Sample code will be included in the project directory for new applications.  Different samples
are available for <span class="ncbi_value">type=app[/basic]</span> (a command-line argument demo application based
on the <a href="libs.html#ref_SumXNCBI"><span class="ncbi_lib">corelib</span></a> library),
<span class="ncbi_value">type=app/cgi</span> (for a <a href="libs.html#ref_SumXCGI">CGI or Fast-CGI</a> application),
<span class="ncbi_value">type=app/objmgr</span> (for an application using the <span class="ncbi_term">Object Manager</span>) and <span class="ncbi_value">type=app/objects</span>
(for an application using ASN.1 objects).

<p></p>
You will need to slightly edit the resultant <span class="ncbi_term">makefile</span> to:
<ul>
  <li> specify the name of your library (or application)
  <li> specify the list of source files going to it
  <li> modify some preprocessor, compiler, etc.  flags, if needed
  <li> modify the set of additional libraries to link to it
       (if it's an application), if needed
</ul>

<p>
For example (<a href="scripts_usage.html#ref_New_ProjectUsage">full usage</a>):

<pre class="ncbi_cmd">
    <a href="new_project.create.session">new_project.sh foo app/basic</a>
</pre>


creates a model <span class="ncbi_term">makefile</span> <span class="ncbi_file">Makefile.foo_app</span> to build
an application using tools and flags hard-coded in <span class="ncbi_file">$NCBI/c++/Debug/build/Makefile.mk</span>,
and headers from <span class="ncbi_dir">$NCBI/c++/include/</span>.  The file <span class="ncbi_file">/tmp/foo/foo.cpp</span> is
also created; you can either replace this with your own <span class="ncbi_file">foo.cpp</span> or modify its sample
code as required.

<p></p>
Now, after specifying the application name, list of source files, etc.,
you can just go to the created working directory <span class="ncbi_dir">foo/</span> and build your application using:

<pre class="ncbi_cmd">
    make -f Makefile.foo_app
</pre>

<p>
You can easily change the active version of NCBI C++ Toolkit
by manually setting variable <span class="ncbi_make_var">$(builddir)</span> in the file
<span class="ncbi_file">Makefile.foo_app</span> to the desired Toolkit path, e.g.,
<span class="ncbi_code">builddir = $(NCBI)/c++/GCC-Release/build</span>
</dl>

<p>
<a name="ref_OutsideHello"></a>
<h3><span class="ncbi_cmd">scripts/hello.sh</span></h3>

<dl>
    <dt>
    <dd>
This script will:
<ul>
  <li> retrieve the demo CGI application project HELLO
  <li> create a standalone makefile to build it
  <li> build HELLO application using this makefile
  <li> run HELLO application
</ul>
It will produce the file <span class="ncbi_file">hello.html</span> containing a model
HTTP response. For more info on the HELLO CGI project see
in section
<a href="tools.html">NCBI C++ tools and applications</a> /
<a href="tools/hello/hello.html">HELLO.CGI -- a demo CGI application (NCBI C++)</a>.
</dl>

<!--#include virtual="./ssi/navlinks.shtml" -->

<table border=0 width="100%" cellspacing=0>
<script>
<!--
print_author('cpp-core', 'Denis Vakatov', '$Date$', 'ncbi.nlm.nih.gov');
print_author('cpp-core', 'Chris Lanczycki');
// -->
</script>
</table>

<!--#include virtual="./ssi/footer.shtml" -->
