<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Introduction to the C++ Toolkit - The NCBI C++ Toolkit Book [Internet] - NCBI</title><meta name="description" content="A comprehensive manual on the NCBI C++ toolkit, including its design and development framework, a C++ library reference, software examples and demos, FAQs and release notes." /><meta name="robots" content="index,nofollow,noarchive" /><meta name="page_id" content="ch_intro" /><meta name="page_type" content="chapter" /><meta name="ncbipopper" content="triggerPosition:'bottom left',destPosition:'top left',openEvent:'click',closeEvent:'click'" /><script type="text/javascript" src="js/jig/1.7/js/jig.min.js"></script><script type="text/javascript" src="js/toolkitSymbolSearch.js"></script><link type="text/css" rel="stylesheet" href="css/ptbooks.css" /><link type="text/css" rel="stylesheet" href="css/toolkit.css" /></head><body><div class="grid no_max_width"><div class="col twelve_col nomargin shadow"><div class="content"><div class="col eight_col"><div class="nvgtn"><a href="#__nav_cntnt" class="jig-ncbipopper">Contents â–¾</a><div style="display:none;width:700px;height:500px;overflow:auto;" id="__nav_cntnt"><a class="right" href="toc.html">Table of Contents Page</a><ul class="simple-list"><li class="half_rhythm"><a href="toolkit.fm.html">Book Information</a></li><li class="half_rhythm"><a href="part1.html">Part 1. Overview</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_intro.html">1. Introduction to the C++ Toolkit</a></li><li class="half_rhythm"><a href="ch_start.html">2. Getting Started</a></li></ul></li><li class="half_rhythm"><a href="part2.html">Part 2. Development Framework</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_getcode_svn.html">3. Retrieve the Source Code (FTP and Subversion)</a></li><li class="half_rhythm"><a href="ch_config.html">4. Configure, Build, and Use the Toolkit</a></li><li class="half_rhythm"><a href="ch_build.html">5. Working with Makefiles</a></li><li class="half_rhythm"><a href="ch_proj.html">6. Project Creation and Management</a></li><li class="half_rhythm"><a href="ch_style.html">7. Programming Policies and Guidelines</a></li></ul></li><li class="half_rhythm"><a href="part3.html">Part 3. C++ Toolkit Library Reference</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_core.html">8. Portability, Core Functionality and Application Framework</a></li><li class="half_rhythm"><a href="ch_conn.html">9. Networking and IPC</a></li><li class="half_rhythm"><a href="ch_dbapi.html">10. Database Access - SQL, Berkley DB</a></li><li class="half_rhythm"><a href="ch_cgi.html">11. CGI and Fast-CGI </a></li><li class="half_rhythm"><a href="ch_html.html">12. HTML</a></li><li class="half_rhythm"><a href="ch_ser.html">13. Data Serialization (ASN.1, XML)</a></li><li class="half_rhythm"><a href="ch_datamod.html">14. Biological Sequence Data Model</a></li><li class="half_rhythm"><a href="ch_objmgr.html">15. Biological Object Manager</a></li><li class="half_rhythm"><a href="ch_blast.html">16. BLAST API</a></li><li class="half_rhythm"><a href="ch_dataaccess.html">17. Access to NCBI data</a></li><li class="half_rhythm"><a href="ch_algoalign.html">18. Biological Sequence Alignment</a></li><li class="half_rhythm"><a href="ch_gui.html">19. GUI and Graphics</a></li><li class="half_rhythm"><a href="ch_boost.html">20. Using the Boost Unit Test Framework</a></li></ul></li><li class="half_rhythm"><a href="part4.html">Part 4. Wrappers for 3rd-Party Packages</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_xmlwrapp.html">21. XmlWrapp (XML parsing and handling, XSLT, XPath)</a></li></ul></li><li class="half_rhythm"><a href="part5.html">Part 5. Software</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_debug.html">22. Debugging, Exceptions, and Error Handling</a></li><li class="half_rhythm"><a href="ch_grid.html">23. Distributed Computing</a></li><li class="half_rhythm"><a href="ch_app.html">24. Applications</a></li><li class="half_rhythm"><a href="ch_demo.html">25. Examples and Demos</a></li><li class="half_rhythm"><a href="ch_res.html">26. C Toolkit Resources for C++ Toolkit Users</a></li></ul></li><li class="half_rhythm"><a href="part6.html">Part 6. Help and Support</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_browse.html">27. NCBI C++ Toolkit Source Browser</a></li><li class="half_rhythm"><a href="ch_devtools.html">28. Software Development Tools</a></li><li class="half_rhythm"><a href="ch_xmlauthor.html">29. XML Authoring using Word</a></li><li class="half_rhythm"><a href="ch_faq.html">30. FAQs, Useful Documentation Links, and Mailing Lists</a></li></ul></li><li class="half_rhythm"><a href="part7.html">Part 7. Library and Applications Configuration</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_libconfig.html">31. Library Configuration</a></li></ul></li><li class="half_rhythm"><a href="part8.html">Release Notes</a><ul class="simple-list"><li class="half_rhythm"><a href="release_notes.html">Release Notes (Version 9, May 2012)</a></li><li class="half_rhythm"><a href="release_notes_7-05_2011.html">Release Notes (Version 7, May 2011)</a></li><li class="half_rhythm"><a href="release_notes_06_29_2010.html">Release Notes (June, 2010)</a></li><li class="half_rhythm"><a href="release_notes_05_15_2009.html">Release Notes (May, 2009)</a></li><li class="half_rhythm"><a href="release_notes_12_24_2008.html">Release Notes (December, 2008)</a></li><li class="half_rhythm"><a href="release_notes_12_31_2008.html">Release Notes (March, 2008)</a></li><li class="half_rhythm"><a href="release_notes_08_27_2007.html">Release Notes (August, 2007)</a></li><li class="half_rhythm"><a href="release_notes_03_12_2007.html">Release Notes (March, 2007)</a></li><li class="half_rhythm"><a href="release_notes_08_14_2006.html">Release Notes (August, 2006)</a></li><li class="half_rhythm"><a href="release_notes_04_30_2006.html">Release Notes (April 30, 2006)</a></li><li class="half_rhythm"><a href="release_notes_12_31_2005.html">Release Notes (December 31, 2005)</a></li><li class="half_rhythm"><a href="release_notes_10_03_2005.html">Release Notes (August, 2005)</a></li><li class="half_rhythm"><a href="release_notes_05_05_2005.html">Release Notes (April, 2005)</a></li><li class="half_rhythm"><a href="release_notes_03_09_2005.html">Release Notes (February, 2005)</a></li><li class="half_rhythm"><a href="release_notes_11_22_2004.html">Release Notes (November 22, 2004)</a></li><li class="half_rhythm"><a href="release_notes_10_2_2004.html">Release Notes (October 2, 2004)</a></li><li class="half_rhythm"><a href="release_notes_7_8_2004.html">Release Notes (July 8, 2004)</a></li><li class="half_rhythm"><a href="release_notes_april_16_2004.html">Release Notes (April 16, 2004)</a></li><li class="half_rhythm"><a href="release_notes_12_08_2003.html">Release Notes (December 8, 2003)</a></li><li class="half_rhythm"><a href="release_notes_08_01_2003.html">Release Notes (August 1, 2003)</a></li></ul></li><li class="half_rhythm"><a href="app1.appendix1.html">Appendix - Books and Styles</a></li></ul></div><div class="pagination"><a class="pagelink active prev" title="Previous page" href="part1.html">&lt; Prev</a><a class="pagelink active next" title="Next page" href="ch_start.html">Next &gt;</a></div></div><div class="meta_content"><h1><span class="label">1</span><span class="title">Introduction to the C++ Toolkit</span></h1><p class="small">Last Update: January 29, 2013.</p></div><div class="body_content"><div class="sec"><h2><span class="title">Overview</span></h2><p>The overview for this chapter consists of the following topics:</p><ul><li><p>Introduction</p></li><li><p>Chapter Outline</p></li></ul><div class="sec"><h3><span class="title">Introduction</span></h3><p>One difficulty in understanding a major piece of software such as the C++ Toolkit is knowing where to begin in understanding the overall framework or getting the 'big picture' of how all the different components relate to each other. One approach is to dive into the details of one component and understand it in sufficient detail to get a roadmap of the rest of the components, and then repeat this process with the other components. Without a formal road map, this approach can be very time consuming and it may take a long time to locate the functionality one needs.</p><p>When trying to understand a major piece of software, it would be more effective if there is a written text that explains the overall framework without getting too lost in the details. This chapter is written with the intent to provide you with this broader picture of the C++ Toolkit.</p><p>This chapter provides an introduction to the major components that make up the toolkit. You can use this chapter as a roadmap for the rest of the chapters that follow.</p></div><div class="sec"><h3><span class="title">Chapter Outline</span></h3><p>The following is an outline of the topics presented in this chapter:</p><ul><li><p><a href="ch_intro.html#ch_intro.intro_corelib">The CORELIB Module</a></p><ul><li><p><a href="ch_intro.html#ch_intro.intro_appframe">Application Framework</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_args">Argument processing</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_diag">Diagnostics</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_env">Environment Interface</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_files_dirs">Files and Directories</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_mt_test">MT Test wrappers</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_cref">Object and Ref classes</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_pdef">Portability definitions</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_pexcep">Portable Exception Handling</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_pipe">Portable Process Pipes</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_reg">Registry</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_stl">STL Use Hints</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_str">String Manipulations</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_tempu">Template Utilities</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_threads">Threads</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_time">Time</a></p></li></ul></li><li><p><a href="ch_intro.html#ch_intro.intro_algo">The ALGORITHM Module</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_cgi">The CGI Module</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_conn">The CONNECT Module</a></p><ul><li><p><a href="ch_intro.html#ch_intro.intro_socket">Socket classes</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_connector">Connector and Connection Handles</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_streams">Connection Streams</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_sendmail">Sendmail API</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_threadedserver">Threaded Server</a></p></li></ul></li><li><p><a href="ch_intro.html#ch_intro.intro_ctool">The CTOOL Module</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_dbapi">The DBAPI Module</a></p><ul><li><p><a href="ch_intro.html#ch_intro.intro_dbapi_user">Database User Classes</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_dbapi_driver">Database Driver Architecture</a></p></li></ul></li><li><p><a href="ch_intro.html#ch_intro.intro_gui">The GUI Module</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_html">The HTML Module</a></p><ul><li><p><a href="ch_intro.html#ch_intro.intro_html_classes">Relationships between HTML classes</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_html_processing">HTML Processing</a></p></li></ul></li><li><p><a href="ch_intro.html#ch_intro.intro_objmgr">The OBJECT MANAGER Module</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_ser">The SERIAL Module</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_util">The UTIL Module</a></p><ul><li><p><a href="ch_intro.html#ch_intro.intro_checksum">Checksum</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_dumpv">Console Debug Dump Viewer</a></p></li><li><p><a href="ch_intro.html#ch_intro.Diff_API">Diff API</a></p></li><li><p><a href="ch_intro.html#ch_intro.Floating_Point_Comparison">Floating Point Comparison</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_lightstring">Lightweight Strings</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_linkedset">Linked Sets</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_random">Random Number Generator</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_range">Range Support</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_regdns">Registry based DNS</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_resizeiterator">Resizing Iterator</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_rotatelog">Rotating Log Streams</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_streamsupport">Stream Support</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_strsearch">String Search</a></p></li><li><p><a href="ch_intro.html#ch_intro.Synchronized_and_blo">Synchronized and blocking queue</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_thrpools">Thread Pools</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_utf8">UTF 8 Conversion</a></p></li></ul></li></ul></div></div><div class="sec" id="ch_intro.intro_corelib"><h2><span class="title">The CORELIB Module</span></h2><p>The C++ Toolkit can be seen as consisting of several major pieces of code that we will refer to as <i>module</i>. The core module is called, appropriately enough, CORELIB, and provides a portable way to write C++ code and many useful facilities such as an application framework, argument processing, template utilities, threads, etc. The CORELIB facilities are used by other major modules. The rest of the sections that follow discusses the CORELIB and the other C++ Toolkit modules in more detail.</p><p>The following is a list of the CORELIB facilities. Note that each facility may be implemented by a number of C++ classes spread across many files.</p><ul><li><p><a href="ch_intro.html#ch_intro.intro_appframe">Application Framework</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_args">Argument processing</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_diag">Diagnostics</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_env">Environment Interface</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_files_dirs">Files and Directories</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_mt_test">MT Test wrappers</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_cref">Object and Ref classes</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_pdef">Portability definitions</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_pexcep">Portable Exception Handling</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_pipe">Portable Process Pipes</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_reg">Registry</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_stl">STL Use Hints</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_str">String Manipulations</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_tempu">Template Utilities</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_threads">Threads</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_time">Time</a></p></li></ul><p>A brief description of each of each of these facilities are presented in the subsections that follow:</p><div class="sec" id="ch_intro.intro_appframe"><h3><span class="title">Application Framework</span></h3><p>The Application framework primarily consists of an abstract class called <span class="nctnt ncbi-class">CNcbiApplication</span> which defines the high level behavior of an application. For example, every application upon loading seems to go through a cycle of doing some initialization, then some processing, and upon completion of processing, doing some clean up activity before exiting. These three phases are modeled in the <span class="nctnt ncbi-class">CNcbiApplication</span> class as interface methods <span class="nctnt ncbi-func">Init()</span>, <span class="nctnt ncbi-func">Run()</span>, and <span class="nctnt ncbi-func">Exit()</span>.</p><p>A new application is written by deriving a class from the <span class="nctnt ncbi-class">CNcbiApplication</span> base class and writing an implementation of the <span class="nctnt ncbi-func">Init()</span>, <span class="nctnt ncbi-func">Run()</span>, and <span class="nctnt ncbi-func">Exit()</span> methods. Execution control to the new application is passed by calling the application object's <span class="nctnt ncbi-func">AppMain()</span> method inherited from the <span class="nctnt ncbi-class">CNcbiApplication</span> base class (see <a href="ch_intro.html#ch_intro.F1">Figure 1</a>). The <span class="nctnt ncbi-func">AppMain()</span> method is similar to the <span class="nctnt ncbi-func">main()</span> method used in C/C++ programs and calls the <span class="nctnt ncbi-func">Init()</span>, <span class="nctnt ncbi-func">Run()</span>, and <span class="nctnt ncbi-func">Exit()</span> methods.</p><div class="figure" id="ch_intro.F1"><div class="graphic"><img src="img/CNcbiApplication.gif" alt="Figure 1. The CNcbiApplication class" /></div><div class="caption"><p>Figure 1. The <span class="nctnt ncbi-class">CNcbiApplication</span> class</p></div></div><p>More details on <a href="ch_core.html#ch_core.writing_simple_app">using the CNcbiApplication class</a> are presented in a later chapter.</p></div><div class="sec" id="ch_intro.intro_args"><h3><span class="title">Argument processing</span></h3><p>In a C++ program, control is transferred from the command line to the program via the <span class="nctnt ncbi-func">main()</span> function. The <span class="nctnt ncbi-func">main()</span> function is passed a count of the number of arguments (int argc), and an array of character strings containing arguments to the program (<span class="nctnt ncbi-code">char** argv</span>). As long as the argument types are simple, one can simply set up a loop to iterate through the array of argument values and process them. However, with time applications evolve and grow more complex. Often there is a need to do some more complex argument checking. For example, the application may want to enforce a check on the number and position of arguments, check the argument type (int, string, etc.), check for constraints on argument values, check for flags, check for arguments that follow a keyword (<span class="nctnt ncbi-func">-logfile mylogfile.log</span>), check for mandatory arguments, display usage help on the arguments, etc.</p><p>To make the above tasks easier, the CORELIB provides a number of portable classes that encapsulate the functionality of argument checking and processing. The main classes that provide this functionality are the <span class="nctnt ncbi-class">CArgDescriptions</span>, <span class="nctnt ncbi-class">CArgs</span>, <span class="nctnt ncbi-class">CArgValue</span> classes.</p><p>Argument descriptions such as the expected number, type, position, mandatory and optional attributes are setup during an application's initilization such as the application object's <span class="nctnt ncbi-func">Init()</span> method (see <a href="ch_intro.html#ch_intro.intro_appframe">previous section</a>) by calling the <span class="nctnt ncbi-class">CArgDescriptions</span> class methods. Then, the arguments are extracted by calling the <span class="nctnt ncbi-class">CArgs</span> class methods.</p><p>More details on <a href="ch_core.html#ch_core.cmd_line_args">argument processing</a> are presented in a later chapter.</p></div><div class="sec" id="ch_intro.intro_diag"><h3><span class="title">Diagnostics</span></h3><p>It is very useful for an application to post messages about its internal state or other diagnostic information to a file, console or for that matter any output stream. The CORELIB provides a portable diagnostics facility that enables an application to post diagnostic messages of various severity levels to an output stream. This diagnostic facility is provided by the <span class="nctnt ncbi-class">CNcbiDiag</span> class. You can set the diagnostic stream to the standard error output stream (<span class="nctnt ncbi-code">NcbiErr</span>) or to any other output stream.</p><p>You can set the severity level of the message to Information, Warning, Error, Critical, Fatal, or Trace. You can alter the severity level at any time during the use of the diagnostic stream.</p><p>More details on <a href="ch_core.html#ch_core.CNcbiDiag">diagnostic streams</a> and <a href="ch_debug.html#ch_debug.std_cpp_message_post">processing of diagnostic messages</a> are presented in later chapters.</p></div><div class="sec" id="ch_intro.intro_env"><h3><span class="title">Environment Interface</span></h3><p>An application can read the environment variable settings (such as PATH) that are in affect when the application is run. CORELIB defines a portable <span class="nctnt ncbi-class">CNcbiEnvironment</span> class that stores the environment variable settings and provides applications with methods to get the environment variable values.</p><p>More details on the <a href="ch_core.html#ch_core.CNcbiEnvironment">environment interface</a> are presented in a later chapter.</p></div><div class="sec" id="ch_intro.intro_files_dirs"><h3><span class="title">Files and Directories</span></h3><p>An application may need access to information about a file or directory. The CORELIB provides a number of portable classes to model a system file and directory. Some of the important classes are <span class="nctnt ncbi-class">CFile</span> for modeling a file, <span class="nctnt ncbi-class">CDir</span> for modeling a directory, and <span class="nctnt ncbi-class">CMemoryFile</span> for memory mapped file.</p><p>For example, if you create a <span class="nctnt ncbi-class">CFile</span> object corresponding to a system file, you can get the file's attribute settings such as file size, permission settings, or check the existence of a file. You can get the directory where the file is located, the base name of the file, and the file's extension. There are also a number of useful functions that are made available through these classes to parse a file path or build a file path from the component parts such as a directory, base name, and extension.</p><p>More details on <a href="ch_core.html#ch_core.files_dirs">file and directory classes</a> are presented in later chapters.</p></div><div class="sec" id="ch_intro.intro_mt_test"><h3><span class="title">MT Test wrappers</span></h3><p>The <span class="nctnt ncbi-class">CNcbiApplication</span> class which was <a href="ch_intro.html#ch_intro.intro_appframe">discussed earlier</a> provides a framework for writing portable applications. For writing portable multi-threaded applications, the CORELIB provides a <span class="nctnt ncbi-class">CThreadedApp</span> class derived from <span class="nctnt ncbi-class">CNcbiApplication</span> class which provides a framework for building multi-threaded applications.</p><p>Instead of using the <span class="nctnt ncbi-func">Init()</span>, <span class="nctnt ncbi-func">Run()</span>, <span class="nctnt ncbi-func">Exit()</span> methods for the <span class="nctnt ncbi-class">CNcbiApplication</span> class, the <span class="nctnt ncbi-class">CThreadedApp</span> class defines specialized methods such as <span class="nctnt ncbi-func">Thread_Init()</span>, <span class="nctnt ncbi-func">Thread_Run()</span>, <span class="nctnt ncbi-func">Thread_Exit()</span>, <span class="nctnt ncbi-func">Thread_Destroy()</span> for controlling thread behavior. These methods operate on a specific thread identified by a thread index parameter.</p></div><div class="sec" id="ch_intro.intro_cref"><h3><span class="title">Object and Ref classes</span></h3><p>A major cause of errors in C/C++ programs is due to dynamic allocation of memory. Stated simply, memory for objects allocated using the new operator must be released by a corresponding delete operator. Failure to delete allocated memory results in memory leaks. There may also be programming errors caused by references to objects that have never been allocated or improperly allocated. One reason these types of problems crop up are because a programmer may dynamically allocate memory as needed, but may not deallocate it due to unanticipated execution paths.</p><p>The C++ standard provides the use of a template class, auto_ptr , that wraps memory management inside constructors and destructors. Because a destructor is called for every constructed object, memory allocation and deallocation can be kept symmetrical with respect to each other. However, the auto_ptr does not properly handle the issue of ownership when multiple auto pointers, point to the same object. What is needed is a reference counted smart pointer that keeps a count of the number of pointers pointing to the same object. An object can only be released when its reference count drops to zero.</p><p>The CORELIB implements a portable reference counted smart pointer through the <span class="nctnt ncbi-class">CRef</span> and <span class="nctnt ncbi-class">CObject</span> classes. The <span class="nctnt ncbi-class">CRef</span> class provides the interface methods to access the pointer and the <span class="nctnt ncbi-class">CObject</span> is used to store the object and the reference count.</p><p>More <a href="ch_core.html#ch_core.smart_ptrs">CObject classes</a> are presented in a later chapter.</p></div><div class="sec" id="ch_intro.intro_pdef"><h3><span class="title">Portability definitions</span></h3><p>To help with portability, the CORELIB uses only those C/C++ standard types that have some guarantees about size and representation. In particular, use of long, long long, float is not recommended for portable code.</p><p>To help with portability, integer types such as <span class="nctnt ncbi-code">Int1</span>, <span class="nctnt ncbi-code">Uint1</span>, <span class="nctnt ncbi-code">Int2</span>, <span class="nctnt ncbi-code">Uint2</span>, <span class="nctnt ncbi-code">Int4</span>, <span class="nctnt ncbi-code">Uint4</span>, <span class="nctnt ncbi-code">Int8</span>, <span class="nctnt ncbi-code">Uint8</span> have been defined with constant limits. For example, a signed integer of two bytes size is defined as type <span class="nctnt ncbi-code">Int2</span> with a minimum size of <span class="nctnt ncbi-code">kMin_I2</span> and a maximum size of <span class="nctnt ncbi-code">kMax_I2</span>. There are minimum and maximum limit constants defined for each of the different integer types.</p><p>More details on <a href="ch_core.html#ch_core.std_ncbi_types">standard portable data types</a> are presented in a later chapter.</p></div><div class="sec" id="ch_intro.intro_pexcep"><h3><span class="title">Portable Exception Handling</span></h3><p>C++ defines a structured exception handling mechanism to catch and process errors in a block of code. When the error occurs an exception is thrown and caught by an exception handler. The exception handler can then try to recover from the error, or process the error. In the C++ standard, there is only one exception class (std::exception), that stores a text message that can be printed out. The information reported by the std::exception may not be enough for a complex system. The CORELIB defines a portable <span class="nctnt ncbi-class">CException</span> class derived from std::exception class that remedies the short comings of the standard exception class</p><p>The CORELIB defines a portable <span class="nctnt ncbi-class">CException</span> class derived from std::exception class. The <span class="nctnt ncbi-class">CException</span> class in turn serves as a base class for many other exception classes specific to an application area such as the <span class="nctnt ncbi-class">CCoreException</span>, <span class="nctnt ncbi-class">CAppException</span>, <span class="nctnt ncbi-class">CArgException</span>, <span class="nctnt ncbi-class">CFileException</span>, and so on. Each of these derived classes can add facilities specific to the application area they deal with.</p><p>These exception classes provides many useful facilities such as a unique identification for every exception that is thrown, the location (file name and line number) where the exception occurred, references to lower-level exceptions that have already been thrown so that a more complete picture of the chain of exceptions is available, ability to report the exception data into an arbitrary output channel such as a diagnostic stream, and format the message differently for each channel.</p><p>More details on <a href="ch_debug.html#ch_debug.ncbi_cpp_exceptions">exceptions and exception handling</a> are presented in a later chapter.</p></div><div class="sec" id="ch_intro.intro_pipe"><h3><span class="title">Portable Process Pipes</span></h3><p>A pipe is a common mechanism used to establish communications between two separate processes. The pipe serves as a communication channel between processes.</p><p>The CORELIB defines the <span class="nctnt ncbi-class">CPipe</span> class that provides a portable inter-process communications facility between a parent process and its child process. The pipe is created by specifying the command and arguments used to start the child process and specifying the type of data channels (text or binary) that will connect the processes. Data is sent across the pipe using the <span class="nctnt ncbi-class">CPipe</span> read and write methods.</p></div><div class="sec" id="ch_intro.intro_reg"><h3><span class="title">Registry</span></h3><p><span class="nctnt highlight">N.B.</span> The preferred way to define configuration parameters for an application is to use the macros in the <span class="nctnt ncbi-class">CParam</span> class (e.g. <span class="nctnt ncbi-macro">NCBI_PARAM_DECL</span>). More <a href="ch_core.html#ch_core.Configuration_Parame">details on the CParam class and its macros</a> are presented in a later chapter. If the <span class="nctnt ncbi-class">CParam</span> class cannot be used, then the registry may be used instead.</p><p>The settings for an application may be read from a configuration or initialization file (the "registry"). This configuration file may define the parameters needed by the application. For example, many Unix programs read their parameter settings from configuration files. Similarly, Windows programs may read and store information in an internal registry database, or an initialization file.</p><p>The <span class="nctnt ncbi-class">CNcbiRegistry</span> class provides a portable facility to access, modify and store runtime information read from a configuration file. The configuration file consists of sections. A section is defined by a section header of the form [<b><i>section-header-name</i></b>].  Within each section, the parameters are defined using (name, value) pairs and represented as <b><i>name=value</i></b> strings. The syntax closely resembles the '<span class="nctnt ncbi-path">.ini</span>' files used in Windows and also by Unix tools such as Samba.</p><p>More details on the <a href="ch_core.html#ch_core.CNcbiRegistry">Registry</a> are presented in a later chapter.</p></div><div class="sec" id="ch_intro.intro_stl"><h3><span class="title">STL Use Hints</span></h3><p>To minimize naming conflicts, all NCBI code is placed in the ncbi name space. The CORELIB defines a number of portable macros to help manage name space definitions. For example, you can use the <span class="nctnt ncbi-macro">BEGIN_NAME_SPACE</span> macro at the start of a section of code to place that code in the specified name space. The <span class="nctnt ncbi-macro">END_NAME_SPACE</span> macros is used to indicate the end the of the name space definition. To declare the use of the NCBI namespace, the macros <span class="nctnt ncbi-macro">USING_NCBI_SCOPE</span> is used.</p><p>A number of macros have been defined to handle non-standard behavior of C++ compilers. For example, a macro <span class="nctnt ncbi-macro">BREAK</span> is defined, that is used to break out of a loop, instead of using the break statement directly. This is done to handle a bug in the Sun WorkShop (pre 5.3 version) compiler that fails to call destructors for objects created in for-loop initializers. Another example is that some compilers (example, Sun Pro 4.2) do not understand the using namespace std; statement. Therefore, for portable code, the using namespace statement should be prohibited.</p><p>More details on the <a href="ch_style.html#ch_style.using_NCBI_namespace">use of portable macros</a> are presented in a later chapter.</p></div><div class="sec" id="ch_intro.intro_str"><h3><span class="title">String Manipulations</span></h3><p>C++ defines the standard string class that provides operations on strings. However, compilers may exhibit non-portable string behavior especially with regards to multi-threaded programs. The CORELIB provides portable string manipulation facilities through the <span class="nctnt ncbi-class">NStr</span> class that provides a number of class-wide functions for string manipulation.</p><p><span class="nctnt ncbi-class">NStr</span> portable functions include the string-to-X and X-to-string conversion functions where X is a data type including a pointer type, string comparisons with and without case, pattern searches within a string, string truncation, substring replacements, string splitting and join operations, string tokenization, etc.</p></div><div class="sec" id="ch_intro.intro_tempu"><h3><span class="title">Template Utilities</span></h3><p>The C++ Template classes support a number of useful template classes for data structures such as vectors, lists, sets, maps, and so on.</p><p>The CORELIB defines a number of useful utility template classes. Some examples are template classes and functions for checking for equality of objects through a pointer, checking for non-null values of pointers, getting and setting map elements, deleting all elements from a container of pointers where the container can be a list, vector, set, multiset, map or multimap.</p><p>More details on the <a href="ch_core.html#ch_core.template_utils">template utilities</a> are presented in a later chapter.</p></div><div class="sec" id="ch_intro.intro_threads"><h3><span class="title">Threads</span></h3><p>Applications can run faster, if they are structured to exploit any inherent parallelism in the application's code execution paths. Code execution paths in an application can be assigned to separate threads. When the application is run on a multiprocessor system, there can be significant improvements in performance especially when threads run in parallel on separate processors.</p><p>The CORELIB defines a portable <span class="nctnt ncbi-class">CThread</span> class that can be used to provide basic thread functionality such as thread creation, thread execution, thread termination, and thread cleanup.</p><p>To create user defined threads you need to derive your class from <span class="nctnt ncbi-class">CThread</span>, and override the thread's <span class="nctnt ncbi-func">Main()</span> method and, and if necessary the <span class="nctnt ncbi-func">OnExit()</span> method for thread-specific cleanup. Next, you create a thread object by instantiating the class you derived from <span class="nctnt ncbi-class">CThread</span>. Now you are ready to launch thread execution by calling the thread's <span class="nctnt ncbi-func">Run()</span> method. The <span class="nctnt ncbi-func">Run()</span> method starts thread execution and the thread will continue to run until it terminates. If you want the thread to run independently of the parent thread you call the thread's <span class="nctnt ncbi-func">Detach()</span> method. If you want to wait till the thread terminates, you call the thread's <span class="nctnt ncbi-func">Join()</span> method.</p><p>Synchronization between threads is provided through mutexes and read/write locks.</p><p>More details on <a href="ch_core.html#ch_core.threads">threads</a> and <a href="ch_core.html#ch_core.mutexes">synchronization</a> are presented in a later chapter.</p></div><div class="sec" id="ch_intro.intro_time"><h3><span class="title">Time</span></h3><p>The <span class="nctnt ncbi-class">CTime</span> class provides a portable interface to date and time functions. <span class="nctnt ncbi-class">CTime</span> can operate with both local and UTC time, and can be used to store data and time at a particular moment or elapsed time. The time epoch is defined as Jan 1, 1900 so you cannot use <span class="nctnt ncbi-class">CTime</span> for storing timestamps before Jan 1, 1900.</p><p>The <span class="nctnt ncbi-class">CTime</span> class can adjust for daylight savings time. For display purposes, the time format can be set to a variety of time formats specified by a format string. For example, "M/D/Y h:m:s" for a timestamp of "5/6/03 14:07:09". Additional time format specifiers are defined for full month name (B), abbreviated month name (b), nanosecond (S), timezone format (Z), full weekday name (W) and abbreviated weekday name (w).</p><p>A class <span class="nctnt ncbi-class">CStopWatch</span> is also available that acts as a stop watch and measures elapsed time via the <span class="nctnt ncbi-func">Elapsed()</span> method, after its <span class="nctnt ncbi-func">Start()</span> method is called.</p><p>More details on the <a href="ch_core.html#ch_core.portable_time_class">CTime class</a> are presented in a later chapter.</p></div></div><div class="sec" id="ch_intro.intro_algo"><h2><span class="title">The ALGORITHM Module</span></h2><p>The ALGORITHM module is a collection of rigorously defined, often computationally intensive algorithms performed on sequences. It is divided into three groups:</p><ul><li><p>ALIGN. A set of global alignment algorithms, including generic Needleman-Wunsch, a linear-space Hirschberg's algorithm and a spliced (cDna/mRna-to-Genomic) alignment algorithm.</p></li><li><p>BLAST. Basic Local Alignment Tool code and interface.</p></li><li><p>SEQUENCE. Various algorithms on biological sequences, including antigenic determinant prediction, CPG-island finder, ORF finder, string matcher and others.</p></li></ul></div><div class="sec" id="ch_intro.intro_cgi"><h2><span class="title">The CGI Module</span></h2><p>The CGI module provides an integrated framework for writing CGI applications. It consists of classes that implement the CGI (Common Gateway Interface). These classes are used to retrieve and parse an HTTP request, and then compose and deliver an HTTP response.</p><p>The CGI module consists of a number of classes. The interaction between these classes is fairly complex, and therefore, not covered in this introductory chapter. We will attempt to only identify the major classes in this overview, and cover the details of their interaction in later chapters. Among the more important of the CGI classes are the <span class="nctnt ncbi-class">CCgiApplication</span>, <span class="nctnt ncbi-class">CCgiContext</span>, <span class="nctnt ncbi-class">CCgiRequest</span>, <span class="nctnt ncbi-class">CCgiResponse</span>, and <span class="nctnt ncbi-class">CCgiCookie</span>.</p><p>The <span class="nctnt ncbi-class">CCgiApplication</span> is used to define the CGI application and is derived from the <span class="nctnt ncbi-class">CNcbiApplication</span><a href="ch_intro.html#ch_intro.intro_appframe"> discussed eariler</a>. You write a CGI application by deriving application class from <span class="nctnt ncbi-class">CCgiApplication</span> and providing an adoption of the <span class="nctnt ncbi-func">Init()</span>, <span class="nctnt ncbi-func">Run()</span>, and <span class="nctnt ncbi-func">Exit()</span> methods inherited from the <span class="nctnt ncbi-class">CNcbiApplication</span> class. Details on <a href="ch_cgi.html#ch_cgi.cgi_app_class">how to implement the Init(), Run() and Exit() methods for a CGI application</a> are provided in a later chapter.</p><p>The <span class="nctnt ncbi-class">CCgiRequest</span> class is defined to receive and parse the request, and the <span class="nctnt ncbi-class">CCgiResponse</span> class outputs the response to an output stream.</p><p>The <span class="nctnt ncbi-class">CCgiCookie</span> class models a <i>cookie</i>. A cookie is a name, value string pair that can be stored on the user's web browser in an attempt to remember a session state. All incoming <span class="nctnt ncbi-class">CCgiCookies</span> are parsed and stored by the <span class="nctnt ncbi-class">CCgiRequest</span> object, and the outgoing cookies are sent along with the response by the <span class="nctnt ncbi-class">CCgiResponse</span> object.</p><p>The CGI application executes in a 'context' defined by the <span class="nctnt ncbi-class">CCgiContext</span> class. The <span class="nctnt ncbi-class">CCgiContext</span> class provides a wrapper for the <span class="nctnt ncbi-class">CCgiApplication</span>, <span class="nctnt ncbi-class">CCgiRequest</span> and <span class="nctnt ncbi-class">CCgiResponse</span> objects and drives the processing of input requests.</p><p>More details on <a href="ch_cgi.html#ch_cgi.cgi_class_overview">CGI classes and their interactions</a> are presented in a later chapter.</p></div><div class="sec" id="ch_intro.intro_conn"><h2><span class="title">The CONNECT Module</span></h2><p>The CONNECT module implements a variety of interfaces and classes dealing with making connections to a network services. The core of the Connection Library is written in C which provides a low level interface to the communication protocols. The CONNECT module provides C++ interfaces so that the objects have diagnostic and error handling capabilities that are consistent with the rest of the toolkit. The standard sockets (SOCK) API is implemented on a variety of platforms such as Unix, MS-Windows, MacOS, Darwin. The CONNECT module provides a higher level access to the SOCK API by using C++ wrapper classes.</p><p>The following is a list of topics presented in this section:</p><ul><li><p><a href="ch_intro.html#ch_intro.intro_socket">Socket classes</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_connector">Connector and Connection Handles</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_streams">Connection Streams</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_sendmail">Sendmail API</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_threadedserver">Threaded Server</a></p></li></ul><div class="sec" id="ch_intro.intro_socket"><h3><span class="title">Socket classes</span></h3><p>The C++ classes that implement the socket interface are <span class="nctnt ncbi-class">CSocket</span>, <span class="nctnt ncbi-class">CDatagramSocket</span>, <span class="nctnt ncbi-class">CListeningSocket</span>, and <span class="nctnt ncbi-class">CSocketAPI</span>. The socket defines an end point for a connection which consists of an IP address (or host name) of the end point, port number and transport protocol used (TCP, UDP).</p><p>The <span class="nctnt ncbi-class">CSocket</span> class encapsulates the descriptions of both local and remote end points. The local end point, which is the end point on the client issuing a connection request, is defined as parameters to the <span class="nctnt ncbi-class">CSocket</span> constructor. The remote end point on which the network service is running is specified as parameters to the <span class="nctnt ncbi-func">Connect()</span> method for the <span class="nctnt ncbi-class">CSocket</span> class. The <span class="nctnt ncbi-class">CSocket</span> class defines additional methods to manage the connection such as <span class="nctnt ncbi-func">Reconnect()</span> to reconnect to the same end point as the <span class="nctnt ncbi-func">Connect()</span> method; the <span class="nctnt ncbi-func">Shutdown()</span> method to terminate the connection; the <span class="nctnt ncbi-func">Wait()</span> method to wait on several sockets at once; the <span class="nctnt ncbi-func">Read()</span> and <span class="nctnt ncbi-func">Write()</span> methods to read and write data via the socket; and a number of other support methods.</p><p>The <span class="nctnt ncbi-class">CSocket</span> is designed for connection-oriented services such as those running over the TCP transport protocol. For connectionless, or datagram services, such as those running over the UDP transport protocol, you must use the <span class="nctnt ncbi-class">CDatagramSocket</span> class. The local end point is defined as parameters to the <span class="nctnt ncbi-class">CDatagramSocket</span> constructor. The remote end point is specified as parameters to the <span class="nctnt ncbi-func">Connect()</span> method for the <span class="nctnt ncbi-class">CDatagramSocket</span> class. Unlike the case of the connection-oriented services, this <span class="nctnt ncbi-func">Connect()</span> method only specifies the default destination address, and does not restrict the source address of the incoming messages. The methods <span class="nctnt ncbi-func">Send()</span> and <span class="nctnt ncbi-func">Recv()</span> are used to send the datagram, and the method <span class="nctnt ncbi-func">SetBroadcast()</span> sets the socket to broadcast messages sent to the datagram socket. The <span class="nctnt ncbi-class">CDatagramSocket</span> is derived from the <span class="nctnt ncbi-class">CSocket</span> class but methods such as <span class="nctnt ncbi-func">Shutdown()</span> and <span class="nctnt ncbi-func">Reconnect()</span> that apply to connection-oriented services are not available to users of the <span class="nctnt ncbi-class">CDatagramSocket</span> class.</p><p>The <span class="nctnt ncbi-class">CListeningSocket</span> is used by server-side applications to listen for connection requests. The <span class="nctnt ncbi-class">CListeningSocket</span> constructor specifies the port to listen to and the size of the connection request queue. You can change the port that the server application listens to any time by using the <span class="nctnt ncbi-func">Listen()</span> method. The <span class="nctnt ncbi-func">Accept()</span> method accepts the connection request, and returns a <span class="nctnt ncbi-class">CSocket</span> object through which data is transferred.</p><p>The <span class="nctnt ncbi-class">CSocketAPI</span> is a C++ wrapper for class-wide common socket utility functions available for sockets such as the <span class="nctnt ncbi-func">gethostname()</span>, <span class="nctnt ncbi-func">gethostbyaddr()</span>, <span class="nctnt ncbi-func">ntoa()</span>, <span class="nctnt ncbi-func">aton()</span>, and so on.</p></div><div class="sec" id="ch_intro.intro_connector"><h3><span class="title">Connector and Connection Handles</span></h3><p>The SOCK interface is a relatively low-level interface for connection services. The CONNECT module provides a generalization of this interface to connection services using a connection type and specialized connectors.</p><p>A connection is modeled by a connection type and a connector type. The connector type models the end point of the connection, and the connection type, the actual connection. Together, the connector and connection objects are used to define the following types of connections: socket, file, http, memory, and a general service connection.</p><p>The connector is described by a connector handle, CONNECTOR. CONNECTOR is a typedef and defined as a pointer to an internal data structure.</p><p>The connection is described by a connection handle CONN. CONN is a typedef and defined as a pointer to an internal structure. The CONN type is used as a parameter to a number of functions that handle the connection such as <span class="nctnt ncbi-func">CONN_Create()</span>, <span class="nctnt ncbi-func">CONN_ReInit()</span>, <span class="nctnt ncbi-func">CONN_Read()</span>, <span class="nctnt ncbi-func">CONN_Write()</span>, etc.</p><p>The CONNECTOR socket handle is created by a call to the <span class="nctnt ncbi-func">SOCK_CreateConnector()</span> function and passed the host name to connect to, the port number on the host to connect to, and maximum number of retries. The CONNECTOR handle is then passed as an argument to the <span class="nctnt ncbi-func">CONN_Create()</span> which returns a CONNECTION handle. The CONNECTION handle is then used with the connection functions (that have the prefix CONN_) to process the connection. The connection so created is bi-directional (full duplex) and input and output data can be processed simultaneously.</p><p>The other connector types, file, http, memory are similar to the socket connector type. In the case of a file connector, the connector handle is created by calling the <span class="nctnt ncbi-func">FILE_CreateConnector()</span> function and passed an input file and an output file. This connector could be used for both reading and writing files, when input comes from one file, and output goes to another file. This differs from normal file I/O when a single handle is used to access only one file, but resembles data exchange via sockets, instead. In the case of the HTTP connection, the <span class="nctnt ncbi-type">HTTP_CreateConnector</span> type is called and passed a pointer to network information structure, a pointer to a user-header consisting of HTTP tag-values, and a bitmask representing flags that affect the HTTP response.</p><p>The general service connector is the most complex connector in the library, and can model any type of service. It can be used for data transfer between an application and a named service. The data can be sent via HTTP or directly as a byte stream (using SOCK directly). In the former case it uses the HTTP connectors and in the latter the SOCK connectors. The general service connector is used when the other connector types are not adequate for implementing the task on hand.</p><p>More details on <a href="ch_conn.html#ch_conn.socket_connector">connector classes</a> are presented in a later chapter.</p></div><div class="sec" id="ch_intro.intro_streams"><h3><span class="title">Connection Streams</span></h3><p>The CONNECT module provides a higher level of abstraction to connection programming in the form of C++ connection stream classes derived from the standard iostream class. This makes the familiar stream I/O operators, manipulators available to the connection stream. The main connection stream classes are the <span class="nctnt ncbi-class">CConn_IOStream</span>, <span class="nctnt ncbi-class">CCon_SocketStream</span>, <span class="nctnt ncbi-class">CCon_HttpStream</span>, <span class="nctnt ncbi-class">CCon_ServiceStream</span>, and <span class="nctnt ncbi-class">CCon_MemoryStream</span>.</p><p><a href="ch_intro.html#ch_intro.F2">Figure 2</a> shows the relationship between the different stream classes. From this figure we can see that <span class="nctnt ncbi-class">CConn_IOStream</span> is derived from the C++ iostream class and serves as a base class for all the other connection stream classes. The <span class="nctnt ncbi-class">CCon_IOStream</span> allows input operations to be tied to the output operations so that any input attempt first flushes the output queue from the internal buffers.</p><div class="figure" id="ch_intro.F2"><div class="graphic"><img src="img/CConn_IOStream.gif" alt="Figure 2. Connection stream classes" /></div><div class="caption"><p>Figure 2. Connection stream classes</p></div></div><p>The <span class="nctnt ncbi-class">CCon_SocketStream</span> stream models a stream of bytes in a bi-directional TCP connection between two end points specified by a host/port pair. As the name suggests the socket stream uses the socket interface directly. The <span class="nctnt ncbi-class">CCon_HttpStream</span> stream models a stream of data between and HTTP client and an HTTP server (such as a web server). The server end of the stream is identified by a URL of the form <span class="nctnt ncbi-monospace">http://host[:port]/path[?args]</span>. The <span class="nctnt ncbi-class">CCon_ServiceStream</span> stream models data transfer with a named service that can be found via dispatcher/load-balancing daemon and implemented as either HTTP CGI, standalone server, or NCBI service. The <span class="nctnt ncbi-class">CCon_MemoryStream</span> stream models data transfer in memory similar to the C++ strstream class.</p><p>More details on <a href="ch_conn.html#ch_conn.cpp_connection_streams">connection stream classes</a> are presented in a later chapter.</p></div><div class="sec" id="ch_intro.intro_sendmail"><h3><span class="title">Sendmail API</span></h3><p>The CONNECT module provides an API that provides access to SMTP protocol. SMTP (Simple Mail Transfer Protocol) is a standard email relaying protocol used by many popular MTAs (Message Transfer Agents), such as sendmail, smail, etc, found on many systems. SMTP passes (relays) email messages between hosts in the Internet all the way from sender to recipient.</p><p>To initiate the use of the sendmail API, you must call the <span class="nctnt ncbi-func">SendMailInfo_Int()</span> function that initializes structure <span class="nctnt ncbi-func">SSendMailInfo</span>, passed by a pointer. Your code then modifies the structure to contain proper information such as that expected in a mail header (To, From, CC, BCC fields) and other communication settings from their default values set at initialization. Then, you can send email using the <span class="nctnt ncbi-func">CORE_SendMail()</span> or <span class="nctnt ncbi-func">CORE_SendMailEx()</span> functions.</p></div><div class="sec" id="ch_intro.intro_threadedserver"><h3><span class="title">Threaded Server</span></h3><p>The CONNECT module provides support for multithreaded servers through the <span class="nctnt ncbi-class">CThreadedServer</span> class. The <span class="nctnt ncbi-class">CThreadedServer</span> class is an abstract class for network servers and uses thread pools. This class maintains a pool of threads, called worker threads, to process incoming connections. Each connection gets assigned to one of the worker threads, allowing the server to handle multiple requests in parallel while still checking for new requests.</p><p>You must derive your threaded server from the <span class="nctnt ncbi-class">CThreadedServer</span> class and define the <span class="nctnt ncbi-func">Process()</span> method to indicate what to do with each incoming connection. The <span class="nctnt ncbi-func">Process()</span> method runs asynchronously by using a separate thread for each request.</p><p>More details on threaded server classes are presented in a later chapter.</p></div></div><div class="sec" id="ch_intro.intro_ctool"><h2><span class="title">The CTOOL Module</span></h2><p>The CTOOL module provides bridge mechanisms and conversion functions. More specifically, the CTOOL module provides a number of useful functions such as a bridge between the NCBI C++ Toolkit and the older C Toolkit for error handling, an ASN.1 connections stream that builds on top of the <a href="ch_intro.html#ch_intro.intro_connector">connection stream</a>, and an ASN converter that provides templates for converting ASN.1-based objects between NCBI's C and C++ in-memory layouts.</p><p>The ASN.1 connections support is provides through functions <span class="nctnt ncbi-func">CreateAsnConn()</span> for creating an ASN stream connection; <span class="nctnt ncbi-func">CreateAsnConn_ServiceEx()</span> for creating a service connection using the service name, type and connection parameters; and <span class="nctnt ncbi-func">CreateAsnConn_Service()</span> which is a specialized case of <span class="nctnt ncbi-func">CreateAsnConn_ServiceEx()</span> with some parameters set to zero.</p></div><div class="sec" id="ch_intro.intro_dbapi"><h2><span class="title">The DBAPI Module</span></h2><p>The DBAPI module supports object oriented access to databases by providing user classes that model a database as a data source to which a connection can be made, and on which ordinary SQL queries or stored procedure SQL queries can be issued. The results obtained can be navigated using a result class or using the 'cursor' mechanism that is common to many databases.</p><p>The user classes are used by a programmer to access the database. The user classes depend upon a database driver to allow low level access to the underlying relational database management system (RDBMS). Each type of RDBMS can be expected to have a different driver that provides this low level hook into the database. The database drivers are architected to provide a uniform interface to the user classes so that the database driver can be changed to connect to a different database without affecting the program code that makes use of the user classes. For a list of the database drivers for different database that are supported, see the <a href="ch_dbapi.html#ch_dbapi.dbapi_drivers">Supported DBAPI Drivers section</a>.</p><p>The following is a list of topics presented in this section:</p><ul><li><p><a href="ch_intro.html#ch_intro.intro_dbapi_user">Database User Classes</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_dbapi_driver">Database Driver Architecture</a></p></li></ul><div class="sec" id="ch_intro.intro_dbapi_user"><h3><span class="title">Database User Classes</span></h3><p>The interface to the database is provided by a number of C++ classes such as the <span class="nctnt ncbi-class">IDataSource, IDbConnection, IStatement, ICallableStatement, ICursor, IResultSet, IResultSetMetaData</span> . The user does not use these interfaces directly. Instead, the DBAPI module provides concrete classes that implement these interface classes. The corresponding concrete classes for the above mentioned interfaces are <span class="nctnt ncbi-class">CDataSource, CDbConnection, CStatement, CCallableStatement, CCursor, CResultSet, CResultSetMetaData</span>.</p><p>Before accessing to a specific database, the user must register the driver with the <span class="nctnt ncbi-class">CDriverManager</span> class which maintains the drivers registered for the application. The user does this by using the <span class="nctnt ncbi-class">CDriverManager</span> class' factory method <span class="nctnt ncbi-func">GetInstance()</span> to create an instance of the <span class="nctnt ncbi-class">CDriverManager</span> class and registering the driver with this driver manager object. For details on how this can be done, see the <a href="ch_dbapi.html#ch_dbapi.dbapi_choose_driver">Choosing the Driver</a> section.</p><p>After the driver has been registered, the user classes can be used to access that database. There are a number of ways this can be done, but the most common method is to call the <span class="nctnt ncbi-class">IDataSource</span> factory method <span class="nctnt ncbi-func">CreateDs()</span> to create an instance of the data source. Next, the <span class="nctnt ncbi-func">CreateConnection()</span> method for the data source is called, to return a connection object that implements the <span class="nctnt ncbi-class">IConnection</span> interface. Next, the connection object's <span class="nctnt ncbi-func">Connect()</span> method is called with the user name, password, server name, database name to make the connection to the database. Next, the connection object's <span class="nctnt ncbi-func">CreateStatement()</span> method is called to create a statement object that implements the <span class="nctnt ncbi-class">IStatement</span> interface. Next, the statement object's <span class="nctnt ncbi-func">Execute()</span> method is called to execute the query. Note that additional calls to the <span class="nctnt ncbi-func">IConnection::CreateStatement()</span> results in cloning the connection for each statement which means that these connections inherit the database which was specified in the <span class="nctnt ncbi-func">Connect()</span> or <span class="nctnt ncbi-func">SetDatabase()</span> method.</p><p>Executing the statement objects' <span class="nctnt ncbi-func">Execute()</span> method returns the result set which is stored in the statement object and can be accessed using the statement object's <span class="nctnt ncbi-func">GetResultSet()</span> method. You can then call the statement object's <span class="nctnt ncbi-func">HasRows()</span> method which returns a Boolean true if there are rows to be processed. The type of the result can be obtained by calling the <span class="nctnt ncbi-func">IResultSet::GetResultType() method</span>. The <span class="nctnt ncbi-func">IStatement::ExecuteUpdate()</span> method is used for SQL statements that do not return rows (UPDATE or DELETE SQL statement), in which case the method <span class="nctnt ncbi-func">IStatement::GetRowCount()</span> returns the number of updated or deleted rows.</p><p>Calling the <span class="nctnt ncbi-func">IStatement::GetResultSet()</span> returns the rows via the result set object that implements the <span class="nctnt ncbi-class">IResultSet</span> interface. The method <span class="nctnt ncbi-func">IResultSet::Next()</span> is used to fetch each row in the result set and returns a false when no more fetch data is available; otherwise, it returns a true. All column data, except BLOB data is represented by a <span class="nctnt ncbi-class">CVariant</span> object. The method <span class="nctnt ncbi-func">IResultSet::GetVariant()</span> takes the column number as its parameter where the first column has the start value of 1.</p><p>The <span class="nctnt ncbi-class">CVariant</span> class is used to describe the fields of a record which can be of any data type. The <span class="nctnt ncbi-class">CVariant</span> has a set of accessory methods (<span class="nctnt ncbi-func">GetXXX()</span>) to extract a value of a particular type. For example, the <span class="nctnt ncbi-func">GetInt4(), GetByte(), GetString()</span>, methods will extract an Int4, Byte data value from the <span class="nctnt ncbi-class">CVariant</span> object. If data extraction is not possible because of incompatible types, the <span class="nctnt ncbi-class">CVariantException</span> is thrown. The <span class="nctnt ncbi-class">CVariant</span> has a set of factory methods for creating objects of a particular data type, such as <span class="nctnt ncbi-func">CVariant::BigInt()</span> for Int8, <span class="nctnt ncbi-func">CVariant::SmallDateTime()</span> for NCBI's <span class="nctnt ncbi-class">CTime</span>, and so on.</p><p>For sample code illustrating the above mentioned steps, see the <a href="ch_dbapi.html#ch_dbapi.dbapi_src_cnxns">Data Source and Connections</a> and <a href="ch_dbapi.html#ch_dbapi.dbapi_main_loop">Main Loop</a> sections.</p></div><div class="sec" id="ch_intro.intro_dbapi_driver"><h3><span class="title">Database Driver Architecture</span></h3><p>The driver can use two different methods to access the particular RDBMS. If RDBMS provides a client library (<span class="nctnt ncbi-lib">CTLib</span>) for a given computer system, then the driver utilizes this library. If there is no client library, then the driver connects to RDBMS through a special gateway server which is running on a computer system where such library does exist.</p><p>The database driver architecture has two major groups of the driver's objects: the RDBMS independent objects, and the RDBMS dependent objects specific to a RDBMS. From a user's perspective, the most important RDBMS dependent object is the driver context object. A connection to the database is made by calling the driver context's <span class="nctnt ncbi-func">Connect()</span> method. All driver contexts implement the same interface defined in the <span class="nctnt ncbi-class">I_DriverContext</span> class.</p><p>If the application needs to connect to RDBMS libraries from different vendors, there is a problem trying to link statically with the RDBMS libraries from different vendors. The reason for this is that most of these libraries are written in C, and may use the same names which cause name collisions. Therefore, the <span class="nctnt ncbi-class">C_DriverMgr</span> is used to overcome this problem and allow the creation of a mixture of statically linked and dynamically loaded drivers and use them together in one executable.</p><p>The low level connection to an RDBMS is specific to that RDBMS. To provide RDBMS independence, the connection information is wrapped in an RDBMS independent object <span class="nctnt ncbi-class">CDB_Connection</span>. The commands and the results are also wrapped in an RDBMS independent object. The user is responsible for deleting these RDBMS independent objects because the life spans of the RDBMS dependent and RDBMS independent objects are not necessarily the same.</p><p>Once you have the <span class="nctnt ncbi-class">CDB_Connection</span> object, you can use it as a factory for the different types of command objects. The command object's <span class="nctnt ncbi-func">Result()</span> method can be called to get the results. To send and to receive the data through the driver you must use the driver provided datatypes such as <span class="nctnt ncbi-class">CDB_BigInt, CDB_Float, CDB_SmallDateTime</span>. These driver data types are all derived from <span class="nctnt ncbi-class">CDB_Object</span> class.</p><p>More <a href="ch_dbapi.html#ch_dbapi.dbapi_driver_ref">details on the database driver architecture</a> is presented in a later chapter.</p></div></div><div class="sec" id="ch_intro.intro_gui"><h2><span class="title">The GUI Module</span></h2><p>The C++ Toolkit does not include its own GUI Module. Instead, Toolkit-based GUI applications make use of third party GUI packages. Depending on the requirements, we recommend either <a href="http://www.wxwidgets.org/">wxWidgets</a> or <a href="http://www.fox-toolkit.org/">FOX</a>.</p><p>More details on developing GUI application in conjunction with the C++ Toolkit are presented in a <a href="ch_gui.html">later chapter</a>.</p></div><div class="sec" id="ch_intro.intro_html"><h2><span class="title">The HTML Module</span></h2><p>The HTML module implements a number of HTML classes that are intended for use in CGI and other programs. The HTML classes can be used to generate HTML code dynamically.</p><p>The HTML classes can be used to represent HTML page internally in memory as a graph. Each HTML element or tag is represented by a node in the graph. The attributes for an HTML element are represented as attributes in the node. A node in the graph can have other elements as children. For example, for an HTML page, the top HTML element will be described by an HTML node in the graph. The HTML node will have the HEAD and BODY nodes as its children. The BODY node will have text data and other HTML nodes as its children. The graph structure representation of an HTML page allows easy additions, deletions and modification of the page elements.</p><p>Note that while the HTML classes can be used to represent the HTML page internally in memory as a graph there is no provision for parsing of existing HTML pages to generate these classes.</p><p>The following is a list of topics presented in this section:</p><ul><li><p><a href="ch_intro.html#ch_intro.intro_html_classes">Relationships between HTML classes</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_html_processing">HTML Processing</a></p></li></ul><div class="sec" id="ch_intro.intro_html_classes"><h3><span class="title">Relationships between HTML classes</span></h3><p>The base class for all nodes in the graph structure for an HTML document is the <span class="nctnt ncbi-class">CNCBINode</span>. The <span class="nctnt ncbi-class">CNCBINode</span> class is derived from <span class="nctnt ncbi-class">CObject</span> and provides the ability to add, delete, and modify the nodes in the graph. The ability to add and modify nodes is inherited by all the classes derived from <span class="nctnt ncbi-class">CNCBINode</span> (see <a href="ch_intro.html#ch_intro.F3">Figure 3</a>). The classes derived from <span class="nctnt ncbi-class">CNCBINode</span> represent the HTML elements on an HTML page. You can easily identify the HTML element that a class handles from the class names such as <span class="nctnt ncbi-class">CHTMLText</span>, <span class="nctnt ncbi-class">CHTMLButtonList</span>, etc.</p><div class="figure" id="ch_intro.F3"><div class="graphic"><img src="img/CNCBINode.gif" alt="Figure 3. HTML classes derived from CNCBINode" /></div><div class="caption"><p>Figure 3. HTML classes derived from <span class="nctnt ncbi-class">CNCBINode</span></p></div></div><p>The text node classes <span class="nctnt ncbi-class">CHTMLText</span> and <span class="nctnt ncbi-class">CHTMLPlainText</span> are intended to be used directly by the user. Both <span class="nctnt ncbi-class">CHTMLText</span> and <span class="nctnt ncbi-class">CHTMLPlainText</span> are used to insert text into the generated html, with the difference that <span class="nctnt ncbi-class">CHTMLPlainText</span> class performs HTML encoding before generation. A number of other classes such as <span class="nctnt ncbi-class">CHTMLNode</span>, <span class="nctnt ncbi-class">CHTMLElement</span>, <span class="nctnt ncbi-class">CHTMLOpenElement</span>, and <span class="nctnt ncbi-class">CHTMLListElement</span> are base classes for the elements actually used to construct an HTML page, such as <span class="nctnt ncbi-class">CHTML_head</span>, <span class="nctnt ncbi-class">CHTML_form</span> (see <a href="ch_intro.html#ch_intro.F4">Figure 4</a>).</p><div class="figure" id="ch_intro.F4"><div class="graphic"><img src="img/CHTMLNode.gif" alt="Figure 4. The CHTMLNode class and its derived classes" /></div><div class="caption"><p>Figure 4. The <span class="nctnt ncbi-class">CHTMLNode</span> class and its derived classes</p></div></div><p>The <span class="nctnt ncbi-class">CHTMLNode</span> class is the base class for <span class="nctnt ncbi-class">CHTMLElement</span> and <span class="nctnt ncbi-class">CHTMLOpenElement</span> and is used for describing the HTML elements that are found in an HTML page such as HEAD, BODY, H1, BR, etc. The <span class="nctnt ncbi-class">CHTMLElement</span> tag describes those tags that have a close tag and are well formed. The <span class="nctnt ncbi-class">CHTMLOpenElement</span> class describes tags that are often found without the corresponding close tag such as the BR element that inserts a line break. The <span class="nctnt ncbi-class">CHTMLListElement</span> class is used in lists such as the OL element.</p><p>Important classes of HTML elements used in forms to input data are the input elements such as checkboxes, radio buttons, text fields, etc. The <span class="nctnt ncbi-class">CHTML_input</span> class derived from the <span class="nctnt ncbi-class">CHTML_OpenElement</span> class serves as the base class for a variety of input elements (see <a href="ch_intro.html#ch_intro.F5">Figure 5</a>).</p><div class="figure" id="ch_intro.F5"><div class="graphic"><img src="img/CHTML_input.gif" alt="Figure 5. The CHTML_input class and its derived classes" /></div><div class="caption"><p>Figure 5. The <span class="nctnt ncbi-class">CHTML_input</span> class and its derived classes</p></div></div><p>More <a href="ch_html.html#ch_html.html_classes">details on HTML classes and their relationships</a> is presented in a later chapter.</p></div><div class="sec" id="ch_intro.intro_html_processing"><h3><span class="title">HTML Processing</span></h3><p>The HTML classes can be used to dynamically generate pages. In addition to the classes described in the previous section, there are a number of page classes that are designed to help with HTML processing. The page classes serve as generalized containers for collections of other HTML components, which are mapped to the page. <a href="ch_intro.html#ch_intro.F6">Figure 6</a> describes the important classes in page class hierarchy.</p><div class="figure" id="ch_intro.F6"><div class="graphic"><img src="img/CHTMLPage.gif" alt="Figure 6. HTML page classes" /></div><div class="caption"><p>Figure 6. HTML page classes</p></div></div><p>The <span class="nctnt ncbi-class">CHTMLBasicPage</span> class is as a base class whose features are inherited by the <span class="nctnt ncbi-class">CHTMLPage</span> derived class - it is not intended for direct usage. Through the methods of this class, you can access or set the CgiApplication, Style, and TagMap stored in the class.</p><p>The <span class="nctnt ncbi-class">CHTMLPage</span> class when used with the appropriate HTML template file, can generate the 'bolier plate' web pages such as a standard corporate web page, with a corporate logo, a hook for an application-specific logo, a top menubar of links to several databases served by a query program, a links sidebar for application-specific links to relevant sites, a VIEW tag for an application's web interface, a bottom menubar for help links, disclaimers, and other boiler plate links. The template file is a simple HTML text file with named tags (&lt;@tagname@&gt;) which allow the insertion of new HTML blocks into a pre-formatted page.</p><p>More <a href="ch_html.html#ch_html.page_classes">details on CHTMLBasicPage, CHTMLPage and related classes</a> is presented in a later chapter.</p></div></div><div class="sec" id="ch_intro.intro_objmgr"><h2><span class="title">The OBJECT MANAGER Module</span></h2><p>The Object Manager module is a library of C++ classes, which facilitate access to biological sequence data. It makes it possible to transparently download data from the GenBank database, investigate biological sequence data structure, retrieve sequence data, descriptions and annotations.</p><p>The Object Manager has been designed to present an interface to users and to minimize their exposure to the details of interacting with biological databases and their underlying data structures. The Object Manager, therefore, coordinates the use of biological sequence data objects, particularly the management of the details of loading data from different data sources.</p><p>The NCBI databases and software tools are designed around a particular model of biological sequence data. The data model must be very flexible because the nature of this data is not yet fully understood, and its fundamental properties and relationships are constantly being revised. NCBI uses <a href="http://asn1.elibel.tm.fr">Abstract Syntax Notation One</a> (ASN.1) as a formal language to describe <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/SDKDOCS/INDEX.HTML">biological sequence data and its associated information</a>.</p><p>The bio sequence data may be huge and downloading all of this data may not be practical or desirable. Therefore, the Object Manager transparently transmits only the data that is really needed and not all of it at once. There is a <a href="ch_app.html#ch_app.datatool">datatool</a> that generates corresponding data objects (source code and header files) from the object's ASN.1 specification. The Object Manager is able to manipulate these objects.</p><p>Biological sequences are identified by a <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/SDKDOCS/SEQLOC.HTML">Seq_id</a>, which may have different forms.</p><p>The most general container object of bio sequence data, as defined in NCBI data model, is <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/SDKDOCS/SEQSET.HTML">Seq_entry</a>. A great deal of NCBI software is designed to accept a Seq_entry as the primary unit of data. In general, the Seq_entry is defined recursively as a tree of Seq_entry objects, where each node contains either <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/SDKDOCS/BIOSEQ.HTML">Bioseq</a> or list of other Seq_entry objects and additional data like sequence description, sequence annotations.</p><p>Two important concepts in the Object Manager are <span class="nctnt ncbi-monospace">scope</span> and <span class="nctnt ncbi-monospace">reference resolution</span>. The client defines a scope as the sources of data where the system uses only "allowed" sources to look for data. Scopes may contain several variants of the same bio sequence (Seq_entry). Since sequences refer to each other, the scope sets may have some data that is common to both scopes. In this case changing data in one scope should be reflected in all other scopes, which "look" at the same data.</p><p>The other concept a client uses is <span class="nctnt ncbi-monospace">reference resolution</span>. Reference resolution is used in situations where different biological sequences can refer to each other. For example, a sequence of amino acids may be the same as sequence of amino acids in another sequence. The data retrieval system should be able to resolve such references automatically answering what amino acids are actually here. Optionally, at the client's request, such automatic resolution may be turned off.</p><p>The Object Manager provides a consistent view of the data despite modifications to the data. For example, the data may change during a client's session because new biological data has been uploaded to the database while the client is still processing the old data. In this case, when the client for additional data, the system should retrieve the original bio sequence data, and not the most recent one. However, if the database changes between a client's sessions, then the next time the client session is started, the most recent data is retrieved, unless the client specifically asks for the older data.</p><p>The Object Manager is thread safe, and supports multithreading which makes it possible to work with bio sequence data from multiple threads.</p><p>The Object Manager includes numerous classes for accessing bio sequence data such as <span class="nctnt ncbi-class">CDataLoader</span> and <span class="nctnt ncbi-class">CDataSource</span> which manage global and local accesses to data, <span class="nctnt ncbi-class">CSeqVector</span> and <span class="nctnt ncbi-class">CSeqMap</span> objects to find and manipulate sequence data, a number of <a href="ch_objmgr.html#ch_objmgr.om_def.html_Iterators">specialized iterators</a> to parse descriptions and annotations, among others. The <span class="nctnt ncbi-class">CObjectManager</span> and <span class="nctnt ncbi-class">CScope</span> classes provide the foundation of the library, managing data objects and coordinating their interactions.</p><p>More <a href="ch_objmgr.html">details on the Object Manager and related classes</a> is presented in a later chapter.</p></div><div class="sec" id="ch_intro.intro_ser"><h2><span class="title">The SERIAL Module</span></h2><p>Click here to see <a href="ch_ser.html">Full Documentation on the Data Serialization Library</a>.</p><p>Serial library provides means for loading, accessing, manipulating, and serialization of data in a formatted way. It supports serialization in <a href="http://asn1.elibel.tm.fr">ASN.1</a> (text or BER encoding), <a href="http://www.w3.org/XML">XML</a>, and <a href="http://json.org">JSON</a> formats.</p><p>The structure of data is described by some sort of formal language. In our case it can be ASN.1, DTD or XML Schema. Based on such specification, <a href="ch_app.html#ch_app.datatool">DATATOOL</a> application, which is part of NCBI C++ toolkit, generates a collection of data storage classes that can be used to store and serialize data. The design purpose was to make these classes as lightweight as possible, moving all details of serialization into specialized classes - <a href="ch_ser.html#ch_ser.objstream.html_intro">â€œobject streamsâ€</a>. Structure of the data is described with the help of <a href="ch_ser.html#ch_ser.typeinfo.html">â€œtype informationâ€</a>. Data objects contain data and type information only. Any such data storage object can be viewed as a node tree that provides random access to its data. Serial library provides means to<a href="ch_ser.html#ch_ser.typeinfo.html_cobjinfo"> traversing</a> this data tree without knowing its structure in advance â€“ using only type information; C++ code generated by DATATOOL makes it possible to access any child node directly.</p><p><a href="ch_ser.html#ch_ser.objstream.html_intro">â€œObject streamsâ€</a> are intermediaries between data storage objects and input or output stream. They perform encoding or decoding of data according to format specifications. Guided by the type information embedded into data object, on reading they allocate memory when needed, fill in data, and validate that all mandatory data is present; on writing they guarantee that all relevant data is written and that the resulting document is well-formed. All it takes to read or write a top-level data object is one function call â€“ all the details are handled by an object stream.</p><p>Closely related to serialization is the task of converting data from one format into another. One approach could be reading data object completely into memory and then writing it in another format. The only problem is that the size of data can be huge. To simplify this task and to avoid storing data in memory, serial library provides <a href="ch_ser.html#ch_ser.objstream.html_objcopy">â€œobject stream copierâ€</a> class. It reads data by small chunks and writes it immediately after reading. In addition to small memory footprint, it also works much faster.</p><p>Input data can be very large in size; also, reading it completely into memory could not be the goal of processing. Having a large file of data, one might want to investigate information containers only of a particular type. Serial library provides a variety of means for doing this. The list includes <a href="ch_ser.html#ch_ser.objstream.html_readhooks">read</a> and <a href="ch_ser.html#ch_ser.objstream.html_writehooks">write</a> hooks, several types of <a href="ch_ser.html#ch_ser.stream_iterators">stream iterators</a>, and <a href="ch_ser.html#ch_ser.serial_filter">filter templates</a>. It is worth to note that, when using read hooks to read child nodes, one might end up with an invalid top-level data object; or, when using write hooks, one might begin with an invalid object and fill in missing data on the fly â€“ in hooks.</p><p>In essence, â€œhookâ€ is a callback function that client application provides to serial library. Client application installs the hook, then reads (or writes) data object, and somewhere from the depths of serialization processing, the library calls this hook function at appropriate times, for example, when a data chunk of specified type is about to be read. It is also possible to install <a href="ch_ser.html#ch_ser.stack_path_hooks">context-specific hooks</a>. Such hooks are triggered when serializing a particular object type in a particular context; for example, for all objects of class A which are contained in object B.</p></div><div class="sec" id="ch_intro.intro_util"><h2><span class="title">The UTIL Module</span></h2><p>The UTIL module is collection of some very useful utility classes that implement I/O related functions, algorithms, container classes; text related and thread related functions. Individual facilities include classes to compute checksums, implement interval search trees, lightweight strings, string search, linked sets, random number generation, UTF-8 conversions, registry based DNS, rotating log streams, thread pools, and many others.</p><p>The following sections give an overview of the utility classes:</p><ul><li><p><a href="ch_intro.html#ch_intro.intro_checksum">Checksum</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_dumpv">Console Debug Dump Viewer</a></p></li><li><p><a href="ch_intro.html#ch_intro.Diff_API">Diff API</a></p></li><li><p><a href="ch_intro.html#ch_intro.Floating_Point_Comparison">Floating Point Comparison</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_lightstring">Lightweight Strings</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_range">Range Support</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_linkedset">Linked Sets</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_random">Random Number Generator</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_regdns">Registry based DNS</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_resizeiterator">Resizing Iterator</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_rotatelog">Rotating Log Streams</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_streamsupport">Stream Support</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_strsearch">String Search</a></p></li><li><p><a href="ch_intro.html#ch_intro.Synchronized_and_blo">Synchronized and blocking queue</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_thrpools">Thread Pools</a></p></li><li><p><a href="ch_intro.html#ch_intro.intro_utf8">UTF 8 Conversion</a></p></li></ul><div class="sec" id="ch_intro.intro_checksum"><h3><span class="title">Checksum</span></h3><p>The Checksum class implements CRC32 (Cyclic Redundancy Checksum 32-bit) calculation. The CRC32 is a 32-bit polynomial checksum that has many applications such as verifying the integrity of a piece of data. The <span class="nctnt ncbi-class">CChecksum</span> class implements the CRC32 checksum that can be used to compute the CRC of a sequence of byte values.</p><p>The checksum calculation is set up by creating a <span class="nctnt ncbi-class">CChecksum</span> object using the <span class="nctnt ncbi-class">CChecksum</span> constructor and passing it the type of CRC to be calculated. Currently only CRC32 is defined, so you must pass it the enumeration constant eCRC32 also defined in the class.</p><p>Data on which the checksum is to be computed is passed to the <span class="nctnt ncbi-class">CChecksum's</span><span class="nctnt ncbi-func">AddLine()</span> or <span class="nctnt ncbi-func">AddChars()</span> method as a character array. As data is passed to these methods, the CRC is computed and stored in the class. You can get the value of the computed CRC using the <span class="nctnt ncbi-func">GetChecksum()</span> method. Alternatively, you can use the <span class="nctnt ncbi-func">WriteChecksum()</span> method and pass it a <span class="nctnt ncbi-class">CNcbiOstream</span> object and have the CRC written to the output stream in the following syntax:</p><p>/* Original file checksum: lines: <i>nnnn</i>, chars: <i>nnnn</i>, CRC32: <i>xxxxxxxx </i>*/</p></div><div class="sec" id="ch_intro.intro_dumpv"><h3><span class="title">Console Debug Dump Viewer</span></h3><p>The UTIL module implements a simple Console Debug Dump Viewer that enables the printing of object information on the console, through a simple console interface. Objects that can be debugged must be inherited from <span class="nctnt ncbi-class">CDebugDumpable</span> class. The <span class="nctnt ncbi-class">CObject</span> is derived from <span class="nctnt ncbi-class">CDebugDumpable</span>, and since most other objects are derived from <span class="nctnt ncbi-class">CObject</span> this makes these objects 'debuggable'.</p><p>The Console Debug Dump Viewer is implemented by the <span class="nctnt ncbi-class">CDebugDumpViewer</span> class. This class implements a breakpoint method called <span class="nctnt ncbi-func">Bpt()</span>. This method is called with the name of the object and a pointer to the object to be debugged. This method prompts the user for commands that the user can type from the console:</p><pre>Console Debug Dump Viewer<br />Stopped at  testfile.cpp(120)<br />current object: myobj = xxxxxx<br />Available commands:<br />   t[ypeid]  address<br />   d[ump]    address  depth<br />   go</pre><p>The <span class="nctnt ncbi-class">CDebugDumpViewer</span> class also permits the enabling and disabling of debug dump breakpoints from the <a href="ch_intro.html#ch_intro.intro_reg">registry</a>.</p></div><div class="sec" id="ch_intro.Diff_API"><h3><span class="title">Diff API</span></h3><p>The Diff API includes the <span class="nctnt ncbi-class">CDiff</span> class for character-based diffs and the <span class="nctnt ncbi-class">CDiffText</span> class for line-based diffs. The API is based on the open source <a href="http://code.google.com/p/google-diff-match-patch/">Diff, Match and Patch Library</a> and the <a href="http://code.google.com/p/dtl-cpp/">Diff Template Library</a>.</p><p>To use the Diff API, include <span class="nctnt ncbi-lib">xdiff</span> in the <span class="nctnt ncbi-macro">LIB</span> line of your application makefile, and include <span class="nctnt ncbi-code">&lt;util/diff/diff.hpp&gt;</span> in your source.</p><p>The following sample code shows how to perform both character- and line-based diffs:</p><pre><span class="nctnt-pre ncbi-code">// Print difference list in human readable format<br />static void s_PrintDiff(const string&amp; msg, const string&amp; s1, const string&amp; s2,<br />    const CDiffList&amp; diff)<br />{<br />    NcbiCout &lt;&lt; msg &lt;&lt; NcbiEndl<br />        &lt;&lt; "Comparing '" &lt;&lt; s1 &lt;&lt; "' to '" &lt;&lt; s2 &lt;&lt; "':" &lt;&lt; NcbiEndl;<br />    ITERATE(CDiffList::TList, it, diff.GetList()) {<br />        string op;<br />        size_t n1 = 0;<br />        size_t n2 = 0;<br /><br />        if (it-&gt;IsDelete()) {<br />            op = "-";<br />            n1 = it-&gt;GetLine().first;<br />        } else if (it-&gt;IsInsert()) {<br />            op = "+";<br />            n2 = it-&gt;GetLine().second;<br />        } else {<br />            op = "=";<br />            n1 = it-&gt;GetLine().first;<br />            n2 = it-&gt;GetLine().second;<br />        }<br />        NCbiCout &lt;&lt; op &lt;&lt; " ("<br />             &lt;&lt; n1 &lt;&lt; "," &lt;&lt; n2 &lt;&lt; ")"<br />             &lt;&lt; ": " &lt;&lt; "'" &lt;&lt; it-&gt;GetString() &lt;&lt; "'" &lt;&lt; NCbiEndl;<br />    }<br />}<br /><br />// Perform a character-based diff:<br />{{<br />    CTempString s1("how now");<br />    CTempString s2("brown cow");<br />    CDiff d;<br />    CDiffList&amp; diffs(d.Diff(s1, s2));<br />    s_PrintDiff("Line-based diff:", s1, s2, diffs);<br />}}<br /><br />// Perform a line-based diff:<br />{{<br />    CTempString s1("group 1\nasdf asf\ntttt\nasdf asd");<br />    CTempString s2("group 2\nqwerty\n\nasdf\nasf asd");<br />    CDiffText d;<br />    CDiffList&amp; diffs(d.Diff(s1, s2));<br />    s_PrintDiff("Line-based diff:", s1, s2, diffs);<br />}}</span></pre><p>For more detailed usage, see the test program:</p><p><a href="http://www.ncbi.nlm.nih.gov/viewvc/v1/trunk/c%2B%2B/src/util/diff/test/">http://www.ncbi.nlm.nih.gov/viewvc/v1/trunk/c%2B%2B/src/util/diff/test/</a></p></div><div class="sec" id="ch_intro.Floating_Point_Comparison"><h3><span class="title">Floating Point Comparison</span></h3><p>For technical reasons, direct comparison of "close" floating point values is simply not reliable on most computers in use today. Therefore, in cases where the values being compared might be close, it is advisable to apply a tolerance when making comparisons to avoid unexpected results.</p><p>The UTIL module defines a function, <span class="nctnt ncbi-func">g_FloatingPoint_Compare()</span>, that implements floating point comparison using a tolerance. In practice this means that code like:</p><pre>    if (a &lt; b) {<br />        if (c == d ) {<br />            if (e &gt; f) {</pre><p>should be rewritten as:</p><pre>#include &lt;util/floating_point.hpp&gt;<br />//...<br />    if (g_FloatingPoint_Compare(a, eFP_LessThan, b,<br />                                eFP_WithPercent, percent) {<br />        if (g_FloatingPoint_Compare(c, eFP_EqualTo, d,<br />                                    eFP_WithFraction, fraction) {<br />            if (g_FloatingPoint_Compare(e, eFP_GreaterThan, f,<br />                                        eFP_WithPercent, percent) {</pre><p>Note that compared variables must be of the same floating point type, otherwise a compile error will be generated.</p><p>For further details on this function, see its Doxygen <a href="http://intranet.ncbi.nlm.nih.gov:6224/ieb/ToolBox/CPP_DOC/doxyhtml/floating__point_8hpp.html#593c203d1463234d7eecb617a01ba6cc">documentation</a>.</p><p>For technical details on the subject, including what it means to be close, see "<a href="http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm">Comparing floating point numbers</a>" by Bruce Dawson.</p></div><div class="sec" id="ch_intro.intro_lightstring"><h3><span class="title">Lightweight Strings</span></h3><p>Class <span class="nctnt ncbi-class">CTempString</span> implements a light-weight string on top of a storage buffer whose lifetime management is known and controlled.</p><p><span class="nctnt ncbi-class">CTempString</span> is designed to perform no memory allocation but provide a string interaction interface congruent with std::basic_string&lt;char&gt;.</p><p>As such, CTempString provides a const-only access interface to its underlying storage. Care has been taken to avoid allocations and other expensive operations wherever possible.</p><p><span class="nctnt ncbi-class">CTempString</span> has constructors from std::string and C-style string, which do not copy the string data but keep char pointer and string length.</p><p>This way the construction and destruction are very efficient.</p><p>Take into account, that the character string array kept by <span class="nctnt ncbi-class">CTempString</span> object must remain valid and unchanged during whole lifetime of the <span class="nctnt ncbi-class">CTempString</span> object.</p><p>It's convenient to use the class <span class="nctnt ncbi-class">CTempString</span> as an argument of API functions so that no allocation or deallocation will take place on of the function call.</p></div><div class="sec" id="ch_intro.intro_linkedset"><h3><span class="title">Linked Sets</span></h3><p>The UTIL module defines a template container class, <span class="nctnt ncbi-class">CLinkedMultiset</span>, that can hold a linked list of multiset container types.</p><p>The <span class="nctnt ncbi-class">CLinkedMultiset</span> defines iterator methods <span class="nctnt ncbi-func">begin()</span>, <span class="nctnt ncbi-func">end()</span>, <span class="nctnt ncbi-func">find()</span>, <span class="nctnt ncbi-func">lower_bound()</span>, <span class="nctnt ncbi-func">upper_bound()</span>, to help traverse the container. The method <span class="nctnt ncbi-func">get()</span>, fetches the contained value, the method <span class="nctnt ncbi-func">insert()</span> inserts a new value into the container, and the method <span class="nctnt ncbi-func">erase()</span>, removes the specified value from the container.</p></div><div class="sec" id="ch_intro.intro_random"><h3><span class="title">Random Number Generator</span></h3><p>The UTIL module defines the <span class="nctnt ncbi-class">CRandom</span> class that can be used for generating 32-bit unsigned random numbers. The random number generator algorithm is the Lagged Fibonacci Generator (LFG) algorithm.</p><p>The random number generator is initialized with a seed value, and then the <span class="nctnt ncbi-func">GetRandom()</span> method is called to get the next random number. You can also specify that the random number value that is returned be in a specified range of values.</p></div><div class="sec" id="ch_intro.intro_range"><h3><span class="title">Range Support</span></h3><p>The UTIL module provides a number of container classes that support a <i>range</i> which models an interval consisting of a set of ordered values. the <span class="nctnt ncbi-class">CRange</span> class stores information about an interval, [<b><i>from</i></b>, where the <b><i>from</i></b> and <b><i>to</i></b> points are inclusive. This is sometimes called a <i>closed interval</i>.</p><p>Another class, the <span class="nctnt ncbi-class">CRangeMap</span> class, is similar to the <span class="nctnt ncbi-class">CRange</span> class but allows for the storing and retrieving of data using the interval as key. The time for iterating over the interval is proportional to the amount of intervals produced by the iterator and may not be efficient in some cases.</p><p>Another class, the <span class="nctnt ncbi-class">CIntervalTree</span> class, has the same functionality as the <span class="nctnt ncbi-class">CRangeMap</span> class but uses a different algorithm; that is, one based on McCreight's algorithm. Unlike the <span class="nctnt ncbi-class">CRangeMap</span> class, the <span class="nctnt ncbi-class">CIntervalTree</span> class allows several values to have the same key interval. This class is faster and its speed is not affected by the type of data but it uses more memory (about three times as much as <span class="nctnt ncbi-class">CRangeMap</span>) and, as a result, is less efficient when the amount of interval in the set is quite big. For example, the <span class="nctnt ncbi-class">CIntervalTree</span> class becomes less efficient than <span class="nctnt ncbi-class">CRangeMap</span> when the total memory becomes greater than processor cache.</p><p>More <a href="ch_core.html#ch_core.template_typename_Co">details on range classes</a> are presented in a later chapter.</p></div><div class="sec" id="ch_intro.intro_regdns"><h3><span class="title">Registry based DNS</span></h3><p>The UTIL module defines the <span class="nctnt ncbi-class">CSmallDns</span> class that implements a simple <a href="ch_intro.html#ch_intro.intro_reg">registry</a> based DNS server. The <span class="nctnt ncbi-class">CSmallDns</span> class provides DNS name to IP address translations similar to a standard DNS server, except that the database used to store DNS name to IP address mappings is a non-standard local database. The database of DNS names and IP address mappings are kept in a registry-like file named by local_hosts_file using section [LOCAL_DNS].</p><p>The <span class="nctnt ncbi-class">CSmallDns</span> has two methods that are responsible for providing the DNS name to IP address translations: the <span class="nctnt ncbi-func">LocalResolveDNS</span> method and the <span class="nctnt ncbi-func">LocalBackResolveDNS</span> method. The <span class="nctnt ncbi-func">LocalResolveDNS</span> method does 'forward' name resolution. That is, given a host name, it returns a string containing the IP address in the dotted decimal notation. The <span class="nctnt ncbi-func">LocalBackResolveDNS</span> method does a 'reverse lookup'. That is, given an IP address as a dotted decimal notation string, it returns the host name stored in the registry.</p></div><div class="sec" id="ch_intro.intro_resizeiterator"><h3><span class="title">Resizing Iterator</span></h3><p>The UTIL module defines two template classes, the <span class="nctnt ncbi-class">CResizingIterator</span> and the <span class="nctnt ncbi-class">CConstResizingIterator</span> classes that handle sequences represented as packed sequences of elements of different sizes For example, a vector &lt;char&gt; might actually hold 2-bit values, such as nucleotides, or 32-bit integer values.</p><p>The purpose of these iterator classes is to provide iterator semantics for data values that can be efficiently represented as a packed sequence of elements regardless of the size.</p></div><div class="sec" id="ch_intro.intro_rotatelog"><h3><span class="title">Rotating Log Streams</span></h3><p>The UTIL module defines the <span class="nctnt ncbi-class">CRotatingLogStream</span> class that can be used to implement a rotating log file. The idea being that once the log of messages gets too large, a 'rotation' operation can be performed. The default rotation is to rename the existing log file by appending it with a timestamp, and opening a new log.</p><p>The rotating log can be specified as a file, with an upper limit (in bytes) to how big the log will grow. The <span class="nctnt ncbi-class">CRotatingLogStream</span> defines a method called <span class="nctnt ncbi-func">Rotate()</span> that implements the default rotation.</p></div><div class="sec" id="ch_intro.intro_streamsupport"><h3><span class="title">Stream Support</span></h3><p>The UTIL module defines a number of portable classes that provide additional stream support beyond that provided by the standard C++ streams. The <span class="nctnt ncbi-class">CByteSource</span> class acts as an abstract base class (see <a href="ch_intro.html#ch_intro.F7">Figure 7</a>), for a number of stream classes derived from it. As the name of the other classes derived from <span class="nctnt ncbi-class">CByteSource</span> suggests, each of these classes provides the methods from reading from the named source. To list a few examples: <span class="nctnt ncbi-class">CFileByteSource</span> is a specialized class for reading from a named file; <span class="nctnt ncbi-class">CMemoryByteSource</span> is a specialized class for reading from a memory buffer; <span class="nctnt ncbi-class">CResultByteSource</span> is a specialized class for reading database results; <span class="nctnt ncbi-class">CStreamByteSource</span> is a specialized class from reading from the C++ input stream (istream); <span class="nctnt ncbi-class">CFStreamByteSource</span> is a specialized class from reading from the C++ input file stream (ifstream).</p><div class="figure" id="ch_intro.F7"><div class="graphic"><img src="img/CByteSource.gif" alt="Figure 7. Relationship between CByteSource and its derived classes" /></div><div class="caption"><p>Figure 7. Relationship between <span class="nctnt ncbi-class">CByteSource</span> and its derived classes</p></div></div><p>The classes such as <span class="nctnt ncbi-class">CSubFileByteSource</span> are used to define a slice of the source stream in terms of a start position and a length. The read operations are then confined to this slice.</p><p>Additional classes, the <span class="nctnt ncbi-class">CIStreamBuffer</span> and the <span class="nctnt ncbi-class">COStreamBuffer</span> have been defined for standard input and output buffer streams. These can be used in situations where a compiler's implementation of the standard input and output stream buffering is inefficient.</p><p>More details on the stream classes are presented in a later chapter.</p></div><div class="sec" id="ch_intro.intro_strsearch"><h3><span class="title">String Search</span></h3><p>The UTIL module defines the <span class="nctnt ncbi-class">CBoyerMooreMatcher</span> class and the <span class="nctnt ncbi-class">CFsmText</span> class which are used for searching for a single pattern over varying texts.</p><p>The <span class="nctnt ncbi-class">CBoyerMooreMatcher</span> class, as the name suggests, uses the Boyer-Moore algorithm for string searches. The <span class="nctnt ncbi-class">CFsmText</span> is a template class that performs the search using a finite state automaton for a specified to be matched data type. Since the matched data type is often a string, the <span class="nctnt ncbi-class">CTextFsa</span> class is defined as a convenience by instantiating the <span class="nctnt ncbi-class">CFsmText</span> with the matched type template parameter set to string.</p><p>The search can be setup as a case sensitive or case insensitive search. The default is case sensitive search. In the case of the <span class="nctnt ncbi-class">CBoyerMooreMatcher</span> class, the search can be setup for any pattern match or a whole word match. A whole word match means that a pattern was found to be between white spaces. The default is any pattern match.</p></div><div class="sec" id="ch_intro.Synchronized_and_blo"><h3><span class="title">Synchronized and blocking queue</span></h3><p>The UTIL module defines class <span class="nctnt ncbi-class">CSyncQueue</span> which implements a thread-safe queue that has â€œblockingâ€ semantics: when queue is empty <span class="nctnt ncbi-func">Pop()</span> method will effectively block execution until some elements will be added to the queue; when queue have reached its maximum size <span class="nctnt ncbi-func">Push()</span> method will block execution until some elements will be extracted from queue. All these operations can be controlled by timeout. Besides that <span class="nctnt ncbi-class">CSyncQueue</span> is not bound to first-in-first-out queue paradigm. It has underlying stl container (deque by default) which will define the nature of queue. This container is set via template parameter to <span class="nctnt ncbi-class">CSyncQueue</span> and can be deque, vector, list, CSyncQueue_set, CSyncQueue_multiset and CSyncQueue_priority_queue (the latter three are small addons to STL set, multiset and priority_queue for the sake of compatibility with <span class="nctnt ncbi-class">CSyncQueue</span>).</p><p>There is also <span class="nctnt ncbi-class">CSyncQueue::TAccessGuard</span> class which can lock the queue for some bulk operations if during them queue should not be changed by other threads.</p><p>For more details on <span class="nctnt ncbi-class">CSyncQueue</span> look here: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/CSyncQueueDescription.html">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/CSyncQueueDescription.html</a>.</p></div><div class="sec" id="ch_intro.intro_thrpools"><h3><span class="title">Thread Pools</span></h3><p>The UTIL module defines a number of classes implementing pool of threads.</p><p><span class="nctnt ncbi-class">CThreadPool</span> is the main class. It executes any tasks derived from the <span class="nctnt ncbi-class">CThreadPool_Task</span> class. The number of threads in pool is controlled by special holder of this policy â€” object derived from <span class="nctnt ncbi-class">CThreadPool_Controller</span> (default implementation is <span class="nctnt ncbi-class">CThreadPool_Controller_PID</span> based on Proportional-Integral-Derivative algortithm). All threads executing by <span class="nctnt ncbi-class">CThreadPool</span> are the instances of <span class="nctnt ncbi-class">CThreadPool_Thread</span> class or its derivatives.</p><p>More <a href="ch_core.html#ch_core.Thread_Pools">details on threaded pool classes</a> are presented in a later chapter.</p></div><div class="sec" id="ch_intro.intro_utf8"><h3><span class="title">UTF 8 Conversion</span></h3><p>The UTIL module provides a number of functions to convert between UTF-8 representation, ASCII 7-bit representation and Unicode representations. For example, <span class="nctnt ncbi-func">StringToCode()</span> converts the first UTF-8 character in a string to a Unicode symbol, and <span class="nctnt ncbi-func">StringToVector()</span> converts a UTF-8 string into a vector of Unicode symbols.</p><p>The result of a conversion can be success, out of range, or a two character sequence of the skip character (0xFF) followed by another character.</p></div></div></div></div><div class="col four_col last"><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>In this page</h3></div></div><div class="portlet_content"><ul><li><a href="#ch_intro.intro_corelib">The CORELIB Module</a></li><li><a href="#ch_intro.intro_algo">The ALGORITHM Module</a></li><li><a href="#ch_intro.intro_cgi">The CGI Module</a></li><li><a href="#ch_intro.intro_conn">The CONNECT Module</a></li><li><a href="#ch_intro.intro_ctool">The CTOOL Module</a></li><li><a href="#ch_intro.intro_dbapi">The DBAPI Module</a></li><li><a href="#ch_intro.intro_gui">The GUI Module</a></li><li><a href="#ch_intro.intro_html">The HTML Module</a></li><li><a href="#ch_intro.intro_objmgr">The OBJECT MANAGER Module</a></li><li><a href="#ch_intro.intro_ser">The SERIAL Module</a></li><li><a href="#ch_intro.intro_util">The UTIL Module</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Download</h3></div></div><div class="portlet_content"><ul><li><a href="pdf/ch_intro.pdf">PDF version of this page</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Search</h3></div></div><div class="portlet_content"><form name="frmSymbolSearch" onsubmit="return SymbolSearch('toolkit')" action="/" id="frmSymbolSearch"><table><tbody><tr align="center" valign="middle"><td colspan="2" nowrap="nowrap"><input id="search_box" name="__symbol" style="vertical-align:                                          middle; line-height:normal " onkeypress="SymbolSearchKeyPress('toolkit',event)" type="text" />Â Â  
					<label for="search_box" class="offscreen_noflow">Search term</label><button type="submit" value="Search" style="vertical-align:                                          middle; line-height:normal;" onclick="javasrcipt:SymbolSearch('toolkit');">Search</button></td></tr><tr class="internal-only"><th style="text-align:left">Public</th><th style="text-align:left">Internal</th></tr><tr><td><input id="pToolkitAll" name="__symboloc" type="radio" checked="checked" /><label for="pToolkitAll" title="Search in the C/C++ source code and in this Book">All</label></td><td class="internal-only"><input id="iToolkitAll" name="__symboloc" type="radio" /><label for="iToolkitAll" title="Search in the C/C++ source code,  this Book, and Wiki">All</label></td></tr><tr><td><input id="pLXR" name="__symboloc" type="radio" /><label for="pLXR" title="Search the symbol in the source code using LINUX Cross-Reference browser">LXR</label></td><td class="internal-only"><input id="iLXR" name="__symboloc" type="radio" /><label for="iLXR" title="Search the symbol in the source code using LINUX Cross-Reference browser">LXR</label></td></tr><tr><td><input id="pLib" name="__symboloc" type="radio" /><label for="pLib" title="Locate the Toolkit library(es) where the symbol is defined">Library</label></td><td class="internal-only"><input id="iLib" name="__symboloc" type="radio" /><label for="iLib" title="Locate the Toolkit library(es) where the symbol is defined">Library</label></td></tr></tbody></table></form></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Source Browsers</h3></div></div><div class="portlet_content"><ul><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">LXR</a></li><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">Doxygen</a></li><li class="internal-only">LXR: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">public</a> / <a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lxr/ident">internal</a></li><li class="internal-only">Doxygen: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml">public</a> / <a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml">internal</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>SVN Source Repository</h3></div></div><div class="portlet_content"><ul><li><a href="http://www.ncbi.nlm.nih.gov/bookshelf/br.fcgi?book=toolkit&amp;part=ch_getcode_svn#ch_getcode_svn.code_retrieval">Server</a></li><li><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/c++">Web
                            (dev)</a></li><li><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/internal/c++">Web
                            (extra)</a></li><li><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/production/components">Web (prod)</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Resources</h3></div></div><div class="portlet_content"><ul><li class="internal-only"><a href="http://intranet.ncbi.nlm.nih.gov/wiki-private/CxxToolkit">Wiki</a></li><li class="internal-only"><a href="http://jira/browse/CXX">JIRA</a></li><li class="internal-only"><a href="http://intranet/ieb/ToolBox/STAT/test_stat/test_stat_ext.cgi"><span title="View results of testsuite runs on the automatic C++ Toolkit builds">Testsuite</span></a></li><li><a href="release_notes.html">Release Notes</a></li><li><a href="ch_getcode_svn.html#ch_getcode_svn.ftp_download">Download</a></li><li><a href="pdf/TOC.pdf">PDF of the book</a></li><li><a href="ch_style.html">Coding Style</a></li><li><a href="ch_faq.html#ch_faq.mailing_lists">Mailing Lists</a></li><li><a href="mailto:CPP-CORE@NCBI.NLM.NIH.GOV"><span title="Contact C++ Toolkit group">Help and Support</span></a></li></ul></div></div></div></div></div></div></body></html>
