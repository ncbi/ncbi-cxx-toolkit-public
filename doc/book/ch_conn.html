<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Networking and IPC - The NCBI C++ Toolkit Book [Internet] - NCBI</title><meta name="description" content="A comprehensive manual on the NCBI C++ toolkit, including its design and development framework, a C++ library reference, software examples and demos, FAQs and release notes." /><meta name="robots" content="index,nofollow,noarchive" /><meta name="page_id" content="ch_conn" /><meta name="page_type" content="chapter" /><meta name="ncbipopper" content="triggerPosition:'bottom left',destPosition:'top left',openEvent:'click',closeEvent:'click'" /><script type="text/javascript" src="js/jig/1.7/js/jig.min.js"></script><script type="text/javascript" src="js/toolkitSymbolSearch.js"></script><link type="text/css" rel="stylesheet" href="css/ptbooks.css" /><link type="text/css" rel="stylesheet" href="css/toolkit.css" /></head><body><div class="grid no_max_width"><div class="col twelve_col nomargin shadow"><div class="content"><div class="col eight_col"><div class="nvgtn"><a href="#__nav_cntnt" class="jig-ncbipopper">Contents â–¾</a><div style="display:none;width:700px;height:500px;overflow:auto;" id="__nav_cntnt"><a class="right" href="toc.html">Table of Contents Page</a><ul class="simple-list"><li class="half_rhythm"><a href="toolkit.fm.html">Book Information</a></li><li class="half_rhythm"><a href="part1.html">Part 1. Overview</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_intro.html">1. Introduction to the C++ Toolkit</a></li><li class="half_rhythm"><a href="ch_start.html">2. Getting Started</a></li></ul></li><li class="half_rhythm"><a href="part2.html">Part 2. Development Framework</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_getcode_svn.html">3. Retrieve the Source Code (FTP and Subversion)</a></li><li class="half_rhythm"><a href="ch_config.html">4. Configure, Build, and Use the Toolkit</a></li><li class="half_rhythm"><a href="ch_build.html">5. Working with Makefiles</a></li><li class="half_rhythm"><a href="ch_proj.html">6. Project Creation and Management</a></li><li class="half_rhythm"><a href="ch_style.html">7. Programming Policies and Guidelines</a></li></ul></li><li class="half_rhythm"><a href="part3.html">Part 3. C++ Toolkit Library Reference</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_core.html">8. Portability, Core Functionality and Application Framework</a></li><li class="half_rhythm"><a href="ch_conn.html">9. Networking and IPC</a></li><li class="half_rhythm"><a href="ch_dbapi.html">10. Database Access - SQL, Berkley DB</a></li><li class="half_rhythm"><a href="ch_cgi.html">11. CGI and Fast-CGI </a></li><li class="half_rhythm"><a href="ch_html.html">12. HTML</a></li><li class="half_rhythm"><a href="ch_ser.html">13. Data Serialization (ASN.1, XML)</a></li><li class="half_rhythm"><a href="ch_datamod.html">14. Biological Sequence Data Model</a></li><li class="half_rhythm"><a href="ch_objmgr.html">15. Biological Object Manager</a></li><li class="half_rhythm"><a href="ch_blast.html">16. BLAST API</a></li><li class="half_rhythm"><a href="ch_dataaccess.html">17. Access to NCBI data</a></li><li class="half_rhythm"><a href="ch_algoalign.html">18. Biological Sequence Alignment</a></li><li class="half_rhythm"><a href="ch_gui.html">19. GUI and Graphics</a></li><li class="half_rhythm"><a href="ch_boost.html">20. Using the Boost Unit Test Framework</a></li></ul></li><li class="half_rhythm"><a href="part4.html">Part 4. Wrappers for 3rd-Party Packages</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_xmlwrapp.html">21. XmlWrapp (XML parsing and handling, XSLT, XPath)</a></li></ul></li><li class="half_rhythm"><a href="part5.html">Part 5. Software</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_debug.html">22. Debugging, Exceptions, and Error Handling</a></li><li class="half_rhythm"><a href="ch_grid.html">23. Distributed Computing</a></li><li class="half_rhythm"><a href="ch_app.html">24. Applications</a></li><li class="half_rhythm"><a href="ch_demo.html">25. Examples and Demos</a></li><li class="half_rhythm"><a href="ch_res.html">26. C Toolkit Resources for C++ Toolkit Users</a></li></ul></li><li class="half_rhythm"><a href="part6.html">Part 6. Help and Support</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_browse.html">27. NCBI C++ Toolkit Source Browser</a></li><li class="half_rhythm"><a href="ch_devtools.html">28. Software Development Tools</a></li><li class="half_rhythm"><a href="ch_xmlauthor.html">29. XML Authoring using Word</a></li><li class="half_rhythm"><a href="ch_faq.html">30. FAQs, Useful Documentation Links, and Mailing Lists</a></li></ul></li><li class="half_rhythm"><a href="part7.html">Part 7. Library and Applications Configuration</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_libconfig.html">31. Library Configuration</a></li></ul></li><li class="half_rhythm"><a href="part8.html">Release Notes</a><ul class="simple-list"><li class="half_rhythm"><a href="release_notes.html">Release Notes (Version 9, May 2012)</a></li><li class="half_rhythm"><a href="release_notes_7-05_2011.html">Release Notes (Version 7, May 2011)</a></li><li class="half_rhythm"><a href="release_notes_06_29_2010.html">Release Notes (June, 2010)</a></li><li class="half_rhythm"><a href="release_notes_05_15_2009.html">Release Notes (May, 2009)</a></li><li class="half_rhythm"><a href="release_notes_12_24_2008.html">Release Notes (December, 2008)</a></li><li class="half_rhythm"><a href="release_notes_12_31_2008.html">Release Notes (March, 2008)</a></li><li class="half_rhythm"><a href="release_notes_08_27_2007.html">Release Notes (August, 2007)</a></li><li class="half_rhythm"><a href="release_notes_03_12_2007.html">Release Notes (March, 2007)</a></li><li class="half_rhythm"><a href="release_notes_08_14_2006.html">Release Notes (August, 2006)</a></li><li class="half_rhythm"><a href="release_notes_04_30_2006.html">Release Notes (April 30, 2006)</a></li><li class="half_rhythm"><a href="release_notes_12_31_2005.html">Release Notes (December 31, 2005)</a></li><li class="half_rhythm"><a href="release_notes_10_03_2005.html">Release Notes (August, 2005)</a></li><li class="half_rhythm"><a href="release_notes_05_05_2005.html">Release Notes (April, 2005)</a></li><li class="half_rhythm"><a href="release_notes_03_09_2005.html">Release Notes (February, 2005)</a></li><li class="half_rhythm"><a href="release_notes_11_22_2004.html">Release Notes (November 22, 2004)</a></li><li class="half_rhythm"><a href="release_notes_10_2_2004.html">Release Notes (October 2, 2004)</a></li><li class="half_rhythm"><a href="release_notes_7_8_2004.html">Release Notes (July 8, 2004)</a></li><li class="half_rhythm"><a href="release_notes_april_16_2004.html">Release Notes (April 16, 2004)</a></li><li class="half_rhythm"><a href="release_notes_12_08_2003.html">Release Notes (December 8, 2003)</a></li><li class="half_rhythm"><a href="release_notes_08_01_2003.html">Release Notes (August 1, 2003)</a></li></ul></li><li class="half_rhythm"><a href="app1.appendix1.html">Appendix - Books and Styles</a></li></ul></div><div class="pagination"><a class="pagelink active prev" title="Previous page" href="ch_core.html">&lt; Prev</a><a class="pagelink active next" title="Next page" href="ch_dbapi.html">Next &gt;</a></div></div><div class="meta_content"><h1><span class="label">9</span><span class="title">Networking and IPC</span></h1><p class="small">Last Update: October 22, 2012.</p></div><div class="body_content"><div class="sec"><h2><span class="title">Connection Library [Library <span class="nctnt ncbi-path">xconnect</span>: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect">src</a>]</span></h2><p>The overview for this chapter consists of the following topics:</p><ul><li><p>Introduction</p></li><li><p>Chapter Outline</p></li></ul><div class="sec"><h3><span class="title">Introduction</span></h3><p>Includes a generic socket interface (<span class="nctnt ncbi-type">SOCK</span>), connection object (<span class="nctnt ncbi-type">CONN</span>), and specialized connector constructors (for sockets, files, HTTP, and services) to be used as engines for connections. It also provides access to the load-balancing daemon and NCBI named service dispatching facilities.</p><p>Although the core of the Connection Library is written in C and has an underlying C interface, the analogous C++ interfaces have been built to provide objects that work smoothly with the rest of the Toolkit.</p><p><span class="nctnt highlight">Note</span>: Because of security issues, not all links in the public version of this file are accessible by outside NCBI users.</p><ul><li><p><a href="ch_conn.html#ch_conn.conn_interf_lib">Overview</a></p></li><li><p><a href="ch_conn.html#ch_conn.conn_def">Connections</a>: notion of connection; different types of connections that the library provides; programming API.</p><ul><li><p><a href="ch_conn.html#ch_conn.socket_connector">Socket Connector</a></p></li><li><p><a href="ch_conn.html#ch_conn.file_connector">File Connector</a></p></li><li><p><a href="ch_conn.html#ch_conn.Connection_related_parameters">HTTP Connector</a></p></li><li><p><a href="ch_conn.html#ch_conn.service_connector">Service Connector</a></p></li></ul></li><li><p><a href="ch_conn.html#ch_conn.conn_debug_tools">Debugging Tools and Troubleshooting</a></p></li><li><p><a href="ch_conn.html#ch_conn.cpp_connection_streams">C++ Connection Streams</a> built on top of connection objects.</p></li><li><p><a href="ch_conn.html#ch_conn.service_mapping_api">Service mapping API</a>: description of service name resolution API.</p></li><li><p><a href="ch_conn.html#ch_conn.Threaded_Server_Supp">Threaded Server Support</a></p></li></ul></div><div class="sec"><h3><span class="title">Chapter Outline</span></h3><p>The following is an outline of the topics presented in this chapter:</p><ul><li><p><a href="ch_conn.html#ch_conn.conn_debug_tools">Debugging Tools and Troubleshooting Documentation</a></p></li><li><p><a href="ch_conn.html#ch_conn.conn_interf_lib">C++ Interfaces to the Library</a></p><ul><li><p><a href="ch_conn.html#ch_conn.cpp_connection_streams">CONN-Based C++ Streams and Stream Buffers</a> ncbi_conn_stream[<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_conn_stream.hpp">.hpp</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/ncbi_conn_stream.cpp">.cpp</a>], ncbi_conn_streambuf[<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/ncbi_conn_streambuf.hpp">.hpp</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/ncbi_conn_streambuf.cpp">.cpp</a>]</p></li><li><p><a href="ch_cgi.html#ch_cgi.cgi_diag.html">Diagnostic Handler for E-Mailing Logs</a> email_diag_handler[<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/email_diag_handler.hpp">.hpp</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/email_diag_handler.cpp">.cpp</a>]</p></li><li><p><a href="ch_res.html#ch_res.c_cxx.html">Using the CONNECT Library with the C++ Toolkit</a> ncbi_core_cxx[<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_core_cxx.hpp">.hpp</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/ncbi_core_cxx.cpp">.cpp</a>]</p></li><li><p>Multithreaded Network Server Framework threaded_server[<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/threaded_server.hpp">.hpp</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/threaded_server.cpp">.cpp</a>]</p></li></ul></li><li><p><a href="ch_res.html#ch_res.c_cxx.html_ref_RunTimeResources">Basic Types and Functionality (for Registry, Logging and MT Locks)</a> ncbi_core[<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_core.h">.h</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/ncbi_core.c">.c</a>], ncbi_types[<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_types.h">.h</a>]</p></li><li><p><a href="ch_conn.html#ch_conn.conn_interf_lib">Portable TCP/IP Socket Interface</a> ncbi_socket[<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_socket.h">.h</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/ncbi_socket.c">.c</a>]</p></li><li><p><a href="ch_conn.html#ch_conn.conn_def">Connections and CONNECTORs</a></p><ul><li><p><a href="ch_conn.html#ch_conn.conn_def">Open and Manage Connections to an Abstract I/O</a> ncbi_connection[<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_connection.h">.h</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/ncbi_connection.c">.c</a>]</p></li><li><p>Implement CONNECTOR for a ...</p><ul><li><p><a href="ch_conn.html#ch_conn.conn_def">Abstract I/O</a> ncbi_connector[<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_connector.h">.h</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/ncbi_connector.c">.c</a>]</p></li><li><p><a href="ch_conn.html#ch_conn.socket_connector">Network Socket</a> ncbi_socket_connector[<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_socket_connector.h">.h</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/ncbi_socket_connector.c">.c</a>]</p></li><li><p><a href="ch_conn.html#ch_conn.file_connector">FILE Stream</a> ncbi_file_connector[<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_file_connector.h">.h</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/ncbi_file_connector.c">.c</a>]</p></li><li><p><a href="ch_conn.html#ch_conn.Connection_related_parameters">HTTP-based Network Connection</a> ncbi_http_connector[<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_http_connector.h">.h</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/ncbi_http_connector.c">.c</a>]</p></li><li><p><a href="ch_conn.html#ch_conn.service_connector">Named NCBI Service</a> ncbi_service_connector[<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_service_connector.h">.h</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/ncbi_service_connector.c">.c</a>]</p></li><li><p>In-memory CONNECTOR ncbi_memory_connector[<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_memory_connector.h">.h</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/ncbi_memory_connector.c">.c</a>]</p></li></ul></li></ul></li><li><p><a href="ch_conn.html#ch_conn.service_mapping_api">Servers and Services</a></p><ul><li><p>NCBI Server Meta-Address Info ncbi_server_info[<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_server_info.h">.h</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/ncbi_server_infop.h">p.h</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/ncbi_server_info.c">.c</a>]</p></li><li><p>Resolve NCBI Service Name to the Server Meta-Address ncbi_service[<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_service.h">.h</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/ncbi_servicep.h">p.h</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/ncbi_service.c">.c</a>]</p></li><li><p>Resolve NCBI Service Name to the Server Meta-Address using NCBI Network Dispatcher (<a href="ch_app.html#ch_app.DISPD_Network_Dispat">DISPD</a>) ncbi_service[<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/ncbi_dispd.h">p_dispd.h</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/ncbi_dispd.c">_dispd.c</a>]</p></li><li><p>Resolve NCBI Service Name to the Server Meta-Address using NCBI <a href="ch_app.html#ch_app.Load_Balancing_Servi">Load-Balancing Service Mapper (LBSM)</a> ncbi_service[<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/ncbi_lbsmd.h">p_lbsmd.h</a> | <a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lxr/source//src/connect/ncbi_lbsmd.c">_lbsmd.c</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/ncbi_lbsmd_stub.c">_lbsmd_stub.c</a>]</p></li><li><p><a href="ch_conn.html#ch_conn.service_mapping_api">NCBI LBSM client-server data exchange API</a> ncbi_lbsm[<a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lxr/source//src/connect/ncbi_lbsm.h">.h</a> | <a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lxr/source//src/connect/ncbi_lbsm.c">.c</a>]</p></li><li><p>Implementation of LBSM Using SYSV IPC (shared memory and semaphores) ncbi_lbsm_ipc[<a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lxr/source//src/connect/ncbi_lbsm_ipc.h">.h</a> | <a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lxr/source//src/connect/ncbi_lbsm_ipc.c">.c</a>]</p></li></ul></li><li><p>Memory Management</p><ul><li><p>Memory-Resident FIFO Storage Area ncbi_buffer[<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_buffer.h">.h</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/ncbi_buffer.c">.c</a>]</p></li><li><p>Simple Heap Manager With Primitive Garbage Collection ncbi_heapmgr[<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_heapmgr.h">.h</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/ncbi_heapmgr.c">.c</a>]</p></li></ul></li><li><p>Connection Library Utilities</p><ul><li><p>Connection Utilities ncbi_connutil[<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_connutil.h">.h</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/ncbi_connutil.c">.c</a>]</p></li><li><p>Send Mail (in accordance with RFC821 [protocol] and RFC822 [headers])ncbi_sendmail[<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_sendmail.h">.h</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/ncbi_sendmail.c">.c</a>]</p></li><li><p>Auxiliary (optional) Code for <span class="nctnt ncbi-path">ncbi_core.[ch]</span> ncbi_util[<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_util.h">.h</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/ncbi_util.c">.c</a>]</p></li><li><p>Non-ANSI, Widely Used Functions ncbi_ansi_ext[<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source//src/connect/ncbi_ansi_ext.h">.h</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/ncbi_ansi_ext.c">.c</a>]</p></li></ul></li></ul><p><b>daemons</b> [<a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lxr/source//src/connect/daemons">src/connect/daemons</a>]</p><ul><li><p>LBSMD</p></li><li><p><a href="ch_app.html#ch_app.DISPD_Network_Dispat">DISPD</a></p></li><li><p><a href="ch_app.html#ch_app.Firewall_Daemon_FWDa">Firewall Daemon</a></p></li></ul><p><b>Test Cases</b> [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/test">src/connect/test</a>]</p></div></div><div class="sec" id="ch_conn.conn_interf_lib"><h2><span class="title">Overview</span></h2><p>The NCBI C++ platform-independent connection library (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect">src/connect</a> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect">include/connect</a>) consists of two parts:</p><ul><li><p>Lower-level library written in C (also used as a replacement of the existing connection library in the NCBI C Toolkit)</p></li><li><p>Upper-level library written in C++ and using C++ streams</p></li></ul><p>Functionality of the library includes:</p><ul><li><p><span class="nctnt ncbi-type">SOCK</span> interface (sockets), which works interchangeably on most UNIX varieties, MS Windows, and Mac</p></li><li><p><span class="nctnt ncbi-type">SERV</span> interface, which provides mapping of symbolic service names into server addresses</p></li><li><p><span class="nctnt ncbi-type">CONN</span> interface, which allows the creation of a <span class="nctnt ncbi-monospace">connection</span>, the special object capable to do read, write, etc. I/O operations</p></li><li><p>C++ streams built on top of the <span class="nctnt ncbi-type">CONN</span> interface</p></li></ul><p><span class="nctnt highlight">Note</span>: The lowest level (<span class="nctnt ncbi-type">SOCK</span>) interface is not covered in this document. A well-commented API can be found in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_socket.h">connect/ncbi_socket.h</a>.</p></div><div class="sec" id="ch_conn.conn_def"><h2><span class="title">Connections</span></h2><p>There are three simple types of connections: <span class="nctnt ncbi-monospace">socket</span>, <span class="nctnt ncbi-monospace">file</span> and <span class="nctnt ncbi-monospace">http</span>; and one hybrid type, <span class="nctnt ncbi-monospace">service</span> connection.</p><p>A connection is created with a call to <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CONN_Create">CONN_Create()</a>, declared in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_connection.h">connect/ncbi_connection.h</a>, and returned by a pointer to <span class="nctnt ncbi-type">CONN</span> passed as a second argument:</p><pre><span class="nctnt-pre ncbi-code">CONN conn; /* connection handle */<br />EIO_Status status = CONN_Create(connector, &amp;conn);</span></pre><p>The first argument of this function is a handle of a <span class="nctnt ncbi-monospace">connector</span>, a special object implementing functionality of the connection being built. Above, for each type of connection there is a special connector in the library. For each connector, one or more "constructors" are defined, each returning the connector's handle. Connectors' constructors are defined in individual header files, such as <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_socket_connector.h">connect/ncbi_socket_connector.h</a>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_http_connector.h">connect/ncbi_http_connector.h</a>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_service_connector.h">connect/ncbi_service_connector.h</a>, etc. <span class="nctnt ncbi-func">CONN_Create()</span> resets all timeouts to the default value <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=kDefaultTimeout">kDefaultTimeout</a>.</p><p>After successful creation with <span class="nctnt ncbi-func">CONN_Create()</span>, the following calls from <span class="nctnt ncbi-type">CONN</span> API <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_connection.h">connect/ncbi_connection.h</a> become available. All calls (except <span class="nctnt ncbi-func">CONN_GetTimeout()</span>  and  <span class="nctnt ncbi-func">CONN_GetType()</span> ) return an I/O completion status of type <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=EIO_Status">EIO_Status</a>. Normal completion has code <span class="nctnt ncbi-var">eIO_Success</span>.</p><p><span class="nctnt highlight">Note</span>: There is no means to "open" a connection: it is done automatically when actually needed, and in most cases at the first I/O operation. But the forming of an actual link between source and destination can be postponed even longer. These details are hidden and made transparent to the connection's user. The connection is seen as a two-way communication channel, which is clear for use immediately after a call to <span class="nctnt ncbi-func">CONN_Create()</span>.</p><p><span class="nctnt highlight">Note</span>: If for some reason <span class="nctnt ncbi-func">CONN_Create()</span> failed to create a connection (return code differs from <span class="nctnt ncbi-var">eIO_Success</span>), then the connector passed to this function is left intact, that is, its handle can be used again. Otherwise, if the connection is created successfully, the passed connector handle becomes invalid and cannot be referenced anywhere else throughout the program (with one exception, however: it may be used as a replacing connector in a call to <span class="nctnt ncbi-func">CONN_ReInit()</span> for the same connection).</p><p><span class="nctnt highlight">Note</span>: There are no "destructors" on public connectors. A connector successfully put into connection is deleted automatically, along with that connection by <span class="nctnt ncbi-func">CONN_Close()</span>, or explicitly with a call to <span class="nctnt ncbi-func">CONN_ReInit()</span>, provided that the replacing connector is <span class="nctnt ncbi-macro">NULL</span> or different from the original.</p><div class="table" id="ch_conn.T.nc_conn_readconn_conn_void_buf"><table><tbody><tr><td align="left" valign="top" rowspan="1" colspan="1"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CONN_Read">CONN_Read</a><span class="nctnt ncbi-code">(CONN conn, void* buf, size_t size, size_t* n_read,</span><br /><span class="nctnt ncbi-code">          EIO_ReadMethod how)</span></td></tr></tbody></table></div><p>Read or peek data, depending on read method <span class="nctnt ncbi-var">how</span>, up to <span class="nctnt ncbi-var">size</span> bytes from connection to specified buffer <span class="nctnt ncbi-var">buf</span>, return (via pointer argument <span class="nctnt ncbi-var">n_read</span>) the number of bytes actually read. The last argument <span class="nctnt ncbi-var">how</span> can be one of the following:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=EIO_ReadMethod">eIO_ReadPlain</a> - to read data in a regular way, that is, extracting data from the connection;</p></li><li><p><span class="nctnt ncbi-var">eIO_ReadPeek</span>  - to peek data from the connection, i.e., the next read operation will see the data again;</p></li><li><p><span class="nctnt ncbi-var">eIO_ReadPersist</span>  - to read exactly (not less than) <span class="nctnt ncbi-var">size</span> bytes or until an error condition occurs.</p></li></ul><p>A return value other than <span class="nctnt ncbi-var">eIO_Success</span> means trouble. Specifically, the return value <span class="nctnt ncbi-var">eIO_Timeout</span> indicates that the operation could not be completed within the allotted amount of time; but some data may, however, be available in the buffer (e.g., in case of persistent reading, as with <span class="nctnt ncbi-var">eIO_ReadPersist</span>), and this is actually the case for any return code.</p><div class="table" id="ch_conn.T.nc_conn_readlineconn_conn_char"><table><tbody><tr><td align="left" valign="top" rowspan="1" colspan="1"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CONN_ReadLine">CONN_ReadLine</a><span class="nctnt ncbi-code">(CONN conn, char* line, size_t size, size_t* n_read)</span></td></tr></tbody></table></div><p>Read up to <span class="nctnt ncbi-var">size</span> bytes from connection into the string buffer pointed to by <span class="nctnt ncbi-var">line</span>.  Stop reading if either '\n' or an error is encountered. Replace '\n' with '\0'.  Upon return <span class="nctnt ncbi-var">*n_read</span> contains the number of characters written to <span class="nctnt ncbi-var">line</span>, not including the terminating '\0'. If not enough space provided in <span class="nctnt ncbi-var">line</span> to accomodate the '\0'-terminated line, then all <span class="nctnt ncbi-var">size</span> bytes are used up and <span class="nctnt ncbi-var">*n_read</span> is equal to <span class="nctnt ncbi-var">size</span> upon return - this is the only case when <span class="nctnt ncbi-var">line</span> will not be '\0'-terminated.</p><p>Return code advises the caller whether another read can be attempted:</p><ul><li><p><span class="nctnt ncbi-var">eIO_Success</span> -- read completed successfully, keep reading;</p></li><li><p>other code  -- an error occurred, and further attempt may fail.</p></li></ul><p>This call utilizes <span class="nctnt ncbi-var">eIO_Read</span> timeout as set by <span class="nctnt ncbi-func">CONN_SetTimeout().</span></p><div class="table" id="ch_conn.T.nc_conn_writeconn_conn_const_v"><table><tbody><tr><td align="left" valign="top" rowspan="1" colspan="1"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CONN_Write">CONN_Write</a><span class="nctnt ncbi-code">(CONN conn, const void* buf, size_t size, size_t* n_written)</span></td></tr></tbody></table></div><p>Write up to <span class="nctnt ncbi-var">size</span> bytes from the buffer <span class="nctnt ncbi-var">buf</span> to the connection. Return the number of actually written bytes in <span class="nctnt ncbi-var">n_written</span>. It may not return <span class="nctnt ncbi-var">eIO_Success</span> if no data at all can be written before the write timeout expired or an error occurred. Parameter <span class="nctnt ncbi-var">how</span> modifies the write behavior:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=EIO_WriteMethod">eIO_WritePlain</a> - return immediately after having written as little as 1 byte of data, or if an error has occurred;</p></li><li><p><span class="nctnt ncbi-var">eIO_WritePersist</span>  - return only after having written all of the data from <span class="nctnt ncbi-var">buf</span> (<span class="nctnt ncbi-var">eIO_Success</span>), or if an error has occurred (fewer bytes written, non-<span class="nctnt ncbi-var">eIO_Success</span>).</p></li></ul><p><span class="nctnt highlight">Note:</span>  See CONN_SetTimeout() for how to set the write timeout.</p><div class="table" id="ch_conn.T.nc_conn_pushbackconn_conn_cons"><table><tbody><tr><td align="left" valign="top" rowspan="1" colspan="1"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CONN_PushBack">CONN_PushBack</a><span class="nctnt ncbi-code">(CONN conn, const void* buf, size_t size)</span></td></tr></tbody></table></div><p>Push back <span class="nctnt ncbi-var">size</span> bytes from the buffer <span class="nctnt ncbi-var">buf</span> into connection. Return <span class="nctnt ncbi-var">eIO_Success</span> on success, other code on error.</p><p><span class="nctnt highlight">Note 1:</span> The data pushed back may not necessarily be the same as previously obtained from the connection.</p><p><span class="nctnt highlight">Note 2:</span> Upon a following read operation, the pushed back data are taken out first.</p><div class="table" id="ch_conn.T.nc_conn_getpositionconn_conn_e"><table><tbody><tr><td align="left" valign="top" rowspan="1" colspan="1"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CONN_GetPosition">CONN_GetPosition</a><span class="nctnt ncbi-code">(CONN conn, EIO_Event event)</span></td></tr></tbody></table></div><p>Get read (<span class="nctnt ncbi-var">event</span> == <span class="nctnt ncbi-var">eIO_Read</span>) or write (<span class="nctnt ncbi-var">event</span> == <span class="nctnt ncbi-var">eIO_Write</span>) position within the connection. Positions are advanced from 0 on, and only concerning I/O that has caused calling to the actual connector's "read" (i.e. pushbacks never considered, and peeks -- not always) and "write" methods. Special case:  <span class="nctnt ncbi-var">eIO_Open</span> as <span class="nctnt ncbi-var">event</span> causes to clear both positions with 0, and to return 0.</p><div class="table" id="ch_conn.T.nc_conn_flushconn_conn"><table><tbody><tr><td align="left" valign="top" rowspan="1" colspan="1"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CONN_Flush">CONN_Flush</a><span class="nctnt ncbi-code">(CONN conn)</span></td></tr></tbody></table></div><p>Explicitly flush connection from any pending data written by <span class="nctnt ncbi-func">CONN_Write()</span>.</p><p><span class="nctnt highlight">Note 1: </span><span class="nctnt ncbi-func">CONN_Flush()</span> effectively opens connection (if it wasn't open yet).</p><p><span class="nctnt highlight">Note 2:</span> Connection considered open if underlying connector's "Open" method has successfully executed; an actual data link may not yet exist.</p><p><span class="nctnt highlight">Note 3: </span><span class="nctnt ncbi-func">CONN_Read()</span> always calls <span class="nctnt ncbi-func">CONN_Flush()</span> before proceeding; so does <span class="nctnt ncbi-func">CONN_Close()</span> but only if the connection is already open.</p><div class="table" id="ch_conn.T.nc_conn_settimeoutconn_conn_ei"><table><tbody><tr><td align="left" valign="top" rowspan="1" colspan="1"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CONN_SetTimeout">CONN_SetTimeout</a><span class="nctnt ncbi-code">(CONN conn, EIO_Event action, const STimeout* timeout)</span></td></tr></tbody></table></div><p>Set the timeout on the specified I/O action, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=EIO_Event">eIO_Read</a>, <span class="nctnt ncbi-var">eIO_Write</span>, <span class="nctnt ncbi-var">eIO_ReadWrite</span>, <span class="nctnt ncbi-var">eIO_Open</span>, and <span class="nctnt ncbi-var">eIO_Close</span>. The latter two actions are used in a phase of opening and closing the link, respectively. If the connection cannot be read (written, established, closed) within the specified period, <span class="nctnt ncbi-var">eIO_Timeout</span> would result from connection I/O calls. A timeout can be passed as the <span class="nctnt ncbi-macro">NULL</span>-pointer. This special case denotes an infinite value for that timeout. Also, a special value <span class="nctnt ncbi-var">kDefaultTimeout</span> may be used for any timeout. This value specifies the timeout set by default for the current connection type.</p><div class="table" id="ch_conn.T.nc_conn_gettimeoutconn_conn_ei"><table><tbody><tr><td align="left" valign="top" rowspan="1" colspan="1"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CONN_GetTimeout">CONN_GetTimeout</a><span class="nctnt ncbi-code">(CONN conn, EIO_Event action)</span></td></tr></tbody></table></div><p>Obtain (via the return value of type <span class="nctnt ncbi-type">const </span><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=STimeout">STimeout</a><span class="nctnt ncbi-type">*</span>) timeouts set by the  <span class="nctnt ncbi-func">CONN_SetTimeout()</span> routine, or active by default (i.e., special value <span class="nctnt ncbi-var">kDefaultTimeout</span>).</p><p><span class="nctnt highlight">Caution</span>: The returned pointer is valid only for the time that the connection handle is valid, i.e., up to a call to  <span class="nctnt ncbi-func">CONN_Close().</span></p><div class="table" id="ch_conn.T.nc_conn_reinitconn_conn_connec"><table><tbody><tr><td align="left" valign="top" rowspan="1" colspan="1"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CONN_ReInit">CONN_ReInit</a><span class="nctnt ncbi-code">(CONN conn, CONNECTOR replacement)</span></td></tr></tbody></table></div><p>This function clears the current contents of a connection and places ("immerse") a new connector into it. The previous connector (if any) is closed first (if open), then gets destroyed, and thus must not be referenced again in the program. As a special case, the new connector can be the same connector, which is currently active within the connection. It this case, the connector is not destroyed; instead, it will be effectively re-opened. If the connector passed as <span class="nctnt ncbi-macro">NULL</span>, then the <span class="nctnt ncbi-var">conn</span> handle is kept existing but unusable (the old connector closed and destroyed) and can be <span class="nctnt ncbi-func">CONN_ReInit()</span>'ed later. None of the timeouts are touched by this call.</p><div class="table" id="ch_conn.T.nc_conn_waitconn_conn_eio_even"><table><tbody><tr><td align="left" valign="top" rowspan="1" colspan="1"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CONN_Wait">CONN_Wait</a><span class="nctnt ncbi-code">(CONN conn, EIO_Event event, const STimeout* timeout)</span></td></tr></tbody></table></div><p>Suspend the program until the connection is ready to perform reading (<span class="nctnt ncbi-var">event</span> =<span class="nctnt ncbi-var">eIO_Read</span>) or writing (<span class="nctnt ncbi-var">event</span> = <span class="nctnt ncbi-var">eIO_Write</span>), or until the timeout (if non-<span class="nctnt ncbi-macro">NULL</span>) expires. If the timeout is passed as <span class="nctnt ncbi-macro">NULL</span>, then the wait time is indefinite.</p><div class="table" id="ch_conn.T.nc_conn_statusconn_conn_eio_ev"><table><tbody><tr><td align="left" valign="top" rowspan="1" colspan="1"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CONN_Status">CONN_Status</a><span class="nctnt ncbi-code">(CONN conn, EIO_Event direction)</span></td></tr></tbody></table></div><p>Provide the information about recent low-level data exchange in the link. The operation direction has to be specified as either <span class="nctnt ncbi-var">eIO_Read</span> or <span class="nctnt ncbi-var">eIO_Write</span>. The necessity of this call arises from the fact that sometimes the return value of a <span class="nctnt ncbi-type">CONN</span> API function does not really tell that the problem has been detected: suppose, the user peeks data into a 100-byte buffer and gets 10 bytes. The return status <span class="nctnt ncbi-var">eIO_Success</span> signals that those 10 bytes were found in the connection okay. But how do you know whether the end-of-file condition occurred during the last operation? This is where <span class="nctnt ncbi-func">CONN_Status()</span> comes in handy. When inquired about the read operation, return value <span class="nctnt ncbi-var">eIO_Closed</span> denotes that <span class="nctnt ncbi-macro">EOF</span> was actually hit while making the peek, and those 10 bytes are in fact the only data left untaken, no more are expected to come.</p><div class="table" id="ch_conn.T.nc_conn_closeconn_conn"><table><tbody><tr><td align="left" valign="top" rowspan="1" colspan="1"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CONN_Close">CONN_Close</a><span class="nctnt ncbi-code">(CONN conn)</span></td></tr></tbody></table></div><p>Close the connection by closing the link (if open), deleting underlying connector(s) (if any) and the connection itself. Regardless of the return status (which may indicate certain problems), the connection handle becomes invalid and cannot be reused.</p><div class="table" id="ch_conn.T.nc_conn_cancelconn_conn"><table><tbody><tr><td align="left" valign="top" rowspan="1" colspan="1"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CONN_Cancel">CONN_Cancel</a><span class="nctnt ncbi-code">(CONN conn)</span></td></tr></tbody></table></div><p>Cancel the connection's I/O ability. This is <b>not</b> connection closure, but any data extraction or insertion (Read/Write) will be effectively rejected after this call (and <span class="nctnt ncbi-var">eIO_Interrupt</span> will result, same for <span class="nctnt ncbi-func">CONN_Status()</span>). <span class="nctnt ncbi-func">CONN_Close()</span> is still required to release internal connection structures.</p><div class="table" id="ch_conn.T.nc_conn_gettypeconn_conn"><table><tbody><tr><td align="left" valign="top" rowspan="1" colspan="1"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CONN_GetType">CONN_GetType</a><span class="nctnt ncbi-code">(CONN conn)</span></td></tr></tbody></table></div><p>Return character string (null-terminated), verbally representing the current connection type, such as <span class="nctnt ncbi-monospace">"HTTP"</span>, <span class="nctnt ncbi-monospace">"SOCKET"</span>, <span class="nctnt ncbi-monospace">"SERVICE/HTTP"</span>, etc. The unknown connection type gets returned as <span class="nctnt ncbi-macro">NULL</span>.</p><div class="table" id="ch_conn.T.nc_conn_descriptionconn_conn"><table><tbody><tr><td align="left" valign="top" rowspan="1" colspan="1"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CONN_Description">CONN_Description</a><span class="nctnt ncbi-code">(CONN conn)</span></td></tr></tbody></table></div><p>Return a human-readable description of the connection as a character '\0'-terminated string. The string is not guaranteed to have any particular format and is intended solely for something like logging and debugging.  Return <span class="nctnt ncbi-macro">NULL</span> if the connection cannot provide any description information (or if it is in a bad state). Application program must call <span class="nctnt ncbi-func">free()</span> to deallocate space occupied by the returned string when the description is no longer needed.</p><div class="table" id="ch_conn.T.nc_conn_setcallbackconn_conn_e"><table><tbody><tr><td align="left" valign="top" rowspan="1" colspan="1"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CONN_SetCallback">CONN_SetCallback</a><span class="nctnt ncbi-code">(CONN conn, ECONN_Callback type,</span><br /><span class="nctnt ncbi-code">               const SCONN_Callback* new_cb, SCONN_Callback* old_cb)</span></td></tr></tbody></table></div><p>Set user callback function to be invoked upon an event specified by callback <span class="nctnt ncbi-var">type</span>. The old callback (if any) gets returned via the passed pointer <span class="nctnt ncbi-var">old_cb</span> (if not <span class="nctnt ncbi-macro">NULL</span>). Callback structure <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SCONN_Callback">SCONN_Callback</a> has the following fields: callback function <span class="nctnt ncbi-monospace">func</span> and <span class="nctnt ncbi-monospace">void* data</span>. Callback function <span class="nctnt ncbi-var">func</span> should have the following prototype:</p><p><span class="nctnt ncbi-code">typedef void (*FCONN_Callback)(CONN conn, ECONN_Callback type, void* data)</span></p><p>When called, both <span class="nctnt ncbi-var">type</span> of callback and <span class="nctnt ncbi-var">data</span> pointer are supplied. The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=ECONN_Callback">callback types</a> defined at the time of this writing are:</p><ul><li><p><span class="nctnt ncbi-var">eCONN_OnClose</span></p></li><li><p><span class="nctnt ncbi-var">eCONN_OnRead</span></p></li><li><p><span class="nctnt ncbi-var">eCONN_OnWrite</span></p></li><li><p><span class="nctnt ncbi-var">eCONN_OnCancel</span></p></li></ul><p>The callback function is always called prior to the event happening, e.g., a close callback is called when the connection is about to close.</p><div class="sec" id="ch_conn.socket_connector"><h3><span class="title">Socket Connector</span></h3><p>Constructors are defined in:</p><pre><span class="nctnt-pre ncbi-code">#include &lt;</span><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_socket_connector.h">connect/ncbi_socket_connector.h</a><span class="nctnt-pre ncbi-code">&gt;</span></pre><p>A socket connection, based on the socket connector, brings almost direct access to the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_socket.h">SOCK</a> API. It allows the user to create a peer-to-peer data channel between two programs, which can be located anywhere on the Internet.</p><p>To create a socket connection, user has to create a socket connector first, then pass it to <span class="nctnt ncbi-func">CONN_Create()</span>, as in the following example:</p><pre><span class="nctnt-pre ncbi-code">#include &lt;connect/ncbi_socket_connector.h&gt;<br />#include &lt;connect/ncbi_connection.h&gt;<br /><br />#define MAX_TRY 3 /* Try to connect this many times before giving up */<br /><br />unsigned short port = 1234;<br />CONNECTOR socket_connector = SOCK_CreateConnector("host.foo.com", port,<br />    MAX_TRY);<br />if (!socket_connector)<br />    fprintf(stderr, "Cannot create SOCKET connector");<br />else {<br />    CONN conn;<br />    if (CONN_Create(socket_connector, &amp;conn) != eIO_Success)<br />        fprintf(stderr, "CONN_Create failed");<br />    else {<br />        /* Connection created ok, use CONN_... function */<br />        /* to access the network */<br />        ...<br />        CONN_Close(conn);<br />    }<br />}</span></pre><p>A variant form of this connector's constructor, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SOCK_CreateConnectorEx">SOCK_CreateConnectorEx()</a>, takes three more arguments: a pointer to data (of type <span class="nctnt ncbi-type">void*</span>), data size (bytes) to specify the data to be sent as soon as the link has been established, and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=TSOCK_Flags">flags</a>.</p><p>The <span class="nctnt ncbi-path">CONN</span> library defines two more constructors, which build SOCKET connectors on top of existing <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_socket.h">SOCK</a> objects: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SOCK_CreateConnectorOnTop">SOCK_CreateConnectorOnTop()</a> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SOCK_CreateConnectorOnTopEx">SOCK_CreateConnectorOnTopEx()</a>, the description of which is intentionally omitted here because SOCK is not discussed either. Please refer to the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_socket_connector.h">description</a> in the Toolkit code.</p></div><div class="sec" id="ch_conn.file_connector"><h3><span class="title">File Connector</span></h3><p>Constructors defined in:</p><pre><span class="nctnt-pre ncbi-code">#include &lt;</span><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_file_connector.h">connect/ncbi_file_connector.h</a><span class="nctnt-pre ncbi-code">&gt;<br /><br />CONNECTOR file_connector = </span><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=FILE_CreateConnector">FILE_CreateConnector</a><span class="nctnt-pre ncbi-code">("InFile", "OutFile");</span></pre><p>This connector could be used for both reading and writing files, when input goes from one file and output goes to another file. (This differs from normal file I/O, when a single handle is used to access only one file, but rather resembles data exchange via socket.)</p><p>Extended variant of this connector's constructor, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=FILE_CreateConnectorEx">FILE_CreateConnectorEx()</a>, takes an additional argument, a pointer to a structure of type <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SFileConnAttr">SFILE_ConnAttr</a> describing file connector attributes, such as the initial read position to start from in the input file, an open mode for the output file (append <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=EFILE_ConnMode">eFCM_Append</a>, truncate <span class="nctnt ncbi-var">eFCM_Truncate</span>, or seek <span class="nctnt ncbi-var">eFCM_Seek</span> to start writing at a specified file position), and the position in the output file, where to begin output. The attribute pointer passed as <span class="nctnt ncbi-macro">NULL</span> is equivalent to a call to <span class="nctnt ncbi-func">FILE_CreateConnector()</span>, which reads from the very beginning of the input file and entirely overwrites the output file (if any), implicitly using <span class="nctnt ncbi-var">eFCM_Truncate</span>.</p></div><div class="sec" id="ch_conn.Connection_related_parameters"><h3><span class="title">Connection-related parameters for higher-level connection protocols</span></h3><p>The network information structure (from <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_connutil.h">connect/ncbi_connutil.h</a>) defines parameters of the connection point, where a server is running. See the <a href="ch_libconfig.html#ch_libconfig.libconfig_connect">Library Configuration</a> chapter for descriptions of the corresponding configuration parameters.</p><p><span class="nctnt highlight">Note</span>: Not all parameters of the structure shown below apply to every network connector.</p><pre><span class="nctnt-pre ncbi-code">/* Network connection related configurable info struct.<br /> * ATTENTION:  Do NOT fill out this structure (SConnNetInfo) "from scratch"!<br /> *             Instead, use ConnNetInfo_Create() described below to create<br /> *             it, and then fix (hard-code) some fields, if really necessary.<br /> * NOTE1:      Not every field may be fully utilized throughout the library.<br /> * NOTE2:      HTTP passwords can be either clear text or Base64 encoded values<br /> *             enclosed in square brackets [] (which are not Base-64 charset).<br /> *             For encoding / decoding, one can use command line open ssl:<br /> *             echo "password|base64value" | openssl enc {-e|-d} -base64<br /> *             or an online tool (search the Web for "base64 online").<br /> */<br />typedef struct {<br />    char            client_host[256]; /* effective client hostname ('\0'=def)*/<br />    EURLScheme      scheme;           /* only pre-defined types (limited)    */<br />    char            user[64];         /* username (if specified)             */<br />    char            pass[64];         /* password (if any)                   */<br />    char            host[256];        /* host to connect to                  */<br />    unsigned short  port;             /* port to connect to, host byte order */<br />    char            path[1024];       /* service: path(e.g. to  a CGI script)*/<br />    char            args[1024];       /* service: args(e.g. for a CGI script)*/<br />    EReqMethod      req_method;       /* method to use in the request (HTTP) */<br />    const STimeout* timeout;          /* ptr to i/o tmo (infinite if NULL)   */<br />    unsigned short  max_try;          /* max. # of attempts to connect (&gt;= 1)*/<br />    char            http_proxy_host[256]; /* hostname of HTTP proxy server   */<br />    unsigned short  http_proxy_port;      /* port #   of HTTP proxy server   */<br />    char            http_proxy_user[64];  /* http proxy username             */<br />    char            http_proxy_pass[64];  /* http proxy password             */<br />    char            proxy_host[256];  /* CERN-like (non-transp) f/w proxy srv*/<br />    EDebugPrintout  debug_printout;   /* printout some debug info            */<br />    int/*bool*/     stateless;        /* to connect in HTTP-like fashion only*/<br />    int/*bool*/     firewall;         /* to use firewall/relay in connects   */<br />    int/*bool*/     lb_disable;       /* to disable local load-balancing     */<br />    const char*     http_user_header; /* user header to add to HTTP request  */<br />    const char*     http_referer;     /* default referrer (when not spec'd)  */<br /><br />    /* the following field(s) are for the internal use only -- don't touch!  */<br />    STimeout        tmo;              /* default storage for finite timeout  */<br />    const char      svc[1];           /* service which this info created for */<br />} </span><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SConnNetInfo">SConnNetInfo</a><span class="nctnt-pre ncbi-code">;</span></pre><p><span class="nctnt highlight">Caution</span>: Unlike other "static fields" of this structure, <a href="ch_conn.html#ch_conn.Connection_related_parameters">http_user_header</a> (if non-<span class="nctnt ncbi-macro">NULL</span>) is assumed to be dynamically allocated on the heap (via a call to <span class="nctnt ncbi-func">malloc</span>, <span class="nctnt ncbi-func">calloc</span>, or a related function, such as <span class="nctnt ncbi-func">strdup</span>).</p><div class="sec" id="ch_conn.ref_ConnNetInfo_Create_ref"><h4><span class="title">ConnNetInfo convenience API</span></h4><p>Although users can create and fill out this structure via field-by-field assignments, there is, however, a better, easier, much safer, and configurable way (the interface is defined in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_connutil.h">connect/ncbi_connutil.h</a>) to deal with this structure:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=ConnNetInfo_Create">ConnNetInfo_Create</a><span class="nctnt ncbi-code">(const char* service)</span></p></li></ul><p>Create and return a pointer to new <span class="nctnt ncbi-type">SConnNetInfo</span> structure, filled with parameters specific either for a named <span class="nctnt ncbi-var">service</span> or by default (if the <span class="nctnt ncbi-var">service</span> is specified as <span class="nctnt ncbi-macro">NULL</span> - most likely the case for ordinary HTTP connections). Parameters for the structure are taken from (in the order of precedence):</p><ul><li><p>Environment variables of the form <span class="nctnt ncbi-var">&lt;service&gt;_CONN_&lt;name&gt;</span>, where <span class="nctnt ncbi-var">name</span> is the name of the field;</p></li><li><p>Service-specific registry section (see below the note about the registry) named <span class="nctnt ncbi-var">[service]</span> using the key CONN_&lt;name&gt;;</p></li><li><p>environment variable of the form <span class="nctnt ncbi-var">CONN_&lt;name&gt;</span></p></li><li><p>registry section named <span class="nctnt ncbi-var">[CONN]</span> using <span class="nctnt ncbi-var">name</span> as a key</p></li><li><p>default value applied, if none of the above resulted in a successful match</p></li></ul><p>Search for the keys in both environment and registry is not case-sensitive, but the values of the keys are case sensitive (except for enumerated types and boolean values, which can be of any, even mixed, case). Boolean fields accept <span class="nctnt ncbi-monospace">1</span>, <span class="nctnt ncbi-monospace">"ON"</span>, <span class="nctnt ncbi-monospace">"YES"</span>, and <span class="nctnt ncbi-monospace">"TRUE"</span> as <span class="nctnt ncbi-monospace">true</span> values; all other values are treated as <span class="nctnt ncbi-monospace">false</span>. In addition to a floating point number treated as a number of seconds, <span class="nctnt ncbi-var">timeout</span> can accept (case-insensitively) keyword <span class="nctnt ncbi-monospace">"INFINITE"</span>.</p><p><span class="nctnt highlight">Note</span>: The first two steps in the above sequence are skipped if the <span class="nctnt ncbi-var">service</span> name is passed as <span class="nctnt ncbi-macro">NULL</span>.</p><p><span class="nctnt highlight">Caution</span>: The library can not provide reasonable default values for <span class="nctnt ncbi-var">path</span> and <span class="nctnt ncbi-var">args</span> when the structure is used for HTTP connectors.</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=ConnNetInfo_Destroy">ConnNetInfo_Destroy</a><span class="nctnt ncbi-code">(SConnNetInfo* info)</span></p></li></ul><p>Delete and free the info structure via a passed pointer (note that the HTTP user header http_user_header is freed as well).</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=ConnNetInfo_SetUserHeader">ConnNetInfo_SetUserHeader</a><span class="nctnt ncbi-code">(SConnNetInfo* info, const char* new_user_header)</span></p></li></ul><p>Set the new HTTP user header (freeing the previous one, if any) by cloning the passed string argument and storing it in the http_user_header field. New_user_header passed as NULL resets the field.</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=ConnNetInfo_Clone">ConnNetInfo_Clone</a><span class="nctnt ncbi-code">(SConnNetInfo* info)</span></p></li></ul><p>Create and return a pointer to a new <span class="nctnt ncbi-type">SConnNetInfo</span> structure, which is an exact copy of the passed structure. This function is recognizes the dynamic nature of the HTTP <a href="ch_conn.html#ch_conn.Connection_related_parameters">user header field</a>.</p><p><span class="nctnt highlight">Note about the registry</span>. The registry used by the <span class="nctnt ncbi-path">connect</span> library is separate from the <a href="ch_core.html#ch_core.registry">CNcbiRegistry</a> class. To learn more about the difference and how to use both objects together in a single program, please see <a href="ch_res.html#ch_res.c_cxx.html">Using NCBI C and C++ Toolkits Together</a>.</p></div></div><div class="sec" id="ch_conn.HTTP_Connector"><h3><span class="title">HTTP Connector</span></h3><p>Constructors defined in:</p><pre><span class="nctnt-pre ncbi-code">#include &lt;</span><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_http_connector.h">connect/ncbi_http_connector.h</a><span class="nctnt-pre ncbi-code">&gt;</span></pre><p>The simplest form of this connector's constructor takes three parameters:</p><pre><span class="nctnt-pre ncbi-code">CONNECTOR </span><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=HTTP_CreateConnector">HTTP_CreateConnector</a><span class="nctnt-pre ncbi-code">(const </span><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SConnNetInfo">SConnNetInfo</a><span class="nctnt-pre ncbi-code">* net_info,<br />                               const char*         user_header,</span><br />                               <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=THCC_Flags">THCC_Flags</a>          <span class="nctnt-pre ncbi-code">flags);</span></pre><p>a pointer to the network information structure (can be <span class="nctnt ncbi-macro">NULL</span>), a pointer to a custom HTTP tag-value(s) called a user-header, and a bitmask of various flags. The user-header has to be in the form <span class="nctnt ncbi-code">"HTTP-Tag: Tag-value\r\n"</span>, or even multiple tag-values delimited and terminated by <span class="nctnt ncbi-monospace">"\r\n"</span>. If specified, the <span class="nctnt ncbi-var">user_header</span> parameter overrides the corresponding field in the passed <span class="nctnt ncbi-var">net_info</span>.</p><p>The following fields of <span class="nctnt ncbi-type">SConnNetInfo</span> pertain to the HTTP connector: <span class="nctnt ncbi-var">client_host</span>, <span class="nctnt ncbi-var">host</span>, <span class="nctnt ncbi-var">port</span>, <span class="nctnt ncbi-var">path</span>, <span class="nctnt ncbi-var">args</span>, <span class="nctnt ncbi-var">req_method</span> (can be one of <span class="nctnt ncbi-monospace">"GET"</span>, <span class="nctnt ncbi-monospace">"POST"</span>, and <span class="nctnt ncbi-monospace">"ANY"</span>), <span class="nctnt ncbi-var">timeout</span>, <span class="nctnt ncbi-var">max_try</span> (analog of maximal try parameter for the <a href="ch_conn.html#ch_conn.socket_connector">socket connector</a>), <span class="nctnt ncbi-var">http_proxy_host</span>, <span class="nctnt ncbi-var">http_proxy_port</span>, and <span class="nctnt ncbi-var">debug_printout</span> (values are <span class="nctnt ncbi-monospace">"NONE"</span> to disable any trace printout of the connection data, <span class="nctnt ncbi-monospace">"SOME"</span> to enable printing of <span class="nctnt ncbi-type">SConnNetInfo</span> structure before each connection attempt, and <span class="nctnt ncbi-monospace">"DATA"</span> to print both headers and data of the HTTP packets in addition to dumps of <span class="nctnt ncbi-type">SConnNetInfo</span> structures). Values of other fields are ignored.</p><div class="sec" id="ch_conn.fHCC_KeepHeader_ref"><h4><span class="title">HTTP connector's flags</span></h4><p>Argument <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=TSOCK_Flags">flags</a> in the HTTP connector's constructor is a bitwise OR of the following values:</p><ul><li><p><span class="nctnt ncbi-var">fHTTP_AutoReconnect</span> Allow multiple request/reply HTTP transactions. (Otherwise, by default, only one request/reply is allowed.)</p></li><li><p><span class="nctnt ncbi-var">fHTTP_SureFlush</span>  Always flush a request (may consist solely of HTTP header with no body at all) down to the HTTP server before preforming any read or close operations.</p></li><li><p><span class="nctnt ncbi-var">fHTTP_KeepHeader</span>  By default, the HTTP connection sorts out the HTTP header and parses HTTP errors (if any). Thus, reading normally from the connection returns data from the HTTP body only. The flag disables this feature, and the HTTP header is not parsed but instead is passed "as is" to the application on a call to <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CONN_Create">CONN_Read()</a>.</p></li><li><p><span class="nctnt ncbi-var">fHTTP_UrlDecodeInput</span>  Decode input data passed in HTTP body from the HTTP server.</p></li><li><p><span class="nctnt ncbi-var">fHTTP_UrlEncodeOutput</span>  Encode output data passed in the HTTP body to the HTTP server.</p></li><li><p><span class="nctnt ncbi-var">fHTTP_UrlCodec</span>  Perform both decoding and encoding (<span class="nctnt ncbi-var">fHTTP_UrlDecodeInput | fHTTP_UrlEncodeOutput</span>).</p></li><li><p><span class="nctnt ncbi-var">fHTTP_UrlEncodeArgs</span>  Encode URL if it contains special characters such as "+". By default, the arguments are passed "as is" (exactly as taken from <span class="nctnt ncbi-type">SConnNetInfo</span>).</p></li><li><p><span class="nctnt ncbi-var">fHTTP_DropUnread</span>  Drop unread data, which might exist in connection, before making another request/reply HTTP shot. Normally, the connection first tries to read out the data from the HTTP server entirely, until <span class="nctnt ncbi-macro">EOF</span>, and store them in the internal buffer, even if either application did not request the data for reading, or the data were read only partially, so that the next read operation will see the data.</p></li><li><p><span class="nctnt ncbi-var">fHTTP_NoUpread</span>  Do not attempt to empty incoming data channel into a temporary intermediate buffer while writing to the outgoing data channel. By default, writing always makes checks that incoming data are available for reading, and those data are extracted and stored in the buffer. This approach avoids I/O deadlock, when writing creates a backward stream of data, which, if unread, blocks the connection entirely.</p></li><li><p><span class="nctnt ncbi-var">fHTTP_Flushable</span>  By default all data written to the connection are kept until read begins (even though <span class="nctnt ncbi-func">Flush()</span> might have been called in between the writes);  with this flag set, <span class="nctnt ncbi-func">Flush()</span> will result the data to be actually sent to server side, so the following write will form new request, and not get added to the previous one.</p></li><li><p><span class="nctnt ncbi-var">fHTTP_InsecureRedirect</span>  For security reasons the following redirects comprise security risk and, thus, are prohibited:  switching from https to http, and re-posting data (regardless of the transport, either http or https); this flag allows such redirects (if needed) to be honored.</p></li><li><p><span class="nctnt ncbi-var">fHTTP_NoAutoRetry</span>  Do not attempt any auto-retries in case of failing connections (this flag effectively means having <span class="nctnt ncbi-var">SConnNetInfo::max_try</span> set to 1).</p></li><li><p><span class="nctnt ncbi-var">fHTTP_DetachableTunnel </span><span class="nctnt ncbi-func">SOCK_Close()</span> won't close the OS handle.</p></li></ul><p>The HTTP connection will be established using the following URL: <span class="nctnt ncbi-monospace">http://host:port/path?args</span></p><p><span class="nctnt highlight">Note</span> that <span class="nctnt ncbi-var">path</span> has to have a leading slash "/" as the first character, that is, only "http://" and "?" are added by the connector; all other characters appear exactly as specified (but maybe encoded with <span class="nctnt ncbi-var">fHTTP_UrlEncodeArgs</span>). The question mark does not appear if the URL has no arguments.</p><p>A more elaborate form of the HTTP connector's constructor has the following prototype:</p><pre><span class="nctnt-pre ncbi-code">typedef int/*bool*/ (*FHTTP_ParseHeader)<br />(const char*         http_header,   /* HTTP header to parse, '\0'-terminated */<br /> void*               user_data,     /* supplemental user data                */<br /> int                 server_error   /* != 0 if HTTP error                    */<br /> );<br /><br />typedef int/*bool*/ (*FHTTP_Adjust)<br />(SConnNetInfo*       net_info,      /* net_info to adjust (in place)         */<br /> void*               user_data,     /* supplemental user data                */<br /> unsigned int        failure_count  /* how many failures since open          */<br /> );<br /><br />typedef void        (*FHTTP_Cleanup)<br />(void*               user_data      /* supplemental user data for cleanup    */<br /> );<br /><br />CONNECTOR HTTP_CreateConnectorEx<br />(const SConnNetInfo* net_info,<br /> THTTP_Flags         flags,<br /> FHTTP_ParseHeader   parse_header,  /* may be NULL, then no addtl. parsing   */<br /> void*               user_data,     /* user data for HTTP callbacks (CBs)    */<br /> FHTTP_Adjust        adjust,        /* may be NULL, then no adjustments      */<br /> FHTTP_Cleanup       cleanup        /* may be NULL, then no cleanup          */<br /> );</span></pre><p>This form is assumed to be used rarely by the users directly, but it provides rich access to the internal management of HTTP connections.</p><p>The first two arguments are identical to their counterparts in the arguments number one and three of <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=HTTP_CreateConnector">HTTP_CreateConnector()</a>. The HTTP user header field (if any) is taken directly from the <span class="nctnt ncbi-monospace">http_user_header</span> field of <span class="nctnt ncbi-type">SConnNetInfo</span>, a pointer to which is passed as <span class="nctnt ncbi-var">net_info</span> (which in turn can be passed as <span class="nctnt ncbi-macro">NULL</span>, meaning to use the environment, registry, and defaults as described above).</p><p>The third parameter specifies a callback to be activated to parse the HTTP reply header (passed as a single string, with CR-LF (carriage return/line feed) characters incorporated to divide header lines). This callback also gets some custom data <span class="nctnt ncbi-var">user_data</span> as supplied in the fourth argument of the connector's constructor and a boolean value of <span class="nctnt ncbi-monospace">true</span> if the parsed response code from the server was not okay. The callback can return <span class="nctnt ncbi-monospace">false</span> (zero), which is considered the same way as having an error from the HTTP server. However, the pre-parsed error condition (passed in <span class="nctnt ncbi-var">server_error</span>) is retained, even if the return value of the callback is <span class="nctnt ncbi-monospace">true</span>, i.e. the callback is unable to "fix" the error code from the server. This callback is <b>not called</b> if <a href="ch_conn.html#ch_conn.fHCC_KeepHeader_ref">fHTTP_KeepHeader</a> is set in flags.</p><p>The fifth argument is a callback, which is in control when an attempt to connect to the HTTP server has failed. On entry, this callback has current <span class="nctnt ncbi-type">SConnNetInfo</span>, which is requested for an adjusted in an attempt that the connection to the HTTP server will finally succeed. That is, the callback can change anything in the info structure, and the modified structure will be kept for all further connection attempts, until changed by this callback again. The number (starting from 1) of successive failed attempts is given in the argument of the last callback. The callback return value <span class="nctnt ncbi-monospace">true</span> (non-zero) means a successful adjustment. The return value <span class="nctnt ncbi-monospace">false</span> (zero) stops connection attempts and returns an error to the application.</p><p>When the connector is being destroyed, the custom object <span class="nctnt ncbi-var">user_data</span> can be destroyed in the callback, specified as the last argument of the extended constructor.</p><p><span class="nctnt highlight">Note</span>: Any callback may be specified as <span class="nctnt ncbi-macro">NULL</span>, which means that no action is foreseen by the application, and default behavior occurs.</p></div></div><div class="sec" id="ch_conn.service_connector"><h3><span class="title">Service Connector</span></h3><p>Constructors defined in:</p><pre><span class="nctnt-pre ncbi-code">#include &lt;</span><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_service_connector.h">connect/ncbi_service_connector.h</a><span class="nctnt-pre ncbi-code">&gt;</span></pre><p>This is the most complex connector in the library. It can initiate data exchange between an application and a named NCBI service, and the data link can be either wrapped in HTTP or be just a byte-stream (similar to a socket). In fact, this connector sits on top of either <a href="ch_conn.html#ch_conn.Connection_related_parameters">HTTP</a> or <a href="ch_conn.html#ch_conn.socket_connector">SOCKET</a> connectors.</p><p>The library provides two forms of the connector's constructor:</p><pre><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SERVICE_CreateConnector">SERVICE_CreateConnector</a><span class="nctnt-pre ncbi-code">(const char* service_name);</span><br /><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SERVICE_CreateConnectorEx">SERVICE_CreateConnectorEx</a><span class="nctnt-pre ncbi-code">(<br />    const char*           service_name,<br />                                    /* The registered name of an NCBI service */</span><br />    <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident? i=TSERV_Type">TSERV_Type</a>            <span class="nctnt-pre ncbi-code">types,    /* Accepted server types, bitmask */</span><br />    <span class="nctnt-pre ncbi-code">const </span><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident? i=SConnNetInfo">SConnNetInfo</a><span class="nctnt-pre ncbi-code">*   net_info, /* Connection parameters */<br />    const </span><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident? i=SSERVICE_Extra">SSERVICE_Extra</a><span class="nctnt-pre ncbi-code">* params);  /* Additional set of parameters, may be NULL */</span></pre><p>The first form is equivalent to <span class="nctnt ncbi-code">SERVICE_CreateConnectorEx(service_name, fSERV_Any, 0, 0)</span>. A named NCBI service is a CGI program or a stand-alone server (can be one of two supported types), which runs at the NCBI site and is accessible by the outside world. A special dispatcher (which runs on the <a href="http://www.ncbi.nlm.nih.gov">NCBI Web servers</a>) performs automatic switching to the appropriate server without having the client to know, a priori, the connection point, i.e. the client just uses the main entry gate of the NCBI Web (usually, <a href="http://www.ncbi.nlm.nih.gov">www.ncbi.nlm.nih.gov</a>) with a request to have a service "<span class="nctnt ncbi-monospace">service_name</span>", then, depending on the service availability, the request will be either <a href="http://www.ncbi.nlm.nih.gov/Service/dispd.cgi?service=bounce">honored</a> (by switching and routing the client to the machine actually running the server: clicking on the previous link should bring you to a page containing "name=value" message, obtained from the special bouncing service as a result of the form submission), <a href="http://www.ncbi.nlm.nih.gov/Service/dispd.cgi?service=blahblah">rejected</a>, or <a href="http://www.ncbi.nlm.nih.gov/Service/dispd.cgi?service=PubMedXml">declined</a>. To the client, the entire process of dispatching is completely transparent (for example, try clicking several times on either of the latter two links and see that the error replies are actually sent from different hosts, and the successful processing of the first link is done by one of several hosts running the bouncing service).</p><p><span class="nctnt highlight">Note:</span> Services can be <a href="ch_conn.html#ch_conn.Service_Redirection">redirected</a>.</p><p>The <a href="ch_app.html#ch_app.DISPD_Network_Dispat">Dispatching Protocol</a> per se is implemented on top of HTTP protocol and is parsed by a CGI program <a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lxr/source//src/connect/daemons//dispd_cgi.c">dispd.cgi</a> (or another dispatching CGI), which is available on the NCBI Web. On every server running the named services, another program, called the <a href="ch_app.html#ch_app.Load_Balancing_Servi">load-balancing daemon</a> (<a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lxr/source//src/connect/daemons//lbsmd.c">lbsmd</a>), is executing. This daemon supports having the same service running on different machines and provides a choice of the one machine that is less loaded. When <span class="nctnt ncbi-app">dispd.cgi</span> receives a request for a named service, it first consults the load-balancing table, which is broadcasted by each load-balancing daemon and populated in a network-wide form on each server. When the corresponding server is found, the client request can be passed, or a dedicated connection to the server can be established. The dispatching is made in such a way that it can be also used directly from most Internet browsers.</p><p>The named service facility uses the following distinction of server types:</p><ul><li><p>HTTP servers, which are usually CGI programs:</p><ul><li><p><span class="nctnt ncbi-type">HTTP_GET</span> servers are those accepting requests only using the HTTP <span class="nctnt ncbi-type">GET</span> method.</p></li><li><p><span class="nctnt ncbi-type">HTTP_POST</span> servers are those accepting requests only using the HTTP <span class="nctnt ncbi-type">POST</span> method.</p></li><li><p><span class="nctnt ncbi-type">HTTP</span> servers are those accepting both of either <span class="nctnt ncbi-type">GET</span> or <span class="nctnt ncbi-type">POST</span> methods.</p></li></ul></li><li><p><span class="nctnt ncbi-type">NCBID</span> servers are those run by a special CGI engine, called <a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lxr/source//src/connect/daemons//dispd_cgi.c">ncbid.cgi</a>, a configurable program (now integrated within <a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lxr/source//src/connect/daemons//dispd_cgi.c">dispd.cgi</a> itself) that can convert byte-stream output from another program (server) started by the request from a dispatcher, to an HTTP-compliant reply (that is, a packet having both HTTP header and body, and suitable, for  example, for Web browsers).</p></li><li><p><span class="nctnt ncbi-type">STANDALONE</span> servers, similar to mailing daemons, are those listening to the network, on their own, for incoming connections.</p></li><li><p><span class="nctnt ncbi-type">FIREWALL</span> servers are the special pseudo-servers, not existing in reality, but that are created and used internally by the dispatcher software to indicate that only a firewall connection mode can be used to access the requested service.</p></li><li><p><span class="nctnt ncbi-type">DNS</span> servers are beyond the scope of this document because they are used to declare domain names, which are used internally at the NCBI site to help load-balancing based on DNS lookup (see <a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lxr/source//src/connect/daemons//mghbn.c">here</a>).</p></li></ul><p>A formal description of these types is given in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_server_info.h">connect/ncbi_server_info.h</a>:</p><pre><span class="nctnt-pre ncbi-code">/* Server types<br /> */<br />typedef enum {<br />    fSERV_Ncbid      = 0x01,<br />    fSERV_Standalone = 0x02,<br />    fSERV_HttpGet    = 0x04,<br />    fSERV_HttpPost   = 0x08,<br />    fSERV_Http       = fSERV_HttpGet | fSERV_HttpPost,<br />    fSERV_Firewall   = 0x10,<br />    fSERV_Dns        = 0x20<br />} </span><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=ESERV_Type">ESERV_Type</a><span class="nctnt-pre ncbi-code">;<br /><br />#define fSERV_Any           0<br />#define fSERV_StatelessOnly 0x80<br />typedef unsigned TSERV_Type;  /* bit-wise OR of "ESERV_Type" flags */</span></pre><p>The bitwise <span class="nctnt ncbi-monospace">OR</span> of the <span class="nctnt ncbi-type">ESERV_Type</span> flags can be used to restrict the search for the servers, matching the requested service name. These flags passed as argument <span class="nctnt ncbi-var">types</span> are used by the dispatcher when figuring out which server is acceptable for the client. A special value <span class="nctnt ncbi-monospace">0</span> (or, better <span class="nctnt ncbi-var">fSERV_Any</span>) states no such preference whatsoever. A special bit-value <span class="nctnt ncbi-var">fSERV_StatelessOnly</span> set, together with other bits or just alone, specifies that the servers should be of stateless (HTTP-like) type only, and it is the client who is responsible for keeping track of the logical sequence of the transactions.</p><p>The following code fragment establishes a service connection to the named service <span class="nctnt ncbi-monospace">"io_bounce"</span>, using only stateless servers:</p><pre><span class="nctnt-pre ncbi-code">CONNECTOR c;<br />CONN conn;<br />if(!(c = SERVICE_CreateConnectorEx("io_bounce", fSERV_StatelessOnly, 0, 0))) {<br />    fprintf(stderr, "No such service available");<br />} else if (CONN_Create(c, &amp;conn) != eIO_Success) {<br />    fprintf(stderr, "Failed to create connection");<br />} else {<br />    static const char buffer[] = "Data to pass to the server";<br />    size_t n_written;<br />    CONN_Write(conn, buffer, sizeof(buffer) - 1, &amp;n_written);<br />    ...<br />}</span></pre><p>The real type of the data channel can be obtained via a call to <span class="nctnt ncbi-func">CONN_GetType()</span>.</p><p><span class="nctnt highlight">Note</span>: In the above example, the client has no assumption of how the data actually passed to the server. The server could be of any type in principle, even a stand-alone server, which was used in the request/reply mode of one-shot transactions. If necessary, such wrapping would have been made by the dispatching facility as well.</p><p>The next-to-last parameter of the extended constructor is the network info, described in the section devoted to the <a href="ch_conn.html#ch_conn.Connection_related_parameters">HTTP connector</a>. The service connector uses all fields of this structure, except for <a href="ch_conn.html#ch_conn.Connection_related_parameters">http_user_header</a>, and the following assumptions apply:</p><ul><li><p><span class="nctnt ncbi-var">path</span>  specifies the dispatcher program (defaulted to <span class="nctnt ncbi-app">dispd.cgi</span>)</p></li><li><p><span class="nctnt ncbi-var">args</span>  specifies parameters for the requested service (this is service specific, no defaults)</p></li><li><p><span class="nctnt ncbi-var">stateless</span>  is used to set the <span class="nctnt ncbi-var">fSERV_StatelessOnly</span> flag in the server type bitmask, if it was not set there already (which is convenient for modifying the dispatch by using environment and/or registry, if the flag is not set, yet allows hardcoding of the flag at compile time by setting it in the constructor's <span class="nctnt ncbi-var">types</span> argument explicitly)</p></li><li><p><span class="nctnt ncbi-var">lb_disable</span>  set to <span class="nctnt ncbi-monospace">true</span> (non-zero) means to always use the remote dispatcher (via network connection), even if locally running load-balancing daemon is available (by default, the local load-balancing deamon is consulted first to resolve the name of the service)</p></li><li><p><span class="nctnt ncbi-var">firewall</span>  set to true (non-zero) disables the direct connection to the service; instead,</p><ul><li><p>a connection to a proxy <a href="ch_app.html#ch_app.Firewall_Daemon_FWDa">firewall daemon</a> (<a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lxr/source/src/connect/daemons/fwdaemon.c">fwdaemon</a>), running at the NCBI site, is initiated to pass the data in stream mode;</p></li><li><p>or data get relayed via the dispatcher, if the stateless server is used</p></li></ul></li><li><p><span class="nctnt ncbi-var">http_user_header</span> merged not to conflict with special dispatcher parameter.</p></li></ul><p>As with the HTTP connector, if the network information structure is specified as <span class="nctnt ncbi-macro">NULL</span>, the default values are obtained as described above, as with the call to   <a href="ch_conn.html#ch_conn.ref_ConnNetInfo_Create_ref">ConnNetInfo_Create(service_name)</a>.</p><p>Normally, the last parameter of <span class="nctnt ncbi-func">SERVICE_CreateConnectorEx()</span> is left <span class="nctnt ncbi-macro">NULL</span>, which sets all additional parameters to their default values. Among others, this includes the default procedure of choosing an appropriate server when the connector is looking for a mapping of the service name into a server address. To see how this parameter can be used to change the mapping procedure, please see the <a href="ch_conn.html#ch_conn.service_mapping_api">service mapping API</a> section. The library provides an additional interface to the service mapper, which can be found in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_service.h">connect/ncbi_service.h</a>.</p><p><span class="nctnt highlight">Note</span>: Requesting <span class="nctnt ncbi-var">fSERV_Firewall</span> in the <span class="nctnt ncbi-var">types</span> parameter effectively selects the firewall mode regardless of the network parameters, loaded via the <span class="nctnt ncbi-type">SConnNetInfo</span> structure.</p><div class="sec" id="ch_conn.Service_Redirection"><h4><span class="title">Service Redirection</span></h4><p>Services can be redirected without changing any code - for example, to test production code with a test service, or for debugging. Services are redirected using the <span class="nctnt ncbi-monospace">&lt;service&gt;_CONN_SERVICE_NAME</span> environment variable or the <span class="nctnt ncbi-monospace">[&lt;service&gt;] CONN_SERVICE_NAME</span> registry entry (see the connection library <a href="ch_libconfig.html#ch_libconfig.libconfig_connect">configuration section</a>). The client application will use the original service name, but the connection will actually be made to the redirected-to service.</p></div></div></div><div class="sec" id="ch_conn.conn_debug_tools"><h2><span class="title">Debugging Tools and Troubleshooting</span></h2><p>Each connector (except for the <span class="nctnt ncbi-type">FILE</span> connector) provides a means to view data flow in the connection. In case of the <a href="ch_conn.html#ch_conn.socket_connector">SOCKET</a> connector, debugging information can be turned on by the last argument in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SOCK_CreateConnectorEx">SOCK_CreateConnectorEx()</a> or by using the global routine <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SOCK_SetDataLoggingAPI">SOCK_SetDataLoggingAPI()</a> (declared in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_socket.h">connect/ncbi_socket.h</a>)</p><p><span class="nctnt highlight">Note</span>: In the latter case, every socket (including sockets implicitly used by other connectors such as <span class="nctnt ncbi-type">HTTP</span> or <span class="nctnt ncbi-type">SERVICE</span>) will generate debug printouts.</p><p>In case of <a href="ch_conn.html#ch_conn.Connection_related_parameters">HTTP</a> or <a href="ch_conn.html#ch_conn.service_connector">SERVICE</a> connectors, which use <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SConnNetInfo">SConnNetInfo</a>, debugging can be activated directly from the environment by setting <span class="nctnt ncbi-var">CONN_DEBUG_PRINTOUT</span> to <span class="nctnt ncbi-monospace">TRUE</span> or <span class="nctnt ncbi-monospace">SOME</span>. Similarly, a registry key <span class="nctnt ncbi-var">DEBUG_PRINTOUT</span> with a value of either <span class="nctnt ncbi-monospace">TRUE</span> or <span class="nctnt ncbi-var">SOME</span> found in the section <span class="nctnt ncbi-var">[CONN]</span> will have the same effect: it turns on logging of the connection parameters each time the link is established. When set to <span class="nctnt ncbi-monospace">ALL</span>, this variable (or key) also turns on debugging output on all underlying sockets ever created during the life of the connection. The value <span class="nctnt ncbi-monospace">FALSE</span> (default) turns debugging printouts off. Moreover, for the <span class="nctnt ncbi-type">SERVICE</span> connector, the debugging output option can be set on a per-service basis using <span class="nctnt ncbi-var">&lt;service&gt;_CONN_DEBUG_PRINTOUT</span> environment variables or individual registry sections <span class="nctnt ncbi-var">[&lt;service&gt;]</span> and the key <span class="nctnt ncbi-var">CONN_DEBUG_PRINTOUT</span> in them.</p><p><span class="nctnt highlight">Note</span>: Debugging printouts can only be controlled in a described way via environment or registry if and only if <span class="nctnt ncbi-type">SConnNetInfo</span> is always created with the use of <a href="ch_conn.html#ch_conn.Connection_related_parameters">convenience routines</a>.</p><p>Debugging output is always sent to the same destination, the CORE log file, which is a C object shared between both C and C++ Toolkits. As said previously, the logger is an abstract object, i.e. it is empty and cannot produce any output if not populated accordingly. The library defines a few calls gathered in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_util.h">connect/ncbi_util.h</a>, which allow the logger to output via the <span class="nctnt ncbi-type">FILE</span> file pointer, such as <span class="nctnt ncbi-var">stderr</span>: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CORE_SetLOGFILE">CORE_SetLOGFILE()</a> for example, as shown in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/test/test_ncbi_service_connector.c">test_ncbi_service_connector.c</a>, or to be a regular file on disk. Moreover, both Toolkits define <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/ctools">interfaces</a> to deal with registries, loggers, and locks that use native objects of each toolkit and use them as replacements for the objects of the corresponding abstract layers.</p><p>There is a common problem that has been reported several times and actually concerns network configuration rather than representing a malfunction in the library. If a test program, which connects to a named NCBI service, is not getting anything back from the NCBI site, one first has to check whether there is a transparent proxying/caching between the host and NCBI. Because the service dispatching is implemented on top of the ordinary HTTP protocol, the transparent proxying may latch unsuccessful service searches (which can happen and may not indicate a real problem) as error responses from the NCBI server. Afterwards, instead of actually connecting to NCBI, the proxy returns those cached errors (or sometimes just an empty document), which breaks the service dispatcher code. In most cases, there are configurable ways to exclude certain URLs from proxying and caching, and they are subject for discussion with a local network administrator.</p><p>Here is another tip: Make sure that all custom HTTP header tags (as passed, for example, in the <a href="ch_conn.html#ch_conn.Connection_related_parameters">SConnNetInfo::user_header</a> field) have "\r\n" as tag separators (including the last tag). Many proxy servers (including transparent proxies, of which the user may not even be aware) are known to be sensitive to whether each and every HTTP tag is closed by "\r\n" (and not by a single "\n" character). Otherwise, the HTTP packet may be treated as a defective one and can be discarded.</p><p>Additional discussion on parameters of the service dispatcher as well as the trouble shooting tips can be found <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/NETWORK/dispatcher.html">here</a>.</p></div><div class="sec" id="ch_conn.cpp_connection_streams"><h2><span class="title">C++ Connection Streams</span></h2><p>Using connections and connectors (via the entirely procedural approach) in C++ programs overkills the power of the language. Therefore, we provide C++ users with the stream classes, all derived from a standard <span class="nctnt ncbi-class">iostream</span> class, and as a result, these can be used with all common stream I/O operators, manipulators, etc.</p><p>The declarations of the stream's constructors can be found in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_conn_stream.hpp">connect/ncbi_conn_stream.hpp</a>. We tried to keep the same number and order of the constructor's parameters, as they appear in the corresponding connector's constructors in C.</p><p>The code below is a C++ style example from the previous section devoted to the <a href="ch_conn.html#ch_conn.service_connector">service connector</a>:</p><pre><span class="nctnt-pre ncbi-code">#include &lt;connect/ncbi_conn_stream.hpp&gt;<br />try {<br />    CConn_ServiceStream<br />    ios("io_bounce", fSERV_StatelessOnly, 0);<br />    ios &lt;&lt; "Data to be passed to the server";<br />} STD_CATCH_ALL ("Connection problem");</span></pre><p><span class="nctnt highlight">Note</span>: The stream constructor may show an exception if, for instance, the requested service is not found, or some other kind of problem arose. To see the actual reason, we used a standard toolkit macro <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=STD_CATCH_ALL">STD_CATCH_ALL()</a>, which prints the message and problem description into the log file (<span class="nctnt ncbi-var">cerr</span>, by default).</p></div><div class="sec" id="ch_conn.service_mapping_api"><h2><span class="title">Service mapping API</span></h2><p>The API defined in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_service.h">connect/ncbi_service.h</a> is designed to map the required service name into the server address. Internally, the mapping is done either directly or indirectly by means of the <a href="ch_app.html#ch_app.Load_Balancing_Servi">load-balancing daemon</a>, running at the NCBI site. For the client, the mapping is seen as reading from an iterator created by a call to <span class="nctnt ncbi-func">SERV_Open()</span>, similar to the following fragment (for more examples, please refer to the test program <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/connect/test/test_ncbi_disp.c">test_ncbi_disp.c</a>):</p><pre><span class="nctnt-pre ncbi-code">#include &lt;connect/ncbi_service.h&gt;<br />SERV_ITER iter = SERV_Open("my_service", fSERV_Any, SERV_ANYHOST, 0);<br />int n = 0;<br />if (iter != 0) {<br />    const SSERV_Info * info;<br />    while ((info = SERV_GetNextInfo(iter)) != 0) {<br />        char* str = SERV_WriteInfo(info);<br />        printf("Server = `%s'\n", str);<br />        free(str);<br />        n++;<br />    }<br />    SERV_Close(iter);<br />}<br />if (!iter || !n)<br />    printf("Service not found\n");</span></pre><p><span class="nctnt highlight">Note:</span> Services can be <a href="ch_conn.html#ch_conn.Service_Redirection">redirected</a>.</p><p><span class="nctnt highlight">Note</span>: A non-<span class="nctnt ncbi-macro">NULL</span> iterator returned from <span class="nctnt ncbi-func">SERV_Open()</span><b> does not</b> yet guarantee that the service is available, whereas the <span class="nctnt ncbi-macro">NULL</span> iterator definitely means that the service does not exist.</p><p>As shown in the above example, a loop over reading from the iterator results in the sequence of successive structures (none of which is to be freed by the program!) that along with the conversion functions <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SERV_ReadInfo">SERV_ReadInfo()</a>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SERV_WriteInfo">SERV_WriteInfo()</a> and others are defined in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_server_info.h">connect/ncbi_server_info.h</a>. Structure <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SSERV_Info">SSERV_Info</a> describes a server that implements the requested service. <span class="nctnt ncbi-macro">NULL</span> gets returned when no more servers (if any) could be found. The iterator returns servers in the order that the load-balancing algorithm arranges them. Each server has a rating, and the larger the rating the better the chance for the server to be coming out first (but not necessarily in the order of the rates).</p><p><span class="nctnt highlight">Note</span>: Servers returned from the iterator are all of the requested type, with only one exception: they can include servers of type <span class="nctnt ncbi-var">fSERV_Firewall</span>, even if this type has not been explicitly requested. Therefore, the application must sort these servers out. But if <span class="nctnt ncbi-var">fSERV_Firewall</span> is set in the types, then the search is done for whichever else types are requested, and with the assumption that the client has chosen a firewall connection mode, regardless of the network parameters supplied in <span class="nctnt ncbi-type">SConnNetInfo</span> or read out from either the registry or environment.</p><p><span class="nctnt highlight">Note</span>: A search for servers of type <span class="nctnt ncbi-var">fSERV_Dns</span> is not inclusive with <span class="nctnt ncbi-var">fSERV_Any</span> specified as a server type. That is, servers of type DNS are only returned if specifically requested in the server mask at the time the iterator was opened.</p><p>There is a simplified version of <span class="nctnt ncbi-func">SERV_Open()</span>, called <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SERV_OpenSimple">SERV_OpenSimple()</a>, as well as an advanced version, called <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SERV_OpenEx">SERV_OpenEx()</a>. The former takes only one argument, the service name. The latter takes two more arguments, which describe the set of servers <b>not</b> to be returned from the iterator (server descriptors that to be excluded).</p><p>There is also an advanced version of <span class="nctnt ncbi-func">SERV_GetNextInfo()</span>, called <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SERV_GetNextInfoEx">SERV_GetNextInfoEx()</a>, that, via its second argument, provides the ability to get many host parameters, among which is so-called host environment; a <span class="nctnt ncbi-monospace">"\0"</span>-terminated string, consisting of a set of lines separated by <span class="nctnt ncbi-monospace">"\n"</span> characters and specified in the configuration file of the <a href="ch_app.html#ch_app.Load_Balancing_Servi">load-balancing daemon</a> of the host, where the returned server has been found. The typical line within the set has a form <span class="nctnt ncbi-monospace">"name=value"</span> and resembles very much the shell environment, where its name comes after. The host environment could be very handy for passing additional information to applications if the host has some limitations or requires special handling, should the server be selected and used on this host. The example below shall give an idea. At the time of writing, getting the host information is only implemented when the service is obtained via direct access to the load-balancing daemon. Unlike returned server descriptors, the returned host information handle is not a constant object and must be explicitly freed by the application when no longer needed. All operations (getter methods) that are defined on the host information handle are declared in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/connect/ncbi_host_info.h">connect/ncbi_host_info.h</a>. If the server descriptor was obtained using dispatching CGI (indirect dispatching, see below), then the host information handle is always returned as <span class="nctnt ncbi-macro">NULL</span> (no host information available).</p><p>The back end of the service mapping API is split into two independent parts: <i>direct</i> access to <a href="ch_app.html#ch_app.Load_Balancing_Servi">LBSMD</a>, if the one is both available on the current host and is not disabled by parameter <a href="ch_conn.html#ch_conn.Connection_related_parameters">lb_disable</a> at the iterator opening. If <span class="nctnt ncbi-app">LBSMD</span> is either unavailable or disabled, the second (<i>indirect</i>) part of the back-end API is used, which involves a connection to the <a href="ch_app.html#ch_app.DISPD_Network_Dispat">dispatching CGI</a>, which in turn connects to <span class="nctnt ncbi-app">LBSMD</span> to carry out the request. An attempt to use the CGI is done only if the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SERV_OpenEx">net_info</a> argument is provided as non-<span class="nctnt ncbi-macro">NULL</span> in the calls to <span class="nctnt ncbi-func">SERV_Open()</span> or <span class="nctnt ncbi-func">SERV_OpenEx()</span>.</p><p><span class="nctnt highlight">Note</span>: In a call to <span class="nctnt ncbi-func">SERV_OpenSimple()</span>, <span class="nctnt ncbi-var">net_info</span> gets created internally before an upcall to <span class="nctnt ncbi-func">SERV_Open()</span> and thus CGI dispatching is likely to happen, unless either <span class="nctnt ncbi-var">net_info</span> could not be constructed from the environment, or the environment variable <span class="nctnt ncbi-var">CONN_LB_DISABLE</span> (or a service-specific one, or either of the corresponding registry keys) is set to <span class="nctnt ncbi-monospace">TRUE</span>.</p><p><span class="nctnt highlight">Note</span>: In the above conditions, the network service name resolution is also undertaken if the service name could not be resolved (because the service could not be found or because of some other error) with the use of locally running <span class="nctnt ncbi-app">LBSMD</span>.</p><p>The following code example uses both a <a href="ch_conn.html#ch_conn.service_connector">service connector</a> and the service mapping API to access certain services using an alternate way (other than the connector's default) of choosing appropriate servers. By default, the service connector opens an internal service iterator and then tries to connect to the next server, which <span class="nctnt ncbi-func">SERV_GetNextInfo()</span> returns when given the iterator. That is, the server with a higher rate is tried first. If user provides a pointer to structure <span class="nctnt ncbi-type">SSERVICE_Extra</span> as the last parameter of the connector's constructor, then the user-supplied routine (if any) can be called instead to obtain the next server. The routine is also given a supplemental custom argument <span class="nctnt ncbi-var">data</span> taken from <span class="nctnt ncbi-type">SSERVICE_Extra</span>. The (intentionally simplified) example below tries to create a connector to an imaginary service <span class="nctnt ncbi-monospace">"my_service"</span> with the restriction that the server has to additionally have a certain (user-specified) database present. The database name is taken from the LBSMD host environment keyed by <span class="nctnt ncbi-monospace">"my_service_env"</span>, the first word of which is assumed to be the required database name.</p><pre><span class="nctnt-pre ncbi-code">#include &lt;connect/ncbi_service_connector.h&gt;<br />#include &lt;ctype.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;string.h&gt;<br /><br />#define ENV_DB_KEY "my_service_env="<br /><br />/* This routine gets called when connector is about to be destructed. */<br />static void s_CleanupData(void* data)<br />{<br />    free(data); /* we kept database name there */<br />}<br /><br />/* This routine gets called on each internal close of the connector<br /> * (which may be followed by a subsequent internal open).<br /> */<br />static void s_Reset(void* data)<br />{<br />    /* just see that reset happens by printing DB name */<br />    printf("Connection reset, DB: %s\n", (char*) data);<br />}<br /><br />/* 'Data' is what we supplied among extra-parameters in connector's<br /> * constructor.<br /> * 'Iter' is an internal service iterator used by service connector;<br /> * it must remain open.<br /> */<br />static const SSERV_Info* s_GetNextInfo(void* data, SERV_ITER iter)<br />{<br />    const char* db_name = (const char*) data;<br />    size_t len = strlen(db_name);<br />    SSERV_Info* info;<br />    HOST_INFO hinfo;<br />    int reset = 0;<br />    for (;;) {<br />        while ((info = SERV_GetNextInfoEx(iter, &amp;hinfo)) != 0) {<br />            const char* env = HINFO_Environment(hinfo);<br />            const char* c;<br />            for (c = env; c; c = strchr(c, '\n')) {<br />                if (strncmp(c == env ? c : ++c, ENV_DB_KEY,<br />                    sizeof(ENV_DB_KEY)-1) == 0) {<br />                    /* Our keyword has been detected in environment */<br />                    /* for this host */<br />                    c += sizeof(ENV_DB_KEY) - 1;<br />                    while (*c &amp;&amp; isspace(*c))<br />                        c++;<br />                    if (strncmp(c, db_name, len) == 0 &amp;&amp; !isalnum(c + len)) {<br />                        /* Database name match */<br />                        free(hinfo); /* must be freed explicitly */<br />                        return info;<br />                    }<br />                }<br />            }<br />            if (hinfo)<br />            free(hinfo); /* must be freed explicitly */<br />        }<br />        if (reset)<br />            break; /* coming to reset 2 times in a row means no server fit */<br />        SERV_Reset(iter);<br />        reset = 1;<br />    }<br />    return 0; /* no match found */<br />}<br /><br />int main(int argc, char* argv[])<br />{<br />    char* db_name = strdup(argv[1]);<br />    SSERVICE_Extra params;<br />    CONNECTOR c;<br />    CONN conn;<br />    memset(&amp;params, 0, sizeof(params));<br />    params.data = db_name; /* custom data, anything */<br />    params.reset = s_Reset; /* reset routine, may be NULL */<br />    params.cleanup = s_CleanupData; /* cleanup routine, may be NULL*/<br />    params.get_next_info = s_GetNextInfo; /* custom iterator routine */<br />    if (!(c = SERVICE_CreateConnectorEx("my_service",<br />        fSERV_Any, NULL, &amp;params))) {<br />        fprintf(stderr, "Cannot create connector");<br />        exit(1);<br />    }<br />    if (CONN_Create(c, &amp;conn) != eIO_Success) {<br />        fprintf(stderr, "Cannot create connection");<br />        exit(1);<br />    }<br />    /* Now we can use CONN_Read(),CONN_Write() etc to deal with<br />     * connection, and we are assured that the connection is made<br />     * only to the server on such a host which has "db_name"<br />     * specified in configuration file of LBSMD.<br />     */<br />    ...<br />    CONN_Close(conn);<br />    /* this also calls cleanup of user data provided in params */<br />    return 0;<br />}</span></pre><p><span class="nctnt highlight">Note</span>: No network (indirect) mapping occurs in the above example because <span class="nctnt ncbi-var">net_info</span> is passed as <span class="nctnt ncbi-macro">NULL</span> to the connector's constructor.</p><div class="sec" id="ch_conn.Local_specification_"><h3><span class="title">Local specification of the LBSM table</span></h3><p>The LBSM table can also be specified locally, in config file and/or environment variables.</p><p>Service lookup process now involves looking up through the following sources, in this order:</p><ul><li><p>Local environment/registry settings;</p></li><li><p>LBSM table (only in-house;  this step does not exist in the outside builds);</p></li><li><p>Network dispatcher.</p></li></ul><p>Only one source containing the information about the service is used; the next source is only tried if the previous one did not yield in any servers (for the service).</p><p>Step 1 is disabled by default, to enable it set <span class="nctnt ncbi-var">CONN_LOCAL_ENABLE</span> environment variable to "1" (or "ON, or "YES", or "TRUE") or add <span class="nctnt ncbi-var">LOCAL_ENABLE</span>=1 to [<span class="nctnt ncbi-monospace">CONN</span>] section in <span class="nctnt ncbi-path">.ini</span> file. Steps 2 and 3 are enabled by default. To disable them use <span class="nctnt ncbi-var">CONN_LBSMD_DISABLE</span> and/or <span class="nctnt ncbi-var">CONN_DISPD_DISABLE</span> set to "1" in the environment or <span class="nctnt ncbi-var">LBSMD_DISABLE</span>=1 and/or <span class="nctnt ncbi-var">DISPD_DISABLE</span>=1 under the section "[<span class="nctnt ncbi-monospace">CONN</span>]" in the registry, respectively.</p><p><span class="nctnt highlight">Note:</span>  Alternatively, and for the sake of backward compatibility with older application, the use of local LBSM table can be controlled by <span class="nctnt ncbi-var">CONN_LB_DISABLE</span>={0,1} in the environment or <span class="nctnt ncbi-var">LB_DISABLE</span>={0,1} in the "[<span class="nctnt ncbi-monospace">CONN</span>]" section of the registry, or individually on a per service basis:</p><p>For a service "ANAME", <span class="nctnt ncbi-var">ANAME_CONN_LB_DISABLE</span>={0,1} in the environment, or <span class="nctnt ncbi-var">CONN_LB_DISABLE</span>={0,1} in the section "[<span class="nctnt ncbi-monospace">ANAME</span>]" in the registry (to affect setting of this particular service, and no others).</p><p>The local environment / registry settings for service "ANAME" are screened in the following order:</p><ul><li><p>A value of environment variable "<span class="nctnt ncbi-var">ANAME_CONN_LOCAL_SERVER_n</span>";</p></li><li><p>A value of registry key "<span class="nctnt ncbi-var">CONN_LOCAL_SERVER_n</span>" in the registry section "[<span class="nctnt ncbi-monospace">ANAME</span>]"</p></li></ul><p>Note that service names are not case sensitive, yet the environment variables are looked up all capitalized.</p><p>An entry found in the environment takes precedence over an entry (for the same "n") found in the registry.  "n" counts from 0 to 100, and need not to be sequential.</p><p>All service entries can be (optionally) grouped together in a list as a value of either:</p><ul><li><p>Environment variable "<span class="nctnt ncbi-var">CONN_LOCAL_SERVICES</span>", or</p></li><li><p>Registry key "<span class="nctnt ncbi-var">LOCAL_SERVICES</span>" under the registry section "[<span class="nctnt ncbi-monospace">CONN</span>]".</p></li></ul><p>The list of local services is only used in cases of wildcard searches, or in cases of reverse lookups, and is never consulted in regular cases of forward searches by a complete service name.</p><p>Examples:</p><p>1. In <span class="nctnt ncbi-path">.ini</span> file</p><pre><span class="nctnt-pre ncbi-code">[CONN]<br />LOCAL_ENABLE=yes<br />LOCAL_SERVICES="MSSQL10 MSSQL14 MSSQL15 MSSQL16 MSSQL17"<br /><br />[MSSQL10]<br />CONN_LOCAL_SERVER_6="DNS mssql10:1433 L=yes"<br /><br />[MSSQL15]<br />CONN_LOCAL_SERVER_9="DNS mssql15:1433 L=yes"</span></pre><p>Note that entries for MSSQL14, 16, and 17 are not shown, and they are not required (inexistent definitions for declared services are simply ignored).</p><p>2. In environment set the following variables (equivalent to the <span class="nctnt ncbi-path">.ini</span> fragment above but having a higher precedence):</p><pre><span class="nctnt-pre ncbi-code">CONN_LOCAL_ENABLE=yes<br />CONN_LOCAL_SERVICES="MSSQL10 MSSQL14 MSSQL15 MSSQL16 MSSQL17"<br />MSSQL10_CONN_LOCAL_SERVER_6="DNS mssql10:1433 L=yes"<br />MSSQL15_CONN_LOCAL_SERVER_9="DNS mssql15:1433 L=yes"</span></pre><p>You can also look at the <a href="ch_app.html#ch_app.Load_Balancing_Servi">detailed description of LBSMD</a> and a sample configuration file.</p></div></div><div class="sec" id="ch_conn.Threaded_Server_Supp"><h2><span class="title">Threaded Server Support</span></h2><p>This library also provides <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CServer&amp;d=">CServer</a>, an abstract base class for multithreaded network servers. <a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/c%2B%2B/src/connect/test/test_server.cpp">Here</a> is a demonstration of its use. For more information, see the <a href="http://www.ncbi.nlm.nih.gov/books/NBK7188/#ch_grid.CServer_Multithreade">Implementing a Server with CServer</a> section.</p></div></div></div><div class="col four_col last"><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>In this page</h3></div></div><div class="portlet_content"><ul><li><a href="#ch_conn.conn_interf_lib">Overview</a></li><li><a href="#ch_conn.conn_def">Connections</a></li><li><a href="#ch_conn.conn_debug_tools">Debugging Tools and Troubleshooting</a></li><li><a href="#ch_conn.cpp_connection_streams">C++ Connection Streams</a></li><li><a href="#ch_conn.service_mapping_api">Service mapping API</a></li><li><a href="#ch_conn.Threaded_Server_Supp">Threaded Server Support</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Download</h3></div></div><div class="portlet_content"><ul><li><a href="pdf/ch_conn.pdf">PDF version of this page</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Search</h3></div></div><div class="portlet_content"><form name="frmSymbolSearch" onsubmit="return SymbolSearch('toolkit')" action="/" id="frmSymbolSearch"><table><tbody><tr align="center" valign="middle"><td colspan="2" nowrap="nowrap"><input id="search_box" name="__symbol" style="vertical-align:                                          middle; line-height:normal " onkeypress="SymbolSearchKeyPress('toolkit',event)" type="text" />Â Â  
					<label for="search_box" class="offscreen_noflow">Search term</label><button type="submit" value="Search" style="vertical-align:                                          middle; line-height:normal;" onclick="javasrcipt:SymbolSearch('toolkit');">Search</button></td></tr><tr class="internal-only"><th style="text-align:left">Public</th><th style="text-align:left">Internal</th></tr><tr><td><input id="pToolkitAll" name="__symboloc" type="radio" checked="checked" /><label for="pToolkitAll" title="Search in the C/C++ source code and in this Book">All</label></td><td class="internal-only"><input id="iToolkitAll" name="__symboloc" type="radio" /><label for="iToolkitAll" title="Search in the C/C++ source code,  this Book, and Wiki">All</label></td></tr><tr><td><input id="pLXR" name="__symboloc" type="radio" /><label for="pLXR" title="Search the symbol in the source code using LINUX Cross-Reference browser">LXR</label></td><td class="internal-only"><input id="iLXR" name="__symboloc" type="radio" /><label for="iLXR" title="Search the symbol in the source code using LINUX Cross-Reference browser">LXR</label></td></tr><tr><td><input id="pLib" name="__symboloc" type="radio" /><label for="pLib" title="Locate the Toolkit library(es) where the symbol is defined">Library</label></td><td class="internal-only"><input id="iLib" name="__symboloc" type="radio" /><label for="iLib" title="Locate the Toolkit library(es) where the symbol is defined">Library</label></td></tr></tbody></table></form></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Source Browsers</h3></div></div><div class="portlet_content"><ul><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">LXR</a></li><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">Doxygen</a></li><li class="internal-only">LXR: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">public</a> / <a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lxr/ident">internal</a></li><li class="internal-only">Doxygen: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml">public</a> / <a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml">internal</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>SVN Source Repository</h3></div></div><div class="portlet_content"><ul><li><a href="http://www.ncbi.nlm.nih.gov/bookshelf/br.fcgi?book=toolkit&amp;part=ch_getcode_svn#ch_getcode_svn.code_retrieval">Server</a></li><li><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/c++">Web
                            (dev)</a></li><li><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/internal/c++">Web
                            (extra)</a></li><li><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/production/components">Web (prod)</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Resources</h3></div></div><div class="portlet_content"><ul><li class="internal-only"><a href="http://intranet.ncbi.nlm.nih.gov/wiki-private/CxxToolkit">Wiki</a></li><li class="internal-only"><a href="http://jira/browse/CXX">JIRA</a></li><li class="internal-only"><a href="http://intranet/ieb/ToolBox/STAT/test_stat/test_stat_ext.cgi"><span title="View results of testsuite runs on the automatic C++ Toolkit builds">Testsuite</span></a></li><li><a href="release_notes.html">Release Notes</a></li><li><a href="ch_getcode_svn.html#ch_getcode_svn.ftp_download">Download</a></li><li><a href="pdf/TOC.pdf">PDF of the book</a></li><li><a href="ch_style.html">Coding Style</a></li><li><a href="ch_faq.html#ch_faq.mailing_lists">Mailing Lists</a></li><li><a href="mailto:CPP-CORE@NCBI.NLM.NIH.GOV"><span title="Contact C++ Toolkit group">Help and Support</span></a></li></ul></div></div></div></div></div></div></body></html>
