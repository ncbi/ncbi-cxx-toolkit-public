[server]

; Port numbers server responds to clients on.
;ports = 9000, 9001

; Control port for communication between servers and administrative commands
;control_port = 9010

; Logging of starting and ending points of every request (request-start and
; request-stop entries in the log).
;log_requests = yes

; Name of client to be used for execution of all administrative commands (like
; database re-initialization, server re-configuration, shutdown etc).
; If an attempt will be made to execute these commands with any other client
; name an error will be the result.
;admin_client_name = netcache_control

; Whether to force server to always use poll or to choose between select and
; poll dynamically.
;force_use_poll = yes

; maximum number of open connections to the server
;max_connections=100

; Maximum number of worker threads in the server.
;max_threads = 20

; Turn on special debugging mode of NetCache. Never turn it on in production.
;debug_mode = false

; Maximum amount of the memory NetCache uses for all its data.
; At least half of this amount NetCache will use for database cache. If the
; number given is too low for all data NetCache will use as much as necessary
; but least possible ensuring that at least half of this figure is used for
; database cache at all times.
; NB: Memory counted towards this limit doesn't include thread stacks memory
; (8 Mb per thread with default Linux settings), size of executable and probably
; other types of memory not allocated directly inside application.
;memory_limit=1Gb

; Amount of memory considered to be dangerous.
; There's a possibility that memory consumption in NetCache will raise
; significantly if it's under very heavy load. It's almost impossible to reach
; such state and this state is allowed as a trade-off for writing speed. But
; if memory consumption will raise above this alert level NetCache will start
; to work slower releasing some of allocated memory. So this alert level is
; almost a hard memory limit
; NB: Memory counted towards this limit doesn't include thread stacks memory
; (8 Mb per thread with default Linux settings), size of executable and probably
; other types of memory not allocated directly inside application.
; NB: This value should be at least twice as big as memory_limit.
;memory_alert=4Gb

; Priority of client's parameters involved in determining their specific
; settings. Priority is from most specific one to most general. So the following
; value will devide all clients first by the port they are connected to and then
; by cache name they have provided in the command (for the case of ICache).
;app_setup_priority = cache, port

; The following values are default settings for all clients and can be overridden
; for specific clients later. Description of all parameters is given only in this
; section.

; Disable the client completely, do not allow him to execute any command.
;disable_client = false

; Maximum execution time for each command in seconds
;cmd_timeout = 600

; Network inactivity timeout in seconds
;network_timeout = 10

; Default blob expiration timeout in seconds
;blob_ttl = 3600

; Default expiration timeout for blob's version (works only for ICache)
;ver_ttl = 3600

; Granularity of expiration time measuring. Any change in that time less than
; this value won't be recorded. Bigger values can save some writes to database
; and thus some disk activity and performance.
;ttl_unit = 300

; Update blob's time stamp on every read and calculate its expiration time
; from the last read.
;prolong_on_read = true

; Try to find blob on other servers if it's not found locally
;search_on_read = true

; Number of servers required to process the command before it's reported to
; client as successfully finished. 0 means all available servers should process
; the command.
;quorum = 1

; Policy of using passwords for accessing blobs in NetCache. Possible values:
;   no_password - only commands without passwords are accepted
;   with_password - only commands with password are accepted
;   any - any type of command can be sent, either with password or without it
;blob_password_policy=any



; The following is an example of client-by-client specific parameters. Each
; clients group should be described by section with name starting with
; 'app_setup_'. This section should contain client's parameters that identify
; the group and section name that contains specific parameters. Meaning of all
; specific parameters is described in the "server" section.

;[app_setup_1h]
; Parameters identifying clients.
;port = 9000
; Name of the section with specific parameters.
;setup = app_group_1h

;[app_setup_24h]
;port = 9001
;setup = app_group_24h

;[app_setup_blobs]
;port = 9002
;cache = blobs
;setup = app_group_objcache

;[app_setup_ids]
;port = 9002
;cache = ids
;setup = app_group_ids

;[app_setup_bad_cache]
;port = 9001
;cache = foo
;setup = app_group_bad


;[app_group_1h]
;blob_ttl = 3600
;prolong_on_read = true

;[app_group_24h]
;blob_ttl = 184000
;ttl_unit = 3600

;[app_group_objcache]
;blob_ttl = 184000
;ver_ttl = 3600
;prolong_on_read = true

;[app_group_ids]
;blob_ttl = 3600
;prolong_on_read = false

;[app_group_bad]
;disable_client = true



[storage]
; Directory to keep the database.
;path = ./cache

; Prefix for all files in the database
;prefix = nccache

; Delay (seconds) between garbage collector runs.
;gc_delay = 30

; Garbage collector processes blobs in groups of specified amount.
;gc_batch_size = 500

; Parameters of individual files in the database. Each file will grow until
; it reaches at least min_metafile_size/min_datafile_size. Then it will grow
; further until it reaches max_metafile_size/max_datafile_size or percentage of
; useful information in it (everything else being filled with garbage) becomes
; lower than min_useful_meta_pct/min_useful_data_pct (whichever comes first).
; When one of these events happen database file switches to non-active state
; and exists in file system until last blob in it expires. But no new blobs
; are written to this file and most of old blobs are moved from this file if
; it's read by somebody and its expiration time moves further in the future.
;max_metafile_size = 3Mb
;max_datafile_size = 300Mb
;min_metafile_size = 1Mb
;min_datafile_size = 100Mb
;min_useful_meta_pct = 50
;min_useful_data_pct = 50

; Minimum delay between massive moves of blobs from one file to another in order
; to lower amount of garbage in the system.
;min_move_blobs_delay = 300

; Minimum time left for blob to live to allow to move it to newer database parts
;min_blob_life_to_move = 600

; Number of simultaneously active meta- and data-files. Increasing this number
; to some degree should increase concurrency but also increases total number
; of files in the database, which could negatively impact performance.
;parts_cnt = 5

; Each database "part" can be placed into dedicated directory which can improve
; performance on multi-disk servers. If these parameters are not set all
; "parts" are placed in the same directory which is set in "path" parameter.
;path_1 =
;path_2 =
;path_3 =
;path_4 =
;path_5 =

; Limit for database size when garbage collector starts/stops deletion of oldest
; blobs even though they are not yet expired. Value of 0 for db_limit_del_old_on
; means that this feature shouldn't be activated.
;db_limit_del_old_on = 0
;db_limit_del_old_off = 45Gb

; Increment in seconds for deletion of old not-yet-expired blobs. Garbage
; collector will delete all blobs that expire at (now + delete_old_time_step)
; first. Then if that didn't shrink database enough (its size is still bigger
; than db_limit_del_old_off) it will delete all blobs that expire at
; (now + 2 * delete_old_time_step) and so on.
;delete_old_time_step = 900

; Limit for database size when NetCache stops/starts accepting any new blobs
; from client (even it's just re-writing of the old blob). Value of 0 for
; db_limit_stop_write_on means that this feature shouldn't be activated.
;db_limit_stop_write_on = 0
;db_limit_stop_write_off = 90Gb

; Limit in free disk space when NetCache stops/starts accepting any new blobs
; from client.
;disk_free_limit = 5Gb

; Size of special disk space reserve. NetCache creates a dummy file of this size
; and doesn't delete or shrink it until there's not enough space on disk. In this
; case it will gradually shrink this file so that it could successfully write into
; database. When free disk space grows NetCache expands this dummy file up to the
; given reserve size again.
;disk_reserve_size = 1Gb



[mirror]
; Set of servers participating in the mirroring and replication.
; All servers are in the format <group>:<server name>:<control port>.
; Contents of group name doesn't matter - its string value is considered as group
; identification. When each server needs to proxy some client requests it will
; direct them to members of their own group first.
;server_0 = be:nctest11.be-md:9120
;server_1 = be:nctest21.be-md:9120
;server_2 = st:nctest31.st-va:9120
;server_3 = st:nctest32.st-va:9120
;server_4 = be:nctest11.be-md:9121
;server_5 = be:nctest21.be-md:9121
;server_6 = st:nctest31.st-va:9121
;server_7 = st:nctest32.st-va:9121
; Set of slot numbers served by each server participating in the mirroring
;srv_slots_0 = 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25
;srv_slots_1 = 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25
;srv_slots_2 = 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25
;srv_slots_3 = 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25
;srv_slots_4 = 26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50
;srv_slots_5 = 26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50
;srv_slots_6 = 26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50
;srv_slots_7 = 26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50

; File names to output some statistical information useful for building some graphs
; about NetCache's performance
;mirroring_log_file = ./mirroring.log
;periodic_log_file = ./periodic.log
;copy_delay_log_file = ./copy_delay.log

; Filename to store event logs on server shutdown for future synchronization with other
; servers. It's better to be in the same directory as database
;sync_log_file = ./cache/sync_events.log

; Maximum number of records to store in event logs for each slot
;max_slot_log_records = 200000

; Number of records to leave as a reserve below limit when cleaning happens because number
; of records hit the limit
;clean_slot_log_reserve = 1000

; Maximum number of records in the event log to clean in one cleaning transaction
;max_clean_log_batch = 5000

; Minimum time period that should pass between two consecutive forced cleanings (when all
; synchronizations on the slot are aborted to allow cleaning to proceed).
;min_forced_clean_log_period = 30

; Time interval between attempts to clean event log
;clean_log_attempt_interval = 10

; Time interval between periodic synchronizations
;deferred_sync_interval = 10

; Interval from current time to skip in events log during periodic sync
;deferred_sync_head_time = 1

; Interval in events log below last sync time to add to periodic sync
;deferred_sync_tail_time = 10

; Timeout of inactivity in periodic sync when server can be considered out of service
;deferred_sync_timeout = 10

; Time interval between periodic sync retries when sync fails for some reason
;failed_sync_retry_delay = 1

; Time interval during which network errors should occur with some server to consider
; that server out of service and not requiring initial synchronization.
;network_error_timeout = 300

; Percentage of sync channels (to each mirroring co-server) that can be used to
; sync ONLY small blobs
;small_blob_exclusive_threads_pct = 33

; Percentage of sync channels (to each mirroring co-server) that can be used to
; sync both small and large blobs ? but, the small blobs get unconditional priority.
;small_blob_preferred_threads_pct = 33

; NOTE: The number of sync channels (to each mirroring co-server) that can
; be used to sync both small and large blobs ? but where the large blobs get
; unconditional priority is whatever's left after
; the 'small_blob_exclusive_threads_pct' and 'small_blob_preferred_threads_pct'
; are taken off the table. If the result is zero it means that large blobs won't be
; instantaneosly propagated at all.
; If either of the "small-exclusive", "small-preferred" and "large-preferred"
; percentages is not greater than zero, then we try to allocate at least one channel
; to that purpose. If there are not enough (i.e. less than 3) channels, then 1
; channel goes to "small-preferred" and the other (if any) to "small-exclusive".

; Blobs that are larger than this size (in KB) are considered "large".
; These blobs are mirrored at a lesser priority than smaller blobs,
; see 'small_blob_threads_pct' above.
;small_blob_max_size = 100

; Number of threads used to mirror new blobs (or new version of blobs, or other
; client-initiated events) to other servers instantly, as soon as they come in
;threads_instant = 10

; Number of threads used to synchronize with other servers the blobs/events that failed
; to syncronize instantly
;threads_deferred = 40

; Maximum number of active deferred synchronization transactions to hold. More
; synchronization transactions still can be supported in the passive mode
; (i.e. initiated by other servers).
;max_active_syncs = 4

; Maximum allowed number of active deferred synchronization transactions with the same
; peer. This parameter is important when some server with completely wiped out
; database is launched. If this parameter is not low enough then all servers start
; all their active syncs with the new peer and nobody performs sync with each other.
;max_syncs_one_server = 2

; Maximum time percentage that can be spent for deferred synchronization as opposed
; to all other tasks. This number is good to be low to avoid slowing down response
; to clients when some server is restoring full database from scratch.
; Number interpretation is very implementation specific and should be thought of
; only relatively.
;max_deferred_time_pct = 10


; Recommended settings for NetCacheAPI to work properly inside NetCache
[netservice_api]
connection_max_retries = 0
communication_timeout = 10.0

[netcache_api]
throttle_relaxation_period = 5
throttle_by_subsequent_connection_failures = 5
throttle_by_connection_error_rate = 10/20
