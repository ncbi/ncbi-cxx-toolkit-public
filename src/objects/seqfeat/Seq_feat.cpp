/* $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author:  .......
 *
 * File Description:
 *   .......
 *
 * Remark:
 *   This code was originally generated by application DATATOOL
 *   using specifications from the ASN data definition file
 *   'seqfeat.asn'.
 */

// generated includes
#include <ncbi_pch.hpp>
#include <objects/seqfeat/Seq_feat.hpp>

#include <objects/seqloc/Seq_loc.hpp>


BEGIN_NCBI_SCOPE

BEGIN_objects_SCOPE // namespace ncbi::objects::


// destructor
CSeq_feat::~CSeq_feat(void)
{
}


static int s_TypeOrder[] = {
    3, // e_not_set = 0,
    0, // e_Gene,
    3, // e_Org,
    2, // e_Cdregion,
    3, // e_Prot,
    1, // e_Rna,
    3  // e_Pub, and the rest
};

int CSeq_feat::GetTypeSortingOrder(CSeqFeatData::E_Choice type)
{
    return s_TypeOrder[min(size_t(type),
                           sizeof(s_TypeOrder)/sizeof(s_TypeOrder[0])-1)];
}


// Corresponds to SortFeatItemListByPos from the C toolkit
int CSeq_feat::CompareNonLocation(const CSeq_feat& f2,
                                  const CSeq_loc& loc1,
                                  const CSeq_loc& loc2) const
{
    const CSeqFeatData& data1 = GetData();
    const CSeqFeatData& data2 = f2.GetData();
    CSeqFeatData::E_Choice type1 = data1.Which();
    CSeqFeatData::E_Choice type2 = data2.Which();

    if ( type1 != type2 ) { // order by feature type
        int order1 = GetTypeSortingOrder(type1);
        int order2 = GetTypeSortingOrder(type2);
        int diff = order1 - order2;
        if ( diff != 0 )
            return diff;
    }

    // compare internal intervals
    if ( loc1.IsMix()  &&  loc2.IsMix() ) {
        const CSeq_loc_mix::Tdata& l1 = loc1.GetMix().Get();
        const CSeq_loc_mix::Tdata& l2 = loc2.GetMix().Get();
        for ( CSeq_loc_mix::Tdata::const_iterator
                  it1 = l1.begin(), it2 = l2.begin(); ;  it1++, it2++) {
            if ( it1 == l1.end() ) {
                if ( it2 == l2.end() ) {
                    break;
                }
                else {
                    // f1 loc is shorter
                    return -1;
                }
            }
            if ( it2 == l2.end() ) {
                // f2 loc is shorter
                return 1;
            }
            int diff = (*it1)->Compare(**it2);
            if ( diff != 0 )
                return diff;
        }
    }

    {{ // compare subtypes
        CSeqFeatData::ESubtype subtype1 = data1.GetSubtype();
        CSeqFeatData::ESubtype subtype2 = data2.GetSubtype();
        int diff = subtype1 - subtype2;
        if ( diff != 0 )
            return diff;
    }}

    // compare frames of identical CDS ranges
    if ( type1 == CSeqFeatData::e_Cdregion &&
         type2 == CSeqFeatData::e_Cdregion ) {
        CCdregion::EFrame frame1 = data1.GetCdregion().GetFrame();
        CCdregion::EFrame frame2 = data2.GetCdregion().GetFrame();
        if (frame1 > CCdregion::eFrame_one
            ||  frame2 > CCdregion::eFrame_one) {
            int diff = frame1 - frame2;
            if ( diff != 0 )
                return diff;
        }
    }

    // compare labels
    // if imp features
    if ( type1 == CSeqFeatData::e_Imp && type2 == CSeqFeatData::e_Imp ) {
        int diff = NStr::CompareNocase(data1.GetImp().GetKey(),
                                       data2.GetImp().GetKey());
        if ( diff != 0 )
            return diff;
    }

    // XXX - should compare parent seq-annots
    // XXX 1. parent Seq-annot idx.itemID
    // XXX 2. features itemID

    return 0; // unknown
}

const CGene_ref* CSeq_feat::GetGeneXref(void) const

{
    ITERATE(CSeq_feat::TXref, it, GetXref ()) {
        if ((*it)->IsSetData () && (*it)->GetData ().IsGene ()) {
            return &((*it)->GetData ().GetGene ());
        }
    }
    return 0;
}

void CSeq_feat::SetGeneXref(CGene_ref& value)

{
    NON_CONST_ITERATE(CSeq_feat::TXref, it, SetXref ()) {
        if ((*it)->IsSetData () && (*it)->GetData ().IsGene ()) {
            (*it)->SetData ().SetGene ().Assign(value);
            return;
        }
    }
    TXref& xref = SetXref ();
    CRef<CSeqFeatXref> gref (new CSeqFeatXref);
    xref.push_back (gref);
    gref->SetData ().SetGene ().Assign (value);
}

CGene_ref& CSeq_feat::SetGeneXref(void)

{
    NON_CONST_ITERATE(CSeq_feat::TXref, it, SetXref ()) {
        if ((*it)->IsSetData () && (*it)->GetData ().IsGene ()) {
            return ((*it)->SetData ().SetGene ());
        }
    }
    TXref& xref = SetXref ();
    CRef<CSeqFeatXref> gref (new CSeqFeatXref);
    xref.push_back (gref);
    return gref->SetData ().SetGene ();
}

const CProt_ref* CSeq_feat::GetProtXref(void) const

{
    ITERATE(CSeq_feat::TXref, it, GetXref ()) {
        if ((*it)->IsSetData () && (*it)->GetData ().IsProt ()) {
            return &((*it)->GetData ().GetProt ());
        }
    }
    return 0;
}

void CSeq_feat::SetProtXref(CProt_ref& value)

{
    NON_CONST_ITERATE(CSeq_feat::TXref, it, SetXref ()) {
        if ((*it)->IsSetData () && (*it)->GetData ().IsProt ()) {
            (*it)->SetData ().SetProt ().Assign(value);
            return;
        }
    }
    TXref& xref = SetXref ();
    CRef<CSeqFeatXref> pref (new CSeqFeatXref);
    xref.push_back (pref);
    pref->SetData ().SetProt ().Assign (value);
}

CProt_ref& CSeq_feat::SetProtXref(void)

{
    NON_CONST_ITERATE(CSeq_feat::TXref, it, SetXref ()) {
        if ((*it)->IsSetData () && (*it)->GetData ().IsProt ()) {
            return ((*it)->SetData ().SetProt ());
        }
    }
    TXref& xref = SetXref ();
    CRef<CSeqFeatXref> pref (new CSeqFeatXref);
    xref.push_back (pref);
    return pref->SetData ().SetProt ();
}


void CSeq_feat::AddQualifier(const string& qual_name, const string& qual_val)
{
    CRef<CGb_qual> qual(new CGb_qual());
    qual->SetQual(qual_name);
    qual->SetVal(qual_val);
    SetQual().push_back(qual);
}


void CSeq_feat::AddDbxref(const string& db, const string& tag)
{
    CRef<CDbtag> dbtag(new CDbtag());
    dbtag->SetDb(db);
    dbtag->SetTag().SetStr(tag);
    SetDbxref().push_back(dbtag);
}


void CSeq_feat::AddDbxref(const string& db, int tag)
{
    CRef<CDbtag> dbtag(new CDbtag());
    dbtag->SetDb(db);
    dbtag->SetTag().SetId(tag);
    SetDbxref().push_back(dbtag);
}


END_objects_SCOPE // namespace ncbi::objects::

END_NCBI_SCOPE

/*
 * ===========================================================================
 *
 * $Log$
 * Revision 6.19  2004/05/19 17:26:04  gorelenk
 * Added include of PCH - ncbi_pch.hpp
 *
 * Revision 6.18  2004/02/09 14:45:07  vasilche
 * Do not check type order if types are equal.
 *
 * Revision 6.17  2004/01/05 19:16:57  dicuccio
 * Added APIs to ease adding qualifiers and dbxrefs
 *
 * Revision 6.16  2003/12/31 15:36:08  grichenk
 * Moved CompareLocations() from CSeq_feat to CSeq_loc,
 * renamed it to Compare().
 *
 * Revision 6.15  2003/08/07 21:42:31  kans
 * added SetGeneXref and SetProtXref
 *
 * Revision 6.14  2003/04/24 16:15:32  vasilche
 * Fixed CSeq_feat::Compare().
 *
 * Revision 6.13  2003/04/18 19:40:39  kans
 * changed iterate to ITERATE
 *
 * Revision 6.12  2003/02/26 17:53:06  vasilche
 * Added public version of feature comparison assuming that
 * total range check is done already.
 *
 * Revision 6.11  2003/02/24 18:52:57  vasilche
 * Added optional mapped locations arguments to feature comparison.
 *
 * Revision 6.10  2003/02/10 15:52:08  grichenk
 * CSeq_feat::Compare() takes optional seq-locs for remapped features
 *
 * Revision 6.9  2003/02/06 22:24:23  vasilche
 * Added int CSeq_feat::Compare().
 * Fixed slow comparison of CSeq_feat with mix seq locs.
 *
 * Revision 6.8  2003/01/29 17:43:23  vasilche
 * Added Compare(CSeq_feat, CSeq_feat) returning int for easier comparison.
 * operator<(CSeq_feat, CSeq_feat) uses Compare().
 *
 * Revision 6.7  2002/12/19 21:31:29  kans
 * added GetGeneXref and GetProtXref
 *
 * Revision 6.6  2002/09/18 18:31:11  ucko
 * operator <: Remove bogus comparison of feature type labels.
 * operator <: Mention content labels in to-do comment.
 * general: Move CVS log to end per current practice.
 *
 * Revision 6.5  2002/06/06 20:55:48  clausen
 * Moved GetLabel to objects/util/feature.cpp
 *
 * Revision 6.4  2002/05/06 03:39:11  vakatov
 * OM/OM1 renaming
 *
 * Revision 6.3  2002/01/10 19:53:48  clausen
 * Added GetLabel
 *
 * Revision 6.2  2002/01/09 15:59:28  grichenk
 * Fixed includes
 *
 * Revision 6.1  2001/10/30 20:25:58  ucko
 * Implement feature labels/keys, subtypes, and sorting
 *
 *
 * ===========================================================================
 */

/* Original file checksum: lines: 61, chars: 1885, CRC32: 417ca6e0 */
