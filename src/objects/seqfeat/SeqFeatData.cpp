/* $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author:  .......
 *
 * File Description:
 *   .......
 *
 * Remark:
 *   This code was originally generated by application DATATOOL
 *   using specifications from the ASN data definition file
 *   'seqfeat.asn'.
 */

// standard includes

// generated includes
#include <objects/seqfeat/SeqFeatData.hpp>

#include <objects/seqfeat/RNA_ref.hpp>
#include <objects/seqfeat/Imp_feat.hpp>

#include <algorithm>

// generated classes

BEGIN_NCBI_SCOPE

BEGIN_objects_SCOPE // namespace ncbi::objects::

// destructor
CSeqFeatData::~CSeqFeatData(void)
{
}


// ASCII representation of subtype (GenBank feature key, e.g.)
string CSeqFeatData::GetKey(EVocabulary vocab) const
{
    bool genbank = (vocab == eVocabulary_genbank);
    if (genbank) {
        switch (Which()) {
        case e_Gene:
            return "gene";
        case e_Org:
        case e_Biosrc:
            return "source";
        case e_Prot:
            switch (GetProt().GetProcessed()) {
            case CProt_ref::eProcessed_preprotein:
                return "proprotein";
                break;
            case CProt_ref::eProcessed_mature:
                return "mat_peptide";
                break;
            case CProt_ref::eProcessed_signal_peptide:
                return "sig_peptide";
                break;
            case CProt_ref::eProcessed_transit_peptide:
                return "transit_peptide";
                break;
            default:
                return "Protein";
                break;
            }
        case e_Site: // Is this correct, or are these encoded as Imp?
            switch (GetSite()) {
            case CSeqFeatData::eSite_binding:
            case CSeqFeatData::eSite_metal_binding:
            case CSeqFeatData::eSite_lipid_binding:
                return "misc_binding";
            case CSeqFeatData::eSite_np_binding:
                return "protein_bind";
            case CSeqFeatData::eSite_dna_binding:
                return "primer_bind"; // ?
            case CSeqFeatData::eSite_signal_peptide:
                return "sig_peptide";
            case CSeqFeatData::eSite_transit_peptide:
                return "transit_peptide";
            default:
                return "misc_feature";
            }
        case e_Txinit:
            return "promoter"; // ?
        case e_Het:
            return "misc_binding"; // ?
        case e_Cdregion:
        case e_Rna:
        case e_Imp:
            break;
        default:
            return "misc_feature"; // ???
        }
    }

    switch (Which()) {
    case e_Gene:            return "Gene";
    case e_Org:             return "Org";
    case e_Cdregion:        return "CDS";
    case e_Prot:            return "Prot";
    case e_Rna:
        switch (GetRna().GetType()) {
        case CRNA_ref::eType_premsg:  return "precursor_RNA";
        case CRNA_ref::eType_mRNA:    return "mRNA";
        case CRNA_ref::eType_tRNA:    return "tRNA";
        case CRNA_ref::eType_rRNA:    return "rRNA";
        case CRNA_ref::eType_snRNA:   return "snRNA";
        case CRNA_ref::eType_scRNA:   return "scRNA";
        case CRNA_ref::eType_snoRNA:  return "snoRNA"; // ok for GenBank?
        case CRNA_ref::eType_other:
            // return GetRna().GetExt().GetName();
            return genbank ? "misc_RNA" : "RNA";
        default:                      return "misc_RNA";
        }
    case e_Imp:             return GetImp().GetKey(); // "Imp"?
    case e_Region:          return "Region";
    case e_Comment:         return "Comment";
    case e_Bond:            return "Bond";
    case e_Site:            return "Site";
    case e_Rsite:           return "Rsite";
    case e_User:            return "User";
    case e_Txinit:          return "TxInit";
    case e_Num:             return "Num";
    case e_Psec_str:        return "SecStr";
    case e_Non_std_residue: return "NonStdRes";
    case e_Het:             return "Het";
    case e_Biosrc:          return "Src";
    default:                return "???";
    }
}


struct SImportEntry {
    const char*            m_Name;
    CSeqFeatData::ESubtype m_Subtype;

    bool operator<(const SImportEntry& e) const {
        return strcmp(m_Name, e.m_Name) < 0;
    }
};

// NOTE: these must stay in ASCIIbetical order!
static const SImportEntry kImportTable[] = {
    { "-10_signal",          CSeqFeatData::eSubtype_10_signal },
    { "-35_signal",          CSeqFeatData::eSubtype_35_signal },
    { "3'UTR",               CSeqFeatData::eSubtype_3UTR },
    { "3'clip",              CSeqFeatData::eSubtype_3clip },
    { "5'UTR",               CSeqFeatData::eSubtype_5UTR },
    { "5'clip",              CSeqFeatData::eSubtype_5clip },
    { "CAAT_signal",         CSeqFeatData::eSubtype_CAAT_signal },
    { "C_region",            CSeqFeatData::eSubtype_C_region },
    { "D_loop",              CSeqFeatData::eSubtype_D_loop },
    { "D_segment",           CSeqFeatData::eSubtype_D_segment },
    { "GC_signal",           CSeqFeatData::eSubtype_GC_signal },
    { "Imp_CDS",             CSeqFeatData::eSubtype_Imp_CDS },
    { "J_segment",           CSeqFeatData::eSubtype_J_segment },
    { "LTR",                 CSeqFeatData::eSubtype_LTR },
    { "N_region",            CSeqFeatData::eSubtype_N_region },
    { "RBS",                 CSeqFeatData::eSubtype_RBS },
    { "STS",                 CSeqFeatData::eSubtype_STS },
    { "S_region",            CSeqFeatData::eSubtype_S_region },
    { "TATA_signal",         CSeqFeatData::eSubtype_TATA_signal },
    { "V_region",            CSeqFeatData::eSubtype_V_region },
    { "V_segment",           CSeqFeatData::eSubtype_V_segment },
    { "allele",              CSeqFeatData::eSubtype_allele },
    { "attenuator",          CSeqFeatData::eSubtype_attenuator },
    { "conflict",            CSeqFeatData::eSubtype_conflict },
    { "enhancer",            CSeqFeatData::eSubtype_enhancer },
    { "exon",                CSeqFeatData::eSubtype_exon },
    { "gap",                 CSeqFeatData::eSubtype_gap },
    { "iDNA",                CSeqFeatData::eSubtype_iDNA },
    { "intron",              CSeqFeatData::eSubtype_intron },
    { "mat_peptide",         CSeqFeatData::eSubtype_mat_peptide },
    { "misc_RNA",            CSeqFeatData::eSubtype_misc_RNA },
    { "misc_binding",        CSeqFeatData::eSubtype_misc_binding },
    { "misc_difference",     CSeqFeatData::eSubtype_misc_difference },
    { "misc_feature",        CSeqFeatData::eSubtype_misc_feature },
    { "misc_recomb",         CSeqFeatData::eSubtype_misc_recomb },
    { "misc_signal",         CSeqFeatData::eSubtype_misc_signal },
    { "misc_structure",      CSeqFeatData::eSubtype_misc_structure },
    { "modified_base",       CSeqFeatData::eSubtype_modified_base },
    { "mutation",            CSeqFeatData::eSubtype_mutation },
    { "old_sequence",        CSeqFeatData::eSubtype_old_sequence },
    { "operon",              CSeqFeatData::eSubtype_operon },
    { "oriT",                CSeqFeatData::eSubtype_oriT },
    { "polyA_signal",        CSeqFeatData::eSubtype_polyA_signal },
    { "polyA_site",          CSeqFeatData::eSubtype_polyA_site },
    { "precursor_RNA",       CSeqFeatData::eSubtype_precursor_RNA },
    { "prim_transcript",     CSeqFeatData::eSubtype_prim_transcript },
    { "primer_bind",         CSeqFeatData::eSubtype_primer_bind },
    { "promoter",            CSeqFeatData::eSubtype_promoter },
    { "protein_bind",        CSeqFeatData::eSubtype_protein_bind },
    { "rep_origin",          CSeqFeatData::eSubtype_rep_origin },
    { "repeat_region",       CSeqFeatData::eSubtype_repeat_region },
    { "repeat_unit",         CSeqFeatData::eSubtype_repeat_unit },
    { "satellite",           CSeqFeatData::eSubtype_satellite },
    { "sig_peptide",         CSeqFeatData::eSubtype_sig_peptide },
    { "site_ref",            CSeqFeatData::eSubtype_site_ref },
    { "source",              CSeqFeatData::eSubtype_source },
    { "stem_loop",           CSeqFeatData::eSubtype_stem_loop },
    { "terminator",          CSeqFeatData::eSubtype_terminator },
    { "transit_peptide",     CSeqFeatData::eSubtype_transit_peptide },
    { "unsure",              CSeqFeatData::eSubtype_unsure },
    { "variation",           CSeqFeatData::eSubtype_variation },
    { "virion",              CSeqFeatData::eSubtype_virion }
};

static const SImportEntry* kImportTableEnd
    = kImportTable + sizeof(kImportTable)/sizeof(SImportEntry);


CSeqFeatData::ESubtype CSeqFeatData::GetSubtype(void) const
{
    if (m_Subtype == eSubtype_any) { // unknown
        switch (Which()) {
        case e_Gene:       m_Subtype = eSubtype_gene;     break;
        case e_Org:        m_Subtype = eSubtype_org;      break;
        case e_Cdregion:   m_Subtype = eSubtype_cdregion; break;
        case e_Prot:
            switch (GetProt().GetProcessed()) {
            case CProt_ref::eProcessed_preprotein:
                m_Subtype = eSubtype_preprotein;
                break;
            case CProt_ref::eProcessed_mature:
                m_Subtype = eSubtype_mat_peptide_aa;
                break;
            case CProt_ref::eProcessed_signal_peptide:
                m_Subtype = eSubtype_sig_peptide_aa;
                break;
            case CProt_ref::eProcessed_transit_peptide:
                m_Subtype = eSubtype_transit_peptide_aa;
                break;
            default:
                m_Subtype = eSubtype_prot;
                break;
            }
            break;
        case e_Rna:
            switch (GetRna().GetType()) {
            case CRNA_ref::eType_premsg: m_Subtype = eSubtype_preRNA;   break;
            case CRNA_ref::eType_mRNA:   m_Subtype = eSubtype_mRNA;     break;
            case CRNA_ref::eType_tRNA:   m_Subtype = eSubtype_tRNA;     break;
            case CRNA_ref::eType_rRNA:   m_Subtype = eSubtype_rRNA;     break;
            case CRNA_ref::eType_snRNA:  m_Subtype = eSubtype_snRNA;    break;
            case CRNA_ref::eType_scRNA:  m_Subtype = eSubtype_scRNA;    break;
            default:                     m_Subtype = eSubtype_otherRNA; break;
            }
            break;
        case e_Pub:        m_Subtype = eSubtype_pub;      break;
        case e_Seq:        m_Subtype = eSubtype_seq;      break;
        case e_Imp:
        {
            const string&       key    = GetImp().GetKey();
            SImportEntry        key2   = { key.c_str(), eSubtype_imp };
            const SImportEntry* result = lower_bound(kImportTable,
                                                     kImportTableEnd,
                                                     key2);
            if (strcmp(key2.m_Name, result->m_Name)) {
                m_Subtype = eSubtype_imp;
            } else {
                m_Subtype = result->m_Subtype;
            }
            break;
        }
        case e_Region:          m_Subtype = eSubtype_region;          break;
        case e_Comment:         m_Subtype = eSubtype_comment;         break;
        case e_Bond:            m_Subtype = eSubtype_bond;            break;
        case e_Site:            m_Subtype = eSubtype_site;            break;
        case e_Rsite:           m_Subtype = eSubtype_rsite;           break;
        case e_User:            m_Subtype = eSubtype_user;            break;
        case e_Txinit:          m_Subtype = eSubtype_txinit;          break;
        case e_Num:             m_Subtype = eSubtype_num;             break;
        case e_Psec_str:        m_Subtype = eSubtype_psec_str;        break;
        case e_Non_std_residue: m_Subtype = eSubtype_non_std_residue; break;
        case e_Het:             m_Subtype = eSubtype_het;             break;
        case e_Biosrc:          m_Subtype = eSubtype_biosrc;          break;
        default:                m_Subtype = eSubtype_bad;             break;
        }
    } 
    return m_Subtype;
}


CSeqFeatData::E_Choice CSeqFeatData::GetTypeFromSubtype (ESubtype subtype)
{
    switch (subtype) {
        case eSubtype_gene:
            return e_Gene;
        case eSubtype_org:
            return e_Org;
        case eSubtype_cdregion:
            return e_Cdregion;
        case eSubtype_pub:
            return e_Pub;
        case eSubtype_seq:
            return e_Seq;
        case eSubtype_region:
            return e_Region;
        case eSubtype_comment:
            return e_Comment;
        case eSubtype_bond:
            return e_Bond;
        case eSubtype_site:
            return e_Site;
        case eSubtype_rsite:
            return e_Rsite;
        case eSubtype_user:
            return e_User;
        case eSubtype_txinit:
            return e_Txinit;
        case eSubtype_num:
            return e_Num;
        case eSubtype_psec_str:
            return e_Psec_str;
        case eSubtype_non_std_residue:
            return e_Non_std_residue;
        case eSubtype_het:
            return e_Het;
        case eSubtype_biosrc:
            return e_Biosrc;
        default:
            if (subtype >= eSubtype_prot  &&
                subtype <= eSubtype_transit_peptide_aa) {
                return e_Prot;
            }
            if (subtype >= eSubtype_preRNA  &&  subtype <= eSubtype_otherRNA) {
                return e_Rna;
            }
            if (subtype >= eSubtype_imp  &&  subtype <= eSubtype_site_ref) {
                return e_Imp;
            }
            break;
    }
    return e_not_set;
}


END_objects_SCOPE // namespace ncbi::objects::

END_NCBI_SCOPE

/*
* ===========================================================================
*
* $Log$
* Revision 6.11  2004/03/10 21:33:43  shomrat
* Fixed key for genbank vocabulary
*
* Revision 6.10  2003/10/24 17:14:28  shomrat
* added gap, operaon and oriT subtypes
*
* Revision 6.9  2003/06/02 18:06:10  ucko
* GetSubtype: handle imported features more efficiently.
*
* Revision 6.8  2003/05/20 01:29:39  ucko
* Added missing punctuation in imported keys' names.
*
* Revision 6.7  2003/05/19 18:21:32  ucko
* Add "break" statement accidentally dropped in last change.
*
* Revision 6.6  2003/05/19 17:35:56  ucko
* GetSubtype: properly honor Prot-ref.processed, and ignore bogus
* imports with corresponding names.
*
* Revision 6.5  2003/04/19 16:38:45  dicuccio
* Remove compiler warning about nested comments
*
* Revision 6.4  2003/04/18 21:21:25  kans
* added GetTypeFromSubtype, moved log to end of file
*
* Revision 6.3  2002/03/22 16:13:42  ucko
* CSeqFeatData::GetKey: return "Prot" rather than "Protein" in default
* vocabulary.  (Keep "Protein" for Genbank).
*
* Revision 6.2  2002/03/06 21:59:48  ucko
* CSeqFeatData::GetKey: return (misc_)RNA rather than extended name for
* RNA of type "other."
*
* Revision 6.1  2001/10/30 20:25:58  ucko
* Implement feature labels/keys, subtypes, and sorting
*
*
* ===========================================================================
*/
/* Original file checksum: lines: 61, chars: 1894, CRC32: 86fb976 */
