/* $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author:  .......
 *
 * File Description:
 *   .......
 *
 * Remark:
 *   This code was originally generated by application DATATOOL
 *   using specifications from the data definition file
 *   'seqfeat.asn'.
 */

// standard includes

// generated includes
#include <ncbi_pch.hpp>
#include <objects/seqfeat/BioSource.hpp>
#include <objects/seqfeat/Org_ref.hpp>
#include <objects/seqfeat/OrgName.hpp>
#include <objects/seqfeat/SubSource.hpp>
#include <algorithm>
#include <set>

// generated classes

BEGIN_NCBI_SCOPE

BEGIN_objects_SCOPE // namespace ncbi::objects::

// destructor
CBioSource::~CBioSource(void)
{
}


int CBioSource::GetGenCode(void) const
{
    try {
        int genome = 0;

        if ( IsSetGenome() ) {
            genome = GetGenome();
        }

        const COrgName& orn = GetOrg().GetOrgname();

        switch ( genome ) {
        case eGenome_kinetoplast:
        case eGenome_mitochondrion:
            // bacteria and plant organelle code
            return orn.GetMgcode();
        case eGenome_chloroplast:
        case eGenome_chromoplast:
        case eGenome_plastid:
        case eGenome_cyanelle:
        case eGenome_apicoplast:
        case eGenome_leucoplast:
        case eGenome_proplastid:
            // bacteria and plant plastids are code 11.
            return 11;
        default:
            return orn.GetGcode();
        }
    } catch ( CCoreException exp ) {
        return 0;
    }
}


void CBioSource::BasicCleanup(void)
{
    if (IsSetOrg()) {
        SetOrg().BasicCleanup();
        // convert COrg_reg.TMod string to SubSource objects
        x_OrgModToSubtype();
    }
    if (IsSetSubtype()) {
        x_SubtypeCleanup();
    }
}


static CSubSource* s_StringToSubSource(const string& str)
{
    size_t pos = str.find('=');
    if (pos == NPOS) {
        pos = str.find(' ');
    }
    string subtype = str.substr(0, pos);
    try {
        CSubSource::TSubtype val = CSubSource::GetSubtypeValue(subtype);

        string name;
        if (pos != NPOS) {
            string name = str.substr(pos + 1);
        }
        NStr::TruncateSpacesInPlace(name);

        if (val == CSubSource::eSubtype_germline    ||
            val == CSubSource::eSubtype_rearranged  ||
            val == CSubSource::eSubtype_transgenic  ||
            val == CSubSource::eSubtype_environmental_sample) {
            if (NStr::IsBlank(name)) {
                name = " ";
            }
        }

        if (NStr::IsBlank(name)) {
            return NULL;
        }

        size_t num_spaces = 0;
        bool has_comma = false;
        ITERATE (string, it, name) {
            if (isspace(*it)) {
                ++num_spaces;
            } else if (*it == ',') {
                has_comma = true;
                break;
            }
        }

        if (num_spaces > 4  ||  has_comma) {
            return NULL;
        }
        return new CSubSource(val, name);
    } catch (CSerialException&) {}
    return NULL;
}


void CBioSource::x_OrgModToSubtype(void)
{
    _ASSERT(IsSetOrg());

    if (!SetOrg().IsSetMod()) {
        return;
    }
    TOrg::TMod& mod_list = SetOrg().SetMod();

    TOrg::TMod::iterator it = mod_list.begin();
    while (it != mod_list.end()) {
        CRef<CSubSource> subsrc(s_StringToSubSource(*it));
        if (subsrc) {
            SetSubtype().push_back(subsrc);
            it = mod_list.erase(it);
        } else {
            ++it;
        }
    }
}


struct SSubsourceCompare
{
    bool operator()(const CRef<CSubSource>& s1, const CRef<CSubSource>& s2) {
        return s1->IsSetSubtype()  &&  s2->IsSetSubtype()  &&
            s1->GetSubtype() < s2->GetSubtype();
    }
};


void CBioSource::x_SubtypeCleanup(void)
{
    _ASSERT(IsSetSubtype());

    typedef multiset<CRef<CSubSource>, SSubsourceCompare> TSorter;

    TSubtype& subtypes = SetSubtype();
    TSorter   tmp;

    NON_CONST_ITERATE (TSubtype, it, subtypes) {
        if (*it) {
            (*it)->BasicCleanup();
            tmp.insert(*it);
        }
    }

    subtypes.clear();
    ITERATE (TSorter, it, tmp) {
        subtypes.push_back(*it);
    }
}

END_objects_SCOPE // namespace ncbi::objects::

END_NCBI_SCOPE


/*
* ===========================================================================
*
* $Log$
* Revision 6.5  2005/05/20 20:57:57  ucko
* Rework x_SubtypeCleanup to build against WorkShop's STL implementation,
* which doesn't allow sorting lists via custom comparators.
*
* Revision 6.4  2005/05/20 13:36:54  shomrat
* Added BasicCleanup()
*
* Revision 6.3  2004/05/19 17:26:04  gorelenk
* Added include of PCH - ncbi_pch.hpp
*
* Revision 6.2  2002/11/26 19:01:11  shomrat
* Bug fix in GetGenCode
*
* Revision 6.1  2002/11/26 18:50:31  shomrat
* Add GetGenCode
*
*
* ===========================================================================
*/
/* Original file checksum: lines: 64, chars: 1883, CRC32: e1194deb */
