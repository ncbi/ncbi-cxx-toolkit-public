/* $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author:  .......
 *
 * File Description:
 *   .......
 *
 * Remark:
 *   This code was originally generated by application DATATOOL
 *   using the following specifications:
 *   'seqfeat.asn'.
 */

// standard includes
#include <ncbi_pch.hpp>
#include <serial/enumvalues.hpp>

// generated includes
#include <objects/seqfeat/SubSource.hpp>

#include <math.h>
#include <objects/misc/sequence_util_macros.hpp>

// generated classes

BEGIN_NCBI_SCOPE

BEGIN_objects_SCOPE // namespace ncbi::objects::

auto_ptr<CLatLonCountryMap> CSubSource::m_LatLonCountryMap;
auto_ptr<CLatLonCountryMap> CSubSource::m_LatLonWaterMap;


// destructor
CSubSource::~CSubSource(void)
{
}

void CSubSource::GetLabel(string* str) const
{
    *str += '/';
    string type_name;
    if (GetSubtype() == eSubtype_other) {
        type_name = "other";
    } else {
        try {
            // eVocabulary_insdc has some special cases not (historically)
            // used here.
            type_name = GetSubtypeName(GetSubtype());
            replace(type_name.begin(), type_name.end(), '_', '-');
        } catch (CSerialException&) {
            type_name = "unknown";
        }
    }
    *str += type_name;
    *str += '=';
    *str += GetName();
    if (IsSetAttrib()) {
        *str += " (";
        *str += GetAttrib();
        *str += ")";
    }
}


CSubSource::TSubtype CSubSource::GetSubtypeValue(const string& str,
                                                 EVocabulary vocabulary)
{
    string name = NStr::TruncateSpaces(str);
    NStr::ToLower(name);
    replace(name.begin(), name.end(), '_', '-');

    if ( NStr::EqualNocase(name, "note") ||
         NStr::EqualNocase(name, "subsource-note") ||
         NStr::EqualNocase(name, "subsrc-note")) {
        return eSubtype_other;
    } else if (vocabulary == eVocabulary_insdc) {
        // consider a table if more special cases arise.
        if (name == "insertion-seq") {
            return eSubtype_insertion_seq_name;
        } else if (name == "plasmid") {
            return eSubtype_plasmid_name;
        } else if (name == "transposon") {
            return eSubtype_transposon_name;
        } else if (name == "sub-clone") {
            return eSubtype_subclone;
        }
    }

    return ENUM_METHOD_NAME(ESubtype)()->FindValue(name);
}


bool CSubSource::IsValidSubtypeName(const string& str,
                                    EVocabulary vocabulary)
{
    
    string name = NStr::TruncateSpaces(str);
    NStr::ToLower(name);
    replace(name.begin(), name.end(), '_', '-');

    if ( NStr::EqualNocase(name, "note") ||
         NStr::EqualNocase(name, "subsource-note") ||
         NStr::EqualNocase(name, "subsrc-note")) {
         return true;
    }



    if (vocabulary == eVocabulary_insdc) {
        // consider a table if more special cases arise.
        if (name == "insertion-seq" || 
            name == "plasmid" || 
            name == "transposon" || 
            name == "sub-clone") {
            return true;
        } 
    }
       
    return ENUM_METHOD_NAME(ESubtype)()->IsValidName(name);
}


string CSubSource::GetSubtypeName(CSubSource::TSubtype stype,
                                  EVocabulary vocabulary)
{
    if (stype == CSubSource::eSubtype_other) {
        return "note";
    } else if (vocabulary == eVocabulary_insdc) {
        switch (stype) {
        case eSubtype_subclone:           return "sub_clone";
        case eSubtype_plasmid_name:       return "plasmid";
        case eSubtype_transposon_name:    return "transposon";
        case eSubtype_insertion_seq_name: return "insertion_seq";
        default:
            return NStr::Replace
                (ENUM_METHOD_NAME(ESubtype)()->FindName(stype, true),
                 "-", "_");
        }
    } else {
        return ENUM_METHOD_NAME(ESubtype)()->FindName(stype, true);
    }
}



bool CSubSource::IsMultipleValuesAllowed(TSubtype subtype)
{
    return subtype != eSubtype_chromosome
        && subtype != eSubtype_sex
        && subtype != eSubtype_germline
        && subtype != eSubtype_rearranged
        && subtype != eSubtype_plasmid_name
        && subtype != eSubtype_segment
        && subtype != eSubtype_country
        && subtype != eSubtype_transgenic
        && subtype != eSubtype_environmental_sample
        && subtype != eSubtype_lat_lon
        && subtype != eSubtype_collection_date
        && subtype != eSubtype_collected_by
        && subtype != eSubtype_identified_by
        && subtype != eSubtype_fwd_primer_seq
        && subtype != eSubtype_rev_primer_seq
        && subtype != eSubtype_fwd_primer_name
        && subtype != eSubtype_rev_primer_name
        && subtype != eSubtype_metagenomic
        && subtype != eSubtype_altitude;
}



bool CSubSource::NeedsNoText(const TSubtype& subtype)
{
    if (subtype == eSubtype_germline
        || subtype == eSubtype_rearranged
        || subtype == eSubtype_transgenic
        || subtype == eSubtype_environmental_sample
        || subtype == eSubtype_metagenomic) {
        return true;
    } else {
        return false;
    }
}


bool CSubSource::IsDiscouraged(const TSubtype subtype)
{
    if (subtype == eSubtype_frequency
        || subtype == eSubtype_insertion_seq_name
        || subtype == eSubtype_phenotype
        || subtype == eSubtype_plastid_name
        || subtype == eSubtype_transposon_name
        || subtype == eSubtype_fwd_primer_seq
        || subtype == eSubtype_rev_primer_seq
        || subtype == eSubtype_fwd_primer_name
        || subtype == eSubtype_rev_primer_name
        || subtype == eSubtype_whole_replicon) {  // metagenomic subsrc qualifier taken off this list: GB-3384
        return true;
    } else {
        return false;
    }
}


static const char* const sm_LegalMonths [] = {
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec",
};


static const int sm_daysPerMonth [] = {
  31,
  28,
  31,
  30,
  31,
  30,
  31,
  31,
  30,
  31,
  30,
  31
};


bool CSubSource::IsDayValueOkForMonth(int day, int month, int year)
{
    bool rval = true;
    if (month < 1 || month > 12) {
        return false;
    }
    if (day < 1) {
        return false;
    }
    int dpm = sm_daysPerMonth [month - 1];

    if (day > dpm) {
        rval = false;
        if (month == 2 && day == 29) {
            // true only if this is a leap year
            if (! (year % 400)) {
                rval = true;
            } else if (!(year % 100)) {
                rval = false;
            } else if (!(year % 4)) {
                rval = true;
            }
        }
    }
    return rval;
}


CRef<CDate> CSubSource::DateFromCollectionDate (const string& test) THROWS((CException))
{
    if (NStr::IsBlank(test)) {
        NCBI_THROW (CException, eUnknown,
                        "collection-date string is blank");
    }
    string str = test;
    NStr::TruncateSpacesInPlace(str);

    if (IsISOFormatDate(str)) {
        return GetDateFromISODate(str);
    }

    size_t pos = NStr::Find(str, "-");
    string year = "";
    string month = "";
    string day = "";

    if (pos == string::npos) {
        year = str;
    } else {
        size_t pos2 = NStr::Find(str, "-", pos + 1);
        if (pos2 == string::npos) {
            month = str.substr(0, pos);
            year = str.substr(pos + 1);
            if (NStr::IsBlank(month)) {
                NCBI_THROW (CException, eUnknown,
                                "collection-date string is improperly formatted");
            }
        } else {
            day = str.substr(0, pos);
            month = str.substr(pos + 1, pos2 - pos - 1);
            year = str.substr(pos2 + 1);
            if (NStr::IsBlank(month) || NStr::IsBlank(day)) {
                NCBI_THROW (CException, eUnknown,
                                "collection-date string is improperly formatted");
            }
        }
    }

    int month_val = 0;
    if (!NStr::IsBlank(month)) {
        for (size_t i = 0; i < ArraySize(sm_LegalMonths); i++) {
            if (NStr::Equal(month, sm_LegalMonths[i])) {
                month_val = int(i + 1);
                break;
            }
        }
        if (month_val == 0) {
            NCBI_THROW (CException, eUnknown,
                            "collection-date string has invalid month");
        }
    }

    int day_val = 0;
    if (!NStr::IsBlank(day)) {
        try {
            day_val = NStr::StringToInt (day);
            if (day_val < 1) {
                NCBI_THROW (CException, eUnknown,
                                "collection-date string has invalid day value");
            }
        } catch ( const exception& ) {
            // threw exception while converting to int
            NCBI_THROW (CException, eUnknown,
                            "collection-date string is improperly formatted");
        }
    }

    if (NStr::IsBlank(year)) {
        NCBI_THROW (CException, eUnknown,
                        "collection-date string is improperly formatted");
    } 

    int year_val = 0;
    try {
        year_val = NStr::StringToInt (year);
    } catch ( const exception& ) {
        // threw exception while converting to int
        NCBI_THROW (CException, eUnknown,
                        "collection-date string is improperly formatted");
    }

    if (year_val < 1700 || year_val >= 2100) {
        NCBI_THROW (CException, eUnknown,
                        "collection-date year is out of range");
    }

    if (day_val > 0 && month_val > 0 && !IsDayValueOkForMonth(day_val, month_val, year_val)) {
        NCBI_THROW (CException, eUnknown,
                        "collection-date day is greater than monthly maximum");
    }

    CRef<CDate> date(new CDate);

    date->SetStd().SetYear (year_val);
    if (month_val > 0) {
        date->SetStd().SetMonth (month_val);
    }
    if (day_val > 0) {
        date->SetStd().SetDay (day_val);
    }
    
    return date;
}


bool CSubSource::IsCollectionDateAfterTime(const string& collection_date, time_t t, bool& bad_format)
{
    bad_format = false;
    bool in_future = false;
    vector<string> pieces;
    NStr::Tokenize(collection_date, "/", pieces);
    if (pieces.size() > 2) {
        bad_format = true;
    } else {
        ITERATE(vector<string>, it, pieces) {
            CRef<CDate> coll_date = DateFromCollectionDate (*it);
            if (!coll_date) {
                bad_format = true;
            } else if (IsCollectionDateAfterTime(*coll_date, t)) {
                in_future = true;
            }
        }
    }
    return in_future;
}


bool CSubSource::IsCollectionDateAfterTime(const CDate& collection_date, time_t t)
{
    struct tm *tm;
    tm = localtime(&t);

    bool in_future = false;
    if (collection_date.GetStd().GetYear() > tm->tm_year + 1900) {
        in_future = true;
    } else if (collection_date.GetStd().GetYear() == tm->tm_year + 1900
                && collection_date.GetStd().IsSetMonth()) {
        if (collection_date.GetStd().GetMonth() > tm->tm_mon + 1) {
            in_future = true;
        } else if (collection_date.GetStd().GetMonth() == tm->tm_mon + 1
                    && collection_date.GetStd().IsSetDay()) {
            if (collection_date.GetStd().GetDay() > tm->tm_mday) {
                in_future = true;
            }
        }
    }
    return in_future;
}


bool CSubSource::IsCollectionDateAfterTime(const CDate& collection_date, CTime& ctime)
{
    time_t t = ctime.GetTimeT();
    return IsCollectionDateAfterTime(collection_date, t);
}


void CSubSource::IsCorrectDateFormat(const string& date_string, bool& bad_format, bool& in_future)
{
    bad_format = false;
    in_future = false;

    vector<string> pieces;
    NStr::Tokenize(date_string, "/", pieces);
    if (pieces.size() > 2) {
        bad_format = true;
        return;
    } else if (pieces.size() == 2) {
        bool first_bad = false;
        bool first_future = false;
        bool second_bad = false;
        bool second_future = false;
        IsCorrectDateFormat(pieces[0], first_bad, first_future);
        IsCorrectDateFormat(pieces[1], second_bad, second_future);
        bad_format = first_bad || second_bad;
        if (!bad_format) {
            in_future = first_future || second_future;
        }
        return;
    }

    try {
        CRef<CDate> coll_date = CSubSource::DateFromCollectionDate (date_string);

        if (!IsISOFormatDate(date_string)) {
            // if there are two dashes, then the first token needs to be the day, and the
            // day has to have two numbers, a leading zero if the day is less than 10
            size_t pos = NStr::Find(date_string, "-");
            if (pos != string::npos) {
                size_t pos2 = NStr::Find(date_string, "-", pos + 1);
                if (pos2 != string::npos && pos != 2) {
                    bad_format = true;
                }
            }
        }

        if (!bad_format) {         
            time_t t;

            time(&t);

            in_future = IsCollectionDateAfterTime(*coll_date, t);
        }
    } catch (CException ) {
        bad_format = true;
    }
}


string CSubSource::GetCollectionDateProblem (const string& date_string)
{
    string problem = "";
    bool bad_format = false;
    bool in_future = false;

    IsCorrectDateFormat(date_string, bad_format, in_future);
    if (bad_format) {
        problem = "Collection_date format is not in DD-Mmm-YYYY format";
    } else if (in_future) {
        problem = "Collection_date is in the future";
    }
    return problem;
}


string CSubSource::x_ParseDateRangeWithDelimiter(const string& orig_date, const string& delim)
{
    size_t pos = NStr::Find(orig_date, delim, NStr::eNocase);
    if (pos == string::npos) {
        return "";
    }
    size_t second_pos = NStr::Find(orig_date.substr(pos + 1), delim, NStr::eNocase);
    if (second_pos != string::npos) {
        return "";
    }
    bool month_ambig = false;
    string first_date = FixDateFormat(orig_date.substr(0, pos), true, month_ambig);
    if (month_ambig || NStr::IsBlank(first_date)) {
        return "";
    }
    string second_date = FixDateFormat(orig_date.substr(pos + delim.length()), true, month_ambig);
    if (month_ambig || NStr::IsBlank(second_date)) {
        return "";
    }
    string fix = first_date + "/" + second_date;
    return fix;
}


string CSubSource::FixDateFormat (const string& orig_date)
{
    bool month_ambiguous = false;

    string fix = FixDateFormat(orig_date, true, month_ambiguous);
    if (month_ambiguous) {
        fix = "";
    } else if (NStr::IsBlank(fix)) {
        static const string delimiters[] = {"/", " to ", " and ", "-", "_"};
        for (size_t i = 0; i < sizeof (delimiters) / sizeof (string); i++) {
            fix = x_ParseDateRangeWithDelimiter(orig_date, delimiters[i]);
            if (!NStr::IsBlank(fix)) {
                break;
            }
        }
    }
    return fix;
}

// ISO Format for time is one of these:
// HH:MM:SS
// HH:MM
// HH
// Followed by either Z or +hh:mm to indicate an offset from Zulu
bool CSubSource::IsISOFormatTime(const string& orig_time, int& hour, int& min, int& sec)
{
    int offset_hour = 0;
    int offset_min = 0;
    size_t suffix = NStr::Find(orig_time, "Z");
    if (suffix == string::npos) {
        suffix = NStr::Find(orig_time, "+");
        if (suffix == string::npos ||
            orig_time.substr(suffix).length() != 6 ||
            !isdigit(orig_time.c_str()[suffix + 1]) ||
            !isdigit(orig_time.c_str()[suffix + 2]) ||
            orig_time.c_str()[suffix + 3] != ':' ||
            !isdigit(orig_time.c_str()[suffix + 4]) ||
            !isdigit(orig_time.c_str()[suffix + 5])) {
            return false;
        }
        try {
            offset_hour = NStr::StringToInt(orig_time.substr(suffix + 1, 2));
            offset_min = NStr::StringToInt(orig_time.substr(suffix + 4, 2));
        } catch (...) {
            return false;
        }
    }
    if (suffix != 2 && suffix != 5 && suffix != 8) {
        return false;
    }

    if (!isdigit(orig_time.c_str()[0]) || !isdigit(orig_time.c_str()[1])) {
        return false;
    }
    hour = 0;
    min = 0;
    sec = 0;
    try {
        hour = NStr::StringToInt(orig_time.substr(0, 2));
        if (hour < 0 || hour > 23) {
            return false;
        }
        hour -= offset_hour;
    } catch (...) {
        return false;
    }
    if (suffix > 2) {
        if (!isdigit(orig_time.c_str()[3]) || !isdigit(orig_time.c_str()[4])) {
            return false;
        }
        try {
            min = NStr::StringToInt(orig_time.substr(3, 2));
            if (min < 0 || min > 59) {
                return false;
            }
        } catch (...) {
            return false;
        }
        min -= offset_min;
    }
    if (suffix == 8) {
        if (!isdigit(orig_time.c_str()[6]) || !isdigit(orig_time.c_str()[7])) {
            return false;
        }
        try {
            sec = NStr::StringToInt(orig_time.substr(6, 2));
            if (sec < 0) {
                // negative number bad
                return false;
            } else if (sec > 59) {
                // too big
                return false;
            }
        } catch (...) {
            return false;
        }
    }

    return true;
}

// ISO Format for date is exactly 10 characters long OR exactly 7 characters long.
// For ten characters:
// First four characters must be digits, represent year.
// Fifth character must be dash.
// Sixth and seventh characters must be digits, represent month, use zero padding.
// Eighth character must be dash.
// Ninth and tenth characters must be digits, represent day, use zero padding.
// For 7 characters:
// First four characters must be digits, represent year.
// Fifth character must be dash.
// Sixth and seventh characters must be digits, represent month, use zero padding.
bool CSubSource::IsISOFormatDateOnly (const string& cpy)
{
    if (cpy.length() != 10 && cpy.length() != 7) {
        return false;
    }
    bool rval = true;
    size_t pos = 0;
    string::const_iterator it = cpy.begin();
    while (it != cpy.end() && rval) {
        if (pos == 4 || pos == 7) {
            if (*it != '-') {
                rval = false;
            }
        } else if (!isdigit(*it)) {
            rval = false;
        }
        ++it;
        ++pos;
    }
    if (rval) {
        try {
            int year = NStr::StringToInt(cpy.substr(0, 4));
            int month = NStr::StringToInt(cpy.substr(5, 2));
            if (month < 1 || month > 12) {
                rval = false;
            }
            if (cpy.length() == 10) { // has day 
                int day = NStr::StringToInt(cpy.substr(8, 2));
                if (!IsDayValueOkForMonth(day, month, year)) {
                    rval = false;
                }
            }
        } catch (...) {
            rval = false;
        }
    }
    return rval;
}

bool CSubSource::IsISOFormatDate(const string& orig_date)
{
    string cpy = orig_date;
    NStr::TruncateSpacesInPlace(cpy);
    size_t time_pos = NStr::Find(cpy, "T");
    if (time_pos == string::npos) {
        return IsISOFormatDateOnly(cpy);
    } else {
        int h, m, s;
        return (IsISOFormatDateOnly(cpy.substr(0, time_pos)) &&
            IsISOFormatTime(cpy.substr(time_pos + 1), h, m, s));
    }

}

CRef<CDate> CSubSource::GetDateFromISODate(const string& orig_date)
{
    try {
        string cpy = orig_date;
        NStr::TruncateSpacesInPlace(cpy);
        CRef<CDate> date(new CDate());
        int year_val = NStr::StringToInt(cpy.substr(0, 4));
        int month_val = NStr::StringToInt(cpy.substr(5, 2));
        date->SetStd().SetYear (year_val);
        date->SetStd().SetMonth (month_val);
        if (cpy.length() > 7) {
            int day_val = NStr::StringToInt(cpy.substr(8, 2));
            date->SetStd().SetDay (day_val);
        }
        return date;
    } catch (...) {
        return CRef<CDate>(NULL);
    }
}


// return 1-based month number if found, 0 for error
static
int GetMonthNumberFromString(const string& month) 
{
    for (size_t i = 0; i < ArraySize(sm_LegalMonths); i++) {
        if (NStr::StartsWith(month, sm_LegalMonths[i], NStr::eNocase)) {
            return int(i + 1);
        }
    }
    return 0;
}


vector<string> CSubSource::x_GetDateTokens(const string& orig_date)
{
    vector<string> tokens;
    string token_delimiters = " ,-/=_.";
    size_t i;

    string cpy = orig_date;
    NStr::TruncateSpacesInPlace (cpy);

    string curr_token = "";
    bool is_chars = false;
    ITERATE(string, s, cpy) {
        if (strchr(token_delimiters.c_str(), *s) != NULL) {
            if (!NStr::IsBlank(curr_token)) {
                tokens.push_back(curr_token);
            }
            curr_token = "";
            is_chars = false;
        } else if (is_chars && !isalpha(*s)) {
            // previous token was all letters, do not add non-letter characters
            if (!NStr::IsBlank(curr_token)) {
                tokens.push_back(curr_token);
            }
            curr_token = "";
            curr_token += *s;
            is_chars = false;
        } else if (!NStr::IsBlank(curr_token) && !is_chars && isalpha(*s)) {
            // previous token had no letters
            tokens.push_back(curr_token);
            curr_token = "";
            curr_token += *s;
            is_chars = true;
        } else {
            curr_token += *s;
            if (isalpha(*s)) {
                is_chars = true;
            }
        }
    }
    if (!NStr::IsBlank(curr_token)) {
        tokens.push_back(curr_token);
    }

    // reattach 'st', 'nd', 'rd', and 'th' to numbers if present
    if (tokens.size() > 3) {
        vector<string>::iterator p = tokens.begin();  
        bool prev_is_number = isdigit((*p).c_str()[0]);
        vector<string>::iterator s = p;
        ++s;
        while (s != tokens.end()) {
            if (prev_is_number &&
                (NStr::EqualNocase(*s, "st") ||
                NStr::EqualNocase(*s, "nd") ||
                NStr::EqualNocase(*s, "rd") ||
                NStr::EqualNocase(*s, "th"))) {
                *p += *s;
                s = tokens.erase(s);
                prev_is_number = false;
            } else {
                ++p;
                ++s;
                prev_is_number = isdigit((*p).c_str()[0]);
            }
        }
    }

    return tokens;
}


bool s_ChooseMonthAndDay(const string& token1, const string& token2, bool month_first, string& month, int& day, bool& month_ambiguous)
{
    try {
        int val1 = NStr::StringToInt (token1); 
        int val2 = NStr::StringToInt (token2);
        if (val1 > 12 && val2 > 12) {
            // both numbers too big for month
            return false;
        } else if (val1 < 13 && val2 < 13) {
            if (val1 == val2) {
                // no need to call this ambiguous
                month = sm_LegalMonths[val1 - 1];
                day = val2;
            } else {
                // both numbers could be month
                month_ambiguous = true;
                if (month_first) {
                    month = sm_LegalMonths[val1 - 1];
                    day = val2;
                } else {
                    month = sm_LegalMonths[val2 - 1];
                    day = val1;
                }
            }
        } else if (val1 < 13) {
            month = sm_LegalMonths[val1 - 1];
            day = val2;
        } else {
            month = sm_LegalMonths[val2 - 1];
            day = val1;
        }
        return true;
    } catch ( ... ) {
        return false;
    }
}


string CSubSource::FixDateFormat (const string& test, bool month_first, bool& month_ambiguous)
{
    string orig_date = test;
    NStr::TruncateSpacesInPlace(orig_date);

    if (IsISOFormatDate(orig_date)) {
        return orig_date;
    }

    string reformatted_date = "";
    string month = "";
    int year = 0, day = 0;
    string token_delimiters = " ,-/=_.";
    size_t num_original_tokens = 0;

    month_ambiguous = false;
    vector<string> tokens = x_GetDateTokens(orig_date);
    
    num_original_tokens = tokens.size();
    if (tokens.size() < 1 || tokens.size() > 3) {
        // no tokens or too many tokens
        return "";
    }

    string one_token;    
    vector<string>::iterator it = tokens.begin();
    while (it != tokens.end()) {
        one_token = *it;        
        bool found = false;
        if (NStr::EqualNocase(one_token, "1st") || NStr::EqualNocase(one_token, "first")) {
            day = 1;
            found = true;
        } else if (NStr::EqualNocase(one_token, "2nd") || NStr::EqualNocase(one_token, "second")) {
            day = 2;
            found = true;
        } else if (NStr::EqualNocase(one_token, "3rd") || NStr::EqualNocase (one_token, "third")) {
            day = 3;
            found = true;
        } else if (one_token.length() > 0
                   && isdigit(one_token.c_str()[0])
                   && NStr::EndsWith(one_token, "th")) {
            try {
                day = NStr::StringToInt (one_token.substr(0, one_token.length() - 2));
                found = true;
            } catch ( ... ) {
                // threw exception while converting to int
                return "";
            }
        } else if (isalpha(one_token.c_str()[0])) {
            if (!NStr::IsBlank (month)) {
                // already have month, error
                return "";
            }
            size_t month_num = GetMonthNumberFromString(one_token);
            if (month_num > 0) {
                month = sm_LegalMonths[month_num - 1];
                found = true;
            }
        } else {
            try {
                int this_val = NStr::StringToInt (one_token);
                int min = 1;
                int max = 31;
                if (this_val < min) {
                    return "";
                } else if (this_val > max) {
                    if (year > 0) {
                        // already have year, error
                        return "";
                    }
                    year = this_val;
                    found = true;
                }
            } catch ( ... ) {
                // threw exception while converting to int
                return "";
            }
        }
        if (found) {
            it = tokens.erase(it);
        } else {
            it++;
        }
    }

    if (tokens.size() == 0) {
        // good - all tokens assigned to values
    } else if (tokens.size() > 2) {
        // three numbers: treat last one as year
        try {
            year = NStr::StringToInt(tokens[2]);
            if (year < 100) {
                year += 2000;
            }
            if (!s_ChooseMonthAndDay(tokens[0], tokens[1], month_first, month, day, month_ambiguous)) {
                return "";
            }
            // mark month as ambiguous, since we are guessing about year
            month_ambiguous = true;
        } catch ( ... ) {
            // threw exception while converting to int
            return "";
        }
    } else if (tokens.size() == 1) {
        try {
            int val = NStr::StringToInt (tokens[0]);
            if (year == 0) {
                year = val;
            } else {
                if (NStr::IsBlank (month)) {
                    if (val > 0 && val < 13) {
                        month = sm_LegalMonths[val - 1];
                    } else {
                        // month number out of range
                        return "";
                    }
                } else {
                    day = val;
                }
            }
        } catch ( ... ) {
            // threw exception while converting to int
            return "";
        }
    } else if (!NStr::IsBlank (month)) {
        if (tokens.size() == 2) {
            // we have a month and two other numbers (we hope)
            int val1 = 0;
            int val2 = 0;
            try {
                val1 = NStr::StringToInt (tokens[0]); 
                val2 = NStr::StringToInt (tokens[1]);
            } catch (CException& /*e*/) {
                // not actually numbers
                return "";
            }
            bool zero_pad_1 = NStr::StartsWith(tokens[0], "0");
            bool zero_pad_2 = NStr::StartsWith(tokens[1], "0");
            if (val1 < 10 && !zero_pad_1 && (val2 > 10 || zero_pad_2)) {
                // if one token is not zero-padded and less than 10,
                // the other either is zero-padded and greater than 10,
                // the "small" token is the day and the second (+2000) is the year
                day = val1;
                year = val2 + 2000;
            } else if (val2 < 10 && !zero_pad_2 && (val1 > 10 || zero_pad_1)) {
                // if one token is not zero-padded and less than 10,
                // the other either is zero-padded and greater than 10,
                // the "small" token is the day and the second (+2000) is the year
                day = val2;
                year = val1 + 2000;
            } else {
                int month_num = GetMonthNumberFromString(month); 
                if (IsDayValueOkForMonth(val1, month_num, val2 + 2000)) {
                    day = val1;
                    year = val2 + 2000;
                } else {
                    day = val2;
                    year = val1 + 2000;
                }                
            }
        } else {
            return "";
        }
    } else {
        if (!s_ChooseMonthAndDay(tokens[0], tokens[1], month_first, month, day, month_ambiguous)) {
            return "";
        }
    }

    // make sure day is valid
    if (day > 0 && !NStr::IsBlank(month) && year > -1) {
        int month_num = GetMonthNumberFromString(month);
        if (month_num == 0) {
            return "";
        } else if (!IsDayValueOkForMonth(day, month_num, year)) {
            return "";
        }
    }
        
    if (year > 31 && year < 100 && num_original_tokens > 1) {
        // try to guess year from two-digit year provided,
        // only if it could not possibly be a day of the month
        // and if there were at least two tokens provided
        string year_date = NStr::NumericToString(year + 2000);
        bool format_bad = false;
        bool in_future = false;
        IsCorrectDateFormat(year_date, format_bad, in_future);
        if (in_future) {
            year += 1900;
        } else {
            year += 2000;
        }
    }
    if (year >= 1700 && year < 2100) {
        reformatted_date = NStr::NumericToString (year);
        if (!NStr::IsBlank (month)) {
            reformatted_date = month + "-" + reformatted_date;
            if (day > 0) {
                string day_str = NStr::NumericToString (day);
                if (day_str.length() < 2) {
                    day_str = "0" + day_str;
                }
                reformatted_date = day_str + "-" + reformatted_date;
            }
        }
    }

    return reformatted_date;
}


void CSubSource::DetectDateFormat(const string& orig_date, bool& ambiguous, bool &day_first)
{
    ambiguous = false;
    day_first = false;
    vector<string> tokens = x_GetDateTokens(orig_date);
    if (tokens.size() != 3) {
        // can't do detection if there are more or less than three tokens
        ambiguous = true;
        return;
    }
    vector<int> nums;

    // detection is only valid if all tokens are numbers and at least one is known to be the year
    try {
        ITERATE(vector<string>, it, tokens) {
            nums.push_back(NStr::StringToInt (*it));
        }
    } catch ( ... ) {
        // threw exception while converting to int
        ambiguous = true;
        return;
    }
    enum EPos { eDay = 0, eMonth = 1, eYear = 2 };
    vector<int> positions;
    positions.push_back(0);
    positions.push_back(0);
    positions.push_back(0);
    
    int token_pos = 1;
    ITERATE(vector<int>, it, nums) {
        if (*it > 31) {
            if (positions[eYear] > 0) {
                // already found a year
                ambiguous = true;
                return;
            }
            positions[eYear] = token_pos;
        } else if (*it > 12) {
            if (positions[eDay] > 0) {
                // already found a day
                ambiguous = true;
                return;
            }
            positions[eDay] = token_pos;
        } else if (positions[eMonth] > 0) {
            // already found a month
            ambiguous = true;
            return;
        } else {
            positions[eMonth] = token_pos;
        }
        token_pos++;
    }
    if (positions[eDay] < positions[eMonth]) {
        day_first = true;
    } else {
        day_first = false;
    }
}


void CSubSource::IsCorrectLatLonFormat (string lat_lon, bool& format_correct, bool& precision_correct,
                                     bool& lat_in_range, bool& lon_in_range,
                                     double& lat_value, double& lon_value)
{
    format_correct = false;
    lat_in_range = false;
    lon_in_range = false;
    precision_correct = false;
    double ns, ew;
    char lon, lat;
    int processed;

    lat_value = 0.0;
    lon_value = 0.0;

    if (NStr::IsBlank(lat_lon)) {
        return;
    } else if (sscanf (lat_lon.c_str(), "%lf %c %lf %c%n", &ns, &lat, &ew, &lon, &processed) != 4
               || size_t(processed) != lat_lon.length()) {
        return;
    } else if ((lat != 'N' && lat != 'S') || (lon != 'E' && lon != 'W')) {
        return;
    } else {
        // init values found
        if (lat == 'N') {
            lat_value = ns;
        } else {
            lat_value = 0.0 - ns;
        }
        if (lon == 'E') {
            lon_value = ew;
        } else {
            lon_value = 0.0 - ew;
        }

    // make sure format is correct
        vector<string> pieces;
        NStr::Tokenize(lat_lon, " ", pieces);
        if (pieces.size() > 3) {
            int precision_lat = x_GetPrecision(pieces[0]);
            int precision_lon = x_GetPrecision(pieces[2]);

            char reformatted[1000];
            sprintf (reformatted, "%.*lf %c %.*lf %c", precision_lat, ns, lat,
                                                       precision_lon, ew, lon);

            size_t len = strlen (reformatted);
            if (NStr::StartsWith(lat_lon, reformatted)
                && (len == lat_lon.length() 
                  || (len < lat_lon.length() 
                      && lat_lon.c_str()[len] == ';'))) {
                format_correct = true;
                if (ns <= 90 && ns >= 0) {
                    lat_in_range = true;
                }
                if (ew <= 180 && ew >= 0) {
                    lon_in_range = true;
                }
                if (precision_lat < 3 && precision_lon < 3) {
                    precision_correct = true;
                }
            }
        }
    }
}


static void s_TrimInternalSpaces (string& token)
{
    size_t pos;

    while ((pos = NStr::Find (token, "  ")) != string::npos) {
        string before = token.substr(0, pos);
        string after = token.substr(pos + 1);
        token = before + after;
    }
    while ((pos = NStr::Find (token, " '")) != string::npos) {
        string before = token.substr(0, pos);
        string after = token.substr(pos + 1);
        token = before + after;
    }
}


string s_GetDefaultDir(bool is_negative, string default_dir)
{
    string dir = "";
    if (is_negative) {
        if (NStr::Equal("N", default_dir)) {
            dir = "S";
        } else if (NStr::Equal("E", default_dir)) {
            dir = "W";
        }
    } else {
        dir = default_dir;
    }
    return dir;
}

static void s_RemoveLeadingZeros(string& token)
{

    size_t index = 0;
    while (index < token.size() &&
        token[index] == '0' &&
        (index + 1 < token.size() && isdigit(token[index + 1]))) {
        ++index;
    }
    if (index != 0) {
        token = token.substr(index);
    }
}


static string s_GetNumFromLatLonToken (string token, string default_dir)
{
    NStr::TruncateSpacesInPlace(token);
    string dir = "";
    if (NStr::StartsWith (token, "N") || NStr::StartsWith (token, "S") || NStr::StartsWith (token, "E") || NStr::StartsWith (token, "W")) {
        dir = token.substr(0, 1);
        token = token.substr(1);
    } else {
        dir = token.substr(token.length() - 1, 1);
        if (isalpha(dir.c_str()[0])) {
            token = token.substr(0, token.length() - 1);
        } else {
            dir = "";
        }
    }
    NStr::TruncateSpacesInPlace(token);
    // clean up double spaces, spaces between numbers and '
    s_TrimInternalSpaces(token);

    // find leading negative sign
    bool is_negative = false;
    if (NStr::StartsWith(token, "-")) {
        is_negative = true;
        token = token.substr(1);
    }

    if (NStr::IsBlank(dir)) {
        dir = s_GetDefaultDir(is_negative, default_dir);
    } else if (is_negative) {
        return "";
    }

    size_t pos = 0;
    double val = 0;
    size_t num_sep = 0, prev_start = 0;
    size_t prec = 0;
    bool seen_period = false;
    bool last_is_sep = false;
    while (pos < token.length()) {
        char ch = token.c_str()[pos];
        if (ch == ' ' || ch == ':' || ch == '-') {
            if (pos == prev_start) {
                // too many separators
                return "";
            }
            string num_str = token.substr(prev_start, pos - prev_start);
            double this_val = NStr::StringToDouble (num_str);
            if (num_sep == 0) {
                val += this_val;
            } else if (num_sep == 1) {
                val += (this_val) / (60.0);
                prec += 2;
            } else if (num_sep == 2) {
                val += (this_val) / (3600.0);
                prec += 2;
            } else {
                // too many separators
                return "";
            }
            size_t p_pos = NStr::Find (num_str, ".");
            if (p_pos != string::npos) {
                prec += num_str.substr(p_pos + 1).length();
            }
            num_sep++;
            pos++;
            prev_start = pos;
            last_is_sep = true;
        } else if (ch == '\'') {
            string num_str = token.substr(prev_start, pos - prev_start);
            double this_val = NStr::StringToDouble (num_str);
            if (token.c_str()[pos + 1] == '\'') {
                if (num_sep > 2) {
                    // already found seconds
                    return "";
                }
                // seconds
                val += (this_val) / (3600.0);
                prec += 2;
                if (NStr::Find (token, "'") == pos) {
                    // seconds specified without minutes
                    prec += 2;
                }
                pos++;
                num_sep ++;
            } else {
                if (num_sep > 1) {
                    // already found minutes
                    return "";
                }
                val += (this_val) / (60.0);
                prec += 2;
                num_sep ++;
            }
            size_t p_pos = NStr::Find (num_str, ".");
            if (p_pos != string::npos) {
                prec += num_str.substr(p_pos + 1).length();
            }
            pos++;
            while (isspace (token.c_str()[pos])) {
                pos++;
            }
            prev_start = pos;
            last_is_sep = true;
        } else if (isdigit(ch)) {
            pos++;
            last_is_sep = false;
        } else if (ch == '.') {
            if (seen_period) {
                return "";
            }
            seen_period = true;
            pos++;
            last_is_sep = false;
        } else {
            return "";
        }
    }
    if (num_sep > 0 && !last_is_sep) {
        // if there have been separators, but the last value is not a separator,
        if (num_sep == 2 && !seen_period) {
            // if we have seen minutes but not seconds we'll treat this last value as seconds
        } else {
            // otherwise this is a bad format
            return "";
        }
    }

    s_RemoveLeadingZeros(token);

    if (prev_start == 0) {
        if (!NStr::IsBlank(dir)) {
            token = token + " " + dir;
        }
        return token;
    } else {
        if (prev_start < pos) {
            string num_str = token.substr(prev_start, pos - prev_start);

            double this_val = NStr::StringToDouble (num_str);
            if (num_sep == 0) {
                val += this_val;
            } else if (num_sep == 1) {
                val += (this_val) / (60.0);
                prec += 2;
            } else if (num_sep == 2) {
                val += (this_val) / (3600.0);
                prec += 2;
            } else {
                // too many separators
                return "";
            }
            size_t p_pos = NStr::Find (num_str, ".");
            if (p_pos != string::npos) {
                prec += num_str.substr(p_pos + 1).length();
            }
        }
        if (prec > 0) {
            double mult = pow ((double)10.0, int(prec));
            bool round_down = true;
            double remainder = (val * mult) - floor (val * mult);
            if (remainder > 0.5) {
                round_down = false;
            }
            double tmp;
            if (round_down) {
                tmp = floor(val * mult);
            } else {
                tmp = ceil(val * mult);
            }
            val = tmp / mult;
        }
        string val_str = NStr::NumericToString (val, NStr::fDoubleFixed);
        pos = NStr::Find (val_str, ".");
        if (pos != string::npos && prec > 0) {
            while (val_str.substr(pos + 1).length() < prec) {
                val_str += "0";
            }
            if (val_str.substr(pos + 1).length() > prec) {
                val_str = val_str.substr (0, pos + prec + 1);
            }
        }


        if (!NStr::IsBlank(dir)) {
            val_str = val_str + " " + dir;
        }

        return val_str;
    }            
}


static bool s_IsNumberStringInRange(const string& val_str, double max)
{
    double val;
    char dir;
    int processed;

    if (sscanf (val_str.c_str(), "%lf %c%n", &val, &dir, &processed) != 2
        || size_t(processed) != val_str.length()
        || val < 0.0 || val > max) {
        return false;
    } else {
        return true;
    }
}


static void s_RemoveLeadingCommaOrSemicolon(string& token)
{
    NStr::TruncateSpacesInPlace(token);
    if (NStr::StartsWith (token, ",") || NStr::StartsWith (token, ";")) {
        token = token.substr(1);
        NStr::TruncateSpacesInPlace(token);
    }
}


static void s_RemoveExtraText (string& token, string& extra_text)
{
    size_t comma_pos = NStr::Find (token, ",");
    size_t semicolon_pos = NStr::Find (token, ";");
    size_t sep_pos = string::npos;

    if (comma_pos == string::npos) {
        sep_pos = semicolon_pos;
    } else if (semicolon_pos != string::npos) {
        if (semicolon_pos < comma_pos) {
            sep_pos = semicolon_pos;
        } else {
            sep_pos = comma_pos;
        }
    }
    if (sep_pos != string::npos) {
        extra_text = token.substr(sep_pos + 1);
        NStr::TruncateSpacesInPlace(extra_text);
        token = token.substr(0, sep_pos - 1);
        NStr::TruncateSpacesInPlace(token);
    }        
}


string CSubSource::FixLatLonFormat (string orig_lat_lon, bool guess)
{
    string cpy;
    size_t pos;

    if (NStr::IsBlank (orig_lat_lon))
    {
        return "";
    }

    cpy = orig_lat_lon;
    
    // replace all 'O' (capital o) following non-alpha characters with '0' (zero)
    pos = NStr::Find (cpy, "O");
    while (pos != string::npos) {
        if (pos > 0 && !isalpha(cpy.c_str()[pos - 1])) {
            string before = cpy.substr(0, pos);
            string after = cpy.substr(pos + 1);
            cpy = before + "0" + after;
        }
        pos = NStr::Find (cpy, "O", pos + 1);
    }
    // replace all 'o' with non-alpha characters before and after with space
    pos = NStr::Find (cpy, "o");
    while (pos != string::npos) {
        if ((pos == 0 || !isalpha(cpy.c_str()[pos - 1]))
            && !isalpha (cpy.c_str()[pos + 1])) {
            string before = cpy.substr(0, pos);
            string after = cpy.substr(pos + 1);
            cpy = before + " " + after;
        }
        pos = NStr::Find (cpy, "o", pos + 1);
    }

    // replace all '°' with space
    NStr::ReplaceInPlace(cpy, "\xC2\xB0", " ");
    NStr::ReplaceInPlace(cpy, "\xB0",     " ");

    // replace all '#' with ' '
    NStr::ReplaceInPlace (cpy, "#", " ");

    // now make all letters uppercase (note, do not do this before converting 'o' and 'O'(
    cpy = NStr::ToUpper (cpy);

    // replace commas that should be periods
    pos = NStr::Find (cpy, ",");
    while (pos != string::npos) {
        if (pos > 0 && isdigit (cpy.c_str()[pos + 1]) && isdigit (cpy.c_str()[pos - 1])) {
            // follow digits all the way back, make sure character before digits is not '.'
            size_t dpos = pos - 2;
            while (dpos > 0 && isdigit (cpy.c_str()[dpos])) {
                dpos--;
            }
            if (cpy.c_str()[dpos] != '.') {
                string before = cpy.substr(0, pos);
                string after = cpy.substr(pos + 1);
                cpy = before + " " + after;
            }
        }
        pos = NStr::Find (cpy, "o", pos + 1);
    }

    // get rid of colons, semicolons, and commas
    NStr::ReplaceInPlace (cpy, ":", " ");
    NStr::ReplaceInPlace (cpy, ";", " ");
    NStr::ReplaceInPlace (cpy, ",", " ");

    // get rid of periods after letters not before numbers
    pos = NStr::Find (cpy, ".");
    while (pos != string::npos) {
        if (pos > 0 && isalpha(cpy.c_str()[pos - 1])) {
            string before = cpy.substr(0, pos);
            string after = cpy.substr(pos + 1);
            cpy = before + " " + after;
        }
        pos = NStr::Find (cpy, ".", pos + 1);
    }

    NStr::ReplaceInPlace (cpy, "LONGITUDE", "LONG");
    NStr::ReplaceInPlace (cpy, "LON.",      "LONG");
    NStr::ReplaceInPlace (cpy, "LONG",      "LO");
    NStr::ReplaceInPlace (cpy, "LO:",       "LO");
    NStr::ReplaceInPlace (cpy, "LATITUDE",  "LAT");
    NStr::ReplaceInPlace (cpy, "LATTITUDE",  "LAT");
    NStr::ReplaceInPlace (cpy, "LAT.",      "LAT");
    NStr::ReplaceInPlace (cpy, "LAT:",      "LAT");
    NStr::ReplaceInPlace (cpy, "DEGREES",   " " );
    NStr::ReplaceInPlace (cpy, "DEGREE",    " ");
    NStr::ReplaceInPlace (cpy, "DEG.",      " ");
    NStr::ReplaceInPlace (cpy, "DEG",       " " );
    NStr::ReplaceInPlace (cpy, "MASCULINE", " "); // masculine ordinal indicator U+00BA often confused with degree sign U+00B0
    NStr::ReplaceInPlace (cpy, "MIN.",      "'");
    NStr::ReplaceInPlace (cpy, "MINUTES",   "'");
    NStr::ReplaceInPlace (cpy, "MINUTE",    "'");
    NStr::ReplaceInPlace (cpy, "MIN",       "'");
    NStr::ReplaceInPlace (cpy, "SEC.",      "''");
    NStr::ReplaceInPlace (cpy, "SEC",       "''");
    NStr::ReplaceInPlace (cpy, "NORTH",     "N");
    NStr::ReplaceInPlace (cpy, "SOUTH",     "S");
    NStr::ReplaceInPlace (cpy, "EAST",      "E");
    NStr::ReplaceInPlace (cpy, "WEST",      "W");
    NStr::ReplaceInPlace (cpy, " AND ",     " "); // treat AND like a space delimiter
    NStr::ReplaceInPlace (cpy, "_", " ");
    NStr::ReplaceInPlace (cpy, "  ", " "); // double-spaces become single spaces

    size_t lat_pos = NStr::Find (cpy, "LAT");
    size_t lon_pos = NStr::Find (cpy, "LO");
    if ((lat_pos == string::npos && lon_pos != string::npos)
        || (lat_pos != string::npos && lon_pos == string::npos)) {
        // must specify both lat and lon or neither
        return "";
    }
    if (lat_pos != string::npos && NStr::Find (cpy, "LAT", lat_pos + 1) != string::npos) {
        // better not find two
        return "";
    }
    if (lon_pos != string::npos && NStr::Find (cpy, "LO", lon_pos + 1) != string::npos) {
        // better not find two
        return "";
    }

    size_t ns_pos = NStr::Find (cpy, "N");
    if (ns_pos == string::npos) {
        ns_pos = NStr::Find (cpy, "S");
        if (ns_pos != string::npos && NStr::Find(cpy, "S", ns_pos + 1) != string::npos) {
            // better not find two
            return "";
        }
    } else if (NStr::Find (cpy, "S") != string::npos || NStr::Find (cpy, "N", ns_pos + 1) != string::npos) {
        // better not find two
        return "";
    }

    size_t ew_pos = NStr::Find (cpy, "E");
    if (ew_pos == string::npos) {
        ew_pos = NStr::Find (cpy, "W");
        if (ew_pos != string::npos && NStr::Find(cpy, "W", ew_pos + 1) != string::npos) {
            // better not find two
            return "";
        }
    } else if (NStr::Find (cpy, "W") != string::npos || NStr::Find (cpy, "E", ew_pos + 1) != string::npos) {
        // better not find two
        return "";
    }

    // todo - figure out how to use degrees as ew_pos markers

    // need to have both or neither
    if ((ns_pos == string::npos && ew_pos != string::npos)
        || (ns_pos != string::npos && ew_pos == string::npos)) {
        return "";
    }

    string extra_text = "";
    string la_token = "";
    string lo_token = "";
    bool la_first = true;

    if (lat_pos == string::npos) {
        if (ns_pos == string::npos) {
            if (guess) {
                // do we have just two numbers, separated by either a comma or just a space?
                s_TrimInternalSpaces(cpy);
                size_t sep_pos = NStr::Find (cpy, ",");
                if (sep_pos == string::npos) {
                    sep_pos = NStr::Find (cpy, " ");
                    if (sep_pos == string::npos || NStr::Find (cpy, " ", sep_pos + 1) != string::npos) {
                        return "";
                    }
                } else if (NStr::Find (cpy, ",", sep_pos + 1) != string::npos) {
                    return "";
                }
                la_token = cpy.substr(0, sep_pos);
                lo_token = cpy.substr(sep_pos + 1);                 
                NStr::TruncateSpacesInPlace (la_token);
                NStr::TruncateSpacesInPlace (lo_token);
                if (NStr::StartsWith (la_token, "-")) {
                  la_token = "S " + la_token.substr(1);
                } else {
                  la_token = "N " + la_token;
                }
                if (NStr::StartsWith (lo_token, "-")) {
                  lo_token = "W " + lo_token.substr(1);
                } else {
                  lo_token = "E " + lo_token;
                }
            } else {
                return "";
            }
        } else if (ns_pos < ew_pos) {
            // as it should be
            if (ns_pos == 0) {
                // letter is first, token ends with ew_pos
                la_token = cpy.substr(0, ew_pos);
                lo_token = cpy.substr(ew_pos);
            } else {
                // letter is last, token ends here
                la_token = cpy.substr(0, ns_pos + 1);
                lo_token = cpy.substr(ns_pos + 1);
            }
        } else {
            // positions reversed
            la_first = false;
            if (ew_pos == 0) {
                // letter is first, token ends with ns_pos
                lo_token = cpy.substr(0, ns_pos);
                la_token = cpy.substr(ns_pos);
            } else {
                // letter is last, token ends here
                lo_token = cpy.substr(0, ew_pos + 1);
                la_token = cpy.substr(ew_pos + 1);
            }
        }            
    } else {
        if (lat_pos < lon_pos) {
            // as it should be
            if (lat_pos == 0) {
                // letter is first, token ends with lon_pos
                la_token = cpy.substr(3, lon_pos - 3);
                lo_token = cpy.substr(lon_pos + 2);
            } else {
                // letter is last, token ends here
                la_token = cpy.substr(0, lat_pos);
                lo_token = cpy.substr(lat_pos + 3);
            }
        } else {
            // positions reversed
            la_first = false;
            if (lon_pos == 0) {
                // letter is first, token ends with lat_pos
                lo_token = cpy.substr(2, lat_pos);
                la_token = cpy.substr(lat_pos + 3);
            } else {
                // letter is last, token ends here
                lo_token = cpy.substr(0, lon_pos);
                la_token = cpy.substr(lon_pos + 2);
            }
        }
        NStr::ReplaceInPlace (la_token, "LAT", "");
        NStr::ReplaceInPlace (lo_token, "LO", "");
        if (NStr::Find (la_token, "E") != string::npos || NStr::Find (la_token, "W") != string::npos) {
            return "";
        } else if (NStr::Find (lo_token, "N") != string::npos || NStr::Find (lo_token, "S") != string::npos) {
            return "";
        }
    }
    if (la_first) {
        NStr::ReplaceInPlace (la_token, ",", "");
        NStr::ReplaceInPlace (la_token, ";", "");
        s_RemoveLeadingCommaOrSemicolon (lo_token);
        s_RemoveExtraText (lo_token, extra_text);
    } else {
        NStr::ReplaceInPlace (lo_token, ",", "");
        NStr::ReplaceInPlace (lo_token, ";", "");
        s_RemoveLeadingCommaOrSemicolon (la_token);
        s_RemoveExtraText (lo_token, extra_text);
    }

    la_token = s_GetNumFromLatLonToken (la_token, "N");
    if (NStr::IsBlank (la_token)
        || !s_IsNumberStringInRange(la_token, 90.0)) {
        return "";
    }

    lo_token = s_GetNumFromLatLonToken (lo_token, "E");

    if (NStr::IsBlank (lo_token)
        || !s_IsNumberStringInRange(lo_token, 180.0)) {
        return "";
    }

    string fix = la_token + " " + lo_token;
    if (!NStr::IsBlank (extra_text)) {
        fix += ",";
        fix += " " + extra_text;
    }
    return fix;
}


string CSubSource::MakeLatLon(double lat_value, double lon_value)
{
    char ns = 'N';
    if (lat_value < 0) {
        ns = 'S';
        lat_value = -lat_value;
    }
    char ew = 'E';
    if (lon_value < 0) {
        ew = 'W';
        lon_value = -lon_value;
    }

    char reformatted[1000];
    sprintf (reformatted, "%.*lf %c %.*lf %c", 2, lat_value, ns, 2, lon_value, ew);

    string latlon = reformatted;
    return latlon;
}


CLatLonCountryId *CSubSource::x_CalculateLatLonId(float lat_value, float lon_value, string country, string province)
{
    CLatLonCountryId *id = new CLatLonCountryId(lat_value, lon_value);

    bool goodmatch = false;

    // lookup region by coordinates, or find nearest region and calculate distance
    const CCountryExtreme * guess = m_LatLonCountryMap->GuessRegionForLatLon(lat_value, lon_value, country, province);
    if (guess) {
        id->SetFullGuess(guess->GetCountry());
        id->SetGuessCountry(guess->GetLevel0());
        id->SetGuessProvince(guess->GetLevel1());
        if (NStr::EqualNocase(country, id->GetGuessCountry())
            && (NStr::IsBlank(province) || NStr::EqualNocase(province, id->GetGuessProvince()))) {
            goodmatch = true;
        }
    } else {
        // not inside a country, check water
        guess = m_LatLonWaterMap->GuessRegionForLatLon(lat_value, lon_value, country);
        if (guess) {
            // found inside water
            id->SetGuessWater(guess->GetCountry());
            if (NStr::EqualNocase(country, id->GetGuessWater())) {
                goodmatch = true;
            }

            // also see if close to land for coastal warning (if country is land)
            // or proximity message (if country is water)
            double landdistance = 0.0;
            guess = m_LatLonCountryMap->FindClosestToLatLon (lat_value, lon_value, 5.0, landdistance);
            if (guess) {
                id->SetClosestFull(guess->GetCountry());
                id->SetClosestCountry(guess->GetLevel0());
                id->SetClosestProvince(guess->GetLevel1());
                id->SetLandDistance(m_LatLonCountryMap->AdjustAndRoundDistance (landdistance));
                if (NStr::EqualNocase(country, id->GetClosestCountry()) 
                    && (NStr::IsBlank(province) || NStr::EqualNocase(province, guess->GetLevel1()))) {
                    goodmatch = true;
                }
            }
        } else {
            // may be coastal inlet, area of data insufficiency
            double landdistance = 0.0;
            guess = m_LatLonCountryMap->FindClosestToLatLon (lat_value, lon_value, 5.0, landdistance);
            if (guess) {
                id->SetClosestFull(guess->GetCountry());
                id->SetClosestCountry(guess->GetLevel0());
                id->SetClosestProvince(guess->GetLevel1());
                id->SetLandDistance(m_LatLonCountryMap->AdjustAndRoundDistance (landdistance));
                if (NStr::EqualNocase(country, id->GetClosestCountry())
                     && (NStr::IsBlank(province) || NStr::EqualNocase(province, guess->GetLevel1()))) {
                    goodmatch = true;
                }
            }

            double waterdistance = 0.0;
            guess = m_LatLonWaterMap->FindClosestToLatLon (lat_value, lon_value, 5.0, waterdistance);
            if (guess) {
                id->SetClosestWater(guess->GetLevel0());
                id->SetWaterDistance(m_LatLonWaterMap->AdjustAndRoundDistance (waterdistance));
                if (NStr::EqualNocase(country, id->GetClosestWater())) {
                    goodmatch = true;
                }
            }
        }
    }

    // if guess is not the provided country or province, calculate distance to claimed country
    if (!goodmatch) {
        double distance = 0.0;
        guess = m_LatLonCountryMap->IsNearLatLon (lat_value, lon_value, 5.0, distance, country, province);
        if (guess) {
            if (distance < ErrorDistance(lat_value, lon_value, m_LatLonCountryMap->GetScale())) {
                // close enough
                id->SetGuessCountry(country);
                id->SetGuessProvince(province);
                id->SetFullGuess(guess->GetCountry());
            } else {            
                id->SetClaimedFull(guess->GetCountry());
                id->SetClaimedDistance(m_LatLonCountryMap->AdjustAndRoundDistance (distance));
            }
        } else if (NStr::IsBlank(province)) {
            guess = m_LatLonWaterMap->IsNearLatLon (lat_value, lon_value, 5.0, distance, country, province);
            if (guess) {
                id->SetClaimedFull(guess->GetCountry());
                id->SetClaimedDistance(m_LatLonWaterMap->AdjustAndRoundDistance (distance));
            }
        }
    }

    return id;
}



typedef SStaticPair<const char*, const char*>  TWaterPairElem;
static const TWaterPairElem k_water_pair_map[] = {
    {"Adriatic Sea",         "Mediterranean Sea"},
    {"Aegean Sea",           "Mediterranean Sea"},
    {"Alboran Sea",          "Mediterranean Sea"},
    {"Andaman Sea",          "Indian Ocean"},
    {"Arabian Sea",          "Indian Ocean"},
    {"Argentine Sea",        "Atlantic Ocean"},
    {"Ariake Sea",           "Pacific Ocean"},
    {"Baffin Bay",           "Atlantic Ocean"},
    {"Balearic Sea",         "Mediterranean Sea"},
    {"Baltic Sea",           "Atlantic Ocean"},
    {"Barents Sea",          "Arctic Ocean"},
    {"Bay of Bengal",        "Indian Ocean"},
    {"Beaufort Sea",         "Arctic Ocean"},
    {"Bering Sea",           "Pacific Ocean"},
    {"Bismarck Sea",         "Pacific Ocean"},
    {"Black Sea",            "Mediterranean Sea"},
    {"Bohai Sea",            "Pacific Ocean"},
    {"Caribbean Sea",        "Atlantic Ocean"},
    {"Celebes Sea",          "Pacific Ocean"},
    {"Champlain Sea",        "Atlantic Ocean"},
    {"Chilean Sea",          "Pacific Ocean"},
    {"China Seas",           "Pacific Ocean"},
    {"Chukchi Sea",          "Arctic Ocean"},
    {"Coral Sea",            "Pacific Ocean"},
    {"Davis Strait",         "Atlantic Ocean"},
    {"East China Sea",       "Pacific Ocean"},
    {"East Siberian Sea",    "Arctic Ocean"},
    {"English Channel",      "Atlantic Ocean"},
    {"Erythraean Sea",       "Indian Ocean"},
    {"Greenland Sea",        "Arctic Ocean"},
    {"Gulf of Mexico",       "Atlantic Ocean"},
    {"Gulf of Thailand",     "Pacific Ocean"},
    {"Gulf of Tonkin",       "Pacific Ocean"},
    {"Hudson Bay",           "Arctic Ocean"},
    {"Ionian Sea",           "Mediterranean Sea"},
    {"Irish Sea",            "Atlantic Ocean"},
    {"Irminger Sea",         "Atlantic Ocean"},
    {"James Bay",            "Atlantic Ocean"},
    {"Java Sea",             "Indian Ocean"},
    {"Kara Sea",             "Arctic Ocean"},
    {"Koro Sea",             "Pacific Ocean"},
    {"Labrador Sea",         "Atlantic Ocean"},
    {"Laccadive Sea",        "Indian Ocean"},
    {"Laptev Sea",           "Arctic Ocean"},
    {"Ligurian Sea",         "Mediterranean Sea"},
    {"Lincoln Sea",          "Arctic Ocean"},
    {"Myrtoan Sea",          "Mediterranean Sea"},
    {"North Sea",            "Atlantic Ocean"},
    {"Norwegian Sea",        "Atlantic Ocean"},
    {"Pechora Sea",          "Arctic Ocean"},
    {"Persian Gulf",         "Indian Ocean"},
    {"Philippine Sea",       "Pacific Ocean"},
    {"Red Sea",              "Indian Ocean"},
    {"Salish Sea",           "Pacific Ocean"},
    {"Sargasso Sea",         "Atlantic Ocean"},
    {"Scotia Sea",           "Southern Ocean"},
    {"Sea of Azov",          "Black Sea"},
    {"Sea of Chiloe",        "Pacific Ocean"},
    {"Sea of Crete",         "Mediterranean Sea"},
    {"Sea of Japan",         "Pacific Ocean"},
    {"Sea of Okhotsk",       "Pacific Ocean"},
    {"Sea of the Hebrides",  "Atlantic Ocean"},
    {"Sea of Zanj",          "Indian Ocean"},
    {"Seas of Greenland",    "Atlantic Ocean"},
    {"Sethusamudram",        "Indian Ocean"},
    {"Sibutu Passage",       "Pacific Ocean"},
    {"Solomon Sea",          "Pacific Ocean"},
    {"South China Sea",      "Pacific Ocean"},
    {"Sulu Sea",             "Pacific Ocean"},
    {"Tasman Sea",           "Pacific Ocean"},
    {"Thracian Sea",         "Mediterranean Sea"},
    {"Timor Sea",            "Indian Ocean"},
    {"Tyrrhenian Sea",       "Mediterranean Sea"},
    {"Wandel Sea",           "Arctic Ocean"},
    {"White Sea",            "Arctic Ocean"},
    {"Yellow Sea",           "Pacific Ocean"}
};
typedef CStaticArrayMap<const char*, const char*, PNocase_CStr> TWaterPairMap;
DEFINE_STATIC_ARRAY_MAP(TWaterPairMap, sc_WaterPairMap, k_water_pair_map);

static string x_FindSurroundingOcean (string& water)

{
    TWaterPairMap::const_iterator new_water_pair_iter = sc_WaterPairMap.find(water.c_str());
    if( new_water_pair_iter != sc_WaterPairMap.end() ) {
        return new_water_pair_iter->second;
    }
    return "";
}


string CSubSource::ValidateLatLonCountry (const string& input_countryname, string& lat_lon, bool check_state, ELatLonCountryErr& errcode)
{
    errcode = eLatLonCountryErr_None;
    string countryname = input_countryname;
    if (NStr::IsBlank(countryname) || NStr::IsBlank(lat_lon)) {
        return "";
    }

    if ( m_LatLonCountryMap.get() == 0 ) {
        m_LatLonCountryMap.reset (new CLatLonCountryMap(false));
    }
    if ( m_LatLonWaterMap.get() == 0 ) {
        m_LatLonWaterMap.reset (new CLatLonCountryMap(true));
    }

    // only do these checks if the latlon format is good
    bool format_correct, lat_in_range, lon_in_range, precision_correct;
    double lat_value = 0.0, lon_value = 0.0;
    CSubSource::IsCorrectLatLonFormat (lat_lon, format_correct, precision_correct,
                               lat_in_range, lon_in_range,
                               lat_value, lon_value);
    if (!format_correct) {
        // may have comma and then altitude, so just get lat_lon component */
        size_t pos = NStr::Find(lat_lon, ",", 0, string::npos, NStr::eLast);
        if (pos != string::npos) {
            lat_lon = lat_lon.substr(0, pos);
            CSubSource::IsCorrectLatLonFormat (lat_lon, format_correct, precision_correct,
                                       lat_in_range, lon_in_range,
                                       lat_value, lon_value);
        }
    }

    // reality checks
    if (!format_correct || !lat_in_range || !lon_in_range) {
        // incorrect lat_lon format should be reported elsewhere
        // incorrect latitude range should be reported elsewhere
        // incorrect longitude range should be reported elsewhere
        return "";
    }

    // get rid of comments after semicolon or comma in country name
    size_t pos = NStr::Find(countryname, ";");
    if (pos != string::npos) {
         countryname = countryname.substr(0, pos);
        }
    pos = NStr::Find(countryname, ",");
    if (pos != string::npos) {
         countryname = countryname.substr(0, pos);
    }

    // adjust for special cases
    if (NStr::StartsWith(countryname, "Norway: Svalbard")) {
        countryname = "Svalbard";
    }

    string country = countryname;
    string province = "";
    pos = NStr::Find(country, ":");
    if (pos != string::npos) {
        // is the full string in the list?
        if (m_LatLonCountryMap->HaveLatLonForRegion(countryname)) {
            province = country.substr(pos + 1);
            NStr::TruncateSpacesInPlace(province, NStr::eTrunc_Both);
        }
        country = country.substr(0, pos);
        NStr::TruncateSpacesInPlace(country, NStr::eTrunc_Both);
    }
    if (NStr::IsBlank(country)) {
        return "";
    }

    // known exceptions - don't even bother calculating any further
    if (NStr::EqualNocase (country, "Antarctica") && lat_value < -60.0) {
        return "";
    }

    if (! NStr::IsBlank(province)) {
        // do not attempt quick exit
    } else if (m_LatLonCountryMap->HaveLatLonForRegion(country)) {
        if (m_LatLonCountryMap->IsCountryInLatLon(country, lat_value, lon_value)) {
            return "";
        }
    } else if (m_LatLonWaterMap->HaveLatLonForRegion(country)) {
        if (m_LatLonWaterMap->IsCountryInLatLon(country, lat_value, lon_value)) {
            return "";
        }
    } else if (NStr::EqualNocase (country, "Palestine") || NStr::EqualNocase (country, "State of Palestine")) {
    } else {
        // report unrecognized country
        return "";
    }

    CLatLonCountryId *id = x_CalculateLatLonId(lat_value, lon_value, country, province);

    CLatLonCountryId::TClassificationFlags flags = (id == NULL ? 0 : id->Classify(country, province));

    string wguess = id->GetGuessWater();
    string cguess = id->GetGuessCountry();

    if (NStr::EqualNocase (country, "China") && NStr::EqualNocase (cguess, "Hong Kong")) {
        return "";
    }
    if (NStr::EqualNocase (country, "USA") && NStr::EqualNocase (cguess, "Puerto Rico")) {
        return "";
    }
    if ((NStr::EqualNocase (country, "Palestine") ||
         NStr::EqualNocase (country, "State of Palestine")) &&
        (NStr::EqualNocase (cguess, "Gaza Strip") ||
         NStr::EqualNocase (cguess, "West Bank"))) {
        return "";
    }

    if (NStr::IsBlank (cguess) && (! NStr::IsBlank (wguess))) {
        string parent = x_FindSurroundingOcean (wguess);
        if ((! NStr::IsBlank (parent)) && NStr::EqualNocase (country, parent)) {
            delete id;
            return "";
        }
    }

    double neardist = 0.0;
    CLatLonCountryMap::TLatLonAdjustFlags adjustment = CLatLonCountryMap::fNone;
    CLatLonCountryId::TClassificationFlags adjusted_flags = 0;

    if (!flags && m_LatLonCountryMap->IsNearLatLon(lat_value, lon_value, 2.0, neardist, country) && neardist < 5.0) {
        id->SetGuessCountry (country);
        id->SetGuessProvince ("");
        flags = id->Classify(country, province);
    }

    if (!flags && !m_LatLonCountryMap->IsNearLatLon(lat_value, lon_value, 20.0, neardist, country)
        && !m_LatLonWaterMap->IsNearLatLon(lat_value, lon_value, 20.0, neardist, country)
        && (! NStr::IsBlank (cguess)) && NStr::IsBlank (wguess)) {
        /* do not flip from water */
        CLatLonCountryId *adjust_id = x_CalculateLatLonId(lon_value, lat_value, country, province);
        adjusted_flags = adjust_id == NULL ? 0 : adjust_id->Classify(country, province);
        if (adjusted_flags) {
            string awguess = adjust_id->GetGuessWater();
            string acguess = adjust_id->GetGuessCountry();
            if (NStr::IsBlank (awguess) && (! NStr::IsBlank (acguess))) {
                delete id;
                id = adjust_id;
                flags = adjusted_flags;
                adjustment = CLatLonCountryMap::fFlip;
            }
        } else {
            if (adjust_id) {
                delete adjust_id;
            }
            adjust_id = x_CalculateLatLonId(-lat_value, lon_value, country, province);
            adjusted_flags = adjust_id == NULL ? 0 : adjust_id->Classify(country, province);
            if (adjusted_flags) {
                string awguess = adjust_id->GetGuessWater();
                string acguess = adjust_id->GetGuessCountry();
                if (NStr::IsBlank (awguess) && (! NStr::IsBlank (acguess))) {
                    delete id;
                    id = adjust_id;
                    flags = adjusted_flags;
                    adjustment = CLatLonCountryMap::fNegateLat;
                }
            } else {
                if (adjust_id) {
                    delete adjust_id;
                }
                adjust_id = x_CalculateLatLonId(lat_value, -lon_value, country, province);
                adjusted_flags = adjust_id == NULL ? 0 : adjust_id->Classify(country, province);
                if (adjusted_flags) {
                    string awguess = adjust_id->GetGuessWater();
                    string acguess = adjust_id->GetGuessCountry();
                    if (NStr::IsBlank (awguess) && (! NStr::IsBlank (acguess))) {
                        delete id;
                        id = adjust_id;
                        flags = adjusted_flags;
                        adjustment = CLatLonCountryMap::fNegateLon;
                    }
                } else {
                    if (adjust_id) {
                        delete adjust_id;
                    }
                }
            }
        }
    }

    string error = "";

    if (adjustment != CLatLonCountryMap::fNone) {
        if (adjustment == CLatLonCountryMap::fFlip) {
            errcode = eLatLonCountryErr_Value;
            error = "Latitude and longitude values appear to be exchanged";
            lat_lon = MakeLatLon(lon_value, lat_value);
        } else if (adjustment == CLatLonCountryMap::fNegateLat) {
            errcode = eLatLonCountryErr_Value;  
            if (lat_value < 0.0) {
                error = "Latitude should be set to N (northern hemisphere)";
            } else {
                error = "Latitude should be set to S (southern hemisphere)";
            }
            lat_lon = MakeLatLon(-lat_value, lon_value);
        } else if (adjustment == CLatLonCountryMap::fNegateLon) {
            errcode = eLatLonCountryErr_Value;
            if (lon_value < 0.0) {
                error = "Longitude should be set to E (eastern hemisphere)";
            } else {
                error = "Longitude should be set to W (western hemisphere)";
            }
            lat_lon = MakeLatLon(lat_value, -lon_value);
        }
    } else if ((flags & CLatLonCountryId::fCountryMatch) && (flags & CLatLonCountryId::fProvinceMatch)) {
        // success!  nothing to report
    } else if (flags & CLatLonCountryId::fWaterMatch) {
        // success!  nothing to report
    } else if (flags & CLatLonCountryId::fCountryMatch && NStr::IsBlank(province)) {
        if (check_state) {
            errcode = eLatLonCountryErr_State;
            error = "Lat_lon " + lat_lon + " is in " + id->GetFullGuess()
                        + " (more specific than " + country + ")";
        }
    } else if (!NStr::IsBlank(id->GetGuessWater())) {
        if (flags & (CLatLonCountryId::fCountryClosest | CLatLonCountryId::fProvinceClosest)) {
            bool suppress = false;
            string reportregion;
            string nosubphrase = "";
            string desphrase = "designated subregion ";
            string subphrase = "another subregion ";
            string phrase = nosubphrase;
            bool show_claimed = false;

            if (id->GetLandDistance() < 22) {
                // for now, will not report
                // this is a policy decision
                suppress = true;
            } else if (NStr::Find(countryname, "Island") != string::npos) {
                suppress = true;
            }


            if (flags & CLatLonCountryId::fProvinceClosest) {
                reportregion = countryname;
                phrase = desphrase;
            } else {
                // wasn't closest province, so must be closest country
                if (!NStr::IsBlank(province) && check_state) {
                  phrase = subphrase;
                  reportregion = id->GetClosestFull();
                } else {
                  reportregion = id->GetClosestCountry();
                }
                if (!NStr::IsBlank(id->GetClaimedFull())) {
                  show_claimed = true;
                }
            }
            if (!suppress) {
                errcode = eLatLonCountryErr_Water;
                if (show_claimed) {
                    error = "Lat_lon '" + lat_lon + "' is closest to " + phrase + "'" + reportregion + "' at distance "
                            + NStr::IntToString(id->GetLandDistance())
                            + " km, but in water '" + id->GetGuessWater()
                            + "' - claimed region '" + id->GetClaimedFull() 
                            + "' is at distance " + NStr::IntToString(id->GetClaimedDistance()) + " km";
                } else {
                    error = "Lat_lon '" + lat_lon + "' is closest to " + phrase + "'" + reportregion
                            + "' at distance " + NStr::IntToString(id->GetLandDistance()) + " km, but in water '"
                            + id->GetGuessWater() + "'";
                }
            }
        } else if (neardist > 0.0) { 
            errcode = eLatLonCountryErr_Water;
            error = "Lat_lon '" + lat_lon + "' is in water '" + id->GetGuessWater() + "', '"
                        + countryname + "' is " + NStr::IntToString(m_LatLonCountryMap->AdjustAndRoundDistance(neardist)) + " km away";
        } else {
            errcode = eLatLonCountryErr_Water;
            error = "Lat_lon '" + lat_lon + "' is in water '" + id->GetGuessWater() + "'";
        }
    } else if (!NStr::IsBlank(id->GetGuessCountry())) {
        if (NStr::IsBlank(id->GetClaimedFull())) {
            errcode = eLatLonCountryErr_Country;
            error = "Lat_lon '" + lat_lon + "' maps to '" + id->GetFullGuess() + "' instead of '"
                        + countryname + "'";
        } else {
            if (NStr::IsBlank(province)) {
                errcode = eLatLonCountryErr_Country;
                error = "Lat_lon '" + lat_lon + "' maps to '" + id->GetFullGuess() + "' instead of '"
                            + country + "' - claimed region '" + id->GetClaimedFull() 
                            + "' is at distance " + NStr::IntToString(id->GetClaimedDistance()) + " km";
            } else {
                errcode = eLatLonCountryErr_Country;
                if (NStr::EqualNocase(id->GetGuessCountry(), country)) {
                    errcode = eLatLonCountryErr_State;
                }
                if (errcode == eLatLonCountryErr_Country || check_state) {
                    error = "Lat_lon '" + lat_lon + "' maps to '" + id->GetFullGuess() + "' instead of '"
                                + countryname + "' - claimed region '" + id->GetClaimedFull() 
                                + "' is at distance " + NStr::IntToString(id->GetClaimedDistance()) + " km";
                } else {
                    errcode = eLatLonCountryErr_None;
                }
            }
        }
    } else if (!NStr::IsBlank(id->GetClosestCountry())) {
        errcode = eLatLonCountryErr_Country;
        error = "Lat_lon '" + lat_lon + "' is closest to '" + id->GetClosestCountry() + "' instead of '"
                    + countryname + "'";
    } else if (!NStr::IsBlank(id->GetClosestWater())) {
        errcode = eLatLonCountryErr_Water;
        error = "Lat_lon '" + lat_lon + "' is closest to '" + id->GetClosestWater() + "' instead of '"
                    + countryname + "'";
    } else {
        errcode = eLatLonCountryErr_Country;
        error = "Unable to determine mapping for lat_lon '" + lat_lon + "' and country '" + countryname + "'";
    }


    delete id;
    return error;
}


const char* sm_ValidSexQualifierTokens[] = {
  "asexual",
  "bisexual",
  "diecious",
  "dioecious",
  "f",
  "female",
  "gelding",
  "hermaphrodite",
  "m",
  "male",
  "mixed",
  "monecious",
  "monoecious",
  "neuter",
  "unisexual",
};


const char* sm_ValidSexQualifierPhrases[] = {
  "pooled males and females",
  "pooled male and female",
};


bool s_IsValidSexQualifierPhrase(const string& value)
{
    size_t max = sizeof(sm_ValidSexQualifierPhrases) / sizeof(const char*);

    const char* *begin = sm_ValidSexQualifierPhrases;
    const char* *end = &(sm_ValidSexQualifierPhrases[max]);

    if (find(begin, end, value) != end) {
        return true;
    } else {
        return false;
    }
}


bool CSubSource::IsValidSexQualifierValue (const string& value)

{
    string str = value;
    NStr::ToLower(str);

    if (s_IsValidSexQualifierPhrase(str)) {
        return true;
    }

    vector<string> words;
    NStr::Tokenize(str," ,/",words);
    if (words.size() == 0) {
        return false;
    }

    size_t max = sizeof(sm_ValidSexQualifierTokens) / sizeof(const char*);

    const char* *begin = sm_ValidSexQualifierTokens;
    const char* *end = &(sm_ValidSexQualifierTokens[max]);

    bool is_good = false;

    ITERATE(vector<string>, w, words) {
        if (NStr::Equal(*w, "and")) {
            // ok, skip it
        } else {
            if (find(begin, end, *w) != end) {
                is_good = true;
            } else {
                is_good = false;
                break;
            }
        }
    }
    return is_good;
}


string CSubSource::FixSexQualifierValue (const string& value)
{
    string str = value;
    NStr::ToLower(str);

    if (s_IsValidSexQualifierPhrase(str)) {
        return str;
    }

    vector<string> words;
    NStr::Tokenize(str," ,/",words);

    if (words.size() == 0) {
        return "";
    }
    size_t max = sizeof(sm_ValidSexQualifierTokens) / sizeof(const char*);

    const char* *begin = sm_ValidSexQualifierTokens;
    const char* *end = &(sm_ValidSexQualifierTokens[max]);

    vector<string> good_values;
    bool pooled = false;

    ITERATE(vector<string>, w, words) {
        if (NStr::Equal(*w, "and")) {
            // ok, skip it
        } else if (NStr::EqualNocase(*w, "(pooled)") || NStr::EqualNocase(*w, "pooled")) {
            // set pooled flag
            pooled = true;
        } else {
            if (find(begin, end, *w) != end) {
                if (NStr::Equal(*w, "m")) {
                    good_values.push_back("male");
                } else if (NStr::Equal(*w, "f")) {
                    good_values.push_back("female");
                } else {
                    good_values.push_back(*w);
                }
            } else {
                // if any bad values, can't autofix
                return "";
            }
        }
    }
    if (good_values.size() == 0) {
        // no good tokens, can't autofix
        return "";
    }

    string fixed = good_values[0];
    for (size_t i = 1; i < good_values.size(); i++) {
        if (good_values.size() > 2) {
            fixed += ",";
        }
        if (i == good_values.size() - 1) {
            fixed += " and";
        }
        fixed += " " + good_values[i];
    }
    if (pooled) {
        fixed = "pooled " + fixed;
    }
    return fixed;
}


void s_CollectNumberAndUnits(const string& value, string& number, string& units)
{
    number = "";
    units = "";

    if (NStr::IsBlank(value)) {
        return;
    }

    string::const_iterator it = value.begin();
    if (*it == '+' || *it == '-') {
        number += *it;
        it++;
    }

    bool any_digit = false;
    while (it != value.end() && isdigit(*it)) {
        any_digit = true;
        number += *it;
        it++;
    }

    if (it == value.end()) {
        number = "";
        return;
    }

    if (*it == '.') {
        number += *it;
        it++;
        while (it != value.end() && isdigit(*it)) {
            any_digit = true;
            number += *it;
            it++;
        }
    }

    if (it == value.end() || *it != ' ' || !any_digit) {
        number = "";
        return;
    }

    it++;
    while (it != value.end()) {
        units += *it;
        it++;
    }
}


bool CSubSource::IsAltitudeValid (const string& value)
{
    if (NStr::IsBlank(value)) {
        return false;
    }

    string number = "";
    string units = "";
    s_CollectNumberAndUnits(value, number, units);
    if (NStr::IsBlank(number) || !NStr::EqualCase(units, "m")) {
        return false;
    } else {
        return true;
    }

}


int CSubSource::x_GetPrecision(const string& num_str)
{
    int precision = 0;
    size_t pos = NStr::Find(num_str, ".");
    if (pos != string::npos) {
        precision = int(num_str.length() - pos - 1);
    }
    return precision;
}


string CSubSource::x_FormatWithPrecision(double val, int precision)
{
    char reformatted[1000];
    sprintf(reformatted, "%.*lf", precision, val);
    string rval = reformatted;
    return rval;
}

string CSubSource::FixAltitude (const string& value)
{
    if (NStr::IsBlank(value)) {
        return "";
    }

    string number = "";
    string units = "";
    s_CollectNumberAndUnits(value, number, units);
    if (NStr::IsBlank(number)) {
        return "";
    } else if (NStr::Equal(units, "ft.") || NStr::Equal(units, "ft") || NStr::Equal(units, "feet") || NStr::Equal(units, "foot")) {
        int precision = x_GetPrecision(number);
        double val = NStr::StringToDouble(number);
        val *= 0.3048;
        number = x_FormatWithPrecision(val, precision);
        units = "m";
    } 
    
    if (NStr::Equal(units, "m.")
        || NStr::Equal(units, "meters")
        || NStr::Equal(units, "meter")
        || NStr::Equal(units, "m")) {
        return number + " " + "m";
    } else {
        return "";
    }
}


typedef pair<string, string> TContaminatingCellLine;
typedef map<string, TContaminatingCellLine> TSpeciesContaminant;
typedef map<string, TSpeciesContaminant> TCellLineContaminationMap;

static TCellLineContaminationMap s_CellLineContaminationMap;
static bool s_CellLineContaminationMapInitialized = false;
DEFINE_STATIC_FAST_MUTEX(s_CellLineContaminationMutex);

#include "cell_line.inc"

static void s_ProcessCellLineLine(const CTempString& line)
{
    vector<string> tokens;
    NStr::Tokenize(line, "\t", tokens);
    if (tokens.size() < 4) {
        ERR_POST_X(1, Warning << "Not enough columns in cell_line entry " << line
                   << "; disregarding");
    } else {
        NStr::ToUpper(tokens[0]);
        (s_CellLineContaminationMap[tokens[0]])[tokens[1]] = TContaminatingCellLine(tokens[2], tokens[3]);
    }
}


static void s_InitializeCellLineContaminationMap(void)
{
    CFastMutexGuard GUARD(s_CellLineContaminationMutex);
    if (s_CellLineContaminationMapInitialized) {
        return;
    }

    // read table
    
    size_t count = sizeof(kCellLine) / sizeof (*kCellLine);
    const char * const * start = kCellLine;
    while (count--) {
        s_ProcessCellLineLine(*start++);
    }


    s_CellLineContaminationMapInitialized = true;
}


string CSubSource::CheckCellLine(const string& cell_line, const string& organism)
{
    string rval = "";

    s_InitializeCellLineContaminationMap();
    string cell_line_search = cell_line;
    NStr::ToUpper(cell_line_search);

    if (!NStr::IsBlank(((s_CellLineContaminationMap[cell_line_search])[organism]).first)) {
        rval = "The International Cell Line Authentication Committee database indicates that " +
               cell_line + " from " + organism + " is known to be contaminated by " +
               ((s_CellLineContaminationMap[cell_line_search])[organism]).first +
               " from " + ((s_CellLineContaminationMap[cell_line_search])[organism]).second +
               ". Please see http://iclac.org/databases/cross-contaminations/ for more information and references.";
    }
    return rval;
}


// =============================================================================
//                                 Country Names
// =============================================================================


// legal country names, must be in alphabetical order (case sensitive)
static const char* const s_Countries[] = {
    "Afghanistan",
    "Albania",
    "Algeria",
    "American Samoa",
    "Andorra",
    "Angola",
    "Anguilla",
    "Antarctica",
    "Antigua and Barbuda",
    "Arctic Ocean",
    "Argentina",
    "Armenia",
    "Aruba",
    "Ashmore and Cartier Islands",
    "Atlantic Ocean",
    "Australia",
    "Austria",
    "Azerbaijan",
    "Bahamas",
    "Bahrain",
    "Baker Island",
    "Baltic Sea",
    "Bangladesh",
    "Barbados",
    "Bassas da India",
    "Belarus",
    "Belgium",
    "Belize",
    "Benin",
    "Bermuda",
    "Bhutan",
    "Bolivia",
    "Borneo",
    "Bosnia and Herzegovina",
    "Botswana",
    "Bouvet Island",
    "Brazil",
    "British Virgin Islands",
    "Brunei",
    "Bulgaria",
    "Burkina Faso",
    "Burundi",
    "Cambodia",
    "Cameroon",
    "Canada",
    "Cape Verde",
    "Cayman Islands",
    "Central African Republic",
    "Chad",
    "Chile",
    "China",
    "Christmas Island",
    "Clipperton Island",
    "Cocos Islands",
    "Colombia",
    "Comoros",
    "Cook Islands",
    "Coral Sea Islands",
    "Costa Rica",
    "Cote d'Ivoire",
    "Croatia",
    "Cuba",
    "Curacao",
    "Cyprus",
    "Czech Republic",
    "Democratic Republic of the Congo",
    "Denmark",
    "Djibouti",
    "Dominica",
    "Dominican Republic",
    "East Timor",
    "Ecuador",
    "Egypt",
    "El Salvador",
    "Equatorial Guinea",
    "Eritrea",
    "Estonia",
    "Ethiopia",
    "Europa Island",
    "Falkland Islands (Islas Malvinas)",
    "Faroe Islands",
    "Fiji",
    "Finland",
    "France",
    "French Guiana",
    "French Polynesia",
    "French Southern and Antarctic Lands",
    "Gabon",
    "Gambia",
    "Gaza Strip",
    "Georgia",
    "Germany",
    "Ghana",
    "Gibraltar",
    "Glorioso Islands",
    "Greece",
    "Greenland",
    "Grenada",
    "Guadeloupe",
    "Guam",
    "Guatemala",
    "Guernsey",
    "Guinea",
    "Guinea-Bissau",
    "Guyana",
    "Haiti",
    "Heard Island and McDonald Islands",
    "Honduras",
    "Hong Kong",
    "Howland Island",
    "Hungary",
    "Iceland",
    "India",
    "Indian Ocean",
    "Indonesia",
    "Iran",
    "Iraq",
    "Ireland",
    "Isle of Man",
    "Israel",
    "Italy",
    "Jamaica",
    "Jan Mayen",
    "Japan",
    "Jarvis Island",
    "Jersey",
    "Johnston Atoll",
    "Jordan",
    "Juan de Nova Island",
    "Kazakhstan",
    "Kenya",
    "Kerguelen Archipelago",
    "Kingman Reef",
    "Kiribati",
    "Kosovo",
    "Kuwait",
    "Kyrgyzstan",
    "Laos",
    "Latvia",
    "Lebanon",
    "Lesotho",
    "Liberia",
    "Libya",
    "Liechtenstein",
    "Line Islands",
    "Lithuania",
    "Luxembourg",
    "Macau",
    "Macedonia",
    "Madagascar",
    "Malawi",
    "Malaysia",
    "Maldives",
    "Mali",
    "Malta",
    "Marshall Islands",
    "Martinique",
    "Mauritania",
    "Mauritius",
    "Mayotte",
    "Mediterranean Sea",
    "Mexico",
    "Micronesia",
    "Midway Islands",
    "Moldova",
    "Monaco",
    "Mongolia",
    "Montenegro",
    "Montserrat",
    "Morocco",
    "Mozambique",
    "Myanmar",
    "Namibia",
    "Nauru",
    "Navassa Island",
    "Nepal",
    "Netherlands",
    "New Caledonia",
    "New Zealand",
    "Nicaragua",
    "Niger",
    "Nigeria",
    "Niue",
    "Norfolk Island",
    "North Korea",
    "North Sea",
    "Northern Mariana Islands",
    "Norway",
    "Oman",
    "Pacific Ocean",
    "Pakistan",
    "Palau",
    "Palestine",
    "Palmyra Atoll",
    "Panama",
    "Papua New Guinea",
    "Paracel Islands",
    "Paraguay",
    "Peru",
    "Philippines",
    "Pitcairn Islands",
    "Poland",
    "Portugal",
    "Puerto Rico",
    "Qatar",
    "Republic of the Congo",
    "Reunion",
    "Romania",
    "Ross Sea",
    "Russia",
    "Rwanda",
    "Saint Helena",
    "Saint Kitts and Nevis",
    "Saint Lucia",
    "Saint Pierre and Miquelon",
    "Saint Vincent and the Grenadines",
    "Samoa",
    "San Marino",
    "Sao Tome and Principe",
    "Saudi Arabia",
    "Senegal",
    "Serbia",
    "Seychelles",
    "Sierra Leone",
    "Singapore",
    "Sint Maarten",
    "Slovakia",
    "Slovenia",
    "Solomon Islands",
    "Somalia",
    "South Africa",
    "South Georgia and the South Sandwich Islands",
    "South Korea",
    "South Sudan",
    "Southern Ocean",
    "Spain",
    "Spratly Islands",
    "Sri Lanka",
    "State of Palestine",
    "Sudan",
    "Suriname",
    "Svalbard",
    "Swaziland",
    "Sweden",
    "Switzerland",
    "Syria",
    "Taiwan",
    "Tajikistan",
    "Tanzania",
    "Tasman Sea",
    "Thailand",
    "Togo",
    "Tokelau",
    "Tonga",
    "Trinidad and Tobago",
    "Tromelin Island",
    "Tunisia",
    "Turkey",
    "Turkmenistan",
    "Turks and Caicos Islands",
    "Tuvalu",
    "USA",
    "Uganda",
    "Ukraine",
    "United Arab Emirates",
    "United Kingdom",
    "Uruguay",
    "Uzbekistan",
    "Vanuatu",
    "Venezuela",
    "Viet Nam",
    "Virgin Islands",
    "Wake Island",
    "Wallis and Futuna",
    "West Bank",
    "Western Sahara",
    "Yemen",
    "Zambia",
    "Zimbabwe"
};
typedef CStaticArraySet<const char*, PCase_CStr> TCStrSet;
static const TCStrSet s_CountriesSet(s_Countries, sizeof(s_Countries), __FILE__, __LINE__);

// former legal country names, must be in alphabetical order (case sensitive)
static const char* const s_Former_Countries[] = {
    "Belgian Congo",
    "British Guiana",
    "Burma",
    "Czechoslovakia",
    "Korea",
    "Netherlands Antilles",
    "Serbia and Montenegro",
    "Siam",
    "USSR",
    "Yugoslavia",
    "Zaire"
};
static const TCStrSet s_Former_CountriesSet(s_Former_Countries, sizeof(s_Former_Countries), __FILE__, __LINE__);

bool CCountries::IsValid(const string& country)
{
    string name = country;
    size_t pos = country.find(':');

    if ( pos != string::npos ) {
        if (pos == country.length() - 1) {
            return false;
        }
        name = country.substr(0, pos);
    }

    // try current countries
    if (s_CountriesSet.find(name.c_str()) != s_CountriesSet.end()) {
        return true;
    } else if (s_Former_CountriesSet.find(name.c_str()) != s_Former_CountriesSet.end()) {
        return true;
    } else {
        return false;
    }
}


bool CCountries::IsValid(const string& country, bool& is_miscapitalized)
{
    string name = country;
    size_t pos = country.find(':');

    if ( pos != string::npos ) {
        name = country.substr(0, pos);
        if (pos == country.length() - 1) {
            return false;
        }
    }

    is_miscapitalized = false;
    // try current countries
    // fast check for properly capitalized
    if ( s_CountriesSet.find(name.c_str()) != s_CountriesSet.end() ) {
        return true;
    }
    if ( s_Former_CountriesSet.find(name.c_str()) != s_Former_CountriesSet.end() ) {
        return true;
    }
    // slow check for miscapitalized
    ITERATE ( TCStrSet, it, s_CountriesSet ) {
        if ( NStr::EqualNocase(name, *it) ) {
            is_miscapitalized = true;
            return true;
        }
    }
    ITERATE ( TCStrSet, it, s_Former_CountriesSet ) {
        if ( NStr::EqualNocase(name, *it) ) {
            is_miscapitalized = true;
            return true;
        }
    }

    return false;
}


bool CCountries::WasValid(const string& country)
{
    string name = country;
    size_t pos = country.find(':');

    if ( pos != string::npos ) {
        name = country.substr(0, pos);
    }

    // try formerly-valid countries
    return s_Former_CountriesSet.find(name.c_str()) != s_Former_CountriesSet.end();
}


bool CCountries::WasValid(const string& country, bool& is_miscapitalized)
{
    string name = country;
    size_t pos = country.find(':');

    if ( pos != string::npos ) {
        name = country.substr(0, pos);
    }

    is_miscapitalized = false;
    // try formerly-valid countries
    // fast check for properly capitalized
    if ( s_Former_CountriesSet.find(name.c_str()) != s_Former_CountriesSet.end() ) {
        return true;
    }
    // slow check for miscapitalized
    ITERATE ( TCStrSet, it, s_Former_CountriesSet ) {
        if ( NStr::EqualNocase(name, *it) ) {
            is_miscapitalized = true;
            return true;
        }
    }
    return false;
}

/////////////////////////////////////////////////////////////////////////////
////// Country Capitalization Fix ///////////////////////////////////////////

static const SStaticPair<const char*, const char*> s_map_whole_country_fixes[] =
{
  {"england", "United Kingdom: England"},
  {"great britain", "United Kingdom: Great Britain"},
  {"new jersey, usa", "USA: New Jersey"}
};
typedef CStaticPairArrayMap<const char*, const char*, PCase_CStr> TCStringPairsMap;
DEFINE_STATIC_ARRAY_MAP(TCStringPairsMap,k_whole_country_fixes, s_map_whole_country_fixes);

static const SStaticPair<const char*, const char*> s_map_country_name_fixes[] = {
{"ABW", "Aruba"},
{"AFG", "Afghanistan"},
{"AGO", "Angola"},
{"AIA", "Anguilla"},
{"ALA", "Aland Islands"},
{"ALB", "Albania"},
{"AND", "Andorra"},
{"ARE", "United Arab Emirates"},
{"ARG", "Argentina"},
{"ARM", "Armenia"},
{"ASM", "American Samoa"},
{"ATA", "Antarctica"},
{"ATF", "French Southern Territories"},
{"ATG", "Antigua and Barbuda"},
{"AUS", "Australia"},
{"AUT", "Austria"},
{"AZE", "Azerbaijan"},
{"Antigua", "Antigua and Barbuda: Antigua"},
{"Antigua & Barbuda", "Antigua and Barbuda"},
{"Ashmore & Cartier Islands", "Ashmore and Cartier Islands"},
{"Ashmore Island", "Ashmore and Cartier Islands: Ashmore Island"},
{"Autonomous Region of the Azores", "Portugal: Azores"},
{"Azores", "Portugal: Azores"},
{"BDI", "Burundi"},
{"BEL", "Belgium"},
{"BEN", "Benin"},
{"BES", "Bonaire, Sint Eustatius and Saba"},
{"BFA", "Burkina Faso"},
{"BGD", "Bangladesh"},
{"BGR", "Bulgaria"},
{"BHR", "Bahrain"},
{"BHS", "Bahamas"},
{"BIH", "Bosnia and Herzegovina"},
{"BLM", "Saint Barthelemy"},
{"BLR", "Belarus"},
{"BLZ", "Belize"},
{"BMU", "Bermuda"},
{"BOL", "Bolivia"},
{"BRA", "Brazil"},
{"BRB", "Barbados"},
{"BRN", "Brunei"},
{"BTN", "Bhutan"},
{"BVT", "Bouvet Island"},
{"BWA", "Botswana"},
{"Barbuda", "Antigua and Barbuda: Barbuda"},
{"Bassas da India", "French Southern and Antarctic Lands: Bassas da India"},
{"Brasil", "Brazil"},
{"CAF", "Central African Republic"},
{"CAN", "Canada"},
{"CCK", "Cocos Islands"},
{"CHE", "Switzerland"},
{"CHL", "Chile"},
{"CHN", "China"},
{"CIV", "Cote d'Ivoire"},
{"CMR", "Cameroon"},
{"COD", "Democratic Republic of the Congo"},
{"COG", "Republic of the Congo"},
{"COK", "Cook Islands"},
{"COL", "Colombia"},
{"COM", "Comoros"},
{"CPV", "Cape Verde"},
{"CRI", "Costa Rica"},
{"CUB", "Cuba"},
{"CUW", "Curacao"},
{"CXR", "Christmas Island"},
{"CYM", "Cayman Islands"},
{"CYP", "Cyprus"},
{"CZE", "Czech Republic"},
{"Caicos Islands", "Turks and Caicos Islands: Caicos Islands"},
{"Canary Islands", "Spain: Canary Islands"},
{"Cape Verde Islands", "Cape Verde"},
{"Cartier Island", "Ashmore and Cartier Islands: Cartier Island"},
{"DEU", "Germany"},
{"DJI", "Djibouti"},
{"DMA", "Dominica"},
{"DNK", "Denmark"},
{"DOM", "Dominican Republic"},
{"DZA", "Algeria"},
{"ECU", "Ecuador"},
{"EGY", "Egypt"},
{"ERI", "Eritrea"},
{"ESH", "Western Sahara"},
{"ESP", "Spain"},
{"EST", "Estonia"},
{"ETH", "Ethiopia"},
{"East Germany", "Germany: East Germany"},
{"El Hierro", "Spain: El Hierro"},
{"Europa Island", "French Southern and Antarctic Lands: Europa Island"},
{"FIN", "Finland"},
{"FJI", "Fiji"},
{"FLK", "Falkland Islands (Islas Malvinas)"},
{"FRA", "France"},
{"FRO", "Faroe Islands"},
{"FSM", "Micronesia"},
{"Falkland Islands", "Falkland Islands (Islas Malvinas)"},
{"French Southern & Antarctic Lands", "French Southern and Antarctic Lands"},
{"Fuerteventura", "Spain: Fuerteventura"},
{"GAB", "Gabon"},
{"GBR", "United Kingdom"},
{"GEO", "Georgia"},
{"GGY", "Guernsey"},
{"GHA", "Ghana"},
{"GIB", "Gibraltar"},
{"GIN", "Guinea"},
{"GLP", "Guadeloupe"},
{"GMB", "Gambia"},
{"GNB", "Guinea-Bissau"},
{"GNQ", "Equatorial Guinea"},
{"GRC", "Greece"},
{"GRD", "Grenada"},
{"GRL", "Greenland"},
{"GTM", "Guatemala"},
{"GUF", "French Guiana"},
{"GUM", "Guam"},
{"GUY", "Guyana"},
{"Glorioso Islands", "French Southern and Antarctic Lands: Glorioso Islands"},
{"Gran Canaria", "Spain: Gran Canaria"},
{"Grenadines", "Saint Vincent and the Grenadines: Grenadines"},
{"HKG", "Hong Kong"},
{"HMD", "Heard Island and McDonald Islands"},
{"HND", "Honduras"},
{"HRV", "Croatia"},
{"HTI", "Haiti"},
{"HUN", "Hungary"},
{"Hawaii", "USA: Hawaii"},
{"Heard Island", "Heard Island and McDonald Islands: Heard Island"},
{"Heard Island & McDonald Islands", "Heard Island and McDonald Islands"},
{"IDN", "Indonesia"},
{"IMN", "Isle of Man"},
{"IND", "India"},
{"IOT", "British Indian Ocean Territory"},
{"IRL", "Ireland"},
{"IRN", "Iran"},
{"IRQ", "Iraq"},
{"ISL", "Iceland"},
{"ISR", "Israel"},
{"ITA", "Italy"},
{"Ile Amsterdam", "French Southern and Antarctic Lands: Ile Amsterdam"},
{"Ile Saint-Paul", "French Southern and Antarctic Lands: Ile Saint-Paul"},
{"Iles Crozet", "French Southern and Antarctic Lands: Iles Crozet"},
{"Iles Kerguelen", "French Southern and Antarctic Lands: Iles Kerguelen"},
{"Ivory Coast", "Cote d'Ivoire"},
{"JAM", "Jamaica"},
{"JEY", "Jersey"},
{"JOR", "Jordan"},
{"JPN", "Japan"},
{"Juan de Nova Island", "French Southern and Antarctic Lands: Juan de Nova Island"},
{"KAZ", "Kazakhstan"},
{"KEN", "Kenya"},
{"KGZ", "Kyrgyzstan"},
{"KHM", "Cambodia"},
{"KIR", "Kiribati"},
{"KNA", "Saint Kitts and Nevis"},
{"KOR", "South Korea"},
{"KWT", "Kuwait"},
{"LAO", "Lao People's Democratic Republic"},
{"LBN", "Lebanon"},
{"LBR", "Liberia"},
{"LBY", "Libyan Arab Jamahiriya"},
{"LCA", "Saint Lucia"},
{"LIE", "Liechtenstein"},
{"LKA", "Sri Lanka"},
{"LSO", "Lesotho"},
{"LTU", "Lithuania"},
{"LUX", "Luxembourg"},
{"LVA", "Latvia"},
{"La Gomera", "Spain: La Gomera"},
{"La Graciosa", "Spain: La Graciosa"},
{"La Palma", "Spain: La Palma"},
{"La Reunion Island", "Reunion"},
{"Lanzarote", "Spain: Lanzarote"},
{"Luxemburg", "Luxembourg"},
{"MAC", "Macao"},
{"MAF", "Saint Martin (French part)"},
{"MAR", "Morocco"},
{"MCO", "Monaco"},
{"MDA", "Moldova"},
{"MDG", "Madagascar"},
{"MDV", "Maldives"},
{"MEX", "Mexico"},
{"MHL", "Marshall Islands"},
{"MKD", "Macedonia"},
{"MLI", "Mali"},
{"MLT", "Malta"},
{"MMR", "Myanmar"},
{"MNE", "Montenegro"},
{"MNG", "Mongolia"},
{"MNP", "Northern Mariana Islands"},
{"MOZ", "Mozambique"},
{"MRT", "Mauritania"},
{"MSR", "Montserrat"},
{"MTQ", "Martinique"},
{"MUS", "Mauritius"},
{"MWI", "Malawi"},
{"MYS", "Malaysia"},
{"MYT", "Mayotte"},
{"Madeira", "Portugal: Madeira"},
{"McDonald Island", "Heard Island and McDonald Islands: McDonald Island"},
{"McDonald Islands", "Heard Island and McDonald Islands: McDonald Islands"},
{"Miquelon", "Saint Pierre and Miquelon: Miquelon"},
{"NAM", "Namibia"},
{"NCL", "New Caledonia"},
{"NER", "Niger"},
{"NFK", "Norfolk Island"},
{"NGA", "Nigeria"},
{"NIC", "Nicaragua"},
{"NIU", "Niue"},
{"NLD", "Netherlands"},
{"NOR", "Norway"},
{"NPL", "Nepal"},
{"NRU", "Nauru"},
{"NZL", "New Zealand"},
{"Netherland", "Netherlands"},
{"Nevis", "Saint Kitts and Nevis: Nevis"},
{"New Guinea", "Papua New Guinea"},
{"OMN", "Oman"},
{"P, R, China", "China"},
{"P.R. China", "China"},
{"P.R.China", "China"},
{"PAK", "Pakistan"},
{"PAN", "Panama"},
{"PCN", "Pitcairn"},
{"PER", "Peru"},
{"PHL", "Philippines"},
{"PLW", "Palau"},
{"PNG", "Papua New Guinea"},
{"POL", "Poland"},
{"PRI", "Puerto Rico"},
{"PRK", "North Korea"},
{"PRT", "Portugal"},
{"PRY", "Paraguay"},
{"PSE", "Palestinian Territory"},
{"PYF", "French Polynesia"},
{"People's Republic of China", "China"},
{"Pr China", "China"},
{"Prchina", "China"},
{"Principe", "Sao Tome and Principe: Principe"},
{"QAT", "Qatar"},
{"REU", "Reunion"},
{"ROU", "Romania"},
{"RUS", "Russia"},
{"RWA", "Rwanda"},
{"SAU", "Saudi Arabia"},
{"SDN", "Sudan"},
{"SEN", "Senegal"},
{"SGP", "Singapore"},
{"SGS", "South Georgia and the South Sandwich Islands"},
{"SHN", "Saint Helena"},
{"SJM", "Svalbard and Jan Mayen"},
{"SLB", "Solomon Islands"},
{"SLE", "Sierra Leone"},
{"SLV", "El Salvador"},
{"SMR", "San Marino"},
{"SOM", "Somalia"},
{"SPM", "Saint Pierre and Miquelon"},
{"SRB", "Serbia"},
{"SSD", "South Sudan"},
{"STP", "Sao Tome and Principe"},
{"SUR", "Suriname"},
{"SVK", "Slovakia"},
{"SVN", "Slovenia"},
{"SWE", "Sweden"},
{"SWZ", "Swaziland"},
{"SXM", "Sint Maarten (Dutch part)"},
{"SYC", "Seychelles"},
{"SYR", "Syrian Arab Republic"},
{"Saint Kitts", "Saint Kitts and Nevis: Saint Kitts"},
{"Saint Kitts & Nevis", "Saint Kitts and Nevis"},
{"Saint Pierre", "Saint Pierre and Miquelon: Saint Pierre"},
{"Saint Pierre & Miquelon", "Saint Pierre and Miquelon"},
{"Saint Vincent", "Saint Vincent and the Grenadines: Saint Vincent"},
{"Saint Vincent & Grenadines", "Saint Vincent and the Grenadines"},
{"Saint Vincent & the Grenadines", "Saint Vincent and the Grenadines"},
{"Saint Vincent and Grenadines", "Saint Vincent and the Grenadines"},
{"San Tome and Principe Island", "Sao Tome and Principe"},
{"Sao Tome", "Sao Tome and Principe: Sao Tome"},
{"Sao Tome & Principe", "Sao Tome and Principe"},
{"Scotland", "United Kingdom: Scotland"},
{"South Georgia & South Sandwich Islands", "South Georgia and the South Sandwich Islands"},
{"South Georgia & the South Sandwich Islands", "South Georgia and the South Sandwich Islands"},
{"South Sandwich Islands", "South Georgia and the South Sandwich Islands: South Sandwich Islands"},
{"St Helena", "Saint Helena"},
{"St Kitts", "Saint Kitts and Nevis: Saint Kitts"},
{"St Lucia", "Saint Lucia"},
{"St Pierre", "Saint Pierre and Miquelon: Saint Pierre"},
{"St Pierre and Miquelon", "Saint Pierre and Miquelon"},
{"St Thomas", "USA: Saint Thomas"},
{"St Vincent", "Saint Vincent and the Grenadines: Saint Vincent"},
{"St Vincent and the Grenadines", "Saint Vincent and the Grenadines"},
{"St. Helena", "Saint Helena"},
{"St. Kitts", "Saint Kitts and Nevis: Saint Kitts"},
{"St. Lucia", "Saint Lucia"},
{"St. Pierre", "Saint Pierre and Miquelon: Saint Pierre"},
{"St. Pierre and Miquelon", "Saint Pierre and Miquelon"},
{"St. Thomas", "USA: Saint Thomas"},
{"St. Vincent", "Saint Vincent and the Grenadines: Saint Vincent"},
{"St. Vincent and the Grenadines", "Saint Vincent and the Grenadines"},
{"TCA", "Turks and Caicos Islands"},
{"TCD", "Chad"},
{"TGO", "Togo"},
{"THA", "Thailand"},
{"TJK", "Tajikistan"},
{"TKL", "Tokelau"},
{"TKM", "Turkmenistan"},
{"TLS", "Timor-Leste"},
{"TON", "Tonga"},
{"TTO", "Trinidad and Tobago"},
{"TUN", "Tunisia"},
{"TUR", "Turkey"},
{"TUV", "Tuvalu"},
{"TWN", "Taiwan"},
{"TZA", "Tanzania"},
{"Tenerife", "Spain: Tenerife"},
{"The Netherlands", "Netherlands"},
{"Tobago", "Trinidad and Tobago: Tobago"},
{"Trinidad", "Trinidad and Tobago: Trinidad"},
{"Trinidad & Tobago", "Trinidad and Tobago"},
{"Tromelin Island", "French Southern and Antarctic Lands: Tromelin Island"},
{"Turks & Caicos", "Turks and Caicos Islands"},
{"Turks & Caicos Islands", "Turks and Caicos Islands"},
{"Turks Islands", "Turks and Caicos Islands: Turks Islands"},
{"Turks and Caicos", "Turks and Caicos Islands"},
{"U.S.A.", "USA"},
{"UGA", "Uganda"},
{"UK", "United Kingdom"},
{"UKR", "Ukraine"},
{"UMI", "United States Minor Outlying Islands"},
{"URY", "Uruguay"},
{"UZB", "Uzbekistan"},
{"United States", "USA"},
{"United States of America", "USA"},
{"VAT", "Holy See (Vatican City State)"},
{"VCT", "Saint Vincent and the Grenadines"},
{"VEN", "Venezuela"},
{"VGB", "British Virgin Islands"},
{"VIR", "Virgin Islands"},
{"VNM", "Viet Nam"},
{"VUT", "Vanuatu"},
{"Vietnam", "Viet Nam"},
{"WLF", "Wallis and Futuna"},
{"WSM", "Samoa"},
{"Wales", "United Kingdom: Wales"},
{"West Germany", "Germany: West Germany"},
{"YEM", "Yemen"},
{"ZAF", "South Africa"},
{"ZMB", "Zambia"},
{"ZWE", "Zimbabwe"},
{"the Netherlands", "Netherlands"}
};

DEFINE_STATIC_ARRAY_MAP(TCStringPairsMap,k_country_name_fixes, s_map_country_name_fixes);

string CCountries::CapitalizeFirstLetterOfEveryWord (const string &phrase)
{
    vector<string> words;
    NStr::Tokenize(phrase," \t\r\n",words);
    for(vector<string>::iterator word = words.begin(); word != words.end(); ++word)
        if (!word->empty() && isalpha(word->at(0)))
            word->at(0) = toupper(word->at(0));
    return NStr::Join(words," ");
}

string CCountries::WholeCountryFix(string country)
{
    string new_country;
    TCStringPairsMap::const_iterator found = k_whole_country_fixes.find(NStr::ToLower(country).c_str());
    if (found != k_whole_country_fixes.end())
        new_country = found->second;
    return new_country;
}

bool CCountries::IsSubstringOfStringInList(const string& phrase, const string& country1, size_t pos1)
{
    bool r = false;
    ITERATE ( TCStrSet, c, s_CountriesSet ) 
    {
        string country2(*c);
        if (country2.length() > country1.length() && NStr::FindNoCase(country2,country1) != NPOS)
        {
            SIZE_TYPE pos2 = NStr::FindNoCase(phrase,country2);
            while (pos2 != NPOS)
            { 
                if (pos2 <= pos1 && pos2+country2.length() >= pos1+country1.length())
                    r = true;
                pos2 = NStr::FindNoCase(phrase,country2,pos2+country2.length());
            }
        }
    }
    return r;
}

bool CCountries::ContainsMultipleCountryNames (const string &phrase)
{
    int num_matches = 0;
    ITERATE ( TCStrSet, c, s_CountriesSet ) 
    {
        string country(*c);
        size_t pos = NStr::FindNoCase(phrase,country);
        while (pos != string::npos)
        {
            if (!((pos+country.length()<phrase.length() && isalpha(phrase[pos+country.length()]))
                  || (pos > 0 && isalpha(phrase[pos-1]))
                  || IsSubstringOfStringInList(phrase,country,pos)))
                num_matches++;
            pos = NStr::FindNoCase(phrase,country,pos+country.length());
        }

    }
    return (num_matches > 1);
}

string CCountries::GetCorrectedCountryCapitalization(const string& country)
{
    string output = country;
    ITERATE ( TCStrSet, it, s_CountriesSet ) {
        if ( NStr::EqualNocase(country, *it) ) {
            output = *it;
        }
    }
    return output;
}


void CCountries::x_RemoveDelimitersFromEnds(string& val, bool except_paren)
{
    NStr::TruncateSpacesInPlace(val);
    bool any_found = true;
    while (!val.empty() && any_found) {
        any_found = false;
        if (NStr::StartsWith(val, ",") 
            || NStr::StartsWith(val, ":") 
            || NStr::StartsWith(val, ".")
            || (!except_paren && NStr::StartsWith(val, ")"))) {
            val = val.substr(1);
            any_found = true;
            NStr::TruncateSpacesInPlace(val);
        } else if (NStr::EndsWith(val, ",") 
            || NStr::EndsWith(val, ":")
            || (!except_paren && NStr::EndsWith(val, "("))) {
            val = val.substr(0, val.length() - 1);
            any_found = true;
            NStr::TruncateSpacesInPlace(val);
        } else if (NStr::EndsWith(val, "the") && val.length() > 3 && !isalpha(val.c_str()[val.length() - 4])) {
            val = val.substr(0, val.length() - 4);
            any_found = true;
        } else if (NStr::EndsWith(val, ".")) {
            size_t len = val.length();
            if (len > 1 && isspace(val.c_str()[len - 2])) {
                val = val.substr(0, val.length() - 1);
                any_found = true;
                NStr::TruncateSpacesInPlace(val);
            } else if (len > 5) {
                // make sure no spaces or punctuation within 4 characters before '.'
                bool do_remove = true;
                size_t pos = val.length() - 2;
                size_t dist = 0;
                while (dist < 4 && do_remove) {
                    if (isspace(val.c_str()[pos]) || ispunct(val.c_str()[pos])) {
                        do_remove = false;
                    }
                    pos--;
                    dist++;
                }
                if (do_remove) {
                    val = val.substr(0, val.length() - 1);
                    any_found = true;
                }
            }
        }           
    }
}


vector<string> CCountries::x_Tokenize(const string& val)
{
    vector<string> tokens;
    NStr::Tokenize(val,",:()",tokens);
    // special tokenizing - if tokens contain periods but resulting token is at least four characters long
    vector<string>::iterator it = tokens.begin();
    while (it != tokens.end()) {
        size_t pos = NStr::Find(*it, ".");
        if (pos != string::npos && pos > 3 && (*it).length() - pos > 4) {
            string first = (*it).substr(0, pos);
            string remainder = (*it).substr(pos + 1);
            size_t space_pos = NStr::Find(first, " ");
            size_t len_to_space = first.length();
            while (space_pos != string::npos) {
                first = first.substr(space_pos + 1);
                len_to_space = first.length();
                space_pos = NStr::Find(first, " ");
            }
            if (len_to_space > 4) {
                (*it) = (*it).substr(0, pos);
                it = tokens.insert(it, remainder);
            } else {
                it++;
            }
        } else {
            it++;
        }
    }
    return tokens;
}


bool s_ContainsWholeWord(const string& test, const string& word, NStr::ECase case_sense)
{
    size_t pos = NStr::Find(test, word, 0, string::npos, NStr::eFirst, case_sense);
    while (pos != string::npos) {
        if ((pos == 0 || !isalpha(test.c_str()[pos - 1]))
            && !isalpha(test.c_str()[pos + word.length()])) {
            return true;
        }
        pos = NStr::Find(test, word, pos + 1, string::npos, NStr::eFirst, case_sense);
    }

    return false;
}


bool s_SuppressCountryFix(const string& test)
{
    if (s_ContainsWholeWord(test, "Sea", NStr::eNocase)) {
        return true;
    } else if (s_ContainsWholeWord(test, "USSR", NStr::eNocase)) {
        return true;
    }
    return false;
}


string CCountries::NewFixCountry (const string& test)
{
    // change requested for JIRA:SQD-1410
    if (s_SuppressCountryFix(test)) {
        if (IsValid(test)) {
            return test;
        } else {
            return "";
        }
    }


    string input = test;
    if (NStr::StartsWith(input, "\"") && NStr::EndsWith(input, "\"")) {
        input = input.substr(1, input.length() - 2);
    }
    NStr::TruncateSpacesInPlace(input);

    if (NStr::EndsWith(input, ":")) {
        input = input.substr(0, input.length() - 1);
        NStr::TruncateSpacesInPlace(input);
    }

    if (IsValid(input)) {
        return input;
    }
    string new_country = WholeCountryFix(input);
    if (!new_country.empty())
        return new_country;
    
    bool too_many_countries = false;
    bool bad_cap = false;
    vector<string> countries = x_Tokenize(input);
    string valid_country;
    string orig_valid_country;
    for(vector<string>::iterator country = countries.begin(); country != countries.end(); ++country)
    {        
        if (!country->empty() && !too_many_countries)
        {
            string check = *country;
            NStr::TruncateSpacesInPlace(check);
            x_RemoveDelimitersFromEnds(check);

            bool check_has_bad_cap = false;
            if (IsValid(check,check_has_bad_cap))
            {
                if (valid_country.empty())
                {
                    valid_country = check;
                    orig_valid_country = check;
                    bad_cap = check_has_bad_cap;
                }
                else
                {
                    too_many_countries = true;
                }
            }
            else // see if this is a fixable country
            {
                TCStringPairsMap::const_iterator found = k_country_name_fixes.find(check.c_str());
                if (found != k_country_name_fixes.end())
                {
                    if (valid_country.empty())
                    {
                        valid_country = found->second;
                        orig_valid_country = check;
                    }
                    else
                    {
                        too_many_countries = true;
                    }
                }
            }
        }
    }

    if (!valid_country.empty() && !too_many_countries) 
        too_many_countries = ContainsMultipleCountryNames (input);
  
    if (!valid_country.empty() && too_many_countries && valid_country == input) 
    {
        string str1,str2;
        NStr::SplitInTwo(valid_country,":",str1,str2);
        if (!str1.empty() && !str2.empty() && !NStr::StartsWith(str2," "))
            new_country = str1+": "+str2;
    }   
    else if(!valid_country.empty() && !too_many_countries)
    {
        // find valid_country in input
        size_t pos = NStr::Find(input,orig_valid_country);
        // save preceeding string without trailing spaces or delimiters ":,"
        string before = input.substr(0,pos);
        
        x_RemoveDelimitersFromEnds(before);
        NStr::TruncateSpacesInPlace(before);
        // save trailing string without initial spaces or delimiters
        string after = input.substr(pos+orig_valid_country.length());
        x_RemoveDelimitersFromEnds(after, true);
        NStr::TruncateSpacesInPlace(after);
        if (bad_cap) new_country = GetCorrectedCountryCapitalization(valid_country);
        else new_country = valid_country;
        if (!before.empty() || !after.empty())
            new_country += ": ";
        if (!before.empty())
            new_country += before;
        if (!before.empty() && !after.empty() && !NStr::Equal(after, ")"))
            new_country += ", ";
        if (!after.empty())
            new_country += after;
    }
    return new_country;
}

string CCountries::CountryFixupItem(const string &input, bool capitalize_after_colon)
{
    string country = NewFixCountry (input);
    string new_country = country;
    SIZE_TYPE country_end_pos = NStr::Find(country,":");
    if (country_end_pos != NPOS)
    {
        SIZE_TYPE pos = country_end_pos;
        while (country.c_str()[pos] == ',' || country.c_str()[pos] == ':' 
               || isspace(country.c_str()[pos])) 
        {
            pos++;
        }
        string after = country.substr(pos);
        if (after.empty()) {
            if (pos > country_end_pos) {
                new_country = country.substr(0, country_end_pos);
            }
        } else {
            NStr::TruncateSpacesInPlace(after,NStr::eTrunc_Begin);
            if (capitalize_after_colon) 
                after = CapitalizeFirstLetterOfEveryWord (after);
            new_country = country.substr(0,country_end_pos);
            new_country += ": " + after;
        }
    }
    return new_country;
}
      

const char * sm_KnownDevStageWords[] = {
  "adult",
  "egg",
  "juvenile",
  "larva",
};


string CSubSource::FixDevStageCapitalization(const string& value)
{
    string fix = value;

    size_t max = sizeof(sm_KnownDevStageWords) / sizeof(const char*);
    for (size_t i = 0; i < max; i++) {
        if (NStr::EqualNocase(fix, sm_KnownDevStageWords[i])) {
            fix = sm_KnownDevStageWords[i];
            break;
        }
    }
    return fix;
}


const char * sm_CellTypeWords[] = {
  "hemocyte",
  "hepatocyte",
  "lymphocyte",
  "neuroblast",
};


string CSubSource::FixCellTypeCapitalization(const string& value)
{
    string fix = value;

    size_t max = sizeof(sm_CellTypeWords) / sizeof(const char*);
    for (size_t i = 0; i < max; i++) {
        if (NStr::EqualNocase(fix, sm_CellTypeWords[i])) {
            fix = sm_CellTypeWords[i];
            break;
        }
    }
    return fix;
}


const char * sm_KnownIsolationAndTissueTypeWords[] = {
  "abdomen",
  "abdominal fluid",
  "acne",
  "activated sludge",
  "adductor muscle",
  "agricultural soil",
  "air",
  "amniotic fluid",
  "antenna",
  "aspirate",
  "bile",
  "biofilm",
  "blood",
  "blood cells",
  "blood sample",
  "body fluid",
  "bone",
  "bovine feces",
  "bovine milk",
  "brain",
  "brain abscess",
  "brain tissue",
  "branch",
  "bronchial mucosa",
  "bronchoalveolar lavage",
  "buccal epithelial cells",
  "buccal mucosa",
  "buccal swab",
  "bursa",
  "callus",
  "cave sediment",
  "cave sediments",
  "cerebellum",
  "cerebrospinal fluid",
  "cervix",
  "cheese",
  "clinical",
  "clinical isolate",
  "clinical isolates",
  "clinical sample",
  "clinical samples",
  "cloaca",
  "cloacal swab",
  "compost",
  "coral reef",
  "corn rhizosphere",
  "cornea",
  "cotton rhizosphere",
  "dairy cow rumen",
  "distillery",
  "drinking water",
  "ear",
  "egg",
  "embryogenic callus",
  "epithelium",
  "esophageal mucosa",
  "estuarine water",
  "estuarine waters",
  "eye",
  "fecal",
  "fecal sample",
  "fecal samples",
  "feces",
  "fermented food",
  "fermented soybeans",
  "fetal brain",
  "fin",
  "fin wound",
  "fish eggs",
  "flooded rice soil",
  "flower",
  "food",
  "food product",
  "food sample",
  "food samples",
  "forest",
  "forest soil",
  "freshwater stream",
  "fruit",
  "fruitbody",
  "fruiting body",
  "gastric mucosa",
  "gastrointestinal tract",
  "genital cells",
  "genitals",
  "gill",
  "gills",
  "goat milk",
  "head",
  "head kidney",
  "heart",
  "heart blood",
  "hemocyte",
  "hepatocyte",
  "hepatopancreas",
  "horse",
  "horse",
  "hot spring",
  "hot springs",
  "human plasma",
  "human skin",
  "infected leaf",
  "inflorescence",
  "intestinal mucosa",
  "intestine",
  "intestines",
  "kidney",
  "kimchi",
  "lake",
  "lake sediment",
  "lake soil",
  "lake water",
  "leaf",
  "leaves",
  "lentil",
  "liver",
  "liver abscess",
  "lung",
  "lymph node",
  "lymphocyte",
  "maize",
  "mammary gland",
  "mangrove sediment",
  "mangrove sediments",
  "manure",
  "marine environment",
  "marine sediment",
  "marine sediments",
  "marine water",
  "mature leaf",
  "meat",
  "midgut",
  "milk",
  "mitral valve",
  "mouth wound",
  "mucosa",
  "mucus",
  "muscle",
  "muscle tissue",
  "mycelium",
  "nasal mucosa",
  "nasal sample",
  "nasal samples",
  "nasal swab",
  "nasopharyngeal aspirate",
  "nasopharyngeal swab",
  "nasopharynx",
  "nest",
  "neuroblast",
  "nodule",
  "nodules",
  "nose swab",
  "olfactory mucosa",
  "oral fluid",
  "oral lexion",
  "oral mucosa",
  "ovary",
  "oviduct",
  "paddy soil",
  "parietal cortex",
  "patient",
  "pericardial",
  "pharnyx",
  "placenta",
  "plasma",
  "pleopod",
  "pleopods",
  "pleura",
  "pod",
  "purulent fluid",
  "respiratory tract",
  "rhizosphere",
  "rhizosphere soil",
  "rice rhizosphere",
  "rice soil",
  "river sediment",
  "river sediments",
  "river water",
  "root",
  "root nodule",
  "root nodules",
  "root tip",
  "root tips",
  "roots",
  "rumen",
  "saliva",
  "salivary gland",
  "saltern soil",
  "seafood",
  "seawater",
  "sediment",
  "sediments",
  "seedling",
  "seedling roots",
  "sera",
  "serum",
  "sesame seeds",
  "shrimp pond",
  "skeletal muscle",
  "skin",
  "skin lesion",
  "sludge",
  "soil",
  "spindle leaf",
  "spleen",
  "sputum",
  "stem",
  "stem base",
  "stems",
  "stomach",
  "stool",
  "stool sample",
  "stool samples",
  "strawberry",
  "swab",
  "swamp soil",
  "tail",
  "tentacle",
  "testes",
  "testis",
  "textile wastewater",
  "throat",
  "throat swab",
  "throat wash",
  "thymus",
  "trachea",
  "tracheal aspirate",
  "tracheal swab",
  "turfgrass",
  "urine",
  "uterine mucosa",
  "wastewater",
  "water",
  "white clover",
  "whole blood",
  "whole cell/tissue lysate",
  "wound",
  "yogurt",
};

     
const char * sm_KnownIsolationSourceWords[] = {
  "adductor muscle",
  "aquaculture water",
  "bile",
  "bitumen",
  "bone marrow",
  "brain biopsy",
  "buffy coat",
  "cabbage leaves",
  "catfish",
  "Channel catfish",
  "compost soil",
  "crown",
  "curd sample",
  "dairy farm soil",
  "farm soil",
  "field soil",
  "fish intestine",
  "freshwater",
  "fruit body",
  "groundwater",
  "hepatic bile duct",
  "hepatic biliary duct",
  "hot marine salterns",
  "human skin",
  "lake isolate",
  "lake mud",
  "mangrove soil",
  "midgut",
  "pond sediment",
  "pond water",
  "poultry farm soil",
  "river sand",
  "saline lake",
  "sewage sludge",
  "soda lake",
  "soil rhizosphere",
  "soil sample",
  "solar saltern",
  "solar salterns",
  "sulphur spring",
  "surface water",
  "tannery waste",
  "tannery waste effluent",
  "tissue biopsy",
  "twig",
  "underground water",
  "vegetable",
  "vegetables",
};


string CSubSource::FixIsolationSourceCapitalization(const string& value)
{
    string fix = value;

    size_t max = sizeof(sm_KnownIsolationSourceWords) / sizeof(const char*);
    for (size_t i = 0; i < max; i++) {
        if (NStr::EqualNocase(fix, sm_KnownIsolationSourceWords[i])) {
            fix = sm_KnownIsolationSourceWords[i];
            break;
        }
    }

    max = sizeof(sm_KnownIsolationAndTissueTypeWords) / sizeof(const char*);
    for (size_t i = 0; i < max; i++) {
        if (NStr::EqualNocase(fix, sm_KnownIsolationAndTissueTypeWords[i])) {
            fix = sm_KnownIsolationAndTissueTypeWords[i];
            break;
        }
    }

    max = sizeof(sm_ValidSexQualifierTokens) / sizeof(const char*);
    for (size_t i = 0; i < max; i++) {
        if (NStr::EqualNocase(fix, sm_ValidSexQualifierTokens[i])) {
            fix = sm_ValidSexQualifierTokens[i];
            break;
        }
    }

    fix = COrgMod::FixHostCapitalization(fix);
    fix = FixDevStageCapitalization(fix);
    fix = FixCellTypeCapitalization(fix);

    return fix;
}


string CSubSource::FixTissueTypeCapitalization(const string& value)
{
    string fix = value;

    size_t max = sizeof(sm_KnownIsolationAndTissueTypeWords) / sizeof(const char*);
    for (size_t i = 0; i < max; i++) {
        if (NStr::EqualNocase(fix, sm_KnownIsolationAndTissueTypeWords[i])) {
            fix = sm_KnownIsolationAndTissueTypeWords[i];
            break;
        }
    }

    max = sizeof(sm_ValidSexQualifierTokens) / sizeof(const char*);
    for (size_t i = 0; i < max; i++) {
        if (NStr::EqualNocase(fix, sm_ValidSexQualifierTokens[i])) {
            fix = sm_ValidSexQualifierTokens[i];
            break;
        }
    }

    fix = COrgMod::FixHostCapitalization(fix);
    fix = FixDevStageCapitalization(fix);
    fix = FixCellTypeCapitalization(fix);

    return fix;
}


string CSubSource::FixLabHostCapitalization(const string& value)
{
    return COrgMod::FixHostCapitalization(value);
}


string CSubSource::FixCapitalization(TSubtype subtype, const string& value)
{
    string new_val = value;
    switch (subtype) {
        case CSubSource::eSubtype_sex:
            new_val = FixSexQualifierValue(value);
            if (NStr::IsBlank(new_val)) {
                new_val = value;
            }
            break;
        case CSubSource::eSubtype_isolation_source:
            new_val = FixIsolationSourceCapitalization(value);
            break;
        case CSubSource::eSubtype_lab_host:
            new_val = FixLabHostCapitalization(value);
            break;
        case CSubSource::eSubtype_tissue_type:
            new_val = FixTissueTypeCapitalization(value);
            break;
        case CSubSource::eSubtype_dev_stage:
            new_val = FixDevStageCapitalization(value);
            break;
        case CSubSource::eSubtype_cell_type:
            new_val = FixCellTypeCapitalization(value);
            break;
        default:
            new_val = value;
            break;
    }
    return new_val;
}


void CSubSource::FixCapitalization()
{
    if (!IsSetSubtype() || !IsSetName()) {
        return;
    }

    TSubtype subtype = GetSubtype();

    if (subtype == CSubSource::eSubtype_sex) {
        string upr = GetName();
        string lwr = upr;
        NStr::ToLower(lwr);
        if (! NStr::Equal(upr, lwr)) {
            SetName(lwr);
        }
    }

    const string& name = GetName();

    string new_val = FixCapitalization(subtype, name);

    if (!NStr::IsBlank(new_val)) {
        SetName(new_val);
    }

}


string CSubSource::AutoFix(TSubtype subtype, const string& value)
{
    string new_val = "";
    switch (subtype) {
        case CSubSource::eSubtype_country:
            new_val = CCountries::NewFixCountry(value);
            break;
        case CSubSource::eSubtype_collection_date:
            new_val = FixDateFormat(value);
            break;
        case CSubSource::eSubtype_lat_lon:
            new_val = FixLatLonFormat(value);
            break;
        case CSubSource::eSubtype_sex:
            new_val = FixSexQualifierValue(value);
            break;
        case CSubSource::eSubtype_altitude:
            new_val = FixAltitude(value);
            break;
        default:
            break;
    }
    return new_val;
}


void CSubSource::AutoFix()
{
    if (!IsSetSubtype() || !IsSetName()) {
        return;
    }

    TSubtype subtype = GetSubtype();
    string new_val = AutoFix(subtype, GetName());

    if (!NStr::IsBlank(new_val)) {
        SetName(new_val);
    } else if (subtype == CSubSource::eSubtype_sex) {
        string upr = GetName();
        string lwr = upr;
        NStr::ToLower(lwr);
        if (! NStr::Equal(upr, lwr)) {
            SetName(lwr);
        }
    }
}
   



static const char * s_RemovableCultureNotes[] = {
 "[BankIt_uncultured16S_wizard]; [universal primers]; [tgge]",
 "[BankIt_uncultured16S_wizard]; [universal primers]; [dgge]",
 "[BankIt_uncultured16S_wizard]; [universal primers]",
 "[BankIt_cultured16S_wizard]",
 "[uncultured (using universal primers)]",
 "[uncultured (using universal primers) bacterial source]",
 "[cultured bacterial source]",
 "[enrichment culture bacterial source]",
 "[mixed bacterial source (cultured and uncultured)]",
 "[uncultured]; [universal primers]",
 "[mixed bacterial source]",
 "[virus wizard]",
 "[cDNA derived from mRNA, purified viral particles]",
 "[cDNA derived from mRNA, whole cell/tissue lysate]",
 "[cDNA derived from genomic RNA, whole cell/tissue lysate]",
 "[cDNA derived from genomic RNA, purified viral particles]",
 "[universal primers]",
 "[uncultured; wizard]",
 "[uncultured; wizard; spans unknown]",
 "[cultured; wizard]",
 "[cultured; wizard; spans unknown]",
 "[intergenic wizard]",
 "[intergenic wizard; spans unknown]",
 "[Microsatellite wizard]",
 "[Microsatellite wizard; multiple repeats]",
 "[D-loop wizard]",
 "[D-loop wizard; spans unknown]",
 "[D-loop wizard; spans known]",
 NULL
};

static const char * s_ReplaceableCultureNotes[] = {
 "[BankIt_uncultured16S_wizard]; [species_specific primers]; [tgge]",
 "[BankIt_uncultured16S_wizard]; [species_specific primers]; [dgge]",
 "[BankIt_uncultured16S_wizard]; [species_specific primers]",
 "[uncultured (with species-specific primers)]",
 "[uncultured]; [amplified with species-specific primers]",
 "[uncultured (using species-specific primers) bacterial source]",
 "[amplified with species-specific primers]",
 NULL
};

void CSubSource::RemoveCultureNotes (string& value, bool is_species_level)
{
    if (NStr::IsBlank(value)) {
        return;
    }

    for (size_t i = 0; s_RemovableCultureNotes[i] != NULL; i++) {
        string to_remove = s_RemovableCultureNotes[i];
        size_t remove_len = to_remove.length();
        size_t pos = NStr::FindNoCase(value, to_remove);
        while (pos != string::npos) {
            size_t extra_len = strspn (value.c_str() + pos + remove_len, " ;");
            value = value.substr(0, pos) + value.substr(pos + remove_len + extra_len);
            pos = NStr::FindNoCase(value, to_remove);
        }
    }
    // remove leading/trailing semicolons
    while (NStr::StartsWith(value, " ") || NStr::StartsWith(value, ";")) {
        value = value.substr(1);
    }
    while (NStr::EndsWith(value, " ") || NStr::EndsWith(value, ";")) {
        value = value.substr(0, value.length() - 1);
    }

    if (is_species_level) {
        for (size_t i = 0; s_ReplaceableCultureNotes[i] != NULL; i++) {
            if (NStr::EqualNocase(value, s_ReplaceableCultureNotes[i])) {
                value = "amplified with species-specific primers";
                break;
            }
        }
    }
}


void CSubSource::RemoveCultureNotes (bool is_species_level)
{
    if (IsSetName()) {
        RemoveCultureNotes(SetName(), is_species_level);
        if (NStr::IsBlank(GetName())) {
            ResetName();
        }
    }
}


// CCountryLine
CCountryLine::CCountryLine 
(const string & country_name, double y, double min_x, double max_x, double scale)
: m_CountryName(country_name) ,
  m_Scale (scale)
{
    m_Y = x_ConvertLat(y);
    m_MinX = x_ConvertLon(min_x);
    m_MaxX = x_ConvertLon(max_x);

}


CCountryLine::~CCountryLine (void)
{
}


#define EPSILON 0.001

int CCountryLine::ConvertLat (double y, double scale) 
{

    int  val = 0;

    if (y < -90.0) {
        y = -90.0;
    }
    if (y > 90.0) {
        y = 90.0;
    }

    if (y > 0) {
        val = (int) (y * scale + EPSILON);
    } else {
        val = (int) (-(-y * scale + EPSILON));
    }

    return val;
}


int CCountryLine::x_ConvertLat (double y) 
{
    return ConvertLat(y, m_Scale);
}

int CCountryLine::ConvertLon (double x, double scale) 
{

  int  val = 0;

  if (x < -180.0) {
    x = -180.0;
  }
  if (x > 180.0) {
    x = 180.0;
  }

  if (x > 0) {
    val = (int) (x * scale + EPSILON);
  } else {
    val = (int) (-(-x * scale + EPSILON));
  }

  return val;
}


int CCountryLine::x_ConvertLon (double x) 
{
    return ConvertLon(x, m_Scale);
}


CCountryExtreme::CCountryExtreme (const string & country_name, int min_x, int min_y, int max_x, int max_y)
: m_CountryName(country_name) , m_MinX (min_x), m_MinY (min_y), m_MaxX(max_x), m_MaxY (max_y)
{
    m_Area = (1 + m_MaxY - m_MinY) * (1 + m_MaxX - m_MinX);
    size_t pos = NStr::Find(country_name, ":");
    if (pos == string::npos) {
        m_Level0 = country_name;
        m_Level1 = "";
    } else {
        m_Level0 = country_name.substr(0, pos);
        NStr::TruncateSpacesInPlace(m_Level0);
        m_Level1 = country_name.substr(pos + 1);
        NStr::TruncateSpacesInPlace(m_Level1);
    }

}


CCountryExtreme::~CCountryExtreme (void)
{

}


bool CCountryExtreme::SetMinX(int min_x) 
{ 
    if (min_x < m_MinX) { 
        m_MinX = min_x; 
        return true;
    } else { 
        return false; 
    } 
}


bool CCountryExtreme::SetMaxX(int max_x) 
{ 
    if (max_x > m_MaxX) { 
        m_MaxX = max_x; 
        return true;
    } else { 
        return false; 
    } 
}


bool CCountryExtreme::SetMinY(int min_y) 
{ 
    if (min_y < m_MinY) { 
        m_MinY = min_y; 
        return true;
    } else { 
        return false; 
    } 
}


bool CCountryExtreme::SetMaxY(int max_y) 
{ 
    if (max_y > m_MaxY) { 
        m_MaxY = max_y; 
        return true;
    } else { 
        return false; 
    } 
}


void CCountryExtreme::AddLine(const CCountryLine *line)
{
    if (line) {
        SetMinX(line->GetMinX());
        SetMaxX(line->GetMaxX());
        SetMinY(line->GetY());
        SetMaxY(line->GetY());
        m_Area += 1 + line->GetMaxX() - line->GetMinX();
    }
}


bool CCountryExtreme::DoesOverlap(const CCountryExtreme* other_block) const
{
    if (!other_block) {
        return false;
    } else if (m_MaxX >= other_block->GetMinX()
        && m_MaxX <= other_block->GetMaxX()
        && m_MaxY >= other_block->GetMinY()
        && m_MinY <= other_block->GetMaxY()) {
        return true;
    } else if (other_block->GetMaxX() >= m_MinX
        && other_block->GetMaxX() <= m_MaxX
        && other_block->GetMaxY() >= m_MinY
        && other_block->GetMinY() <= m_MaxY) {
        return true;
    } else {
        return false;
    }
}


bool CCountryExtreme::PreferTo(const CCountryExtreme* other_block, const string country, const string province, const bool prefer_new) const
{
    if (!other_block) {
        return true;
    }

    // if no preferred country, these are equal
    if (NStr::IsBlank(country)) {
        return prefer_new;
    }
    
    // if match to preferred country 
    if (NStr::EqualNocase(country, m_Level0)) {
        // if best was not preferred country, take new match
        if (!NStr::EqualNocase(country, other_block->GetLevel0())) {
            return true;
        }
        // if match to preferred province
        if (!NStr::IsBlank(province) && NStr::EqualNocase(province, m_Level1)) {
            // if best was not preferred province, take new match
            if (!NStr::EqualNocase(province, other_block->GetLevel1())) {
                return true;
            }
        }
            
        // if both match province, or neither does, or no preferred province, take smallest
        return prefer_new;
    }

    // if best matches preferred country, keep
    if (NStr::EqualNocase(country, other_block->GetLevel0())) {
        return false;
    }

    // otherwise take smallest
    return prefer_new;
}


CLatLonCountryId::CLatLonCountryId(float lat, float lon)
{
    m_Lat = lat;
    m_Lon = lon;
    m_FullGuess = "";
    m_GuessCountry = "";
    m_GuessProvince = "";
    m_GuessWater = "";
    m_ClosestFull = "";
    m_ClosestCountry = "";
    m_ClosestProvince = "";
    m_ClosestWater = "";
    m_ClaimedFull = "";
    m_LandDistance = -1;
    m_WaterDistance = -1;
    m_ClaimedDistance = -1;
}


CLatLonCountryId::TClassificationFlags CLatLonCountryId::Classify(string country, string province)
{
    CLatLonCountryId::TClassificationFlags rval = 0;

    // compare guesses or closest regions to indicated country and province
    if (!NStr::IsBlank(GetGuessCountry())) {
        // if top level countries match
        if (NStr::EqualNocase(country, GetGuessCountry())) {
            rval |= CLatLonCountryId::fCountryMatch;
            // if both are empty, still call it a match
            if (NStr::EqualNocase(province, GetGuessProvince())) {
                rval |= CLatLonCountryId::fProvinceMatch;
            }
        }
        // if they don't match, are they closest?
        if (!(rval & CLatLonCountryId::fCountryMatch)) {
            if (NStr::EqualNocase(country, GetClosestCountry())) {
                rval |= CLatLonCountryId::fCountryClosest;
                if (NStr::EqualNocase(province, GetClosestProvince())) {
                    rval |= CLatLonCountryId::fProvinceClosest;
                }
            }
        } else if (!(rval & CLatLonCountryId::fProvinceMatch) && !NStr::IsBlank(province)) {
            if (NStr::EqualNocase (province, GetClosestProvince())) {
                rval |= CLatLonCountryId::fProvinceClosest;
            }
        }
    }

    if (!NStr::IsBlank(GetGuessWater())) {
        // was the non-approved body of water correctly indicated?
        if (NStr::EqualNocase(country, GetGuessWater())) {
            rval |= CLatLonCountryId::fWaterMatch;
        } else if (NStr::EqualNocase(country, GetClosestWater())) {
            rval |= CLatLonCountryId::fWaterClosest;
        }
    }

    if (!NStr::IsBlank(GetClosestCountry()) && NStr::EqualNocase(country, GetClosestCountry())) {
        if (NStr::IsBlank(GetGuessCountry()) && NStr::IsBlank(GetGuessWater())) {
            rval |= CLatLonCountryId::fCountryMatch;
            SetGuessCountry(GetClosestCountry());
            SetFullGuess(GetClosestCountry());
            if (!NStr::IsBlank(GetClosestProvince()) && NStr::EqualNocase(province, GetClosestProvince())) {
                rval |= CLatLonCountryId::fProvinceMatch;
                SetGuessProvince(GetClosestProvince());
                SetFullGuess(GetClosestFull());
            }
        } else {
            rval |= CLatLonCountryId::fCountryClosest;
            if (!NStr::IsBlank(GetClosestProvince()) && NStr::EqualNocase(province, GetClosestProvince())) {
                rval |= CLatLonCountryId::fProvinceClosest;
            }
        }
    }
    return rval;
}


CLatLonCountryId::~CLatLonCountryId(void)
{
}


#include "lat_lon_country.inc"

static const int k_NumLatLonCountryText = sizeof (s_DefaultLatLonCountryText) / sizeof (char *);

#include "lat_lon_water.inc"

static const int k_NumLatLonWaterText = sizeof (s_DefaultLatLonWaterText) / sizeof (char *);

void CLatLonCountryMap::x_InitFromDefaultList(const char * const *list, int num)
{
      // initialize list of country lines
    m_CountryLineList.clear();
    m_Scale = 20.0;
    string current_country = "";

    for (int i = 0; i < num; i++) {
            const string& line = list[i];

        if (line.c_str()[0] == '-') {
            // skip comment
        } else if (isalpha (line.c_str()[0])) {
            current_country = line;
        } else if (isdigit (line.c_str()[0])) {
            m_Scale = NStr::StringToDouble(line);
        } else {          
            vector<string> tokens;
              NStr::Tokenize(line, "\t", tokens);
            if (tokens.size() > 3) {
                double x = NStr::StringToDouble(tokens[1]);
                for (size_t j = 2; j < tokens.size() - 1; j+=2) {
                    m_CountryLineList.push_back(new CCountryLine(current_country, x, NStr::StringToDouble(tokens[j]), NStr::StringToDouble(tokens[j + 1]), m_Scale));
                }
            }
        }
    }
}




bool CLatLonCountryMap::x_InitFromFile(const string& filename)
{
    string fname = g_FindDataFile (filename);
    if (NStr::IsBlank (fname)) {
        return false;
    }

    CRef<ILineReader> lr = ILineReader::New (fname);
    if (lr.Empty()) {
        return false;
    } else {
        m_Scale = 20.0;
        string current_country = "";

        // make sure to clear before using.  in this outer
        // scope in the interest of speed (avoid repeated 
        // construction/destruction)
        vector<SIZE_TYPE> tab_positions;

        do {
            // const string& line = *++*lr;
            CTempString line = *++*lr;
            if (line[0] == '-') {
                // skip comment
            } else if (isalpha (line[0])) {
                current_country = line;
            } else if (isdigit (line[0])) {
                m_Scale = NStr::StringToDouble(line);
            } else {          
                // NStr::Tokenize would be much simpler, but
                // it's just too slow in this case, especially
                // in debug mode.

                // for the future, if we need even more speed,
                // it should be possible to eliminate the tab_positions
                // vector and collect tab positions on the fly without
                // any heap-allocated memory

                // find position of all tabs on this line
                tab_positions.clear();
                SIZE_TYPE tab_pos = line.find('\t');
                while( tab_pos != NPOS ) {
                    tab_positions.push_back(tab_pos);
                    tab_pos = line.find('\t', tab_pos+1);
                }
                // an imaginary sentinel tab
                tab_positions.push_back(line.length());

                const char * line_start = line.data();
                if( tab_positions.size() >= 4 ) {
                    CTempString y_str( line_start + tab_positions[0]+1, tab_positions[1] - tab_positions[0] - 1 );
                    double y = NStr::StringToDouble( y_str );

                    // convert into line list
                    for (size_t j = 1; j < tab_positions.size() - 2; j+=2) {
                        const SIZE_TYPE pos1 = tab_positions[j];
                        const SIZE_TYPE pos2 = tab_positions[j+1];
                        const SIZE_TYPE pos3 = tab_positions[j+2];
                        CTempString first_num( line_start + pos1 + 1, pos2 - pos1 - 1 );
                        CTempString second_num( line_start + pos2 + 1, pos3 - pos2 - 1 );
                        m_CountryLineList.push_back(new CCountryLine(current_country, y, NStr::StringToDouble(first_num), NStr::StringToDouble(second_num), m_Scale));
                    }
                }
            }
        } while ( !lr->AtEOF() );

        return true;
    }
}

bool
CLatLonCountryMap::s_CompareTwoLinesByLatLonOnly(
    const CCountryLine* line1,
    const CCountryLine* line2)
{
    if (line1->GetY() < line2->GetY()) {
        return true;
    } else if (line1->GetY() > line2->GetY()) {
        return false;
    } else {
        if (line1->GetMinX() < line2->GetMinX()) {
            return true;
        } else {
            return false;
        }
    }
}

bool CLatLonCountryMap::
        s_CompareTwoLinesByCountry(const CCountryLine* line1,
                                    const CCountryLine* line2)
{
    int cmp = NStr::CompareNocase(line1->GetCountry(), line2->GetCountry());
    if (cmp == 0) {
        return s_CompareTwoLinesByLatLonOnly(line1, line2);
    } else if (cmp < 0) {
        return true;
    } else {
        return false;
    }
}


bool CLatLonCountryMap::
        s_CompareTwoLinesByLatLonThenCountry(const CCountryLine* line1,
                                    const CCountryLine* line2)
{
    if (line1->GetY() < line2->GetY()) {
        return true;
    } else if (line1->GetY() > line2->GetY()) {
        return false;
    } if (line1->GetMinX() < line2->GetMinX()) {
        return true;
    } else if (line1->GetMinX() > line2->GetMinX()) {
        return false;
    } else if (line1->GetMaxX() < line2->GetMaxX()) {
        return true;
    } else if (line1->GetMaxX() > line2->GetMaxX()) {
        return false;
    } else {
        int cmp = NStr::CompareNocase(line1->GetCountry(), line2->GetCountry());
        if (cmp < 0) {
            return true;
        } else {
            return false;
        }
    }
}


CLatLonCountryMap::CLatLonCountryMap (bool is_water) 
{
    // initialize list of country lines
    m_CountryLineList.clear();

    if (is_water) {
        if (!x_InitFromFile("lat_lon_water.txt")) {
            x_InitFromDefaultList(s_DefaultLatLonWaterText, k_NumLatLonWaterText);
        }
    } else {
        if (!x_InitFromFile("lat_lon_country.txt")) {
            x_InitFromDefaultList(s_DefaultLatLonCountryText, k_NumLatLonCountryText);
        }
    }

    // Instead of doing a plain sort, we take advantage of the fact that
    // there are few unique country names versus the number
    // of lines.
    typedef map<CTempString, TCountryLineList, PNocase> TCountryToLinesMap;
    // this map maps a country name (case insens) to all the lines that
    // belong to that country.
    TCountryToLinesMap countryToLinesMap;
    ITERATE(TCountryLineList, line_it, m_CountryLineList) {
        countryToLinesMap[(*line_it)->GetCountry()].push_back(*line_it);
    }

    // build new m_CountryLineList here:
    TCountryLineList new_country_line_list;
    NON_CONST_ITERATE(TCountryToLinesMap, country_lines_it, countryToLinesMap)
    {
        // sort the lines for each country by lat/lon only, since we've already
        // implicitly sorted by country in countryToLinesMap
        TCountryLineList & line_list_for_this_country =
            country_lines_it->second;
        stable_sort(
            BEGIN_COMMA_END(line_list_for_this_country),
            s_CompareTwoLinesByLatLonOnly);
        copy(BEGIN_COMMA_END(line_list_for_this_country),
             back_inserter(new_country_line_list));
    }
    // swap should be constant time
    m_CountryLineList.swap(new_country_line_list);

    // set up extremes index and copy into LatLon index
    m_CountryExtremes.clear();
    m_LatLonSortedList.clear();
      size_t i, ext = 0;

    for (i = 0; i < m_CountryLineList.size(); i++) {
        if (ext > 0 && NStr::Equal(m_CountryLineList[i]->GetCountry(), m_CountryExtremes[ext - 1]->GetCountry())) {
            m_CountryExtremes[ext - 1]->AddLine(m_CountryLineList[i]);
        } else {
            m_CountryExtremes.push_back(new CCountryExtreme(m_CountryLineList[i]->GetCountry(),
                                                m_CountryLineList[i]->GetMinX(), 
                                                m_CountryLineList[i]->GetY(),
                                                m_CountryLineList[i]->GetMaxX(),
                                                m_CountryLineList[i]->GetY()));
            ext++;
        }
        m_LatLonSortedList.push_back(m_CountryLineList[i]);
        m_CountryLineList[i]->SetBlock(m_CountryExtremes[ext - 1]);
    }
    sort (m_LatLonSortedList.begin(), m_LatLonSortedList.end(), s_CompareTwoLinesByLatLonThenCountry);

}


CLatLonCountryMap::~CLatLonCountryMap (void)
{
      size_t i;

    for (i = 0; i < m_CountryLineList.size(); i++) {
        delete (m_CountryLineList[i]);
    }
    m_CountryLineList.clear();

    for (i = 0; i < m_CountryExtremes.size(); i++) {
        delete (m_CountryExtremes[i]);
    }
    m_CountryExtremes.clear();
    // note - do not delete items in m_LatLonSortedList, they are pointing to the same objects as m_CountryLineList
    m_LatLonSortedList.clear();
}


bool CLatLonCountryMap::IsCountryInLatLon(const string& country, double lat,
                                          double lon)
{
    int x = CCountryLine::ConvertLon(lon, m_Scale);
    int y = CCountryLine::ConvertLat(lat, m_Scale);

    size_t L, R, mid;

    L = 0;
    R = m_CountryLineList.size() - 1;
    mid = 0;

    while (L < R) {
        mid = (L + R) / 2;
        int cmp = NStr::Compare(m_CountryLineList[mid]->GetCountry(), country);
        if (cmp < 0) {
            L = mid + 1;
        } else if (cmp > 0) {
            R = mid;
        } else {
            while (mid > 0 
                   && NStr::Compare(m_CountryLineList[mid - 1]->GetCountry(), country) == 0
                   && m_CountryLineList[mid - 1]->GetY() >= y) {
                mid--;
            }
            L = mid;
            R = mid;
        }
    }

    while (R < m_CountryLineList.size() 
           && NStr::EqualNocase(country, m_CountryLineList[R]->GetCountry())
           && m_CountryLineList[R]->GetY() < y) {
        R++;
    }

    while (R < m_CountryLineList.size() 
           && NStr::EqualNocase(country, m_CountryLineList[R]->GetCountry())
           && m_CountryLineList[R]->GetY() == y
           && m_CountryLineList[R]->GetMaxX() < x) {
        R++;
    }
    if (R < m_CountryLineList.size() 
           && NStr::EqualNocase(country, m_CountryLineList[R]->GetCountry())
           && m_CountryLineList[R]->GetY() == y
           && m_CountryLineList[R]->GetMinX() <= x 
           && m_CountryLineList[R]->GetMaxX() >= x) {
        return true;
    } else {
        return false;
    }    
}


const CCountryExtreme *
CLatLonCountryMap::x_FindCountryExtreme(const string& country)
{
    size_t L, R, mid;

    if (NStr::IsBlank (country)) return NULL;

    L = 0;
    R = m_CountryExtremes.size() - 1;

    while (L < R) {
        mid = (L + R) / 2;
        if (NStr::CompareNocase(m_CountryExtremes[mid]->GetCountry(), country) < 0) {
            L = mid + 1;
        } else {
            R = mid;
        }
    }
    if (!NStr::EqualNocase(m_CountryExtremes[R]->GetCountry(), country)) {
        return NULL;
    } else {
        return m_CountryExtremes[R];
    }
}


bool CLatLonCountryMap::HaveLatLonForRegion(const string& region)
{
    if (x_FindCountryExtreme(region) == NULL) {
        return false;
    } else {
        return true;
    }
}


size_t CLatLonCountryMap::x_GetLatStartIndex (int y)
{
    size_t L, R, mid;

    L = 0;
    R = m_LatLonSortedList.size() - 1;
    mid = 0;

    while (L < R) {
        mid = (L + R) / 2;
        if (m_LatLonSortedList[mid]->GetY() < y) {
            L = mid + 1;
        } else if (m_LatLonSortedList[mid]->GetY() > y) {
            R = mid;
        } else {
            while (mid > 0 && m_LatLonSortedList[mid - 1]->GetY() == y) {
                mid--;
            }
            L = mid;
            R = mid;
        }
    }
    return R;
}


const CCountryExtreme *
CLatLonCountryMap::GuessRegionForLatLon(double lat, double lon,
                                        const string& country,
                                        const string& province)
{
    int x = CCountryLine::ConvertLon(lon, m_Scale);
    int y = CCountryLine::ConvertLon(lat, m_Scale);

    size_t R = x_GetLatStartIndex(y);

    const CCountryExtreme *best = NULL;

    while (R < m_LatLonSortedList.size() && m_LatLonSortedList[R]->GetY() == y) {
            if (m_LatLonSortedList[R]->GetMinX() <= x 
            && m_LatLonSortedList[R]->GetMaxX() >= x) {
            const CCountryExtreme *other = m_LatLonSortedList[R]->GetBlock();
            if (best == NULL) {
                best = other;
            } else if (!best->PreferTo(other, country, province, (bool)(best->GetArea() <= other->GetArea()))) {
                best = other;
            }
             }
        R++;
      }
      return best;
}


//Distance on a spherical surface calculation adapted from
//http://www.linuxjournal.com/magazine/
//work-shell-calculating-distance-between-two-latitudelongitude-points

#define EARTH_RADIUS 6371.0 /* average radius of non-spherical earth in kilometers */
#define CONST_PI 3.14159265359

static double DegreesToRadians (
  double degrees
)

{
  return (degrees * (CONST_PI / 180.0));
}

static double DistanceOnGlobe (
  double latA,
  double lonA,
  double latB,
  double lonB
)

{
  double lat1, lon1, lat2, lon2;
  double dLat, dLon, a, c;

  lat1 = DegreesToRadians (latA);
  lon1 = DegreesToRadians (lonA);
  lat2 = DegreesToRadians (latB);
  lon2 = DegreesToRadians (lonB);

  dLat = lat2 - lat1;
  dLon = lon2 - lon1;

   a = sin (dLat / 2) * sin (dLat / 2) +
       cos (lat1) * cos (lat2) * sin (dLon / 2) * sin (dLon / 2);
   c = 2 * atan2 (sqrt (a), sqrt (1 - a));

  return (double) (EARTH_RADIUS * c);
}


double ErrorDistance (
  double latA,
  double lonA,
  double scale)
{
  double lat1, lon1, lat2, lon2;
  double dLat, dLon, a, c;

  lat1 = DegreesToRadians (latA);
  lon1 = DegreesToRadians (lonA);
  lat2 = DegreesToRadians (latA + (1.0 / scale));
  lon2 = DegreesToRadians (lonA + (1.0 / scale));

  dLat = lat2 - lat1;
  dLon = lon2 - lon1;

   a = sin (dLat / 2) * sin (dLat / 2) +
       cos (lat1) * cos (lat2) * sin (dLon / 2) * sin (dLon / 2);
   c = 2 * atan2 (sqrt (a), sqrt (1 - a));

  return (double) (EARTH_RADIUS * c);
  
}


const CCountryExtreme * CLatLonCountryMap::FindClosestToLatLon(double lat,
                                                               double lon,
                                                               double range,
                                                               double &distance)
{
    int x = CCountryLine::ConvertLon(lon, m_Scale);
    int y = CCountryLine::ConvertLon(lat, m_Scale);

    int maxDelta = (int) (range * m_Scale + EPSILON);
    int min_y = y - maxDelta;
    int max_y = y + maxDelta;
    int min_x = x - maxDelta;
    int max_x = x + maxDelta;

    // binary search to lowest lat
    size_t R = x_GetLatStartIndex(min_y);

    double closest = 0.0;
    CCountryExtreme *rval = NULL;

    while (R < m_LatLonSortedList.size() && m_LatLonSortedList[R]->GetY() <= max_y) {
        if (m_LatLonSortedList[R]->GetMaxX() < min_x || m_LatLonSortedList[R]->GetMinX() > max_x) {
            // out of range, don't bother calculating distance
        } else {
            double end;
            if (x < m_LatLonSortedList[R]->GetMinX()) {
                end = m_LatLonSortedList[R]->GetMinLon();
            } else if (x > m_LatLonSortedList[R]->GetMaxX()) {
                end = m_LatLonSortedList[R]->GetMaxLon();
            } else {
                end = lon;
            }
            double dist = DistanceOnGlobe (lat, lon, m_LatLonSortedList[R]->GetLat(), end);
            if (rval == NULL || closest > dist 
                || (closest == dist 
                    && (rval->GetArea() > m_LatLonSortedList[R]->GetBlock()->GetArea()
                        || (rval->GetArea() == m_LatLonSortedList[R]->GetBlock()->GetArea()
                            && NStr::IsBlank(rval->GetLevel1())
                            && !NStr::IsBlank(m_LatLonSortedList[R]->GetBlock()->GetLevel1()))))) {
                rval = m_LatLonSortedList[R]->GetBlock();
                closest = dist;
            }
        }
        R++;
    }
    distance = closest;
    return rval;
}


bool CLatLonCountryMap::IsClosestToLatLon(const string& comp_country,
                                          double lat, double lon,
                                          double range, double &distance)
{
    int x = CCountryLine::ConvertLon(lon, m_Scale);
    int y = CCountryLine::ConvertLon(lat, m_Scale);

    int maxDelta = (int) (range * m_Scale + EPSILON);
    int min_y = y - maxDelta;
    int max_y = y + maxDelta;
    int min_x = x - maxDelta;
    int max_x = x + maxDelta;

    // binary search to lowest lat
    size_t R = x_GetLatStartIndex(min_y);

    string country = "";
    double closest = 0.0;
    int smallest_area = -1;

    while (R < m_LatLonSortedList.size() && m_LatLonSortedList[R]->GetY() <= max_y) {
        if (m_LatLonSortedList[R]->GetMaxX() < min_x || m_LatLonSortedList[R]->GetMinX() > max_x) {
            // out of range, don't bother calculating distance
        } else {
            double end;
            if (x < m_LatLonSortedList[R]->GetMinX()) {
                end = m_LatLonSortedList[R]->GetMinLon();
            } else {
                end = m_LatLonSortedList[R]->GetMaxLon();
            }
            double dist = DistanceOnGlobe (lat, lon, m_LatLonSortedList[R]->GetLat(), end);
            if (NStr::IsBlank (country) || closest > dist) {
                country = m_LatLonSortedList[R]->GetCountry();
                closest = dist;
                const CCountryExtreme * ext = x_FindCountryExtreme(country);
                if (ext) {
                    smallest_area = ext->GetArea();
                }
            } else if (closest == dist) {
                // if the distances are the same, prefer the input country, otherwise prefer the smaller region
                if (NStr::Equal(country, comp_country)) {
                    // keep country we're searching for
                } else if (!NStr::Equal(m_LatLonSortedList[R]->GetCountry(), country)) {
                    const CCountryExtreme * ext = x_FindCountryExtreme(m_LatLonSortedList[R]->GetCountry());
                    if (ext 
                        && (ext->GetArea() < smallest_area 
                            || NStr::Equal(m_LatLonSortedList[R]->GetCountry(), comp_country))) {
                        country = m_LatLonSortedList[R]->GetCountry();
                        smallest_area = ext->GetArea();
                    }
                }
            }
        }
        R++;
    }
    distance = closest;
    return NStr::Equal(country, comp_country);
}


const CCountryExtreme * CLatLonCountryMap::IsNearLatLon(double lat, double lon,
                                                        double range,
                                                        double &distance,
                                                        const string& country,
                                                        const string& province)
{
    int x = CCountryLine::ConvertLon(lon, m_Scale);
    int y = CCountryLine::ConvertLat(lat, m_Scale);
    double closest = -1.0;
    int maxDelta = (int) (range * m_Scale + EPSILON);
    int min_y = y - maxDelta;
    int max_y = y + maxDelta;
    int min_x = x - maxDelta;
    int max_x = x + maxDelta;
    CCountryExtreme *ext = NULL;

    // binary search to lowest lat
    size_t R = x_GetLatStartIndex(min_y);

    while (R < m_LatLonSortedList.size() && m_LatLonSortedList[R]->GetY() <= max_y) {
        if (m_LatLonSortedList[R]->GetMaxX() < min_x || m_LatLonSortedList[R]->GetMinX() > max_x) {
            // out of range, don't bother calculating distance
        } else if (!NStr::EqualNocase(m_LatLonSortedList[R]->GetBlock()->GetLevel0(), country)) {
            // wrong country, skip
        } else if (!NStr::IsBlank(province) && !NStr::EqualNocase(m_LatLonSortedList[R]->GetBlock()->GetLevel1(), province)) {
            // wrong province, skip
        } else {
            double end;
            if (x < m_LatLonSortedList[R]->GetMinX()) {
                end = m_LatLonSortedList[R]->GetMinLon();
            } else if (x > m_LatLonSortedList[R]->GetMaxX()) {
                end = m_LatLonSortedList[R]->GetMaxLon();
            } else {
                end = lon;
            }
            double dist = DistanceOnGlobe (lat, lon, m_LatLonSortedList[R]->GetLat(), end);
            if (closest < 0.0 ||  closest > dist) { 
                closest = dist;
                ext = m_LatLonSortedList[R]->GetBlock();
            }
        }
        R++;
    }
    distance = closest;
    return ext;
}





bool CLatLonCountryMap::DoCountryBoxesOverlap(const string& country1,
                                              const string& country2)
{
    if (NStr::IsBlank (country1) || NStr::IsBlank(country2)) return false;

    const CCountryExtreme *ext1 = x_FindCountryExtreme (country1);
    if (!ext1) {
        return false;
    }
    const CCountryExtreme *ext2 = x_FindCountryExtreme (country2);
    if (!ext2) {
        return false;
    }


    return ext1->DoesOverlap(ext2);
}


int CLatLonCountryMap::AdjustAndRoundDistance (double distance, double scale)

{
  if (scale < 1.1) {
    distance += 111.19;
  } else if (scale > 19.5 && scale < 20.5) {
    distance += 5.56;
  } else if (scale > 99.5 && scale < 100.5) {
    distance += 1.11;
  }

  return (int) (distance + 0.5);
}


int CLatLonCountryMap::AdjustAndRoundDistance (double distance)

{
  return AdjustAndRoundDistance (distance, m_Scale);
}




END_objects_SCOPE // namespace ncbi::objects::

END_NCBI_SCOPE

/* Original file checksum: lines: 65, chars: 1891, CRC32: 7724f0c5 */
