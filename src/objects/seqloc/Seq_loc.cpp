/* $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author:   Author:  Cliff Clausen, Eugene Vasilchenko
 *
 * File Description:
 *   .......
 *
 * Remark:
 *   This code was originally generated by application DATATOOL
 *   using specifications from the ASN data definition file
 *   'seqloc.asn'.
 *
 * ===========================================================================
 */
#include <serial/enumvalues.hpp>
#include <objects/general/Int_fuzz.hpp>
#include <objects/seqloc/Seq_point.hpp>
#include <objects/seqloc/Seq_loc_equiv.hpp>
#include <objects/seqloc/Seq_loc.hpp>

BEGIN_NCBI_SCOPE
BEGIN_objects_SCOPE // namespace ncbi::objects::


// destructor
CSeq_loc::~CSeq_loc(void)
{
}


// returns enclosing location range
// the total range is meaningless if there are several seq-ids
// in the location
CSeq_loc::TRange CSeq_loc::GetTotalRange(void) const
{
    TRange total_range;

    switch ( Which() ) {
    case CSeq_loc::e_not_set:
    case CSeq_loc::e_Null:
    case CSeq_loc::e_Empty:
        {
            // Ignore empty locations
            break;
        }
    case CSeq_loc::e_Whole:
        {
            total_range = TRange::GetWhole();
            break;
        }
    case CSeq_loc::e_Int:
        {
            const CSeq_interval& loc = GetInt();
            total_range.Set(loc.GetFrom(), loc.GetTo());
            break;
        }
    case CSeq_loc::e_Pnt:
        {
            TSeqPos pos = GetPnt().GetPoint();
            total_range.Set(pos, pos);
            break;
        }
    case CSeq_loc::e_Packed_int:
        {
            iterate ( CPacked_seqint::Tdata, ii, GetPacked_int().Get() ) {
                const CSeq_interval& loc = **ii;
                total_range += TRange(loc.GetFrom(), loc.GetTo());
            }
            break;
        }
    case CSeq_loc::e_Packed_pnt:
        {
            iterate ( CPacked_seqpnt::TPoints, pi, GetPacked_pnt().GetPoints() ) {
                TSeqPos pos = *pi;
                total_range += TRange(pos, pos);
            }
            break;
        }
    case CSeq_loc::e_Mix:
        {
            iterate(CSeq_loc_mix::Tdata, li, GetMix().Get()) {
                total_range += (*li)->GetTotalRange();
            }
            break;
        }
    case CSeq_loc::e_Equiv:
        {
            iterate(CSeq_loc_equiv::Tdata, li, GetEquiv().Get()) {
                total_range += (*li)->GetTotalRange();
            }
            break;
        }
    case CSeq_loc::e_Bond:
        {
            const CSeq_bond& loc = GetBond();
            TSeqPos pos = loc.GetA().GetPoint();
            total_range = TRange(pos, pos);
            if ( loc.IsSetB() ) {
                pos = loc.GetB().GetPoint();
                total_range = TRange(pos, pos);
            }
            break;
        }
    case CSeq_loc::e_Feat:
    default:
        {
            throw runtime_error
                ("CSeq_loc_CI -- unsupported location type");
        }
    }

    return total_range;
}


// CSeq_loc_CI implementation
CSeq_loc_CI::CSeq_loc_CI(void)
    : m_Location(0)
{
    m_CurLoc = m_LocList.end();
}


CSeq_loc_CI::CSeq_loc_CI(const CSeq_loc& loc)
    : m_Location(&loc)
{
    x_ProcessLocation(loc);
    m_CurLoc = m_LocList.begin();
}


CSeq_loc_CI::CSeq_loc_CI(const CSeq_loc_CI& iter)
{
    *this = iter;
}


CSeq_loc_CI::~CSeq_loc_CI()
{
}


CSeq_loc_CI& CSeq_loc_CI::operator= (const CSeq_loc_CI& iter)
{
    if (this == &iter)
        return *this;
    m_LocList.clear();
    m_Location = iter.m_Location;
    iterate(TLocList, li, iter.m_LocList) {
        TLocList::iterator tmp = m_LocList.insert(m_LocList.end(), *li);
        if (iter.m_CurLoc == li)
            m_CurLoc = tmp;
    }
    return *this;
}


void CSeq_loc_CI::x_ThrowNotValid(const char* where) const
{
    string msg;
    msg += "CSeq_loc_CI::";
    msg += where;
    msg += " -- iterator is not valid";
    throw runtime_error(msg);
}

void CSeq_loc_CI::x_ProcessLocation(const CSeq_loc& loc)
{
    switch ( loc.Which() ) {
    case CSeq_loc::e_not_set:
    case CSeq_loc::e_Null:
    case CSeq_loc::e_Empty:
        {
            // Ignore empty locations
            return;
        }
    case CSeq_loc::e_Whole:
        {
            SLoc_Info info;
            info.m_Id = &loc.GetWhole();
            info.m_Range = TRange::GetWhole();
            info.m_Loc = &loc;
            m_LocList.push_back(info);
            return;
        }
    case CSeq_loc::e_Int:
        {
            SLoc_Info info;
            info.m_Id = &loc.GetInt().GetId();
            info.m_Range.Set(loc.GetInt().GetFrom(), loc.GetInt().GetTo());
            if ( loc.GetInt().IsSetStrand() )
                info.m_Strand = loc.GetInt().GetStrand();
            info.m_Loc = &loc;
            m_LocList.push_back(info);
            return;
        }
    case CSeq_loc::e_Pnt:
        {
            SLoc_Info info;
            info.m_Id = &loc.GetPnt().GetId();
            info.m_Range.Set(loc.GetPnt().GetPoint(), loc.GetPnt().GetPoint());
            if ( loc.GetPnt().IsSetStrand() )
                info.m_Strand = loc.GetPnt().GetStrand();
            info.m_Loc = &loc;
            m_LocList.push_back(info);
            return;
        }
    case CSeq_loc::e_Packed_int:
        {
            iterate ( CPacked_seqint::Tdata, ii, loc.GetPacked_int().Get() ) {
                SLoc_Info info;
                info.m_Id = &(*ii)->GetId();
                info.m_Range.Set((*ii)->GetFrom(), (*ii)->GetTo());
                if ( (*ii)->IsSetStrand() )
                    info.m_Strand = (*ii)->GetStrand();
                info.m_Loc = &loc;
                m_LocList.push_back(info);
            }
            return;
        }
    case CSeq_loc::e_Packed_pnt:
        {
            iterate ( CPacked_seqpnt::TPoints, pi, loc.GetPacked_pnt().GetPoints() ) {
                SLoc_Info info;
                info.m_Id = &loc.GetPacked_pnt().GetId();
                info.m_Range.Set(*pi, *pi);
                if ( loc.GetPacked_pnt().IsSetStrand() )
                    info.m_Strand = loc.GetPacked_pnt().GetStrand();
                info.m_Loc = &loc;
                m_LocList.push_back(info);
            }
            return;
        }
    case CSeq_loc::e_Mix:
        {
            iterate(CSeq_loc_mix::Tdata, li, loc.GetMix().Get()) {
                x_ProcessLocation(**li);
            }
            return;
        }
    case CSeq_loc::e_Equiv:
        {
            iterate(CSeq_loc_equiv::Tdata, li, loc.GetEquiv().Get()) {
                x_ProcessLocation(**li);
            }
            return;
        }
    case CSeq_loc::e_Bond:
        {
            SLoc_Info infoA;
            infoA.m_Id = &loc.GetBond().GetA().GetId();
            infoA.m_Range.Set(loc.GetBond().GetA().GetPoint(),
                              loc.GetBond().GetA().GetPoint());
            if ( loc.GetBond().GetA().IsSetStrand() )
                infoA.m_Strand = loc.GetBond().GetA().GetStrand();
            infoA.m_Loc = &loc;
            m_LocList.push_back(infoA);
            if ( loc.GetBond().IsSetB() ) {
                SLoc_Info infoB;
                infoB.m_Id = &loc.GetBond().GetB().GetId();
                infoB.m_Range.Set(loc.GetBond().GetB().GetPoint(),
                                  loc.GetBond().GetB().GetPoint());
                if ( loc.GetBond().GetB().IsSetStrand() )
                    infoB.m_Strand = loc.GetBond().GetB().GetStrand();
                infoB.m_Loc = &loc;
                m_LocList.push_back(infoB);
            }
            return;
        }
    case CSeq_loc::e_Feat:
    default:
        {
            throw runtime_error
                ("CSeq_loc_CI -- unsupported location type");
        }
    }
}


// Append a string representation of a CSeq_id to label
inline
void s_GetLabel(const CSeq_id& id, string* label)
{
    CNcbiOstrstream os;
    id.WriteAsFasta(os);
    *label += CNcbiOstrstreamToString(os);
}


// Append to label info for a CSeq_point
inline
const CSeq_id* s_GetLabel
(const CSeq_point& pnt,
 const CSeq_id*    last_id,
 string*           label)
{
    // If CSeq_id does not match last_id, then append id to label
    if ( !last_id  ||  !last_id->Match(pnt.GetId()) ) {
        s_GetLabel(pnt.GetId(), label);
        *label += ":";
    }

    // Add strand info to label
    *label += GetTypeInfo_enum_ENa_strand()
        ->FindName(pnt.GetStrand(), true);

    if (pnt.IsSetFuzz()) {
        // Append Fuzz info to label
        pnt.GetFuzz().GetLabel(label, pnt.GetPoint());
    } else {
        // Append 1 based point to label
        *label += NStr::IntToString(pnt.GetPoint()+1);
    }

    // update last_id
    last_id = &pnt.GetId();
    return last_id;
}


// Append to label info for CSeq_interval
inline
const CSeq_id* s_GetLabel
(const CSeq_interval& itval,
 const CSeq_id*       last_id,
 string*              label)
{
    if (!last_id || !last_id->Match(itval.GetId())) {
        s_GetLabel(itval.GetId(), label);
        *label += ":";
    }
    last_id = &itval.GetId();
    if (itval.IsSetStrand()) {
        *label += GetTypeInfo_enum_ENa_strand()
            ->FindName(itval.GetStrand(), true);
    }
    if (itval.GetStrand() == eNa_strand_minus ||
        itval.GetStrand() == eNa_strand_both_rev) {
        if (itval.IsSetFuzz_to()) {
            itval.GetFuzz_to().GetLabel(label, itval.GetTo(), false);
        } else {
            *label += NStr::IntToString(itval.GetTo()+1);
        }
        *label += "-";
        if (itval.IsSetFuzz_from()) {
            itval.GetFuzz_from().GetLabel(label, itval.GetFrom());
        } else {
            *label += NStr::IntToString(itval.GetFrom()+1);
        }
    } else {
        if (itval.IsSetFuzz_from()) {
            itval.GetFuzz_from().GetLabel
                (label, itval.GetFrom(), false);
        } else {
            *label += NStr::IntToString(itval.GetFrom()+1);
        }
        *label += "-";
        if (itval.IsSetFuzz_to()) {
            itval.GetFuzz_to().GetLabel(label, itval.GetTo());
        } else {
            *label += NStr::IntToString(itval.GetTo()+1);
        }
    }
    return last_id;
}


// Forward declaration
const CSeq_id* s_GetLabel
(const CSeq_loc& loc,
 const CSeq_id*  last_id,
 string*         label,
 bool            first = false);


// Appends to label info for each CSeq_loc in a list of CSeq_locs
inline
const CSeq_id* s_GetLabel
(const list<CRef<CSeq_loc> >&  loc_list,
 const CSeq_id*                last_id,
 string*                       label)
{
    bool first = true;
    iterate (list<CRef<CSeq_loc> >, it, loc_list) {

        // Append to label for each CSeq_loc in list
        last_id = s_GetLabel(**it, last_id, label, first);
        first = false;
    }

    return last_id;
}


// Builds a label based upon a CSeq_loc and all embedded CSeq_locs
const CSeq_id* s_GetLabel
(const CSeq_loc& loc,
 const CSeq_id*  last_id,
 string*         label,
 bool            first)
{
    // Ensure label is not null
    if (!label) {
        return last_id;
    }

    // Put a comma separator if necessary
    if (!first) {
        *label += ", ";
    }

    // Loop through embedded CSeq_locs and create a label, depending on
    // type of CSeq_loc
    switch (loc.Which()) {
    case CSeq_loc::e_Null:
        *label += "~";
        break;
    case CSeq_loc::e_Empty:
        *label += "{";
        s_GetLabel(loc.GetEmpty(), label);
        last_id = &loc.GetEmpty();
        *label += "}";
        break;
    case CSeq_loc::e_Whole:
        s_GetLabel(loc.GetWhole(), label);
        last_id = &loc.GetWhole();
        break;
    case CSeq_loc::e_Int:
        last_id = s_GetLabel(loc.GetInt(), last_id, label);
        break;
    case CSeq_loc::e_Packed_int:
    {
        *label += "(";
        bool first = true;
        iterate(list<CRef<CSeq_interval> >, it, loc.GetPacked_int().Get()) {
            if (!first) {
                *label += ", ";
            }
            first = false;
            last_id = s_GetLabel(**it, last_id, label);
        }
        *label += ")";
        break;
    }
    case CSeq_loc::e_Pnt:
        last_id = s_GetLabel(loc.GetPnt(), last_id, label);
        break;
    case CSeq_loc::e_Packed_pnt:
        if (!loc.GetPacked_pnt().GetPoints().empty()) {
            *label += "PackSeqPnt";
        }
        last_id = &loc.GetPacked_pnt().GetId();
        break;
    case CSeq_loc::e_Mix:
        *label += "[";
        last_id = s_GetLabel(loc.GetMix().Get(), last_id, label);
        *label += "]";
        break;
    case CSeq_loc::e_Equiv:
        *label += "[";
        last_id = s_GetLabel(loc.GetEquiv().Get(), last_id, label);
        *label += "]";
        break;
    case CSeq_loc::e_Bond:
        last_id = s_GetLabel(loc.GetBond().GetA(), last_id, label);
        *label += "=";
        if (loc.GetBond().IsSetB()) {
            last_id = s_GetLabel(loc.GetBond().GetB(), last_id, label);
        } else {
            *label += "?";
        }
        break;
    case CSeq_loc::e_Feat:
        *label += "(feat)";
        break;
    default:
        *label += "(??)";
        break;
    }
    return last_id;
}

bool CSeq_loc::IsPartialLeft (void) const

{
    switch (Which ()) {

        case CSeq_loc::e_Null :
            return true;

        case CSeq_loc::e_Int :
            return GetInt ().IsPartialLeft ();

        case CSeq_loc::e_Pnt :
            return GetPnt ().IsPartialLeft ();

        case CSeq_loc::e_Mix :
            return GetMix ().IsPartialLeft ();

        default :
            break;
    }

    return false;
}

bool CSeq_loc::IsPartialRight (void) const

{
    switch (Which ()) {

        case CSeq_loc::e_Null :
            return true;

        case CSeq_loc::e_Int :
            return GetInt ().IsPartialRight ();

        case CSeq_loc::e_Pnt :
            return GetPnt ().IsPartialRight ();

        case CSeq_loc::e_Mix :
            return GetMix ().IsPartialRight ();

        default :
            break;
    }

    return false;
}

// Appends a label suitable for display (e.g., error messages)
// label must point to an existing string object
// Method just returns if label is null
void CSeq_loc::GetLabel(string* label) const
{
    s_GetLabel(*this, 0, label, true);
}

END_objects_SCOPE // namespace ncbi::objects::
END_NCBI_SCOPE


/*
 * =============================================================================
 * $Log$
 * Revision 6.22  2003/01/22 20:17:33  vasilche
 * Optimized CSeq_loc::GetTotalRange().
 *
 * Revision 6.21  2002/12/30 19:37:02  vasilche
 * Rewrote CSeq_loc::GetTotalRange() to avoid using CSeq_loc_CI -
 * it's too expensive.
 *
 * Revision 6.20  2002/12/23 17:19:27  grichenk
 * Added GetSeq_loc() to CSeq_loc_CI
 *
 * Revision 6.19  2002/12/19 20:24:54  grichenk
 * Updated usage of CRange<>
 *
 * Revision 6.18  2002/12/06 15:36:04  grichenk
 * Added overlap type for annot-iterators
 *
 * Revision 6.17  2002/10/03 20:22:50  ucko
 * Drop duplicate default arg. spec. for s_GetLabel.
 *
 * Revision 6.16  2002/10/03 18:53:03  clausen
 * Removed extra whitespace
 *
 * Revision 6.15  2002/10/03 16:36:09  clausen
 * Added GetLabel()
 *
 * Revision 6.14  2002/09/12 21:19:02  kans
 * added IsPartialLeft and IsPartialRight
 *
 * Revision 6.13  2002/06/06 20:35:28  clausen
 * Moved methods using object manager to objects/util
 *
 * Revision 6.12  2002/05/31 13:33:02  grichenk
 * GetLength() -- return 0 for e_Null locations
 *
 * Revision 6.11  2002/05/06 03:39:12  vakatov
 * OM/OM1 renaming
 *
 * Revision 6.10  2002/05/03 21:28:18  ucko
 * Introduce T(Signed)SeqPos.
 *
 * Revision 6.9  2002/04/22 20:08:31  grichenk
 * Redesigned GetTotalRange() using CSeq_loc_CI
 *
 * Revision 6.8  2002/04/17 15:39:08  grichenk
 * Moved CSeq_loc_CI to the seq-loc library
 *
 * Revision 6.7  2002/01/16 18:56:32  grichenk
 * Removed CRef<> argument from choice variant setter, updated sources to
 * use references instead of CRef<>s
 *
 * Revision 6.6  2002/01/10 18:21:26  clausen
 * Added IsOneBioseq, GetStart, and GetId
 *
 * Revision 6.5  2001/10/22 11:40:32  clausen
 * Added Compare() implementation
 *
 * Revision 6.4  2001/01/03 18:59:09  vasilche
 * Added missing include.
 *
 * Revision 6.3  2001/01/03 16:39:05  vasilche
 * Added CAbstractObjectManager - stub for object manager.
 * CRange extracted to separate file.
 *
 * Revision 6.2  2000/12/26 17:28:55  vasilche
 * Simplified and formatted code.
 *
 * Revision 6.1  2000/11/17 21:35:10  vasilche
 * Added GetLength() method to CSeq_loc class.
 *
 *
 * ===========================================================================
*/
