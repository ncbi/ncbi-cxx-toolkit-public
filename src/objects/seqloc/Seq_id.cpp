/* $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author:  .......
 *
 * File Description:
 *   .......
 *
 * Remark:
 *   This code was originally generated by application DATATOOL
 *   using specifications from the ASN data definition file
 *   'seqloc.asn'.
 */

// standard includes

// generated includes
#include <ncbi_pch.hpp>
#include <corelib/ncbiutil.hpp>
#include <util/static_map.hpp>

#include <objects/seq/Bioseq.hpp>
#include <objects/seq/Seq_inst.hpp>

#include <objects/seqloc/Seq_id.hpp>
#include <objects/seqloc/Textseq_id.hpp>
#include <objects/seqloc/Giimport_id.hpp>
#include <objects/seqloc/Patent_seq_id.hpp>
#include <objects/seqloc/PDB_seq_id.hpp>

#include <objects/biblio/Id_pat.hpp>

#include <objects/general/Object_id.hpp>
#include <objects/general/Dbtag.hpp>
#include <objects/general/Date.hpp>
#include <objects/general/Date_std.hpp>

#include <objects/general/Date.hpp>

// generated classes

BEGIN_NCBI_SCOPE
BEGIN_objects_SCOPE // namespace ncbi::objects::


// constructor
CSeq_id::CSeq_id(void)
{
    return;
}

// destructor
CSeq_id::~CSeq_id(void)
{
    return;
}


static void s_SplitVersion(const string& acc_in, string& acc, int& ver)
{
    string verstr;
    NStr::SplitInTwo(acc_in, ".", acc, verstr);
    if (verstr.empty()) {
        ver = 0;
    } else {
        ver = NStr::StringToNumeric(verstr);
        if (ver <= 0) {
            NCBI_THROW(CSeqIdException, eFormat,
                       "Version embedded in accession " + acc_in
                       + " is not a positive integer");
        }
    }
}


const CTextseq_id* CSeq_id::GetTextseq_Id(void) const
{
    switch ( Which() ) {
    case e_Genbank:
        return &GetGenbank();
    case e_Embl:
        return &GetEmbl();
    case e_Ddbj:
        return &GetDdbj();
    case e_Pir:
        return &GetPir();
    case e_Swissprot:
        return &GetSwissprot();
    case e_Other:
        return &GetOther();
    case e_Prf:
        return &GetPrf();
    case e_Tpg:
        return &GetTpg();
    case e_Tpe:
        return &GetTpe();
    case e_Tpd:
        return &GetTpd();
    case e_Gpipe:
        return &GetGpipe();
    default:
        return 0;
    }
}


inline
void x_Assign(CObject_id& dst, const CObject_id& src)
{
    switch ( src.Which() ) {
    case CObject_id::e_not_set:
        dst.Reset();
        return;
    case CObject_id::e_Id:
        dst.SetId(src.GetId());
        return;
    case CObject_id::e_Str:
        dst.SetStr(src.GetStr());
        return;
    default:
        NCBI_THROW(CSeqIdException, eFormat, "invalid Object-id variant");
    }
}


inline
void x_Assign(CGiimport_id& dst, const CGiimport_id& src)
{
    dst.SetId(src.GetId());
    if ( src.IsSetDb() ) {
        dst.SetDb(src.GetDb());
    }
    else {
        dst.ResetDb();
    }
    if ( src.IsSetRelease() ) {
        dst.SetRelease(src.GetRelease());
    }
    else {
        dst.ResetRelease();
    }
}


inline
void x_Assign(CTextseq_id& dst, const CTextseq_id& src)
{
    if ( src.IsSetName() ) {
        dst.SetName(src.GetName());
    }
    else {
        dst.ResetName();
    }
    if ( src.IsSetAccession() ) {
        dst.SetAccession(src.GetAccession());
    }
    else {
        dst.ResetAccession();
    }
    if ( src.IsSetRelease() ) {
        dst.SetRelease(src.GetRelease());
    }
    else {
        dst.ResetRelease();
    }
    if ( src.IsSetVersion() ) {
        dst.SetVersion(src.GetVersion());
    }
    else {
        dst.ResetVersion();
    }
}


inline
void x_Assign(CDbtag& dst, const CDbtag& src)
{
    dst.SetDb(src.GetDb());
    x_Assign(dst.SetTag(), src.GetTag());
}


inline
void x_Assign(CPatent_seq_id& dst, const CPatent_seq_id& src)
{
    dst.SetSeqid(src.GetSeqid());
    dst.SetCit().Assign(src.GetCit());
}


inline
void x_Assign(CDate& dst, const CDate& src)
{
    dst.Assign(src);
}


inline
void x_Assign(CPDB_seq_id& dst, const CPDB_seq_id& src)
{
    dst.SetMol().Set(src.GetMol());
    if ( src.IsSetChain() ) {
        dst.SetChain(src.GetChain());
    }
    else {
        dst.ResetChain();
    }
    if ( src.IsSetRel() ) {
        dst.SetRel().Assign(src.GetRel());
    }
    else {
        dst.ResetRel();
    }
}


void CSeq_id::Assign(const CSerialObject& obj, ESerialRecursionMode how)
{
    if ( GetTypeInfo() == obj.GetThisTypeInfo() ) {
        const CSeq_id& id = static_cast<const CSeq_id&>(obj);
        switch ( id.Which() ) {
        case e_not_set:
            Reset();
            return;
        case e_Local:
            x_Assign(SetLocal(), id.GetLocal());
            return;
        case e_Gibbsq:
            SetGibbsq(id.GetGibbsq());
            return;
        case e_Gibbmt:
            SetGibbmt(id.GetGibbmt());
            return;
        case e_Giim:
            x_Assign(SetGiim(), id.GetGiim());
            return;
        case e_Pir:
            x_Assign(SetPir(), id.GetPir());
            return;
        case e_Swissprot:
            x_Assign(SetSwissprot(), id.GetSwissprot());
            return;
        case e_Patent:
            x_Assign(SetPatent(), id.GetPatent());
            return;
        case e_Other:
            x_Assign(SetOther(), id.GetOther());
            return;
        case e_General:
            x_Assign(SetGeneral(), id.GetGeneral());
            return;
        case e_Gi:
            SetGi(id.GetGi());
            return;
        case e_Prf:
            x_Assign(SetPrf(), id.GetPrf());
            return;
        case e_Pdb:
            x_Assign(SetPdb(), id.GetPdb());
            return;
        case e_Genbank:
            x_Assign(SetGenbank(), id.GetGenbank());
            return;
        case e_Embl:
            x_Assign(SetEmbl(), id.GetEmbl());
            return;
        case e_Ddbj:
            x_Assign(SetDdbj(), id.GetDdbj());
            return;
        case e_Tpg:
            x_Assign(SetTpg(), id.GetTpg());
            return;
        case e_Tpe:
            x_Assign(SetTpe(), id.GetTpe());
            return;
        case e_Tpd:
            x_Assign(SetTpd(), id.GetTpd());
            return;
        case e_Gpipe:
            x_Assign(SetGpipe(), id.GetGpipe());
            return;
        }
    }
    CSerialObject::Assign(obj, how);
}


// Compare() - are SeqIds equivalent?
CSeq_id::E_SIC CSeq_id::Compare(const CSeq_id& sid2) const
{
    if ( Which() != sid2.Which() ) { // Only one case where this will work
        const CTextseq_id *tsip1 = GetTextseq_Id();
        if ( !tsip1 )
            return e_DIFF;

        const CTextseq_id *tsip2 = sid2.GetTextseq_Id();
        if ( !tsip2 )
            return e_DIFF;

        if ( tsip1->Match(*tsip2) ) // id Textseq_id match
            return e_YES;
        else
            return e_NO;
    }

    switch ( Which() ) { // Now we only need to know one
    case e_Local:
        return GetLocal().Match(sid2.GetLocal()) ? e_YES : e_NO;
    case e_Gibbsq:
        return GetGibbsq() == sid2.GetGibbsq() ? e_YES : e_NO;
    case e_Gibbmt:
        return GetGibbmt() == sid2.GetGibbmt() ? e_YES : e_NO;
    case e_Giim:
        return GetGiim().GetId() == sid2.GetGiim().GetId() ? e_YES : e_NO;
    case e_Pir:
        return GetPir().Match(sid2.GetPir()) ? e_YES : e_NO;
    case e_Swissprot:
        return GetSwissprot().Match(sid2.GetSwissprot()) ? e_YES : e_NO;
    case e_Patent:
        return GetPatent().Match(sid2.GetPatent()) ? e_YES : e_NO;
    case e_Other:
        return GetOther().Match(sid2.GetOther()) ? e_YES : e_NO;
    case e_General:
        return GetGeneral().Match(sid2.GetGeneral()) ? e_YES : e_NO;
    case e_Gi:
        return GetGi() == sid2.GetGi() ? e_YES : e_NO;
    case e_Prf:
        return GetPrf().Match(sid2.GetPrf()) ? e_YES : e_NO;
    case e_Pdb:
        return GetPdb().Match(sid2.GetPdb()) ? e_YES : e_NO;
    case e_Genbank:
        return GetGenbank().Match(sid2.GetGenbank()) ? e_YES : e_NO;
    case e_Embl:
        return GetEmbl().Match(sid2.GetEmbl()) ? e_YES : e_NO;
    case e_Ddbj:
        return GetDdbj().Match(sid2.GetDdbj()) ? e_YES : e_NO;
    case e_Tpg:
        return GetTpg().Match(sid2.GetTpg()) ? e_YES : e_NO;
    case e_Tpe:
        return GetTpe().Match(sid2.GetTpe()) ? e_YES : e_NO;
    case e_Tpd:
        return GetTpd().Match(sid2.GetTpd()) ? e_YES : e_NO;
    case e_Gpipe:
        return GetGpipe().Match(sid2.GetGpipe()) ? e_YES : e_NO;
    default:
        return e_error;
    }
}


int CSeq_id::CompareOrdered(const CSeq_id& sid2) const
{
    int ret = Which() - sid2.Which();
    if ( ret != 0 ) {
        return ret;
    }
    const CTextseq_id *tsip1 = GetTextseq_Id();
    const CTextseq_id *tsip2 = sid2.GetTextseq_Id();
    if ( tsip1 && tsip2 ) {
        return tsip1->Compare(*tsip2);
    }
    switch ( Which() ) { // Now we only need to know one
    case e_Local:
        return GetLocal().Compare(sid2.GetLocal());
    case e_Gibbsq:
        return GetGibbsq() - sid2.GetGibbsq();
    case e_Gibbmt:
        return GetGibbmt() - sid2.GetGibbmt();
    case e_Giim:
        return GetGiim().GetId() - sid2.GetGiim().GetId();
    case e_Patent:
        return GetPatent().Compare(sid2.GetPatent());
    case e_General:
        return GetGeneral().Compare(sid2.GetGeneral());
    case e_Gi:
        return GetGi() - sid2.GetGi();
    case e_Pdb:
        return 0;
    default:
        return this == &sid2? 0: this < &sid2? -1: 1;
    }
}

typedef pair<const char*, CSeq_id::E_Choice> TChoiceMapEntry;
// used for binary searching; must be in order.
static const TChoiceMapEntry sc_ChoiceArray[] = {
    TChoiceMapEntry("???",          CSeq_id::e_not_set),
    TChoiceMapEntry("bbm",          CSeq_id::e_Gibbmt),
    TChoiceMapEntry("bbs",          CSeq_id::e_Gibbsq),
    TChoiceMapEntry("dbj",          CSeq_id::e_Ddbj),
    TChoiceMapEntry("ddbj",         CSeq_id::e_Ddbj),
    TChoiceMapEntry("emb",          CSeq_id::e_Embl),
    TChoiceMapEntry("embl",         CSeq_id::e_Embl),
    TChoiceMapEntry("gb",           CSeq_id::e_Genbank),
    TChoiceMapEntry("genbank",      CSeq_id::e_Genbank),
    TChoiceMapEntry("general",      CSeq_id::e_General),
    TChoiceMapEntry("gi",           CSeq_id::e_Gi),
    TChoiceMapEntry("gibbmt",       CSeq_id::e_Gibbmt),
    TChoiceMapEntry("gibbsq",       CSeq_id::e_Gibbsq),
    TChoiceMapEntry("giim",         CSeq_id::e_Giim),
    TChoiceMapEntry("gim",          CSeq_id::e_Giim),
    TChoiceMapEntry("gnl",          CSeq_id::e_General),
    TChoiceMapEntry("gpipe",        CSeq_id::e_Gpipe),
    TChoiceMapEntry("gpp",          CSeq_id::e_Gpipe),
    TChoiceMapEntry("lcl",          CSeq_id::e_Local),
    TChoiceMapEntry("local",        CSeq_id::e_Local),
    TChoiceMapEntry("not_set",      CSeq_id::e_not_set),
    TChoiceMapEntry("oth",          CSeq_id::e_Other), // deprecated vs. ref
    TChoiceMapEntry("other",        CSeq_id::e_Other),
    TChoiceMapEntry("pat",          CSeq_id::e_Patent),
    TChoiceMapEntry("patent",       CSeq_id::e_Patent),
    TChoiceMapEntry("pdb",          CSeq_id::e_Pdb),
    TChoiceMapEntry("pgp",          CSeq_id::e_Patent),
    TChoiceMapEntry("pir",          CSeq_id::e_Pir),
    TChoiceMapEntry("prf",          CSeq_id::e_Prf),
    TChoiceMapEntry("ref",          CSeq_id::e_Other),
    TChoiceMapEntry("sp",           CSeq_id::e_Swissprot),
    TChoiceMapEntry("swissprot",    CSeq_id::e_Swissprot),
    TChoiceMapEntry("tpd",          CSeq_id::e_Tpd),
    TChoiceMapEntry("tpe",          CSeq_id::e_Tpe),
    TChoiceMapEntry("tpg",          CSeq_id::e_Tpg)
};
typedef CStaticArrayMap<const char*, CSeq_id::E_Choice, PNocase_CStr> TChoiceMap;
static const TChoiceMap sc_ChoiceMap(sc_ChoiceArray, sizeof(sc_ChoiceArray));


static const char* const s_TextId[CSeq_id::e_MaxChoice+1] =
{   // FASTA_LONG formats
    "???" , // not-set = ???
    "lcl",  // local = lcl|integer or string
    "bbs",  // gibbsq = bbs|integer
    "bbm",  // gibbmt = bbm|integer
    "gim",  // giim = gim|integer
    "gb",   // genbank = gb|accession|locus
    "emb",  // embl = emb|accession|locus
    "pir",  // pir = pir|accession|name
    "sp",   // swissprot = sp|accession|name
    "pat",  // patent = pat|country|patent number (string)|seq number (integer)
            //     *OR* pgp|country|application number|seq number
    "ref",  // other = ref|accession|name|release - changed from oth to ref
    "gnl",  // general = gnl|database(string)|id (string or number)
    "gi",   // gi = gi|integer
    "dbj",  // ddbj = dbj|accession|locus
    "prf",  // prf = prf|accession|name
    "pdb",  // pdb = pdb|entry name (string)|chain id (char)
    "tpg",  // tpg = tpg|accession|name
    "tpe",  // tpe = tpe|accession|name
    "tpd",  // tpd = tpd|accession|name
    "gpp"   // gpipe = gpp|accession|name
    ""  // Placeholder for end of list
};

CSeq_id::E_Choice CSeq_id::WhichInverseSeqId(const char* SeqIdCode)
{
    TChoiceMap::const_iterator it = sc_ChoiceMap.find(SeqIdCode);
    if (it == sc_ChoiceMap.end()) {
        return e_not_set;
    } else {
        return it->second;
    }
}


static CSeq_id::EAccessionInfo s_IdentifyNAcc(const string& acc)
{
    _ASSERT(acc[0] == 'N');
    int n = NStr::StringToNumeric(acc.substr(1));
    if (n >= 20000) {
        return CSeq_id::eAcc_gb_est;
    } else { // big mess; fortunately, these are all secondary
        switch (n) {
        case 1: case 2: case 11: case 57:
            return CSeq_id::eAcc_gb_embl;

        case 3: case 4: case 6: case 7: case 10: case 14: case 15:
        case 16: case 17: case 21: case 23: case 24: case 26: case 29:
        case 30: case 31: case 32: case 33: case 34: case 36: case 38:
        case 39: case 40: case 42: case 43: case 44: case 45: case 47:
        case 49: case 50: case 51: case 55: case 56: case 59:
            return CSeq_id::eAcc_gb_ddbj;

        case 5: case 9: case 12: case 20: case 22: case 25: case 58:
            return CSeq_id::eAcc_gb_embl_ddbj;

        case 8: case 13: case 18: case 19: case 27: case 41: case 46:
        case 48: case 52: case 54: case 18624:
            return CSeq_id::eAcc_gb_other_nuc;

        case 28: case 35: case 37: case 53: case 61: case 62: case 63:
        case 65: case 66: case 67: case 68: case 69: case 78: case 79:
        case 83: case 88: case 90: case 91: case 92: case 93: case 94:
            return CSeq_id::eAcc_ddbj_other_nuc;

        case 60: case 64:
            return CSeq_id::eAcc_embl_other_nuc;

        case 70:
            return CSeq_id::eAcc_embl_ddbj;

        default: // unassigned or ambiguous
            return CSeq_id::eAcc_unknown;
        }
    }
}


// CXXnnnnn accessions are theoretically all for EMBL's own protein
// records, but third-party annotations are interspersed (albeit often
// several in a row). :-/

typedef pair<const char*, const char*> TTpeRange;
#define SingleTPE(x) TTpeRange(x, x)
static const TTpeRange sc_TpeRanges[] = {
    // Listed as (last, first) because lower_bound() rounds up(!) on misses.
    TTpeRange("CAD29879", "CAD29848"), // subsuming quite a few unassigned IDs
    SingleTPE("CAD43606"),
    SingleTPE("CAD44269"),
    SingleTPE("CAD55807"),
    SingleTPE("CAD56854"),
    SingleTPE("CAD59554"),
    TTpeRange("CAD59975", "CAD59973"),
    SingleTPE("CAD62250"),
    TTpeRange("CAD62385", "CAD62384"),
    TTpeRange("CAD65875", "CAD65874"),
    TTpeRange("CAD66057", "CAD66056"),
    SingleTPE("CAD66176"),
    TTpeRange("CAD66453", "CAD66451"),
    SingleTPE("CAD66657"),
    TTpeRange("CAD67553", "CAD67552"),
    TTpeRange("CAD67579", "CAD67575"),
    SingleTPE("CAD67582"),
    TTpeRange("CAD67593", "CAD67592"),
    SingleTPE("CAD67595"),
    TTpeRange("CAD67964", "CAD67963"),
    SingleTPE("CAD67985"),
    TTpeRange("CAD68171", "CAD68170"),
    SingleTPE("CAD71139"),
    TTpeRange("CAD80157", "CAD80155"),
    TTpeRange("CAD80169", "CAD80167"), // '68 unassigned
    SingleTPE("CAD80243"),
    TTpeRange("CAD88273", "CAD88272"),
    TTpeRange("CAD89268", "CAD89265"),
    SingleTPE("CAD89361"),
    SingleTPE("CAD89763"),
    TTpeRange("CAD89875", "CAD89874"),
    SingleTPE("CAD91637"),
    TTpeRange("CAD91911", "CAD91909"),
    SingleTPE("CAD92036"),
    SingleTPE("CAD98145"),
    TTpeRange("CAE00414", "CAE00378"),
    SingleTPE("CAE00502"),
    TTpeRange("CAE12276", "CAE12270"),
    SingleTPE("CAE18110"),
    SingleTPE("CAE30337"),
    SingleTPE("CAE30362"),
    TTpeRange("CAE30476", "CAE30475"),
    TTpeRange("CAE30502", "CAE30490"),
    SingleTPE("CAE45343"),
    SingleTPE("CAE47417"),
    TTpeRange("CAE48363", "CAE48362"),
    TTpeRange("CAE48393", "CAE48373"),
    TTpeRange("CAE48396", "CAE48395"),
    TTpeRange("CAE51417", "CAE51393"),
    SingleTPE("CAE51851"),
    TTpeRange("CAE51856", "CAE51855"),
    TTpeRange("CAE51916", "CAE51895"),
    TTpeRange("CAE52320", "CAE52317"),
    TTpeRange("CAE54352", "CAE54311"),
    SingleTPE("CAE54495"),
    TTpeRange("CAE75631", "CAE75602"),
    SingleTPE("CAE75743"),
    TTpeRange("CAE82299", "CAE82298"),
    TTpeRange("CAF06530", "CAF06526"),
    SingleTPE("CAF18402"),
    TTpeRange("CAF21739", "CAF21736"),
    SingleTPE("CAF32458"),
    SingleTPE("CAG23871"),
    TTpeRange("CAG26664", "CAG26661"),
    SingleTPE("CAG26750"),
    TTpeRange("CAG29030", "CAG29023"),
    SingleTPE("CAG29113"),
    SingleTPE("CAG30664"),
    SingleTPE("CAG33760"),
    TTpeRange("CAG34296", "CAG34288"),
    TTpeRange("CAH03727", "CAH03726"),
    TTpeRange("CAH17841", "CAH17840"),
    TTpeRange("CAH18926", "CAH18925"),
    SingleTPE("CAH56764"),
    TTpeRange("CAH59194", "CAH59193"),
    TTpeRange("CAH69380", "CAH69244"),
    SingleTPE("CAH74220"),
    SingleTPE("CAH74225"),
    TTpeRange("CAH89263", "CAH89261"),
    TTpeRange("CAI56335", "CAI56319"),
    TTpeRange("CAI61347", "CAI61342"),
    TTpeRange("CAI77245", "CAI77244"),
    SingleTPE("CAI77247"),
    TTpeRange("CAI85013", "CAI84981"),
    TTpeRange("CAI99163", "CAI99158"),
    SingleTPE("CAI99872"),
    TTpeRange("CAJ00252", "CAJ00225"),
    TTpeRange("CAJ13825", "CAJ13823"),
    TTpeRange("CAJ29302", "CAJ29301"),
    SingleTPE("CAJ30479"),
    TTpeRange("CAJ30484", "CAJ30481"),
    SingleTPE("CAJ31324"),
    SingleTPE("CAJ33891"),
    SingleTPE("CAJ55345"),
    TTpeRange("CAJ55733", "CAJ55730"),
    TTpeRange("CAJ55747", "CAJ55745"),
    TTpeRange("CAJ55784", "CAJ55783"),
    TTpeRange("CAJ55825", "CAJ55824"),
    TTpeRange("CAJ57446", "CAJ57445"),
    TTpeRange("CAJ70649", "CAJ70647"),
    TTpeRange("CAJ77886", "CAJ77880"),
    SingleTPE("CAK26553"),
    TTpeRange("CAK26786", "CAK26777"),
    SingleTPE("CAK32514"),
    SingleTPE("CAL10024")
};
typedef CStaticArrayMap<const char*, const char*, PNocase_CStr> TTpeRangeMap;
static const TTpeRangeMap sc_TpeRangeMap(sc_TpeRanges, sizeof(sc_TpeRanges));

static CSeq_id::EAccessionInfo s_IdentifyCxxAcc(const string& acc)
{
    if (acc > "CAL73973") {
        // make no assumptions about as yet unassigned IDs
        // (still not entirely safe due to fill-ins, though :-/ )
        return CSeq_id::eAcc_unreserved_prot;
    } else {
        TTpeRangeMap::const_iterator it
            = sc_TpeRangeMap.lower_bound(acc.c_str());
        if (it != sc_TpeRangeMap.end()  &&  it->second <= acc) {
            return CSeq_id::eAcc_embl_tpa_prot;
        } else {
            return CSeq_id::eAcc_embl_prot;
        }
    }
}


typedef pair<const char*, CSeq_id::EAccessionInfo> TRefSeqType;
// used for binary searching; must be in order.
static const TRefSeqType sc_RefSeqArray[] = {
    TRefSeqType("AC_", CSeq_id::eAcc_refseq_chromosome),
    TRefSeqType("AP_", CSeq_id::eAcc_refseq_prot),
    TRefSeqType("NC_", CSeq_id::eAcc_refseq_chromosome),
    TRefSeqType("NG_", CSeq_id::eAcc_refseq_genomic),
    TRefSeqType("NM_", CSeq_id::eAcc_refseq_mrna),
    TRefSeqType("NP_", CSeq_id::eAcc_refseq_prot),
    TRefSeqType("NR_", CSeq_id::eAcc_refseq_ncrna),
    TRefSeqType("NS_", CSeq_id::eAcc_refseq_genome), /* ? */
    TRefSeqType("NT_", CSeq_id::eAcc_refseq_contig),
    TRefSeqType("NW_", CSeq_id::eAcc_refseq_wgs_intermed),
    // NZ_ accessions have four more letters before any digits.
    // TRefSeqType("NZ_", CSeq_id::eAcc_refseq_wgs_nuc),
    TRefSeqType("XM_", CSeq_id::eAcc_refseq_mrna_predicted),
    TRefSeqType("XP_", CSeq_id::eAcc_refseq_prot_predicted),
    TRefSeqType("XR_", CSeq_id::eAcc_refseq_ncrna_predicted),
    TRefSeqType("YP_", CSeq_id::eAcc_refseq_prot_predicted),
    TRefSeqType("ZP_", CSeq_id::eAcc_refseq_wgs_prot)
};
typedef CStaticArrayMap<const char*, CSeq_id::EAccessionInfo, PCase_CStr> TRefSeqMap;
static const TRefSeqMap sc_RefSeqMap(sc_RefSeqArray, sizeof(sc_RefSeqArray));


static const char kDigits[] = "0123456789";

CSeq_id::EAccessionInfo CSeq_id::IdentifyAccession(const string& acc)
{
    SIZE_TYPE main_size = acc.find('.');
    if (main_size == NPOS) {
        main_size = acc.size();
    } else if (main_size >= acc.size() - 1
               ||  acc.find_first_not_of(kDigits, main_size + 1) != NPOS) {
        return eAcc_unknown; // non-numeric "version"
    }
    SIZE_TYPE digit_pos = acc.find_first_of(kDigits);
    string pfx = acc.substr(0, digit_pos);
    NStr::ToUpper(pfx);
    if (digit_pos == NPOS) {
        return eAcc_unknown;
    } else {
        SIZE_TYPE non_dig_pos = acc.find_first_not_of(kDigits, digit_pos);
        if (non_dig_pos != NPOS  &&  non_dig_pos != main_size) {
            if (main_size != acc.size()) {
                return eAcc_unknown; // these should all be unversioned
            }
            if (digit_pos == 0  &&  main_size >= 4
                &&  (main_size <= 5
                     ||  (ispunct((unsigned char)acc[4])  &&  acc[4] != '.'))) {
                return eAcc_pdb;
            } else if (digit_pos == 1  &&  main_size == 6
                       &&  (pfx[0] == 'O' || pfx[0] == 'P' || pfx[0] == 'Q')
                       &&  isdigit((unsigned char)acc[1])
                       &&  isalnum((unsigned char)acc[2])
                       &&  isalnum((unsigned char)acc[3])
                       &&  isalnum((unsigned char)acc[4])
                       &&  isdigit((unsigned char)acc[5])) {
                return eAcc_swissprot;
            } else {
                return eAcc_unknown;
            }
        }
    }
    switch (digit_pos) {
    case 0:
        if (acc.find_first_not_of(kDigits) == NPOS) { // just digits
            return eAcc_gi;
        } else {
            return eAcc_unknown; // PDB already handled
        }

    case 1:
        if (main_size != 1 + 5) {
            return eAcc_unknown;
        }
        switch (pfx[0]) {
        case 'A':                                return eAcc_embl_patent;
        case 'B':                                return eAcc_gb_gss;
        case 'C':                                return eAcc_ddbj_est;
        case 'D':                                return eAcc_ddbj_dirsub;
        case 'E':                                return eAcc_ddbj_patent;
        case 'F':                                return eAcc_embl_est;
        case 'G':                                return eAcc_gb_sts;
        case 'H': case 'R': case 'T': case 'W':  return eAcc_gb_est;
        case 'I':                                return eAcc_gb_patent;
        case 'J': case 'K': case 'L': case 'M':  return eAcc_gsdb_dirsub;
        case 'N':
            return s_IdentifyNAcc(acc.substr(0, main_size));
        case 'O': case 'P': case 'Q':            return eAcc_swissprot;
        case 'S':                                return eAcc_gb_backbone;
        case 'U':                                return eAcc_gb_dirsub;
        case 'V': case 'X': case 'Y': case 'Z':  return eAcc_embl_dirsub;
        default:                                 return eAcc_unreserved_nuc;
        }

    case 2:
        if (main_size != 2 + 6) {
            return eAcc_unknown;
        }
        switch (pfx[0]) {
        case 'A':
            switch (pfx[1]) {
            case 'A': case 'I': case 'W': return eAcc_gb_est;
            case 'B':                     return eAcc_ddbj_dirsub;
            case 'C':                     return eAcc_gb_htgs;
            case 'D':                     return eAcc_gb_gsdb;
            case 'E':                     return eAcc_gb_genome;
            case 'F': case 'Y':           return eAcc_gb_dirsub;
            case 'G': case 'P':           return eAcc_ddbj_genome;
            case 'H':                     return eAcc_gb_con;
            case 'J': case 'M':           return eAcc_embl_dirsub;
            case 'K':                     return eAcc_ddbj_htgs;
            case 'L':                     return eAcc_embl_genome;
            case 'N':                     return eAcc_embl_con;
            case 'Q': case 'Z':           return eAcc_gb_gss;
            case 'R':                     return eAcc_gb_patent;
            case 'S':                     return eAcc_gb_other_nuc;
            case 'T': case 'U': case 'V': return eAcc_ddbj_est;
            case 'X':                     return eAcc_embl_patent;
            default:                      return eAcc_unreserved_nuc;
            }

        case 'B':
            switch (pfx[1]) {
            case 'A':                               return eAcc_ddbj_con;
            case 'B': case 'J': case 'P': case 'W':
            case 'Y':                               return eAcc_ddbj_est;
            case 'C': case 'T':                     return eAcc_gb_cdna;
            case 'D':                               return eAcc_ddbj_patent;
            case 'E': case 'F': case 'G': case 'I':
            case 'M': case 'Q': case 'U':           return eAcc_gb_est;
            case 'H': case 'Z':                     return eAcc_gb_gss;
            case 'K': case 'L':                     return eAcc_gb_tpa_nuc;
            case 'N':                               return eAcc_embl_tpa_nuc;
            case 'R':                               return eAcc_ddbj_tpa_nuc;
            case 'S':                               return eAcc_ddbj_genome;
                // BS is actually chimp genomes.
            case 'V':                               return eAcc_gb_sts;
            case 'X':                               return eAcc_embl_genome;
            default:                                return eAcc_unreserved_nuc;
            }

        case 'C':
            switch (pfx[1]) {
            case 'A': case 'B': case 'D': case 'F':
            case 'K': case 'N': case 'O': case 'V':
            case 'X':                               return eAcc_gb_est;
            case 'C': case 'E': case 'G': case 'L':
            case 'W': case 'Z':                     return eAcc_gb_gss;
            case 'H': case 'M':                     return eAcc_gb_con;
            case 'I': case 'J':                     return eAcc_ddbj_est;
            case 'P': case 'Y':                     return eAcc_gb_genome;
            case 'Q': case 'S':                     return eAcc_embl_patent;
            case 'R': case 'T': case 'U':           return eAcc_embl_genome;
            default:                                return eAcc_unreserved_nuc;
            }

        case 'D':
            switch (pfx[1]) {
            case 'A': case 'B': case 'C':           return eAcc_ddbj_est;
            case 'D':                               return eAcc_ddbj_patent;
            case 'E': case 'H':                     return eAcc_ddbj_gss;
            case 'F': case 'G':                     return eAcc_ddbj_con;
                // no specific assignments for DI-DM yet
            case 'I': case 'J': case 'K': case 'L':
            case 'M':                               return eAcc_ddbj_other_nuc;
            case 'N': case 'R': case 'T': case 'V':
            case 'W': case 'Y':                     return eAcc_gb_est;
            case 'P':                               return eAcc_gb_htgs;
            case 'Q':                               return eAcc_gb_dirsub;
            case 'S':                               return eAcc_gb_con;
            case 'U': case 'X':                     return eAcc_gb_gss;
            case 'Z':                               return eAcc_gb_patent;
            default:                                return eAcc_unreserved_nuc;
            }

        case 'E':
            switch (pfx[1]) {
            case 'A':                               return eAcc_gb_patent;
            case 'B': case 'C': case 'E': case 'G':
            case 'H':                               return eAcc_gb_est;
            case 'D': case 'I': case 'J': case 'K': return eAcc_gb_gss;
            case 'F':                               return eAcc_gb_dirsub;
            default:                                return eAcc_unreserved_nuc;
            }

        default: return eAcc_unreserved_nuc;
        }

    case 3:
        if (pfx[2] == '_') { // refseq
            if (main_size < 3 + 6  ||  main_size > 3 + 9) {
                return eAcc_unknown;
            }
            TRefSeqMap::const_iterator it = sc_RefSeqMap.find(pfx.c_str());
            if (it == sc_RefSeqMap.end()) {
                return eAcc_refseq_unreserved;
            } else {
                return it->second;
            }
        } else { // protein
            if (main_size != 3 + 5) {
                return eAcc_unknown;
            }
            switch (pfx[0]) {
            case 'A': return (pfx == "AAE") ? eAcc_gb_patent_prot
                          : eAcc_gb_prot;
            case 'B': return eAcc_ddbj_prot;
                // not necessarily "true" EMBL (may be TPE) :-/
            case 'C': return s_IdentifyCxxAcc(acc.substr(0, main_size));
            case 'D': return eAcc_gb_tpa_prot;
            case 'E': return eAcc_gb_wgs_prot;
            case 'F': return eAcc_ddbj_tpa_prot;
            case 'G': return eAcc_ddbj_wgs_prot;
            default:  return eAcc_unreserved_prot;
            }
        }

    case 4:
        if (main_size < 4 + 8  ||  main_size > 4 + 10) {
            return eAcc_unknown;
        }
        switch (pfx[0]) {
        case 'A': return eAcc_gb_wgs_nuc;
        case 'B': return eAcc_ddbj_wgs_nuc;
        case 'C': return eAcc_embl_wgs_nuc;
        default:  return eAcc_unknown;
        }

    case 7:
        if (NStr::StartsWith(acc, "NZ_")  &&  main_size == 7 + 8) {
            return eAcc_refseq_wgs_nuc;
        } else {
            return eAcc_unknown;
        }

    default:
        return eAcc_unknown;
    }
}


CSeq_id::EAccessionInfo CSeq_id::IdentifyAccession(void) const
{
    EAccessionInfo type = (EAccessionInfo)Which();
    switch (type) {
    case e_Pir: case e_Swissprot: case e_Prf: // but *NOT* e_Pdb
        return (EAccessionInfo)(type | fAcc_prot); // always just protein
        
    case e_Genbank: case e_Embl: case e_Ddbj:
    case e_Tpg:     case e_Tpe:  case e_Tpd:
    case e_Other:
    {
        const CTextseq_id* tsid = GetTextseq_Id();
        if (tsid->IsSetAccession()) {
            EAccessionInfo ai = IdentifyAccession(tsid->GetAccession());
            if ((ai & eAcc_type_mask) == e_not_set) {
                // We *know* what the type should be....
                return (EAccessionInfo)((ai & eAcc_flag_mask) | type);
            } else if ((ai & eAcc_type_mask) == type) {
                return ai;
            } else { // misidentified or mislabeled; assume the former
                return type;
            }
        } else {
            return type;
        }
    }
    
    default:
        return type;
    }
}


static inline
void x_GetLabel_Type(const CSeq_id& id, string* label,
                     CSeq_id::TLabelFlags flags)
{
    unsigned choice = id.Which();
    _ASSERT(choice < CSeq_id::e_MaxChoice);
    if (choice >= CSeq_id::e_MaxChoice) {
        return;
    }

    switch (choice) {   
    case CSeq_id::e_General:
        // we may encode 'gnl' or the database name as requested
        if (flags & CSeq_id::fLabel_GeneralDbIsContent) {
            *label += id.GetGeneral().GetDb();
        } else {
            *label += "gnl";
        }
        break;

    case CSeq_id::e_Patent:
        *label += id.GetPatent().GetCit().GetId().IsNumber() ? "pat" : "pgp";
        
    default:
        *label += s_TextId[choice];
        break;
    }

    // no extra flag interpretation currently
}


static inline
void x_GetLabel_Content(const CSeq_id& id, string* label,
                        CSeq_id::TLabelFlags flags)
{
    const CTextseq_id* tsid = id.GetTextseq_Id();

    //text id
    if (tsid) {
        string str;
        if (tsid->IsSetAccession()) {
            str = tsid->GetAccession();
        } else if (tsid->IsSetName()) {
            str = tsid->GetName();
        }

        if ( !str.empty() ) {
            if ( (flags & CSeq_id::fLabel_Version)  &&  tsid->IsSetVersion()) {
                str += "." + NStr::IntToString(tsid->GetVersion());
            }
        }
        *label += str;

    } else { //non-text id
        switch (id.Which()) {   
        case CSeq_id::e_not_set:
            break;

        case CSeq_id::e_Local:
            {{
                const CObject_id& oid = id.GetLocal();
                if (oid.IsId()) {
                    *label += NStr::IntToString(oid.GetId());
                } else if (oid.IsStr()) {
                    *label += oid.GetStr(); 
                }
            }}
            break;

        case CSeq_id::e_Gibbsq:
            *label += NStr::IntToString(id.GetGibbsq());
            break;

        case CSeq_id::e_Gibbmt:
            *label += NStr::IntToString(id.GetGibbmt());
            break;

        case CSeq_id::e_Giim:
            *label += NStr::IntToString(id.GetGiim().GetId());
            break;

        case CSeq_id::e_General:
            {{
                const CDbtag& dbt = id.GetGeneral();
                if (flags & CSeq_id::fLabel_GeneralDbIsContent) {
                    *label += dbt.GetDb() + '|';
                }
                if (dbt.GetTag().IsId()) {
                    *label += NStr::IntToString(dbt.GetTag().GetId());
                } else if (dbt.GetTag().IsStr()) {
                    *label += dbt.GetTag().GetStr();
                }
            }}
            break;

        case CSeq_id::e_Patent:
            {{
                const CId_pat& idp = id.GetPatent().GetCit();
                *label += idp.GetCountry() +
                    (idp.GetId().IsNumber() ?
                        idp.GetId().GetNumber() :
                        idp.GetId().GetApp_number()) +
                    NStr::IntToString(id.GetPatent().GetSeqid());
            }}
            break;

        case CSeq_id::e_Gi:
            *label += NStr::IntToString(id.GetGi());
            break;

        case CSeq_id::e_Pdb:
            {{
                const CPDB_seq_id& pid = id.GetPdb();
                char chain = (char)pid.GetChain();
                if (chain == '|') {
                    *label += pid.GetMol().Get() + "|VB";
                } else if (islower((unsigned char) chain) != 0) {
                    *label += pid.GetMol().Get() + "-" + (char) toupper((unsigned char) chain);
                } else if ( chain == '\0' ) {
                    *label += pid.GetMol().Get() + "-";
                } else {
                    *label += pid.GetMol().Get() + "-" + chain; 
                }
            }}
            break;

        default:
            break;
        }
    }
}


void CSeq_id::GetLabel(string* label, ELabelType type, TLabelFlags flags) const
{
    if ( !label ) {
        return;
    }

    switch (type) {
    case eFasta:
        *label = AsFastaString();
        break;

    case eBoth:
        x_GetLabel_Type(*this, label, flags);
        *label += "|";
        x_GetLabel_Content(*this, label, flags);
        break;

    case eType:
        x_GetLabel_Type(*this, label, flags);
        break;

    case eContent:
        x_GetLabel_Content(*this, label, flags);
        break;
    }
}



/*Return seqid string with optional version for text seqid type 
(default no version).*/ 
string CSeq_id::GetSeqIdString(bool with_version) const
{
    string label;
    TLabelFlags flags = 0;
    if (with_version) {
        flags |= fLabel_Version;
    }
    GetLabel(&label, eContent, flags);
    return label;
}


void CSeq_id::WriteAsFasta(ostream& out)
    const
{
    unsigned the_type = Which();
    if (the_type >= e_MaxChoice)  // New SeqId type
        the_type = e_not_set;

    if (IsPatent()  &&  !GetPatent().GetCit().GetId().IsNumber() ) {
        out << "pgp|";
    } else {
        out << s_TextId[the_type] << '|';
    }

    switch (the_type) {
    case e_not_set:
        break;
    case e_Local:
        GetLocal().AsString(out);
        break;
    case e_Gibbsq:
        out << GetGibbsq();
        break;
    case e_Gibbmt:
        out << GetGibbmt();
        break;
    case e_Giim:
        out << (GetGiim().GetId());
        break;
    case e_Genbank:
        GetGenbank().AsFastaString(out);
        break;
    case e_Embl:
        GetEmbl().AsFastaString(out);
        break;
    case e_Pir:
        GetPir().AsFastaString(out);
        break;
    case e_Swissprot:
        GetSwissprot().AsFastaString(out);
        break;
    case e_Patent:
        GetPatent().AsFastaString(out);
        break;
    case e_Other:
        GetOther().AsFastaString(out);
        break;
    case e_General:
        {
            const CDbtag& dbt = GetGeneral();
            out << (dbt.GetDb()) << '|';  // no Upcase per Ostell - Karl 7/2001
            dbt.GetTag().AsString(out);
        }
        break;
    case e_Gi:
        out << GetGi();
        break;
    case e_Ddbj:
        GetDdbj().AsFastaString(out);
        break;
    case e_Prf:
        GetPrf().AsFastaString(out);
        break;
    case e_Pdb:
        GetPdb().AsFastaString(out);
        break;
    case e_Tpg:
        GetTpg().AsFastaString(out);
        break;
    case e_Tpe:
        GetTpe().AsFastaString(out);
        break;
    case e_Tpd:
        GetTpd().AsFastaString(out);
        break;
    case e_Gpipe:
        GetGpipe().AsFastaString(out);
        break;
    default:
        out << "[UnknownSeqIdType]";
        break;
    }
}


const string CSeq_id::AsFastaString(void) const
{
    CNcbiOstrstream str;
    WriteAsFasta(str);
    return CNcbiOstrstreamToString(str);
}


//
// GetStringDescr()
// Given a bioseq, return the best possible ID description, in a number of
// appealing formats.  This function can produce FastA-formatted titles or a
// number of sub-titles (GI only, Best Accession with or without version).
//
string CSeq_id::GetStringDescr(const CBioseq& bioseq, EStringFormat fmt)
{
    bool is_na            = bioseq.GetInst().GetMol() != CSeq_inst::eMol_aa;
    CRef<CSeq_id> best_id = FindBestChoice(bioseq.GetId(),
                                           is_na ? CSeq_id::FastaNARank
                                           : CSeq_id::FastaAARank);
    switch (fmt) {
    case eFormat_FastA:
        {
            // FastA format
            // Here we have something like:
            //      gi|###|SOME_ACCESSION|title
            bool found_gi = false;

            CNcbiOstrstream out_str;
            ITERATE (CBioseq::TId, id, bioseq.GetId()) {
                if ((*id)->IsGi()) {
                    (*id)->WriteAsFasta(out_str);
                    found_gi = true;
                    break;
                }
            }

            if (best_id.NotEmpty()  &&  !best_id->IsGi() ) {
                if (found_gi) {
                    out_str << '|';
                }
                best_id->WriteAsFasta(out_str);
            }

            return CNcbiOstrstreamToString(out_str);
        }

    case eFormat_ForceGI:
        // eForceGI produces a string containing only the GI in FastA format
        // so we have:
        //    gi|####
        ITERATE (CBioseq::TId, iter, bioseq.GetId()) {
            if ( (*iter)->IsGi() ) {
                CNcbiOstrstream out_str;
                (*iter)->WriteAsFasta(out_str);

                return CNcbiOstrstreamToString(out_str);
            }
        }
        break;

    case eFormat_BestWithVersion:
        // eBestWithVersion produces only the 'best' accession name, with
        // its version indicator
        if (best_id.NotEmpty()) {
            string label;
            best_id->GetLabel(&label, eDefault, fLabel_Version);
            return label;
        }
        break;
        
    case eFormat_BestWithoutVersion:
        // eBestWithoutVersion produces only the 'best' accession name,
        // without its version indicator
        if (best_id.NotEmpty()) {
            string label;
            best_id->GetLabel(&label, eDefault, 0);
            return label;
        }
        break;
    }

    // catch-all for unusual events
    return "";
}


CSeq_id::CSeq_id(const CDbtag& dbtag, bool set_as_general)
{
    Set(dbtag, set_as_general);
}

CSeq_id& CSeq_id::Set(const CDbtag& dbtag, bool set_as_general)
{
    int version = -1;
    string acc, accver;

    switch (dbtag.GetTag().Which()) {
    case CObject_id::e_Str:
        accver = dbtag.GetTag().GetStr();
        s_SplitVersion(accver, acc, version);
        break;
    case CObject_id::e_Id:
        acc = accver = NStr::IntToString(dbtag.GetTag().GetId());
        break;
    default:
        NCBI_THROW(CSeqIdException, eFormat,
                   "Bad CDbtag tag type "
                   + CObject_id::SelectionName(dbtag.GetTag().Which()));
        break;
    }

    switch (dbtag.GetType()) {
    case CDbtag::eDbtagType_GenBank:
        try {
            int gi = NStr::StringToInt(acc);
            SetGi(gi);
        }
        catch (...) {
            SetGenbank().Set(accver);
        }
        break;

    case CDbtag::eDbtagType_EMBL:
        SetEmbl().Set(accver);
        break;

    case CDbtag::eDbtagType_DDBJ:
        SetDdbj().Set(accver);
        break;

    case CDbtag::eDbtagType_GI:
        if (dbtag.GetTag().IsStr()) {
            Set(e_Gi, dbtag.GetTag().GetStr());
        } else {
            SetGi(dbtag.GetTag().GetId());
        }
        break;

    case CDbtag::eDbtagType_bad:
    default:
        // not understood as a sequence id
        if (set_as_general) {
            SetGeneral().Assign(dbtag);
        } else {
            NCBI_THROW(CSeqIdException, eFormat,
                       "Unrecognized Dbtag DB " + dbtag.GetDb());
        }
        break;
    }

    return *this;
}


//SeqIdFastAConstructors
CSeq_id::CSeq_id( const string& the_id )
{
    Set(the_id);
}

CSeq_id& CSeq_id::Set(const string& the_id_in)
{
    string the_id = NStr::TruncateSpaces(the_id_in, NStr::eTrunc_Both);
    if (the_id.empty()) {
        NCBI_THROW(CSeqIdException, eFormat, "Empty bare accession supplied");
    } else if (the_id.find('|') == NPOS
               ||  isdigit((unsigned char)the_id[0])) {
        // If no vertical bar, tries to interpret the string as a pure
        // accession, inferring the type from the initial letter(s).
        EAccessionInfo info = IdentifyAccession(the_id);
        E_Choice       type = GetAccType(info);
        switch (type) {
        case e_not_set:
            NCBI_THROW(CSeqIdException, eFormat, "Malformatted ID " + the_id);
        case e_Pdb:
        {
            string mol(the_id, 0, 4), chain;
            // NStr::SplitInTwo(the_id, "|", mol, chain);
            if (the_id.size() > 5) {
                chain = the_id.substr(5);
            } else if (the_id.size() == 5  &&  the_id[4] != '|') {
                chain = the_id[4];
            }
            return Set(type, mol, chain);
        }
        default:
        {
            string acc;
            int    ver;
            s_SplitVersion(the_id, acc, ver);
            return Set(type, acc, kEmptyStr, ver);
        }
        }
    } else {
        list<string> fasta_pieces;
        NStr::Split(the_id, "|", fasta_pieces, NStr::eNoMergeDelims);
        x_Init(fasta_pieces);
        if ( !fasta_pieces.empty() ) {
            // tolerate trailing parts if they're all empty.
            ITERATE(list<string>, it, fasta_pieces) {
                if ( !it->empty() ) {
                    NCBI_THROW(CSeqIdException, eFormat,
                               "FASTA-style ID " + the_id
                               + " has too many parts.");
                }
            }
        }
        return *this;
    }
}


SIZE_TYPE CSeq_id::ParseFastaIds(CBioseq::TId& ids, const string& s,
                                 bool allow_partial_failure)
{
    string ss = NStr::TruncateSpaces(s, NStr::eTrunc_Both);
    if (ss.empty()) {
        return 0;
    }
    list<string> fasta_pieces;
    NStr::Split(ss, "|", fasta_pieces, NStr::eNoMergeDelims);
    if ((fasta_pieces.size() < 2  ||  isdigit((unsigned char)ss[0]))) {
        CRef<CSeq_id> id(new CSeq_id);
        // In this context, it's probably reasonable to expect GIs to be
        // tagged with gi| and to treat untagged numeric IDs as local.
        if (ss.find_first_not_of(kDigits) == NPOS) {
            id->Set(e_Local, ss);
        } else {
            try {
                id->Set(ss);
            } catch (CSeqIdException&) {
                id->Set(e_Local, ss);
            }
        }
        ids.push_back(id);
        return 1;
    }
    SIZE_TYPE count = 0;
    while ( !fasta_pieces.empty() ) {
        try {
            CRef<CSeq_id> id(new CSeq_id);
            id->x_Init(fasta_pieces);
            ids.push_back(id);
            ++count;
        } catch (std::exception& e) {
            if (allow_partial_failure) {
                ERR_POST(Warning << e.what());
            } else {
                throw;
            }
        }
    }
    return count;
}


void CSeq_id::x_Init(list<string>& fasta_pieces)
{
    _ASSERT(!fasta_pieces.empty());
    string typestr = fasta_pieces.front();
    fasta_pieces.pop_front();
    NStr::TruncateSpacesInPlace(typestr, NStr::eTrunc_Both);
    E_Choice type = WhichInverseSeqId(typestr.c_str());
    if (type == e_not_set  ||  typestr.size() > 3) {
        NCBI_THROW(CSeqIdException, eFormat, "Unsupported ID type " + typestr);
    }

    string    fields[3];
    SIZE_TYPE min_fields, max_fields;
    switch (type) {
    case e_Local:
    case e_Gibbsq:
    case e_Gibbmt:
    case e_Giim:
    case e_Gi:
        min_fields = max_fields = 1;
        break;
    case e_Patent:
        min_fields = max_fields = 3;
        break;
    case e_General:
        min_fields = max_fields = 2;
        break;
#if 0 // release no longer used
    case e_Other:
        min_fields = 1;
        max_fields = 3;
        break;
#endif
    default: // text seqid: accession and optional name
        min_fields = 1;
        max_fields = 2;
        break;
    }

    for (SIZE_TYPE i = 0;  i < max_fields;  ++i) {
        if (fasta_pieces.empty()) {
            if (i >= min_fields) {
                break;
            } else {
                NCBI_THROW(CSeqIdException, eFormat,
                           "Not enough fields for ID of type " + typestr);
            }
        } else {
            // XXX - stop if we have enough fields and the next one looks
            // like an ID type?
            fields[i] = fasta_pieces.front();
            fasta_pieces.pop_front();
        }
    }

    // Special case -- dbSNP IDs have historically contained internal
    // vertical bars, so we have to parse them greedily.
    if (type == e_General  &&  NStr::EqualNocase(fields[0], "dbSNP")
        &&  !fasta_pieces.empty() ) {
        fields[1] += '|';
        fields[1] += NStr::Join(fasta_pieces, "|");
        fasta_pieces.clear();
    }
    
    int ver = 0;
    if (type == e_Patent) {
        // actually sequence number within patent, but whatever...
        ver = NStr::StringToNumeric(fields[2]);
        if (ver <= 0) {
            NCBI_THROW(CSeqIdException, eFormat,
                       "Bad sequence number " + fields[2] + " for " + fields[0]
                       + " patent " + fields[1]);
        }
        // to distinguish applications from granted patents; the numeric
        // content has already made its way into ver.
        fields[2] = typestr;
    }

    Set(type, fields[0] /* acc */, fields[1] /* name */, ver,
        fields[2] /* rel */);
}


CSeq_id::CSeq_id(E_Choice the_type, int the_id)
{
    Set(the_type, the_id);
}

CSeq_id& CSeq_id::Set(E_Choice the_type, int the_id)
{
    if (the_id <= 0) {
        NCBI_THROW(CSeqIdException, eFormat,
                   "Non-positive numeric ID " + NStr::IntToString(the_id));
    }
  
    switch (the_type) {
    case e_Local:
        SetLocal().SetId(the_id);
        break;
    case e_Gibbsq:
        SetGibbsq(the_id);
        break;
    case e_Gibbmt:
        SetGibbmt(the_id);
        break;
    case e_Giim:
    {
        CGiimport_id& giim = SetGiim();
        giim.SetId(the_id);
        giim.ResetDb();
        giim.ResetRelease();
        break;
    }
    case e_Gi:
        SetGi(the_id);
        break;
    default:
        NCBI_THROW(CSeqIdException, eFormat,
                   "Invalid numeric ID type" + SelectionName(the_type));
    }
    return *this;
}


CSeq_id::CSeq_id(E_Choice      the_type,
                 const string& acc_in,
                 const string& name_in,
                 int           version,
                 const string& release_in)
{
    Set(the_type, acc_in, name_in, version, release_in);
}

// Karl Sirotkin 7/2001

CSeq_id& CSeq_id::Set(E_Choice      the_type,
                      const string& acc_in,
                      const string& name_in,
                      int           version,
                      const string& release_in)
{
    string acc     = NStr::TruncateSpaces(acc_in,     NStr::eTrunc_Both);
    string name    = NStr::TruncateSpaces(name_in,    NStr::eTrunc_Both);
    string release = NStr::TruncateSpaces(release_in, NStr::eTrunc_Both);

    int          the_id;
    CTextseq_id* tsid      = 0;
    bool         allow_dot = true;

    switch (the_type) {
    case e_not_set: // Will cause unspecified SeqId to be returned.
        break;

    case e_Local:
        {
            string::const_iterator it = acc.begin();

            if ( (the_id = NStr::StringToNumeric(acc)) >= 0 && *it != '0' ) {
                SetLocal().SetId(the_id);
            } else { // to cover case where embedded vertical bar in
                // string, could add code here, to concat a
                // '|' and name string, if not null/empty
                SetLocal().SetStr(acc);
            }
            break;
        }

        // numeric IDs
    case e_Gibbsq:
    case e_Gibbmt:
    case e_Giim:
    case e_Gi:
        if ( (the_id = NStr::StringToNumeric (acc)) >= 0 ) {
            return Set(the_type, the_id);
        } else {
            NCBI_THROW(CSeqIdException, eFormat,
                       "Negative, excessively large, or non-numeric "
                       + SelectionName(the_type)
                       + " ID " + acc);
        }
        break;

        // text IDs
    case e_Genbank:    tsid = &SetGenbank();    break;
    case e_Embl:       tsid = &SetEmbl();       break;
    case e_Pir:        tsid = &SetPir();        allow_dot = false;  break;
    case e_Swissprot:  tsid = &SetSwissprot();  allow_dot = false;  break;
    case e_Other:      tsid = &SetOther();      break;
    case e_Ddbj:       tsid = &SetDdbj();       break;
    case e_Prf:        tsid = &SetPrf();        allow_dot = false;  break;
    case e_Tpg:        tsid = &SetTpg();        break;
    case e_Tpe:        tsid = &SetTpe();        break;
    case e_Tpd:        tsid = &SetTpd();        break;
    case e_Gpipe:      tsid = &SetGpipe();      break;

    case e_Patent:
        {
            CPatent_seq_id&  pat    = SetPatent();
            CId_pat&         id_pat = pat.SetCit();
            CId_pat::C_Id&   id_pat_id = id_pat.SetId();
            id_pat.SetCountry(acc);

            if (NStr::EqualNocase(release, "pgp")) {
                id_pat_id.SetApp_number(name);
            } else {
                id_pat_id.SetNumber(name);
            }
            id_pat.ResetDoc_type();
            pat.SetSeqid(version);
            break;
        }

    case e_General:
        {
            CDbtag& dbt = SetGeneral();
            dbt.SetDb(acc);
            CObject_id& oid = dbt.SetTag();
            the_id = NStr::StringToNumeric(name);
            if (the_id >= 0  &&  (name.size() == 1 || name[0] != '0')) {
                oid.SetId(the_id);
            } else {
                oid.SetStr(name);
            }
            break;
        }

    case e_Pdb:
        {
            CPDB_seq_id& pdb = SetPdb();
            pdb.SetMol().Set(acc);

            if (name.empty()) {
                pdb.SetChain(' ');
            } else if (name.size() == 1) { // force upper case?
                pdb.SetChain(static_cast<unsigned char>(name[0]));
            } else if (NStr::EqualNocase(name, "VB")) {
                pdb.SetChain('|');
            } else if (name.size() == 2  &&  name[0] == name[1]) {
                pdb.SetChain(tolower(static_cast<unsigned char>(name[0])));
            } else {
                NCBI_THROW(CSeqIdException, eFormat,
                           "Unexpected PDB chain id " + name + " for " + acc);
            }
            pdb.ResetRel();
            break;
        }

    default:
        NCBI_THROW(CSeqIdException, eFormat,
                   "Unsupported Seq-id type " + SelectionName(the_type));
    }

    if (tsid) {
        tsid->Set(acc, name, version, release, allow_dot);
    }

    return *this;
}


bool CSeq_id::Equals(const CSerialObject& object, ESerialRecursionMode how) const
{
    if ( typeid(object) != typeid(*this) ) {
        ERR_POST(Fatal <<
            "CSeq_id::Assign() -- Assignment of incompatible types: " <<
            typeid(*this).name() << " = " << typeid(object).name());
    }
    return CSerialObject::Equals(object, how);
}


END_objects_SCOPE // namespace ncbi::objects::
END_NCBI_SCOPE

/*
 * ===========================================================================
 *
 * $Log$
 * Revision 6.143  2007/01/04 20:08:03  ucko
 * IdentifyAccession: allow for nucleotide(!) PDB accessions.
 *
 * Revision 6.142  2007/01/04 16:02:01  ucko
 * IdentifyAccession: EJ, EK -> eAcc_gb_gss.
 *
 * Revision 6.141  2006/12/20 15:07:48  ucko
 * IdentifyAccession: specifically assign DH to eAcc_ddbj_gss.
 *
 * Revision 6.140  2006/12/08 20:32:36  ucko
 * Update EMBL/TPE protein info.
 *
 * Revision 6.139  2006/12/05 15:31:32  ucko
 * IdentifyAccession: EI -> eAcc_gb_gss
 *
 * Revision 6.138  2006/11/14 21:45:37  ucko
 * Properly recognize RefSeq AC_ (alternate chromosome-class) records.
 *
 * Revision 6.137  2006/11/14 19:30:50  ucko
 * s_IdentifyCxxAcc: correct the known EMBL protein ID cutoff (slightly) upwards.
 *
 * Revision 6.136  2006/11/14 19:13:38  ucko
 * Cope (somewhat painfully) with EMBL's policy of mixing some TPA
 * proteins into their namespace.
 *
 * Revision 6.135  2006/11/03 19:14:40  ucko
 * IdentifyAccession: EH -> eAcc_gb_est.
 *
 * Revision 6.134  2006/09/18 18:07:44  ucko
 * IdentifyAccession: EG -> eAcc_gb_est
 *
 * Revision 6.133  2006/08/21 19:33:26  ucko
 * IdentifyAccession: EF -> eAcc_gb_dirsub
 *
 * Revision 6.132  2006/07/06 14:06:33  ucko
 * IdentifyAccession: EE -> eAcc_gb_est
 *
 * Revision 6.131  2006/06/29 15:05:37  ucko
 * IdentifyAccession: ED -> eAcc_gb_gss
 *
 * Revision 6.130  2006/06/20 21:02:48  ucko
 * IdentifyAccession: EMBL has specifically assigned CU to genome
 * projects; also correct the comment for unassigned DDBJ Dx prefixes.
 *
 * Revision 6.129  2006/06/15 14:19:17  ucko
 * Loosen syntax requirements for bare PDB accessions.
 *
 * Revision 6.128  2006/05/25 14:39:34  ucko
 * IdentifyAccession: EC -> eAcc_gb_est.
 *
 * Revision 6.127  2006/04/11 15:07:20  ucko
 * ParseFastaIds: when fed an empty string (or just whitespace), return 0
 * rather than storing a blank local ID.
 *
 * Revision 6.126  2006/04/06 15:59:34  ucko
 * DDBJ changes its use of DF from CON to scaffold/CON and will be using
 * DG for CON entries.  [We represent both as eAcc_ddbj_con.]
 *
 * Revision 6.125  2006/03/30 14:53:32  ucko
 * IdentifyAccession: DDBJ has specifically assigned DF to CON sequences.
 *
 * Revision 6.124  2006/03/24 21:30:37  ucko
 * Really fix ParseFastaIds' handling of untagged numeric IDs.
 *
 * Revision 6.123  2006/03/23 18:57:48  ucko
 * IdentifyAccession: EB -> eAcc_gb_est
 *
 * Revision 6.122  2006/02/15 17:17:42  ucko
 * Expose ranking methods used for FASTA deflines per Tom Madden's request.
 *
 * Revision 6.121  2006/02/07 19:29:11  ucko
 * Use pgp|... rather than pat|... for "pre-grant patents" (applications).
 *
 * Revision 6.120  2006/02/02 16:07:51  ucko
 * IdentifyAccession: DZ and EA are GenBank patents (eAcc_gb_patent).
 *
 * Revision 6.119  2006/01/25 15:59:26  ucko
 * IdentifyAccession: DY has been assigned to GenBank ESTs (eAcc_gb_est)
 *
 * Revision 6.118  2006/01/03 19:42:37  ucko
 * IdentifyAccession: DX -> eAcc_gb_gss.
 *
 * Revision 6.117  2005/12/28 17:05:13  ucko
 * CSeq_id::Set(const string&): put up with trailing parts in FASTA-style
 * IDs as long as they're all empty.
 *
 * Revision 6.116  2005/12/12 15:47:00  ucko
 * IdentifyAccession: DW has been allocated to GenBank ESTs.
 * ParseFastaIds: treat untagged numeric IDs as local IDs rather than GIs.
 *
 * Revision 6.115  2005/09/21 13:51:59  ucko
 * IdentifyAccession: DV -> eAcc_gb_est.
 *
 * Revision 6.114  2005/09/07 15:41:12  ucko
 * dbSNP is moving away from extra fields, so don't assume they're always
 * present.
 *
 * Revision 6.113  2005/08/25 14:02:04  jcherry
 * More accurate exception message for bad numeric accessions
 *
 * Revision 6.112  2005/08/18 14:42:26  ucko
 * By request, parse FASTA-style dbSNP IDs greedily, as they may contain
 * extra vertical bars as part of the tag.
 *
 * Revision 6.111  2005/07/28 18:28:51  ucko
 * CSeq_id::IdentifyAccession: DT -> gb_est, DU -> gb_gss.
 *
 * Revision 6.110  2005/07/06 13:54:05  ucko
 * IdentifyAccession: DS has been assigned to GenBank CON records.
 *
 * Revision 6.109  2005/06/30 20:06:32  ucko
 * ParseFastaIds: try to make sense of IDs without vertical bars,
 * treating them as bare accessions if possible and local IDs otherwise.
 *
 * Revision 6.108  2005/06/29 19:22:20  ucko
 * Refactor, introducing Set methods that can be called on previously
 * initialized IDs and a static ParseFastaIDs method.
 * Make an effort to weed out malformatted IDs in IdentifyAccession.
 * Also introduce CSeqIdException, and use it consistently.
 * Fully support gpipe IDs.
 * Various minor cleanups.
 *
 * Revision 6.107  2005/06/15 18:23:55  ucko
 * IdentifyAccession: CT has been assigned to eAcc_embl_genome.
 *
 * Revision 6.106  2005/06/03 16:53:08  lavr
 * Explicit (unsigned char) casts in ctype routines
 *
 * Revision 6.105  2005/05/04 19:03:32  ucko
 * Take advantage of PCase_CStr when comparing C strings.
 *
 * Revision 6.104  2005/04/28 19:05:14  ucko
 * Correction: DR is for ESTs, not STSs.
 *
 * Revision 6.103  2005/04/26 20:21:42  vasilche
 * Use e_MaxChoice as size of Seq-id types array.
 *
 * Revision 6.102  2005/04/05 15:22:46  ucko
 * IdentifyAccession: DR -> eAcc_gb_sts.
 *
 * Revision 6.101  2005/03/22 20:12:24  ucko
 * +DP (eAcc_gb_htgs), DQ (eAcc_gb_dirsub)
 *
 * Revision 6.100  2005/02/02 19:49:54  grichenk
 * Fixed more warnings
 *
 * Revision 6.99  2005/02/01 17:10:30  ucko
 * IdentifyAccession: DN -> eAcc_gb_est
 *
 * Revision 6.98  2005/01/25 17:24:55  ucko
 * IdentifyAccession: CS -> eAcc_embl_patent
 *
 * Revision 6.97  2005/01/13 15:59:23  dicuccio
 * Use PCase for case-sensitive comparisons in CStaticArrayMap<> - avoids
 * comparison by pointer
 *
 * Revision 6.96  2005/01/13 15:31:41  ucko
 * IdentifyAccession: use a CStaticArrayMap for RefSeq prefixes, and
 * recognize AP_ and YP_.
 *
 * Revision 6.95  2004/12/08 19:51:52  ucko
 * IdentifyAccession: We have now specifically assigned CZ for our own
 * GSS sequences.
 *
 * Revision 6.94  2004/12/08 15:20:03  ucko
 * IdentifyAccession: DDBJ has specifically assigned DE for GSS.
 *
 * Revision 6.93  2004/12/01 20:04:04  ucko
 * IdentifyAccession: CY is now specifically for (flu) genomes.
 *
 * Revision 6.92  2004/11/22 20:10:24  ucko
 * IdentifyAccession: CX is now specifically assigned to GenBank ESTs.
 *
 * Revision 6.91  2004/11/10 15:09:12  ucko
 * IdentifyAccession: DD -> DDBJ patent, DE-DM also to be used by DDBJ.
 *
 * Revision 6.90  2004/10/13 17:39:08  ucko
 * CSeq_id::IdentifyAccession: CX-CZ are reserved for GenBank
 * nucleotides, and DA-DZ are DDBJ ESTs.
 *
 * Revision 6.89  2004/09/15 14:10:12  ucko
 * IdentifyAccession: CW -> eAcc_gb_gss
 *
 * Revision 6.88  2004/08/06 17:20:59  ucko
 * IdentifyAccession: CV -> eAcc_gb_est
 *
 * Revision 6.87  2004/08/04 17:36:00  ucko
 * Recognize extended Swissprot/Uniprot accessions.
 *
 * Revision 6.86  2004/07/14 19:02:40  ucko
 * CP is now specifically assigned to GenBank genomes.
 *
 * Revision 6.85  2004/06/28 14:21:10  dicuccio
 * Implement flag: treat the db portion of a general ID as content or not
 *
 * Revision 6.84  2004/06/07 20:12:17  ucko
 * Revert previous change, as some code was relying on getting e_not_set
 * for unrecognized IDs.
 *
 * Revision 6.83  2004/06/07 19:00:34  ucko
 * CSeq_id::CSeq_id(const string&): if we can't identify the string at
 * all, turn it into a local ID.
 *
 * Revision 6.82  2004/06/04 14:09:58  ucko
 * IdentifyAccession: CO now specifically assigned to eAcc_gb_est.
 *
 * Revision 6.81  2004/06/01 15:26:07  johnson
 * Make CompareOrdered a true model of strict weak ordering
 *
 * Revision 6.80  2004/05/28 20:09:44  johnson
 * Added Compare for seq-id type General (CDbtag)
 *
 * Revision 6.79  2004/05/21 14:41:46  dicuccio
 * Moved database tag for general IDs to content part of label
 *
 * Revision 6.78  2004/05/19 17:26:25  gorelenk
 * Added include of PCH - ncbi_pch.hpp
 *
 * Revision 6.77  2004/05/16 16:57:44  dicuccio
 * Removed insertion of db type in general seq-id labels of type content - led to
 * duplicates of type
 *
 * Revision 6.76  2004/05/14 14:34:02  dicuccio
 * Include database name in label content if the db-tag is just an integer
 *
 * Revision 6.75  2004/03/25 15:59:06  gouriano
 * Added possibility to copy and compare serial object non-recursively
 *
 * Revision 6.74  2004/03/22 16:24:19  ucko
 * CN is now specifically assigned to GenBank ESTs.
 *
 * Revision 6.73  2004/01/22 21:03:58  dicuccio
 * Separated functionality of enums in GetLabel() into discrete mode and flags
 *
 * Revision 6.72  2004/01/22 18:45:46  dicuccio
 * Added new API: CSeq_id::GetLabel().  Rewired GetSeqIdString() to feed into
 * GetLabel().  Rewired GetStringDescr() to feed into GetLabel() directly instead
 * of feeding through GetSeqIdString().
 *
 * Revision 6.71  2004/01/21 22:55:47  ucko
 * GetSeqIdString: drop the database name from general IDs for
 * compatibility with code that can't handle its presence.
 *
 * Revision 6.70  2004/01/21 18:04:20  dicuccio
 * Added ctor to create a seq-id from a given dbtag, performing conversion to
 * specific seq-id types where possible
 *
 * Revision 6.69  2004/01/20 16:59:38  ucko
 * CSeq_id::IdentifyAccession: identify IDs consisting solely of digits as GIs.
 *
 * Revision 6.68  2004/01/16 17:39:17  vasilche
 * Fixed parsing 'gnl|xxx|999' format - integer tag detection.
 *
 * Revision 6.67  2004/01/16 15:58:19  ucko
 * CM now specifically assigned to eAcc_gb_con.
 *
 * Revision 6.66  2003/12/18 18:55:59  ucko
 * CSeq_id::IdentifyAccession: CQ is EMBL patents, CR is EMBL genomes,
 * CS-CU are reserved for future EMBL nucleotide use.
 *
 * Revision 6.65  2003/12/16 16:00:16  ucko
 * CSeq_id::IdentifyAccession: CL is GenBank GSS, CM-CP are GenBank
 * nucleotides to be assigned to specific projects as needed.
 *
 * Revision 6.64  2003/11/10 15:05:42  ucko
 * +CK to eAcc_gb_est
 *
 * Revision 6.63  2003/10/31 20:16:07  ucko
 * CSeq_id::IdentifyAccession: CI and CJ are both DDBJ EST.
 *
 * Revision 6.62  2003/10/24 14:57:03  ucko
 * IdentifyAccession: CH -> eAcc_gb_con.
 * GetSeqIdString: include the database name for IDs of type general.
 *
 * Revision 6.61  2003/08/25 21:15:41  ucko
 * Tweak slightly for efficiency.
 *
 * Revision 6.60  2003/08/22 15:16:48  dondosha
 * Correction in CSeq_id constructor, to allow id strings starting with a gi id
 *
 * Revision 6.59  2003/08/11 14:37:20  ucko
 * IdentifyAccession: "CG" is GenBank GSS.
 *
 * Revision 6.58  2003/07/14 20:11:59  ucko
 * +CF (eAcc_gb_est)
 *
 * Revision 6.57  2003/07/02 13:46:14  ucko
 * +CE (eAcc_gb_gss)
 *
 * Revision 6.56  2003/06/24 16:33:48  ucko
 * CSeq_id::IdentifyAccession: always return unknown for accessions that
 * contain no digits, even if they happen to look like prefixes.
 *
 * Revision 6.55  2003/05/09 14:22:56  ucko
 * CSeq_id::x_Init: treat missing (chain) names as spaces (reported by
 * Michel Dumontier) and get rid of some unnecessary calls to c_str().
 *
 * Revision 6.54  2003/04/30 14:41:01  ucko
 * CSeq_id::IdentifyAccession: CDnnnnnn -> eAcc_gb_est
 *
 * Revision 6.53  2003/03/25 15:37:18  ucko
 * CSeq_id::IdentifyAccession("CC...") -> eAcc_gb_gss
 *
 * Revision 6.52  2003/03/11 15:55:44  kuznets
 * iterate -> ITERATE
 *
 * Revision 6.51  2003/02/06 22:23:29  vasilche
 * Added CSeq_id::Assign(), CSeq_loc::Assign().
 * Added int CSeq_id::Compare() (not safe).
 * Added caching of CSeq_loc::GetTotalRange().
 *
 * Revision 6.50  2003/02/04 15:15:12  grichenk
 * Overrided Assign() for CSeq_loc and CSeq_id
 *
 * Revision 6.49  2003/01/18 08:40:03  kimelman
 * addes seqid constructor for numeric types
 *
 * Revision 6.48  2003/01/15 18:27:13  ucko
 * +AK (accidentally skipped earlier -- sigh)
 *
 * Revision 6.47  2003/01/10 15:57:30  ucko
 * Identify CB as gb_est.
 *
 * Revision 6.46  2003/01/08 16:48:03  ucko
 * +AL (accidentally skipped earlier)
 *
 * Revision 6.45  2003/01/07 19:52:15  ucko
 * Add more refseq types (NR_, NS_, NW_).
 *
 * Revision 6.44  2002/12/30 23:44:42  vakatov
 * CSeq_id::GetStringDescr() -- un-freeze "strstream" to avoid a mem.leak
 *
 * Revision 6.43  2002/12/26 16:39:25  vasilche
 * Object manager class CSeqMap rewritten.
 *
 * Revision 6.42  2002/12/03 15:55:12  dicuccio
 * Corrected processing of text id accessions with no accession set (in
 * GetSeqIdString()) - use name instead.
 *
 * Revision 6.41  2002/11/26 15:13:32  dicuccio
 * Added CSeq_id::GetStringDescr() - provides text representations of seq-ids in a
 * number of formats.
 *
 * Revision 6.40  2002/10/23 18:23:07  ucko
 * Add self-classification (using known type information).
 *
 * Revision 6.39  2002/10/22 20:19:14  jianye
 * Added GetSeqIdString()
 *
 * Revision 6.38  2002/10/18 16:03:08  ucko
 * +CA (eAcc_gb_est)
 *
 * Revision 6.37  2002/10/03 18:55:04  clausen
 * Removed extra whitespace
 *
 * Revision 6.36  2002/10/03 17:17:11  clausen
 * Added BestRank() and WorstRank()
 *
 * Revision 6.35  2002/10/03 16:03:00  ucko
 * +BZ (eAcc_gb_gss)
 *
 * Revision 6.34  2002/09/23 16:43:46  ucko
 * Change check for absence of '|' to use string::find.
 *
 * Revision 6.33  2002/09/20 19:55:29  ucko
 * +BY (eAcc_ddbj_est)
 *
 * Revision 6.32  2002/08/28 14:07:56  ucko
 * IdentifyAccession: handle BX (EMBL genome)
 *
 * Revision 6.31  2002/08/26 20:44:06  ucko
 * CSeq_id::IdentifyAccession: +BW (DDBJ EST)
 *
 * Revision 6.30  2002/08/19 16:54:30  ucko
 * IdentifyAccession: add BV (eAcc_gb_sts).
 *
 * Revision 6.29  2002/08/19 15:42:14  ucko
 * IdentifyAccession: add BU (eAcc_gb_est).
 *
 * Revision 6.28  2002/08/16 19:27:01  ucko
 * Recognize new WGS RefSeq accessions.
 *
 * Revision 6.27  2002/08/14 15:52:27  ucko
 * Add BT and XR_.
 *
 * Revision 6.26  2002/08/06 18:22:19  ucko
 * Properly handle versioned PDB accessions.
 *
 * Revision 6.25  2002/08/01 20:33:10  ucko
 * s_IdentifyAccession -> IdentifyAccession; s_ is only for module-static names.
 *
 * Revision 6.24  2002/07/30 19:42:44  ucko
 * Add s_IdentifyAccession, and use it in the string-based constructor if
 * the input isn't FASTA-format.
 * Move CVS log to end.
 *
 * Revision 6.23  2002/06/06 20:31:33  clausen
 * Moved methods using object manager to objects/util
 *
 * Revision 6.22  2002/05/22 14:03:40  grichenk
 * CSerialUserOp -- added prefix UserOp_ to Assign() and Equals()
 *
 * Revision 6.21  2002/05/06 03:39:12  vakatov
 * OM/OM1 renaming
 *
 * Revision 6.20  2002/05/03 21:28:17  ucko
 * Introduce T(Signed)SeqPos.
 *
 * Revision 6.19  2002/01/16 18:56:32  grichenk
 * Removed CRef<> argument from choice variant setter, updated sources to
 * use references instead of CRef<>s
 *
 * Revision 6.18  2002/01/10 19:00:04  clausen
 * Added GetLength
 *
 * Revision 6.17  2002/01/09 15:59:30  grichenk
 * Fixed includes
 *
 * Revision 6.16  2001/10/15 23:00:00  vakatov
 * CSeq_id::x_Init() -- get rid of unreachable "break;"
 *
 * Revision 6.15  2001/08/31 20:05:44  ucko
 * Fix ICC build.
 *
 * Revision 6.14  2001/08/31 16:02:10  clausen
 * Added new constructors for Fasta and added new id types, tpd, tpe, tpg
 *
 * Revision 6.13  2001/07/16 16:22:48  grichenk
 * Added CSerialUserOp class to create Assign() and Equals() methods for
 * user-defind classes.
 * Added SerialAssign<>() and SerialEquals<>() functions.
 *
 * Revision 6.12  2001/05/24 20:24:27  grichenk
 * Renamed seq/objmgrstub.hpp -> obgmgr/objmgr_base.hpp
 * Added Genbank, Embl and Ddbj support in CSeq_id::Compare()
 * Fixed General output by CSeq_id::WriteAsFasta()
 *
 * Revision 6.11  2001/04/17 04:14:49  vakatov
 * CSeq_id::AsFastaString() --> CSeq_id::WriteAsFasta()
 *
 * Revision 6.10  2001/01/03 16:39:05  vasilche
 * Added CAbstractObjectManager - stub for object manager.
 * CRange extracted to separate file.
 *
 * Revision 6.9  2000/12/26 17:28:55  vasilche
 * Simplified and formatted code.
 *
 * Revision 6.8  2000/12/15 19:30:31  ostell
 * Used Upcase() in AsFastaString() and changed to PNocase().Equals() style
 *
 * Revision 6.7  2000/12/08 22:19:45  ostell
 * changed MakeFastString to AsFastaString and to use ostream instead of string
 *
 * Revision 6.6  2000/12/08 20:45:14  ostell
 * added MakeFastaString()
 *
 * Revision 6.5  2000/12/04 15:09:41  vasilche
 * Added missing include.
 *
 * Revision 6.4  2000/11/30 22:08:18  ostell
 * finished Match()
 *
 * Revision 6.3  2000/11/30 16:13:12  ostell
 * added support for Textseq_id to Seq_id.Match()
 *
 * Revision 6.2  2000/11/28 12:47:41  ostell
 * fixed first switch statement to break properly
 *
 * Revision 6.1  2000/11/21 18:58:29  vasilche
 * Added Match() methods for CSeq_id, CObject_id and CDbtag.
 *
 * ===========================================================================
 */
