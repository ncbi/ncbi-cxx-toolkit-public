/* $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author:  .......
 *
 * File Description:
 *   .......
 *
 * Remark:
 *   This code was originally generated by application DATATOOL
 *   using the following specifications:
 *   'seqtable.asn'.
 */

// standard includes
#include <ncbi_pch.hpp>

// generated includes
#include <objects/seqtable/SeqTable_column_info.hpp>
#include <util/static_map.hpp>

// generated classes

BEGIN_NCBI_SCOPE

BEGIN_objects_SCOPE // namespace ncbi::objects::

// destructor
CSeqTable_column_info::~CSeqTable_column_info(void)
{
}


typedef pair<const char*, CSeqTable_column_info::EField_id> TNameToIdPair;
static const TNameToIdPair s_NameToIdArr[] = {
    TNameToIdPair("comment", CSeqTable_column_info::eField_id_comment),
    TNameToIdPair("data.cdregion.frame", CSeqTable_column_info::eField_id_data_cdregion_frame),
    TNameToIdPair("data.imp.key", CSeqTable_column_info::eField_id_data_imp_key),
    TNameToIdPair("data.region", CSeqTable_column_info::eField_id_data_region),
    TNameToIdPair("dbxref.db", CSeqTable_column_info::eField_id_dbxref_db),
    TNameToIdPair("dbxref.tag", CSeqTable_column_info::eField_id_dbxref_tag),
    TNameToIdPair("ext.type", CSeqTable_column_info::eField_id_ext_type),
    TNameToIdPair("id.local", CSeqTable_column_info::eField_id_id_local),
    TNameToIdPair("location", CSeqTable_column_info::eField_id_location),
    TNameToIdPair("location.from", CSeqTable_column_info::eField_id_location_from),
    TNameToIdPair("location.fuzz.from.lim", CSeqTable_column_info::eField_id_location_fuzz_from_lim),
    TNameToIdPair("location.fuzz.to.lim", CSeqTable_column_info::eField_id_location_fuzz_to_lim),
    TNameToIdPair("location.gi", CSeqTable_column_info::eField_id_location_gi),
    TNameToIdPair("location.id", CSeqTable_column_info::eField_id_location_id),
    TNameToIdPair("location.strand", CSeqTable_column_info::eField_id_location_strand),
    TNameToIdPair("location.to", CSeqTable_column_info::eField_id_location_to),
    TNameToIdPair("partial", CSeqTable_column_info::eField_id_partial),
    TNameToIdPair("product", CSeqTable_column_info::eField_id_product),
    TNameToIdPair("product.from", CSeqTable_column_info::eField_id_product_from),
    TNameToIdPair("product.fuzz.from.lim", CSeqTable_column_info::eField_id_product_fuzz_from_lim),
    TNameToIdPair("product.fuzz.to.lim", CSeqTable_column_info::eField_id_product_fuzz_to_lim),
    TNameToIdPair("product.gi", CSeqTable_column_info::eField_id_product_gi),
    TNameToIdPair("product.id", CSeqTable_column_info::eField_id_product_id),
    TNameToIdPair("product.strand", CSeqTable_column_info::eField_id_product_strand),
    TNameToIdPair("product.to", CSeqTable_column_info::eField_id_product_to),
    TNameToIdPair("qual.qual", CSeqTable_column_info::eField_id_qual_qual),
    TNameToIdPair("qual.val", CSeqTable_column_info::eField_id_qual_val),
    TNameToIdPair("title", CSeqTable_column_info::eField_id_title),
    TNameToIdPair("xref.id.local", CSeqTable_column_info::eField_id_xref_id_local)
};

typedef CStaticArrayMap<const char*, CSeqTable_column_info::EField_id, PCase_CStr> TNameToIdMap;

DEFINE_STATIC_ARRAY_MAP(TNameToIdMap, s_NameToIdMap, s_NameToIdArr);

static const char* s_Field_id_names[] = {
    "location",
    "location.id",
    "location.gi",
    "location.from",
    "location.to",
    "location.strand",
    "location.fuzz.from.lim",
    "location.fuzz.to.lim",
    "",
    "",
    "product",
    "product.id",
    "product.gi",
    "product.from",
    "product.to",
    "product.strand",
    "product.fuzz.from.lim",
    "product.fuzz.to.lim",
    "",
    "",
    "id.local",
    "xref.id.local",
    "partial",
    "comment",
    "title",
    "", //    ext, field-name must be "E.xxx"
    "", //   qual, field-name must be "Q.xxx"
    "", // dbxref, field-name must be "D.xxx"
    "",
    "",
    "data.imp.key",
    "data.region",
    "data.cdregion.frame",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "ext.type",
    "qual.qual",
    "qual.val",
    "dbxref.db",
    "dbxref.tag"
};


int CSeqTable_column_info::GetIdForName(const string& name)
{
    TNameToIdMap::const_iterator iter = s_NameToIdMap.find(name.c_str());
    return iter == s_NameToIdMap.end()? -1: iter->second;
}


const char* CSeqTable_column_info::GetNameForId(int id)
{
    size_t index = id;
    if ( index < sizeof(s_Field_id_names)/sizeof(s_Field_id_names[0]) ) {
        return s_Field_id_names[index];
    }
    return "";
}


END_objects_SCOPE // namespace ncbi::objects::

END_NCBI_SCOPE
