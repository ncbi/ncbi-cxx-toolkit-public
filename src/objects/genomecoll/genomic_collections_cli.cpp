/* $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author:  Vinay Kumar
 *
 * File Description:
 *   .......
 *
 * Remark:
 *   This code was originally generated by application DATATOOL
 *   using the following specifications:
 *   'gencoll_client.asn'.
 */

// standard includes
#include <ncbi_pch.hpp>

// generated includes
#include <objects/genomecoll/genomic_collections_cli.hpp>
#include <objects/genomecoll/GCClient_AssemblyInfo.hpp>
#include <objects/genomecoll/GCClient_AssemblySequenceI.hpp>
#include <objects/genomecoll/GCClient_AssembliesForSequ.hpp>
#include <objects/genomecoll/GCClient_Error.hpp>
#include <objects/genomecoll/GC_Assembly.hpp>
#include <objects/genomecoll/GCClient_ValidateChrTypeLo.hpp>
#include <objects/genomecoll/GCClient_EquivalentAssembl.hpp>
#include <objects/genomecoll/GCClient_GetEquivalentAsse.hpp>
#include <sstream>
#include <util/compress/stream_util.hpp>

// generated classes

BEGIN_NCBI_SCOPE

BEGIN_objects_SCOPE // namespace ncbi::objects::

// constructor
CGenomicCollectionsService::CGenomicCollectionsService(void)
{
}

CGenomicCollectionsService::CGenomicCollectionsService(const string& url)
: m_url(url)
{
}

// destructor
CGenomicCollectionsService::~CGenomicCollectionsService(void)
{
}


string CGenomicCollectionsService::x_GetURL()
{
    return m_url;
}

void CGenomicCollectionsService::x_Connect()
{
#ifdef _DEBUG
    LOG_POST(Info << "Connecting to url:" << x_GetURL().c_str());
#endif
    STimeout to5Min;
    to5Min.sec=600;
    to5Min.usec=0;
    SetTimeout(&to5Min);

    string url = x_GetURL();
    if(url.empty())
        CGenomicCollectionsService_Base::x_Connect();
    else
        x_ConnectURL(url);
}

static
CRef<CGC_Assembly> AssemblyFromBlob(const vector<char>& blob)
{
    const string blobStr(blob.begin(), blob.end());
    return CCachedAssembly(blobStr).Assembly();
}

CRef<CGC_Assembly> CGenomicCollectionsService::GetAssembly(const string& acc, 
                                            int level, 
                                            int asmAttrFlags, 
                                            int chrAttrFlags, 
                                            int scafAttrFlags, 
                                            int compAttrFlags)
{
    CGCClient_GetAssemblyRequest req;
    CGCClientResponse reply;

    req.SetAccession(acc);
    req.SetLevel(level);
    req.SetAssm_flags(asmAttrFlags);
    req.SetChrom_flags(chrAttrFlags);
    req.SetScaf_flags(scafAttrFlags);
    req.SetComponent_flags(compAttrFlags);

#ifdef _DEBUG
    ostringstream ostrstrm;
    ostrstrm << "Making request -" << MSerial_AsnText << req;
    LOG_POST(Info << ostrstrm.str());
#endif

    try {
        return AssemblyFromBlob(AskGet_assembly_blob(req, &reply));
    } catch (CException& ex) {
        if(reply.Which() == CGCClientResponse::e_Srvr_error) {
            NCBI_THROW(CException, eUnknown, reply.GetSrvr_error().GetDescription());
        }
        throw;
    }
}


CRef<CGC_Assembly> CGenomicCollectionsService::GetAssembly(int releaseId, 
                                            int level, 
                                            int asmAttrFlags, 
                                            int chrAttrFlags, 
                                            int scafAttrFlags, 
                                            int compAttrFlags)
{
    CGCClient_GetAssemblyRequest req;
    CGCClientResponse reply;
    
    req.SetRelease_id(releaseId);
    req.SetLevel(level);
    req.SetAssm_flags(asmAttrFlags);
    req.SetChrom_flags(chrAttrFlags);
    req.SetScaf_flags(scafAttrFlags);
    req.SetComponent_flags(compAttrFlags);

#ifdef _DEBUG
    ostringstream ostrstrm;
    ostrstrm << "Making request -" << MSerial_AsnText << req;
    LOG_POST(Info << ostrstrm.str());
#endif
    
    try {
        return AssemblyFromBlob(AskGet_assembly_blob(req, &reply));
    } catch (CException& ex) {
        if(reply.Which() == CGCClientResponse::e_Srvr_error) {
            NCBI_THROW(CException, eUnknown, reply.GetSrvr_error().GetDescription());
        }
        throw;
    }
}

CRef<CGC_Assembly> CGenomicCollectionsService::GetAssembly(const string& acc, CGCClient_GetAssemblyRequest::EAssemblyMode mode)
{
    CGCClient_GetAssemblyRequest::SRequestParam params;
    if(!params.SetMode(mode))
        NCBI_THROW(CException, eUnknown, "GetAssembly: Illegal mode passed.");

    return GetAssembly(acc,
                       params.level,
                       params.assembly_flags,
                       params.chromosome_flags,
                       params.scaffold_flags,
                       params.component_flags);
}

CRef<CGC_Assembly> CGenomicCollectionsService::GetAssembly(int releaseId, CGCClient_GetAssemblyRequest::EAssemblyMode mode)
{
    CGCClient_GetAssemblyRequest::SRequestParam params;
    if(!params.SetMode(mode))
        NCBI_THROW(CException, eUnknown, "GetAssembly: Illegal mode passed.");

    return GetAssembly(releaseId,
                       params.level,
                       params.assembly_flags,
                       params.chromosome_flags,
                       params.scaffold_flags,
                       params.component_flags);
}

string CGenomicCollectionsService::ValidateChrType(const string& chrType, const string& chrLoc)
{
    CGCClient_ValidateChrTypeLocRequest req;
    CGCClientResponse reply;
    
    req.SetType(chrType);
    req.SetLocation(chrLoc);
    
#ifdef _DEBUG
    ostringstream ostrstrm;
    ostrstrm << "Making request -" << MSerial_AsnText << req;
    LOG_POST(Info << ostrstrm.str());
#endif
    
    try {
        return AskGet_chrtype_valid(req, &reply);
    } catch (CException& ex) {
        if(reply.Which() == CGCClientResponse::e_Srvr_error) {
            NCBI_THROW(CException, eUnknown, reply.GetSrvr_error().GetDescription());
        }
        throw;
    }
}


CRef<CGCClient_AssemblyInfo> CGenomicCollectionsService::FindBestAssembly(const string& seq_id, int filter_type, int sort_type)
{
    CGCClient_FindBestAssemblyRequest  req;
    CGCClientResponse reply;

    req.SetSeq_id_acc().push_back(seq_id);
    req.SetFilter(filter_type);
    req.SetSort(sort_type);
    req.SetAssembly_return_limit(1);

#ifdef _DEBUG
    ostringstream ostrstrm;
    ostrstrm << "Making request -" << MSerial_AsnText << req;
    LOG_POST(Info << ostrstrm.str());
#endif

    try {
        CRef<CGCClient_AssembliesForSequences> assm = AskGet_best_assembly(req, &reply);

        return assm->CanGetAssemblies() && !assm->GetAssemblies().empty() ?
               CRef<CGCClient_AssemblyInfo>(&assm->SetAssemblies().front()->SetAssembly()) :
               CRef<CGCClient_AssemblyInfo>();
    } catch (const CException& ex) {
        if(reply.IsSrvr_error()) {
            NCBI_REPORT_EXCEPTION(reply.GetSrvr_error().GetDescription(), ex);
        }
        throw;
    }
}


CRef<CGCClient_AssemblySequenceInfo> CGenomicCollectionsService::FindBestAssembly(const list<string>& seq_id, int filter_type, int sort_type)
{
    CGCClient_FindBestAssemblyRequest  req;
    CGCClientResponse reply;

    req.SetSeq_id_acc().assign(seq_id.begin(), seq_id.end());
    req.SetFilter(filter_type);
    req.SetSort(sort_type);
    req.SetAssembly_return_limit(1);

#ifdef _DEBUG
    ostringstream ostrstrm;
    ostrstrm << "Making request -" << MSerial_AsnText << req;
    LOG_POST(Info << ostrstrm.str());
#endif

    try {
        CRef<CGCClient_AssembliesForSequences> assm = AskGet_best_assembly(req, &reply);

        return assm->CanGetAssemblies() && !assm->GetAssemblies().empty() ?
               CRef<CGCClient_AssemblySequenceInfo>(assm->SetAssemblies().front()) :
               CRef<CGCClient_AssemblySequenceInfo>();
    } catch (const CException& ex) {
        if(reply.IsSrvr_error()) {
            NCBI_REPORT_EXCEPTION(reply.GetSrvr_error().GetDescription(), ex);
        }
        throw;
    }
}


CRef<CGCClient_AssembliesForSequences> CGenomicCollectionsService::FindAllAssemblies(const list<string>& seq_id, int filter_type, int sort_type)
{
    CGCClient_FindBestAssemblyRequest  req;
    CGCClientResponse reply;

    req.SetSeq_id_acc().assign(seq_id.begin(), seq_id.end());
    req.SetFilter(filter_type);
    req.SetSort(sort_type);

#ifdef _DEBUG
    ostringstream ostrstrm;
    ostrstrm << "Making request -" << MSerial_AsnText << req;
    LOG_POST(Info << ostrstrm.str());
#endif

    try {
        CRef<CGCClient_AssembliesForSequences> assm = AskGet_best_assembly(req, &reply);

        return assm;
    } catch (const CException& ex) {
        if(reply.IsSrvr_error()) {
            NCBI_REPORT_EXCEPTION(reply.GetSrvr_error().GetDescription(), ex);
        }
        throw;
    }
}


CRef<CGCClient_EquivalentAssemblies> CGenomicCollectionsService::GetEquivalentAssemblies(const string& acc, int equivalency)
{
    CGCClient_GetEquivalentAssembliesRequest req;
    CGCClientResponse reply;

    req.SetAccession(acc);
    req.SetEquivalency(equivalency);

#ifdef _DEBUG
    ostringstream ostrstrm;
    ostrstrm << "Making request -" << MSerial_AsnText << req;
    LOG_POST(Info << ostrstrm.str());
#endif

    try {
        CRef<CGCClient_EquivalentAssemblies> assm = AskGet_equivalent_assemblies(req, &reply);

        return assm;
    } catch (const CException& ex) {
        if(reply.IsSrvr_error()) {
            NCBI_REPORT_EXCEPTION(reply.GetSrvr_error().GetDescription(), ex);
        }
        throw;
    }
}


END_objects_SCOPE // namespace ncbi::objects::

USING_SCOPE(objects);

CCachedAssembly::CCachedAssembly(CRef<CGC_Assembly> assembly)
        : m_assembly(assembly)
{}

CCachedAssembly::CCachedAssembly(const string& blob)
        : m_blob(blob)
{}

CRef<CGC_Assembly> CCachedAssembly::Assembly()
{
    if (m_assembly.NotNull()) {
        return m_assembly;
    }

    if (ValidBlob(m_blob.size())) {
        CNcbiIstrstream istr(m_blob.data(), m_blob.size());
        CDecompressIStream decmp_strm(istr, CCompressStream::eBZip2);
        m_assembly.Reset(new CGC_Assembly);
        decmp_strm >> MSerial_AsnBinary
        >> MSerial_SkipUnknownMembers(eSerialSkipUnknown_Yes)   // Make reading cache backward compatible
        >> MSerial_SkipUnknownVariants(eSerialSkipUnknown_Yes)
        >> (*m_assembly);
    }
    return m_assembly;
}

const string& CCachedAssembly::Blob()
{
    if (!m_blob.empty()) {
        return m_blob;
    }

    CNcbiOstrstream sstrm;
    CCompressOStream cmpstrm(sstrm, CCompressStream::eBZip2);

    cmpstrm << MSerial_AsnBinary << (*m_assembly);
    cmpstrm.Finalize();

    m_blob = CNcbiOstrstreamToString( sstrm );

    return m_blob;
}

bool CCachedAssembly::ValidBlob(int blobSize) {
    const int kSmallestZip(200); // No assembly, let alone a compressed one, will be smaller than this.
    return blobSize >= kSmallestZip;
}

END_NCBI_SCOPE

/* Original file checksum: lines: 57, chars: 1793, CRC32: a9ae6ff4 */
