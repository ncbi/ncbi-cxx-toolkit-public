/* $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author:  .......
 *
 * File Description:
 *   .......
 *
 * Remark:
 *   This code was originally generated by application DATATOOL
 *   using specifications from the ASN data definition file
 *   'cdd.asn'.
 *
 * ---------------------------------------------------------------------------
 * $Log$
 * Revision 1.2  2002/06/07 18:35:48  hurwitz
 * fix 2 bugs for Solaris compilation
 *
 * Revision 1.1  2002/06/07 14:44:11  hurwitz
 * extra functions for cdd objects
 *
 *
 * ===========================================================================
 */

// standard includes

// generated includes
#include <objects/general/Date.hpp>
#include <objects/cdd/Cdd.hpp>
#include <objects/cdd/Cdd_descr_set.hpp>
#include <objects/cdd/Cdd_descr.hpp>
#include <objects/cdd/Cdd_id_set.hpp>
#include <objects/cdd/Cdd_id.hpp>
#include <objects/cdd/Feature_evidence.hpp>
#include <objects/seq/Bioseq.hpp>
#include <objects/seq/Seq_annot.hpp>
#include <objects/seqalign/Dense_diag.hpp>
#include <objects/seqalign/Seq_align.hpp>
#include <objects/seqset/Bioseq_set.hpp>
#include <objects/seqset/Seq_entry.hpp>
#include <objects/seqloc/Seq_loc.hpp>
#include <objects/seqloc/Seq_id.hpp>
#include <objects/seqloc/Seq_interval.hpp>
#include <objects/seqloc/PDB_mol_id.hpp>
#include <objects/cdd/Global_id.hpp>
#include <objects/mmdb1/Biostruc_annot_set.hpp>
#include <objects/mmdb1/Biostruc_id.hpp>
#include <objects/mmdb1/Mmdb_id.hpp>
#include <objects/general/Dbtag.hpp>
#include <objects/general/Object_id.hpp>

// generated classes

BEGIN_NCBI_SCOPE

BEGIN_objects_SCOPE // namespace ncbi::objects::

// destructor
CCdd::~CCdd(void) {
}


void CCdd::EraseStructureEvidence() {
//-------------------------------------------------------------------------
// erase structure evidence for sequences that are no longer present
//-------------------------------------------------------------------------
  list< CRef< CFeature_evidence > >::iterator  FeatureIterator;

  // make list of current mmdb id's
  int  id;
  list<int> MmdbIds;
  for (int SeqIndex=0; SeqIndex<GetNumSequences(); SeqIndex++) {
    if (GetMmdbId(SeqIndex, id)) {
      MmdbIds.push_back(id);
    }
  }

  // delete structure evidence for mmdb-id's not in the list
  while (IsNoEvidenceFor(MmdbIds, FeatureIterator)) {
    GetFeatureSet(MmdbIds).erase(FeatureIterator);
  }
}


list< CRef< CFeature_evidence > >& CCdd::GetFeatureSet(list<int>& MmdbIds) {
//-------------------------------------------------------------------------
// this function mirrors IsNoEvidenceFor.  It returns the list of features
// that is modified.
//-------------------------------------------------------------------------
  list< CRef< CAlign_annot > >::iterator  i;
  list< CRef< CFeature_evidence > >::iterator j;
  list< CRef< CBiostruc_id > >::iterator k;
  list< int >::iterator  m;
  bool  FoundIt;

  // look through each align-annot in the align-annot-set
  if (IsSetAlignannot()) {
    for (i=SetAlignannot().Set().begin(); i!=SetAlignannot().Set().end(); i++) {
      // look through each feature-evidence in the feature-evidence-set
      if ((*i)->IsSetEvidence()) {
        for (j=(*i)->SetEvidence().begin(); j!=(*i)->SetEvidence().end(); j++) {
          // look through each biostruc-id in the biostruc-id-set
          if ((*j)->IsBsannot()) {
            if ((*j)->SetBsannot().IsSetId()) {
              for (k=(*j)->SetBsannot().SetId().begin(); k!=(*j)->SetBsannot().SetId().end(); k++) {
                if ((*k)->IsMmdb_id()) {
                  // if biostruc id is NOT in the list return list to delete id from
                  FoundIt = false;
                  for (m=MmdbIds.begin(); m!=MmdbIds.end(); m++) {
                    if ((*m) == (*k)->GetMmdb_id().Get()) {
                      FoundIt = true;
                    }
                  }
                  if (!FoundIt) {
                    return((*i)->SetEvidence());
                  }
                }
              }
            }
          }
        }
      }
    }
  }
//  assert(false);   // should never get here
  return((*i)->SetEvidence());
}


bool CCdd::IsNoEvidenceFor(list<int>& MmdbIds,
                           list< CRef< CFeature_evidence > >::iterator& FeatureIterator) {
//------------------------------------------------------------------------------------
// look through the feature-evidence of each align-annot-set.
// return true if there's an id that needs to be deleted from a structure-evidence.
//------------------------------------------------------------------------------------
  list< CRef< CAlign_annot > >::iterator  i;
  list< CRef< CFeature_evidence > >::iterator j;
  list< CRef< CBiostruc_id > >::iterator k;
  list<int>::iterator  m;
  bool  FoundIt;

  // look through each align-annot in the align-annot-set
  if (IsSetAlignannot()) {
    for (i=SetAlignannot().Set().begin(); i!=SetAlignannot().Set().end(); i++) {
      // look through each feature-evidence in the feature-evidence-set
      if ((*i)->IsSetEvidence()) {
        for (j=(*i)->SetEvidence().begin(); j!=(*i)->SetEvidence().end(); j++) {
          // look through each biostruc-id in the biostruc-id-set
          if ((*j)->IsBsannot()) {
            if ((*j)->SetBsannot().IsSetId()) {
              for (k=(*j)->SetBsannot().SetId().begin(); k!=(*j)->SetBsannot().SetId().end(); k++) {
                if ((*k)->IsMmdb_id()) {
                  // if biostruc id is NOT in the list return true
                  FoundIt = false;
                  for (m=MmdbIds.begin(); m!=MmdbIds.end(); m++) {
                    if ((*m) == (*k)->GetMmdb_id().Get()) {
                      FoundIt = true;
                    }
                  }
                  if (!FoundIt) {
                    FeatureIterator = j;
                    return(true);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return(false);
}


bool CCdd::GetMmdbId(int SeqIndex, int& id) {
//-------------------------------------------------------------------------
// get mmdb-id from sequence list
//-------------------------------------------------------------------------
  list< CRef< CSeq_entry > >::const_iterator  i;
  list< CRef< CSeq_annot > >::const_iterator  j;
  list< CRef< CSeq_id > >::const_iterator k;
  int  Count;

  if (IsSetSequences()) {
    if (GetSequences().IsSet()) {
      Count = 0;
      // look through each sequence in set for SeqIndex sequence
      for (i=GetSequences().GetSet().GetSeq_set().begin();
           i!=GetSequences().GetSet().GetSeq_set().end(); i++) {
        if (Count == SeqIndex) {
          if ((*i)->IsSeq()) {
            // look through each seq-annot
            if ((*i)->GetSeq().IsSetAnnot()) {
              for (j = (*i)->GetSeq().GetAnnot().begin(); j!= (*i)->GetSeq().GetAnnot().end(); j++) {
                // look through ids for an mmdb id
                if ((*j)->GetData().IsIds()) {
                  for (k = (*j)->GetData().GetIds().begin(); k != (*j)->GetData().GetIds().end(); k++) {
                    if ((*k)->IsGeneral()) {
                      if ((*k)->GetGeneral().GetDb() == "mmdb") {
                        if ((*k)->GetGeneral().GetTag().IsId()) {
                          id = (*k)->GetGeneral().GetTag().GetId();
                          return(true);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        Count++;
      }
    }
  }
  return(false);
}


void CCdd::EraseSequences() {
//-------------------------------------------------------------------------
// erase sequences not in alignment
//-------------------------------------------------------------------------
  int  i, NumSequences;
  CRef<CSeq_id>  ID;

  NumSequences = GetNumSequences();
  for (i=NumSequences-1; i>=0; i--) {
    GetSeqID(i, ID);
    if (!IsAMatchFor(ID)) {
      EraseSequence(i);
    }
  }
  // testing
  NumSequences = GetNumSequences();
}


void CCdd::EraseSequence(int SeqIndex) {
//-------------------------------------------------------------------------
// erase a sequence from the set of sequences
//-------------------------------------------------------------------------
  list< CRef< CSeq_entry > >::iterator  i;
  int  Count;

  if (IsSetSequences()) {
    if (GetSequences().IsSet()) {
      Count = 0;
      for (i=SetSequences().SetSet().SetSeq_set().begin();
           i!=SetSequences().SetSet().SetSeq_set().end(); i++) {
        if (Count == SeqIndex) {
          SetSequences().SetSet().SetSeq_set().erase(i);
          return;
        }
        Count++;
      }
    }
  }
}


bool CCdd::IsAMatchFor(CRef<CSeq_id>& ID) {
//-------------------------------------------------------------------------
// look through each row of the alignment for a matching ID
//-------------------------------------------------------------------------
  int  k, Pair, DenDiagRow, NumRows=GetNumRows();
  CRef< CSeq_id >  TestID;

  for (k=0; k<NumRows; k++) {
    Pair = (k <= 1) ? 0 : k-1;
    DenDiagRow = (k == 0) ? 0 : 1;
    GetSeqID(Pair, DenDiagRow, TestID);
    if (SeqIdsMatch(ID, TestID)) {
      return(true);
    }
  }
  return(false);
}


bool CCdd::SeqIdsMatch(CRef<CSeq_id>& ID1, CRef<CSeq_id>& ID2) {
//-------------------------------------------------------------------------
// return true if the 2 sequence-id's match
//-------------------------------------------------------------------------
  if (ID1->IsGi() && ID2->IsGi()) {
    if (ID1->GetGi() == ID2->GetGi()) {
      return(true);
    }
  }
  if (ID1->IsPdb() && ID2->IsPdb()) {
    if (ID1->GetPdb().GetMol().Get() == ID2->GetPdb().GetMol().Get()) {
      if (ID1->GetPdb().GetChain() == ID2->GetPdb().GetChain()) {
        return(true);
      }
    }
  }
  return(false);
}


bool CCdd::EraseRows(std::deque<int>& KeepRows) {
//-------------------------------------------------------------------------
// erase rows from the alignment.
// KeepRows is a list of rows that are NOT deleted from this CD.
// KeepRows won't contain the master (0 index) row.
//-------------------------------------------------------------------------
  list< CRef< CSeq_annot > >::iterator i;
  int   j, k, NumRows;
  bool  FoundIt;

  if (IsSetSeqannot()) {
    i = SetSeqannot().begin();
    // for each row of the alignment except the master row
    NumRows = (*i)->SetData().SetAlign().size() + 1;
    for (j=NumRows-1; j>0; j--) {
      // see if row is in KeepRows
      FoundIt = false;
      for (k=0; k<KeepRows.size(); k++) {
        if (KeepRows[k] == j) {
          FoundIt = true;
          break;
        }
      }
      // if row is not in KeepRows, then erase it
      if (!FoundIt) {
        if (!EraseRow(j)) {
          return(false);
        }
      }
    }
  }
  return(true);
}


bool CCdd::EraseRow(int RowIndex) {
//-------------------------------------------------------------------------
// Erase the RowIndex-1 seq-align.  don't erase RowIndex 0.
//-------------------------------------------------------------------------
  list< CRef< CSeq_annot > >::iterator i;
  list< CRef< CSeq_align > >::iterator j;
  int  Count;

  if (RowIndex == 0) return(false);

  if (IsSetSeqannot()) {
    i = SetSeqannot().begin();
    if ((*i)->GetData().IsAlign()) {
      Count = 1;
      for (j= (*i)->SetData().SetAlign().begin();
           j!= (*i)->SetData().SetAlign().end(); j++) {
        if (Count == RowIndex) {
          (*i)->SetData().SetAlign().erase(j);
          return(true);
        }
        Count++;
      }
    }
  }
  return(false);
}


bool CCdd::ReMaster(int Row) {
//-------------------------------------------------------------------------
// make Row the new master of this CD.
// TDendiag = list< CRef< CDense_diag > >
//-------------------------------------------------------------------------
  TDendiag*  pDenDiagSet1;
  TDendiag*  pDenDiagSet2;
  list< CRef< CDense_diag > >::iterator  i, ii;
  list< CRef< CSeq_id > >::iterator  j, jj;
  CRef< CSeq_id >  pTempSeqId1, pTempSeqId2;
  list< unsigned int >::iterator  k, kk;
  int  TempStart1, TempStart2, RowIndex, From, To, NewFrom, NewTo;
  list< CRef< CAlign_annot > >::iterator  m;
  list< CRef< CSeq_interval > >::iterator n;

  // get den-diags for current master row
  if (SetDenDiagSet(0, pDenDiagSet1)) {
    // get den-diags for new master row
    if (SetDenDiagSet(Row, pDenDiagSet2)) {
      // for each den-diag in the 2 sets
      ii = pDenDiagSet2->begin();
      for (i=pDenDiagSet1->begin(); i!=pDenDiagSet1->end(); i++) {
        // swap ids
        j = (*i)->SetIds().begin();
        jj = (*ii)->SetIds().begin();
        pTempSeqId1 = *j;
        pTempSeqId2 = *(++jj);
        (*i)->SetIds().pop_front();
        (*i)->SetIds().push_front(pTempSeqId2);
        (*ii)->SetIds().pop_back();
        (*ii)->SetIds().push_back(pTempSeqId1);
        // swap starts
        k = (*i)->SetStarts().begin();
        kk = (*ii)->SetStarts().begin();
        TempStart1 = *k;
        TempStart2 = *(++kk);
        (*i)->SetStarts().pop_front();
        (*i)->SetStarts().push_front(TempStart2);
        (*ii)->SetStarts().pop_back();
        (*ii)->SetStarts().push_back(TempStart1);
        ii++;
      }
    }
  }

  // get den-diags for master row
  if (SetDenDiagSet(0, pDenDiagSet1)) {
    // for each row except first 2
    for (RowIndex=2; RowIndex<GetNumRows(); RowIndex++) {
      // get den-diags for RowIndex row
      if (SetDenDiagSet(RowIndex, pDenDiagSet2)) {
        // for each den-diag in the 2 sets
        ii = pDenDiagSet2->begin();
        for (i=pDenDiagSet1->begin(); i!=pDenDiagSet1->end(); i++) {
          // replace id of master with new-master id
          j =  (*i)->SetIds().begin();
          (*ii)->SetIds().pop_front();
          (*ii)->SetIds().push_front(*j);
          // replace start of master with new-master start
          k =  (*i)->SetStarts().begin();
          (*ii)->SetStarts().pop_front();
          (*ii)->SetStarts().push_front(*k);
          ii++;
        }
      }
    }
  }

  // if there's a master3d
  if (IsSetMaster3d()) {
    // get rid of it
    SetMaster3d().clear();
  }
  // if the new master has a pdb-id
  CRef<CSeq_id>  SeqID;
  if (GetSeqID(0, 0, SeqID)) {
    if (SeqID->IsPdb()) {
      // make it the master3d
      // (the ref-counter for SeqID should have been incremented in GetSeqID)
      SetMaster3d().push_back(SeqID);
    }
  }

  // get den-diag-set.  1st row is new master, 2nd row is old master.
  SetDenDiagSet(Row, pDenDiagSet1);
  // if there's an align-annot set
  if (IsSetAlignannot()) {
    // for each alignannot
    for (m=SetAlignannot().Set().begin(); m!=SetAlignannot().Set().end(); m++) {
      // if it's a from-to
      if ((*m)->SetLocation().IsInt()) {
        // update from and to with new master
        From = (*m)->SetLocation().GetInt().GetFrom();
        To = (*m)->SetLocation().GetInt().GetTo();
        NewFrom = GetSeqPosition(pDenDiagSet1, From, false);
        NewTo = GetSeqPosition(pDenDiagSet1, To, false);
        (*m)->SetLocation().SetInt().SetFrom(NewFrom);
        (*m)->SetLocation().SetInt().SetTo(NewTo);
        // erase old master-id, add new
        (*m)->SetLocation().SetInt().ResetId();
        if (GetSeqID(0, 0, SeqID)) {
          (*m)->SetLocation().SetInt().SetId(*SeqID);
        }
      }
      // if it's a set of from-to's
      else if ((*m)->SetLocation().IsPacked_int()) {
        // for each from-to
        for (n=(*m)->SetLocation().SetPacked_int().Set().begin();
             n!=(*m)->SetLocation().SetPacked_int().Set().end(); n++) {
          // update from and to with new master
          From = (*n)->GetFrom();
          To = (*n)->GetTo();
          NewFrom = GetSeqPosition(pDenDiagSet1, From, false);
          NewTo = GetSeqPosition(pDenDiagSet1, To, false);
          (*n)->SetFrom(NewFrom);
          (*n)->SetTo(NewTo);
          // erase old master-id, add new
          (*n)->ResetId();
          if (GetSeqID(0, 0, SeqID)) {
            (*n)->SetId(*SeqID);
          }
        }
      }
    }
  }


  return(true);
}


int CCdd::GetSeqPosition(TDendiag* pDenDiagSet, int Position, bool OnMasterRow) {
//---------------------------------------------------------------------------
// if OnMasterRow is true, then get position on slave row that corresponds
// to Position on master row.  Otherwise, get position on master row that
// corresponds to Position on slave row.
//---------------------------------------------------------------------------
  list< CRef< CDense_diag > >::iterator  i;
  list< unsigned int >::iterator  k;
  int  Start, Len, OtherStart;

  // find from and to in old-master
  for (i=pDenDiagSet->begin(); i!=pDenDiagSet->end(); i++) {
    k = (*i)->SetStarts().begin();
    Len = (*i)->GetLen();
    Start = OnMasterRow ? *k : *(++k);
    k = (*i)->SetStarts().begin();
    OtherStart = OnMasterRow ? *(++k)  : *k;
    if ((Position >= Start) && (Position < (Start+Len))) {
      return(OtherStart + (Position-Start));
    }
  }
  return(-1);
}


bool CCdd::GetDenDiagSet(int Row, const TDendiag*& pDenDiagSet) {
//-------------------------------------------------------------------------
// basically the same as SetDenDiagSet, but insure that the returned
// den-diag-set is const.
//-------------------------------------------------------------------------
  TDendiag* pTempDenDiagSet;
  bool RetVal;
  RetVal = SetDenDiagSet(Row, pTempDenDiagSet);
  pDenDiagSet = pTempDenDiagSet;
  return(RetVal);
}


bool CCdd::SetDenDiagSet(int Row, TDendiag*& pDenDiagSet) {
//-------------------------------------------------------------------------
// get a set of dense-diag's.  this is dense-diag info for a row.
// for Row = 0, and Row = 1, return the same DenDiagSet.
//-------------------------------------------------------------------------
  TSeqannot::iterator i;
  list< CRef< CSeq_align > >::iterator j;

  if (IsSetSeqannot()) {
    // get the seq-annot
    i = SetSeqannot().begin();
    if ((*i)->GetData().IsAlign()) {
      // figure out which dense-diag set to get (based on Row)
      if (Row == 0) j = (*i)->SetData().SetAlign().begin();
      else {
        int Count = 0;
        for (j= (*i)->SetData().SetAlign().begin();
             j!= (*i)->SetData().SetAlign().end(); j++) {
          if (++Count == Row) break;
        }
      }
      if ((*j)->GetSegs().IsDendiag()) {
        // get the dense-diag set
        pDenDiagSet = &((*j)->SetSegs().SetDendiag());
        return(true);
      }
    }
  }
  return(false);
}


bool CCdd::GetDenDiag(int Row, bool First, CRef<CDense_diag>& DenDiag) {
//-------------------------------------------------------------------------
// get either the first or last dense-diag of Row
//-------------------------------------------------------------------------
  const TDendiag* pDenDiagSet;                     // (TDendiag = list<CRef<CDense_diag>>)
  list< CRef< CDense_diag > >::const_iterator k;

  if (GetDenDiagSet(Row, pDenDiagSet)) {
    if (First) {
      k = pDenDiagSet->begin();
    }
    else {
      k = pDenDiagSet->end();
      k--;
    }
    DenDiag = (*k);
    return(true);
  }
  return(false);
}


bool CCdd::GetSeqID(int SeqIndex, CRef<CSeq_id>& SeqID) {
//-------------------------------------------------------------------------
// get a SeqID from a list of sequences.
// each sequence can have multiple id's.
// if there's a pdb-id, return it.
// otherwise, if there's a gi, return it.
// otherwise, return false.
//-------------------------------------------------------------------------
  list< CRef< CSeq_entry > >::const_iterator  i;
  list< CRef< CSeq_id > >::const_iterator  j;
  int  SeqCount, IDCount, NumIDs;

  if (IsSetSequences()) {
    if (GetSequences().IsSet()) {
      // count to the SeqIndex sequence
      SeqCount = 0;
      for (i=GetSequences().GetSet().GetSeq_set().begin();
           i!=GetSequences().GetSet().GetSeq_set().end(); i++) {
        if (SeqCount == SeqIndex) {
          if ((*i)->IsSeq()) {
            // look through the IDs for a PDB id
            NumIDs = (*i)->GetSeq().GetId().size();
            IDCount = 0;
            for (j = (*i)->GetSeq().GetId().begin();
                 j != (*i)->GetSeq().GetId().end(); j++) {
              if ((*j)->IsPdb()) {
                SeqID = (*j);
                return(true);
              }
              IDCount++;
            }
            // look through IDs again for a gi
            IDCount = 0;
            for (j = (*i)->GetSeq().GetId().begin();
                 j != (*i)->GetSeq().GetId().end(); j++) {
              if ((*j)->IsGi()) {
                SeqID = (*j);
                return(true);
              }
              IDCount++;
            }
          }
        }
        SeqCount++;
      }
    }
  }
  return(false);
}


bool CCdd::GetSeqID(int Pair, int DenDiagRow, CRef<CSeq_id>& SeqID) {
//-------------------------------------------------------------------------
// get a SeqID.
// first get the Pair'th DenDiag, then the DenDiagRow'th SeqID.
//-------------------------------------------------------------------------
  CRef< CDense_diag > DenDiag;
  list< CRef< CSeq_id > > IdsSet;
  list< CRef< CSeq_id > >::iterator i;
  int  Row;

  Row = (Pair == 0) ? DenDiagRow : Pair+1;
  GetDenDiag(Row, true, DenDiag);
  IdsSet = DenDiag->GetIds();
  // for Row=0, get the first id, otherwise get the 2nd id
  i = IdsSet.begin();
  if (DenDiagRow != 0) {
    i++;
  }
  SeqID = (*i);
  return(true);
}


bool CCdd::GetGI(int Row, int& GI) {
//-------------------------------------------------------------------------
// get the GI for Row
//-------------------------------------------------------------------------
  CRef< CSeq_id >  SeqID;
  int  Pair, DenDiagRow;

  Pair = (Row <= 1) ? 0 : Row-1;
  DenDiagRow = (Row == 0) ? 0 : 1;
  GetSeqID(Pair, DenDiagRow, SeqID);
  if (SeqID->IsGi()) {
    GI = SeqID->GetGi();
    return(true);
  }
  return(false);
}


bool CCdd::GetPDB(int Row, const CPDB_seq_id*& pPDB) {
//-------------------------------------------------------------------------
// get the PDB ID for Row
//-------------------------------------------------------------------------
  CRef< CSeq_id >  SeqID;
  int  Pair, DenDiagRow;

  Pair = (Row <= 1) ? 0 : Row-1;
  DenDiagRow = (Row == 0) ? 0 : 1;
  GetSeqID(Pair, DenDiagRow, SeqID);
  if (SeqID->IsPdb()) {
    pPDB = &(SeqID->GetPdb());
    return(true);
  }
  return(false);
}


int CCdd::GetLowerBound(int Row) {
//-------------------------------------------------------------------------
// get the lower alignment boundary for Row
//-------------------------------------------------------------------------
  CRef< CDense_diag > DenDiag;
  list< unsigned int >::const_iterator  i;

  // get the first den-diag for row
  GetDenDiag(Row, true, DenDiag);
  i = DenDiag->GetStarts().begin();
  if (Row != 0) {
    i++;
  }
  return(*i);
}

int CCdd::GetUpperBound(int Row) {
//-------------------------------------------------------------------------
// get the upper alignment boundary for Row
//-------------------------------------------------------------------------
  CRef< CDense_diag > DenDiag;
  list< unsigned int >::const_iterator  i;

  // get the last den-diag for row
  GetDenDiag(Row, false, DenDiag);
  i = DenDiag->GetStarts().begin();
  if (Row != 0) {
    i++;
  }
  return(*i + DenDiag->GetLen());
}


int CCdd::GetNumSequences() {
//-------------------------------------------------------------------------
// get number of sequences in CD
//-------------------------------------------------------------------------
  if (IsSetSequences()) {
    if (GetSequences().IsSet()) {
      return(GetSequences().GetSet().GetSeq_set().size());
    }
  }
  return(0);
}


int CCdd::GetNumRows() {
//-------------------------------------------------------------------------
// get number of rows in CD
//-------------------------------------------------------------------------
  TSeqannot::const_iterator i;

  if (IsSetSeqannot()) {
    for (i=GetSeqannot().begin(); i!=GetSeqannot().end(); i++) {
      if ((*i)->GetData().IsAlign()) {
        // number pairs + 1 == num rows
        return((*i)->GetData().GetAlign().size()+1);
      }
    }
  }
  return(0);
}


string CCdd::GetUpdateDate() {
//-------------------------------------------------------------------------
// get string indicating date of last change to CD
//-------------------------------------------------------------------------
  CCdd_descr_set::Tdata::const_iterator i;
  string  Str;

  if (IsSetDescription()) {
    for (i=GetDescription().Get().begin(); i!=GetDescription().Get().end(); i++) {
      if ((*i)->IsUpdate_date()) {
        (*i)->GetUpdate_date().GetDate(&Str);
        return(Str);
      }
    }
  }
  return(Str);
}


string CCdd::GetCurationStatus() {
//-------------------------------------------------------------------------
// get string indicating curation status of this CD
//-------------------------------------------------------------------------
  CCdd_descr_set::Tdata::const_iterator i;
  string  Str;

  if (IsSetDescription()) {
    for (i=GetDescription().Get().begin(); i!=GetDescription().Get().end(); i++) {
      if ((*i)->IsStatus()) {
        switch((*i)->GetStatus()) {
          case 0:   return("unassigned");
          case 1:   return("finished_ok");
          case 2:   return("pending_release");
          case 3:   return("other_asis");
          case 4:   return("matrix_only");
          case 5:   return("update_running");
          case 6:   return("auto_updated");
          case 7:   return("claimed");
          default:  return("other");
        }
      }
    }
  }
  return(Str);
}


void CCdd::SetAccession(string Accession) {
//-------------------------------------------------------------------------
// set accession name of CD
//-------------------------------------------------------------------------
  CCdd_id_set::Tdata::iterator  i;

  for (i=SetId().Set().begin(); i!=SetId().Set().end(); i++) {
    if ((*i)->IsGid()) {
      (*i)->SetGid().SetAccession(Accession);
    }
  }
}


string CCdd::GetAccession() {
//-------------------------------------------------------------------------
// get accession name of CD
//-------------------------------------------------------------------------
  CCdd_id_set::Tdata::const_iterator  i;
  string  Str;

  for (i=GetId().Get().begin(); i!=GetId().Get().end(); i++) {
    if ((*i)->IsGid()) {
      return((*i)->GetGid().GetAccession());
    }
  }
  return(Str);
}


string CCdd::GetLongDescription() {
//-------------------------------------------------------------------------
// get descriptive comment about CD
//-------------------------------------------------------------------------
  CCdd_descr_set::Tdata::const_iterator  i;
  string  Str;

  if (IsSetDescription()) {
    for (i=GetDescription().Get().begin(); i!=GetDescription().Get().end(); i++) {
      if ((*i)->IsComment()) {
        return((*i)->GetComment());
      }
    }
  }
  return(Str);
}


END_objects_SCOPE // namespace ncbi::objects::

END_NCBI_SCOPE

/* Original file checksum: lines: 61, chars: 1862, CRC32: 24714fb3 */
