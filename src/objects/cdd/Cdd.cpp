/* $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author:  .......
 *
 * File Description:
 *   .......
 *
 * Remark:
 *   This code was originally generated by application DATATOOL
 *   using specifications from the ASN data definition file
 *   'cdd.asn'.
 */

// standard includes

// generated includes
#include <corelib/ncbistd.hpp>
#include <corelib/ncbiargs.hpp>
#include <corelib/ncbiapp.hpp>
#include <corelib/ncbienv.hpp>
#include <corelib/ncbistre.hpp>
#include <serial/serial.hpp>
#include <serial/objistrasn.hpp>
#include <serial/objistrasnb.hpp>
#include <serial/objostrasn.hpp>
#include <serial/objostrasnb.hpp>
#include <serial/iterator.hpp>
#include <objects/general/Date.hpp>
#include <objects/cdd/Cdd.hpp>
#include <objects/cdd/Cdd_descr_set.hpp>
#include <objects/cdd/Cdd_descr.hpp>
#include <objects/cdd/Cdd_id_set.hpp>
#include <objects/cdd/Cdd_id.hpp>
#include <objects/cdd/Feature_evidence.hpp>
#include <objects/cdd/Global_id.hpp>
#include <objects/seq/Bioseq.hpp>
#include <objects/seq/Seq_annot.hpp>
#include <objects/seq/Seq_descr.hpp>
#include <objects/seq/Seqdesc.hpp>
#include <objects/seq/Seq_inst.hpp>
#include <objects/seq/Seq_data.hpp>
#include <objects/seq/NCBIeaa.hpp>
#include <objects/seq/NCBIstdaa.hpp>
#include <objects/seq/IUPACaa.hpp>
#include <objects/seqalign/Dense_diag.hpp>
#include <objects/seqalign/Seq_align.hpp>
#include <objects/seqset/Bioseq_set.hpp>
#include <objects/seqset/Seq_entry.hpp>
#include <objects/seqloc/Seq_loc.hpp>
#include <objects/seqloc/Seq_id.hpp>
#include <objects/seqloc/Seq_interval.hpp>
#include <objects/seqloc/PDB_mol_id.hpp>
#include <objects/seqblock/PDB_block.hpp>
#include <objects/seqfeat/Org_ref.hpp>
#include <objects/seqfeat/BioSource.hpp>
#include <objects/cdd/Global_id.hpp>
#include <objects/mmdb1/Biostruc_annot_set.hpp>
#include <objects/mmdb1/Biostruc_id.hpp>
#include <objects/mmdb1/Mmdb_id.hpp>
#include <objects/general/Dbtag.hpp>
#include <objects/general/Object_id.hpp>

#include <stdio.h>

// generated classes

BEGIN_NCBI_SCOPE

BEGIN_objects_SCOPE // namespace ncbi::objects::

// destructor
CCdd::~CCdd(void) {
}


void CCdd::EraseStructureEvidence() {
//-------------------------------------------------------------------------
// erase structure evidence for sequences that are no longer present
//-------------------------------------------------------------------------
  list< CRef< CFeature_evidence > >::iterator  FeatureIterator;

  // make list of current mmdb id's
  int  id;
  list<int> MmdbIds;
  for (int SeqIndex=0; SeqIndex<GetNumSequences(); SeqIndex++) {
    if (GetMmdbId(SeqIndex, id)) {
      MmdbIds.push_back(id);
    }
  }

  // delete structure evidence for mmdb-id's not in the list
  while (IsNoEvidenceFor(MmdbIds, FeatureIterator)) {
    GetFeatureSet(MmdbIds).erase(FeatureIterator);
  }
}


list< CRef< CFeature_evidence > >& CCdd::GetFeatureSet(list<int>& MmdbIds) {
//-------------------------------------------------------------------------
// this function mirrors IsNoEvidenceFor.  It returns the list of features
// that is modified.
//-------------------------------------------------------------------------
  list< CRef< CAlign_annot > >::iterator  i;
  list< CRef< CFeature_evidence > >::iterator j;
  list< CRef< CBiostruc_id > >::iterator k;
  list< int >::iterator  m;
  bool  FoundIt;

  // look through each align-annot in the align-annot-set
  if (IsSetAlignannot()) {
    for (i=SetAlignannot().Set().begin(); i!=SetAlignannot().Set().end(); i++) {
      // look through each feature-evidence in the feature-evidence-set
      if ((*i)->IsSetEvidence()) {
        for (j=(*i)->SetEvidence().begin(); j!=(*i)->SetEvidence().end(); j++) {
          // look through each biostruc-id in the biostruc-id-set
          if ((*j)->IsBsannot()) {
            if ((*j)->SetBsannot().IsSetId()) {
              for (k=(*j)->SetBsannot().SetId().begin(); k!=(*j)->SetBsannot().SetId().end(); k++) {
                if ((*k)->IsMmdb_id()) {
                  // if biostruc id is NOT in the list return list to delete id from
                  FoundIt = false;
                  for (m=MmdbIds.begin(); m!=MmdbIds.end(); m++) {
                    if ((*m) == (*k)->GetMmdb_id().Get()) {
                      FoundIt = true;
                    }
                  }
                  if (!FoundIt) {
                    return((*i)->SetEvidence());
                  }
                }
              }
            }
          }
        }
      }
    }
  }
//  assert(false);   // should never get here
  return((*i)->SetEvidence());
}


bool CCdd::IsNoEvidenceFor(list<int>& MmdbIds,
                           list< CRef< CFeature_evidence > >::iterator& FeatureIterator) {
//------------------------------------------------------------------------------------
// look through the feature-evidence of each align-annot-set.
// return true if there's an id that needs to be deleted from a structure-evidence.
//------------------------------------------------------------------------------------
  list< CRef< CAlign_annot > >::iterator  i;
  list< CRef< CFeature_evidence > >::iterator j;
  list< CRef< CBiostruc_id > >::iterator k;
  list<int>::iterator  m;
  bool  FoundIt;

  // look through each align-annot in the align-annot-set
  if (IsSetAlignannot()) {
    for (i=SetAlignannot().Set().begin(); i!=SetAlignannot().Set().end(); i++) {
      // look through each feature-evidence in the feature-evidence-set
      if ((*i)->IsSetEvidence()) {
        for (j=(*i)->SetEvidence().begin(); j!=(*i)->SetEvidence().end(); j++) {
          // look through each biostruc-id in the biostruc-id-set
          if ((*j)->IsBsannot()) {
            if ((*j)->SetBsannot().IsSetId()) {
              for (k=(*j)->SetBsannot().SetId().begin(); k!=(*j)->SetBsannot().SetId().end(); k++) {
                if ((*k)->IsMmdb_id()) {
                  // if biostruc id is NOT in the list return true
                  FoundIt = false;
                  for (m=MmdbIds.begin(); m!=MmdbIds.end(); m++) {
                    if ((*m) == (*k)->GetMmdb_id().Get()) {
                      FoundIt = true;
                    }
                  }
                  if (!FoundIt) {
                    FeatureIterator = j;
                    return(true);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return(false);
}


string CCdd::GetDefline(int SeqIndex) {
//-------------------------------------------------------------------------
// get a description for the SeqIndex sequence
//-------------------------------------------------------------------------
  list< CRef< CSeq_entry > >::const_iterator  i;
  list< CRef< CSeqdesc > >::const_iterator  j;
  int  SeqCount;
  string  Description;

  if (IsSetSequences()) {
    if (GetSequences().IsSet()) {
      // count to the SeqIndex sequence
      SeqCount = 0;
      for (i=GetSequences().GetSet().GetSeq_set().begin();
           i!=GetSequences().GetSet().GetSeq_set().end(); i++) {
        if (SeqCount == SeqIndex) {
          if ((*i)->IsSeq()) {
            if ((*i)->GetSeq().IsSetDescr()) {
              // look through the sequence descriptions
              for (j=(*i)->GetSeq().GetDescr().Get().begin();
                   j!=(*i)->GetSeq().GetDescr().Get().end(); j++) {
                // if there's a title, return that description
                if ((*j)->IsTitle()) {
                  return((*j)->GetTitle());
                }
                // if there's a pdb description, return it
                if ((*j)->IsPdb()) {
                  if ((*j)->GetPdb().GetCompound().size() > 0) {
                    return((*j)->GetPdb().GetCompound().front());
                  }
                }
              }
            }
          }
        }
        SeqCount++;
        if (SeqCount > SeqIndex) break;
      }
    }
  }
  return(Description);
}


string CCdd::GetSpecies(int SeqIndex) {
//-------------------------------------------------------------------------
// get the species of the SeqIndex sequence
//-------------------------------------------------------------------------
  list< CRef< CSeq_entry > >::const_iterator  i;
  list< CRef< CSeqdesc > >::const_iterator  j;
  int  SeqCount;
  string  Description;

  if (IsSetSequences()) {
    if (GetSequences().IsSet()) {
      // count to the SeqIndex sequence
      SeqCount = 0;
      for (i=GetSequences().GetSet().GetSeq_set().begin();
           i!=GetSequences().GetSet().GetSeq_set().end(); i++) {
        if (SeqCount == SeqIndex) {
          if ((*i)->IsSeq()) {
            if ((*i)->GetSeq().IsSetDescr()) {
              // look through the sequence descriptions
              for (j=(*i)->GetSeq().GetDescr().Get().begin();
                   j!=(*i)->GetSeq().GetDescr().Get().end(); j++) {
                // if there's an organism identifier
                if ((*j)->IsSource()) {
                  // retrieve common or formal name
                  if ((*j)->GetSource().GetOrg().IsSetTaxname()) {
                    return((*j)->GetSource().GetOrg().GetTaxname());
                  }
                  if ((*j)->GetSource().GetOrg().IsSetCommon()) {
                    return((*j)->GetSource().GetOrg().GetCommon());
                  }
                }
              }
            }
          }
        }
        SeqCount++;
        if (SeqCount > SeqIndex) break;
      }
    }
  }
  return(Description);
}


bool CCdd::GetMmdbId(int SeqIndex, int& id) {
//-------------------------------------------------------------------------
// get mmdb-id from sequence list
//-------------------------------------------------------------------------
  list< CRef< CSeq_entry > >::const_iterator  i;
  list< CRef< CSeq_annot > >::const_iterator  j;
  list< CRef< CSeq_id > >::const_iterator k;
  int  SeqCount;

  if (IsSetSequences()) {
    if (GetSequences().IsSet()) {
      SeqCount = 0;
      // look through each sequence in set for SeqIndex sequence
      for (i=GetSequences().GetSet().GetSeq_set().begin();
           i!=GetSequences().GetSet().GetSeq_set().end(); i++) {
        if (SeqCount == SeqIndex) {
          if ((*i)->IsSeq()) {
            // look through each seq-annot
            if ((*i)->GetSeq().IsSetAnnot()) {
              for (j = (*i)->GetSeq().GetAnnot().begin(); j!= (*i)->GetSeq().GetAnnot().end(); j++) {
                // look through ids for an mmdb id
                if ((*j)->GetData().IsIds()) {
                  for (k = (*j)->GetData().GetIds().begin(); k != (*j)->GetData().GetIds().end(); k++) {
                    if ((*k)->IsGeneral()) {
                      if ((*k)->GetGeneral().GetDb() == "mmdb") {
                        if ((*k)->GetGeneral().GetTag().IsId()) {
                          id = (*k)->GetGeneral().GetTag().GetId();
                          return(true);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        SeqCount++;
        if (SeqCount > SeqIndex) break;
      }
    }
  }
  return(false);
}


void CCdd::EraseSequences() {
//-------------------------------------------------------------------------
// erase sequences not in alignment
//-------------------------------------------------------------------------
  int  i, NumSequences;
  CRef<CSeq_id>  ID(new CSeq_id);

  NumSequences = GetNumSequences();
  for (i=NumSequences-1; i>=0; i--) {
    GetSeqID(i, ID);
    if (!IsAMatchFor(ID)) {
      EraseSequence(i);
    }
  }
  // testing
  NumSequences = GetNumSequences();
}


void CCdd::EraseSequence(int SeqIndex) {
//-------------------------------------------------------------------------
// erase a sequence from the set of sequences
//-------------------------------------------------------------------------
  list< CRef< CSeq_entry > >::iterator  i;
  int  SeqCount;

  if (IsSetSequences()) {
    if (GetSequences().IsSet()) {
      SeqCount = 0;
      for (i=SetSequences().SetSet().SetSeq_set().begin();
           i!=SetSequences().SetSet().SetSeq_set().end(); i++) {
        if (SeqCount == SeqIndex) {
          SetSequences().SetSet().SetSeq_set().erase(i);
          return;
        }
        SeqCount++;
        if (SeqCount > SeqIndex) break;
      }
    }
  }
}


bool CCdd::IsAMatchFor(CRef<CSeq_id>& ID) {
//-------------------------------------------------------------------------
// look through each row of the alignment for a matching ID
//-------------------------------------------------------------------------
  int  Dummy;
  return(IsAMatchFor(ID, Dummy));
}


bool CCdd::IsAMatchFor(CRef<CSeq_id>& ID, int& RowIndex) {
//-------------------------------------------------------------------------
// look through each row of the alignment for a matching ID
//-------------------------------------------------------------------------
  int  k, Pair, DenDiagRow, NumRows=GetNumRows();
  CRef< CSeq_id >  TestID(new CSeq_id);

  for (k=0; k<NumRows; k++) {
    Pair = (k <= 1) ? 0 : k-1;
    DenDiagRow = (k == 0) ? 0 : 1;
    GetSeqID(Pair, DenDiagRow, TestID);
    if (SeqIdsMatch(ID, TestID)) {
      RowIndex = k;
      return(true);
    }
  }
  return(false);
}


bool CCdd::SeqIdsMatch(CRef<CSeq_id>& ID1, CRef<CSeq_id>& ID2) {
//-------------------------------------------------------------------------
// return true if the 2 sequence-id's match
//-------------------------------------------------------------------------
  if (ID1->IsGi() && ID2->IsGi()) {
    if (ID1->GetGi() == ID2->GetGi()) {
      return(true);
    }
  }
  if (ID1->IsPdb() && ID2->IsPdb()) {
    if (ID1->GetPdb().GetMol().Get() == ID2->GetPdb().GetMol().Get()) {
      if (ID1->GetPdb().GetChain() == ID2->GetPdb().GetChain()) {
        return(true);
      }
    }
  }
  return(false);
}


bool CCdd::EraseRows(std::deque<int>& KeepRows) {
//-------------------------------------------------------------------------
// erase rows from the alignment.
// KeepRows is a list of rows that are NOT deleted from this CD.
// KeepRows won't contain the master (0 index) row.
//-------------------------------------------------------------------------
  list< CRef< CSeq_annot > >::iterator i;
  int   j, k, NumRows;
  bool  FoundIt;

  if (IsSetSeqannot()) {
    i = SetSeqannot().begin();
    // for each row of the alignment except the master row
    NumRows = (*i)->SetData().SetAlign().size() + 1;
    for (j=NumRows-1; j>0; j--) {
      // see if row is in KeepRows
      FoundIt = false;
      for (k=0; k<KeepRows.size(); k++) {
        if (KeepRows[k] == j) {
          FoundIt = true;
          break;
        }
      }
      // if row is not in KeepRows, then erase it
      if (!FoundIt) {
        if (!EraseRow(j)) {
          return(false);
        }
      }
    }
  }
  return(true);
}


bool CCdd::MoveToBottom(int RowIndex) {
//-------------------------------------------------------------------------
// move the RowIndex-1 seq-align pair to the bottom of the alignment.
// don't move RowIndex 0 (cuz that's the master).
//-------------------------------------------------------------------------
  list< CRef< CSeq_annot > >::iterator i;
  list< CRef< CSeq_align > >::iterator j;
  CRef< CSeq_align > SeqAlign;
  int  RowCount;

  if (RowIndex == 0) return(false);

  if (IsSetSeqannot()) {
    i = SetSeqannot().begin();
    if ((*i)->GetData().IsAlign()) {
      RowCount = 1;
      for (j= (*i)->SetData().SetAlign().begin();
           j!= (*i)->SetData().SetAlign().end(); j++) {
        if (RowCount == RowIndex) {
          SeqAlign = *j;
          (*i)->SetData().SetAlign().erase(j);
          (*i)->SetData().SetAlign().push_back(SeqAlign);
          return(true);
        }
        RowCount++;
        if (RowCount > RowIndex) break;
      }
    }
  }
  return(false);
}


bool CCdd::MoveToTop(int RowIndex) {
//-------------------------------------------------------------------------
// move the RowIndex-1 seq-align pair to the top of the alignment.
// don't move RowIndex 0 (cuz that's the master).
// moving RowIndex 1 doesn't do anything.
//-------------------------------------------------------------------------
  list< CRef< CSeq_annot > >::iterator i;
  list< CRef< CSeq_align > >::iterator j;
  CRef< CSeq_align > SeqAlign;
  int  RowCount;

  if (RowIndex == 0) return(false);
  if (RowIndex == 1) return(true);

  if (IsSetSeqannot()) {
    i = SetSeqannot().begin();
    if ((*i)->GetData().IsAlign()) {
      RowCount = 1;
      for (j= (*i)->SetData().SetAlign().begin();
           j!= (*i)->SetData().SetAlign().end(); j++) {
        if (RowCount == RowIndex) {
          SeqAlign = *j;
          (*i)->SetData().SetAlign().erase(j);
          (*i)->SetData().SetAlign().push_front(SeqAlign);
          return(true);
        }
        RowCount++;
        if (RowCount > RowIndex) break;
      }
    }
  }
  return(false);
}


bool CCdd::EraseRow(int RowIndex) {
//-------------------------------------------------------------------------
// Erase the RowIndex-1 seq-align.  don't erase RowIndex 0.
//-------------------------------------------------------------------------
  list< CRef< CSeq_annot > >::iterator i;
  list< CRef< CSeq_align > >::iterator j;
  int  RowCount;

  if (RowIndex == 0) return(false);

  if (IsSetSeqannot()) {
    i = SetSeqannot().begin();
    if ((*i)->GetData().IsAlign()) {
      RowCount = 1;
      for (j= (*i)->SetData().SetAlign().begin();
           j!= (*i)->SetData().SetAlign().end(); j++) {
        if (RowCount == RowIndex) {
          (*i)->SetData().SetAlign().erase(j);
          return(true);
        }
        RowCount++;
        if (RowCount > RowIndex) break;
      }
    }
  }
  return(false);
}


int CCdd::GetReMasterFailureCode() {
//-------------------------------------------------------------------------
// return an error code indicating which, if any, checks went wrong.
// return value of 0 indicates all checks were ok.
//-------------------------------------------------------------------------
  int RetVal = 0;

  if (!AlignAnnotsAligned()) {
    RetVal = RetVal | ALIGN_ANNOTS_ALIGNED_FAILURE;
  }
  return(RetVal);
}


bool CCdd::AlignAnnotsAligned() {
//-------------------------------------------------------------------------
// check if the alignannot's are covered by aligned blocks
//-------------------------------------------------------------------------
  int  From, To, NewFrom, NewTo;
  const TDendiag*  pDenDiagSet;
  list< CRef< CAlign_annot > >::const_iterator  m;
  list< CRef< CSeq_interval > >::const_iterator  n;

  // get den-diag-set.  first row is master
  GetDenDiagSet(0, pDenDiagSet);
  // if there's an align-annot set
  if (IsSetAlignannot()) {
    // for each alignannot
    for (m=GetAlignannot().Get().begin(); m!=GetAlignannot().Get().end(); m++) {
      // if it's a from-to
      if ((*m)->GetLocation().IsInt()) {
        // update from and to with new master
        From = (*m)->GetLocation().GetInt().GetFrom();
        To = (*m)->GetLocation().GetInt().GetTo();
        NewFrom = GetSeqPosition(pDenDiagSet, From, true);
        NewTo = GetSeqPosition(pDenDiagSet, To, true);
        if ((NewFrom<0) || (NewTo<0)) return(false);
      }
      // if it's a set of from-to's
      else if ((*m)->GetLocation().IsPacked_int()) {
        // for each from-to
        for (n=(*m)->GetLocation().GetPacked_int().Get().begin();
             n!=(*m)->GetLocation().GetPacked_int().Get().end(); n++) {
          // update from and to with new master
          From = (*n)->GetFrom();
          To = (*n)->GetTo();
          NewFrom = GetSeqPosition(pDenDiagSet, From, true);
          NewTo = GetSeqPosition(pDenDiagSet, To, true);
          if ((NewFrom<0) || (NewTo<0)) return(false);
        }
      }
    }
  }
  return(true);
}


bool CCdd::ReMaster(int Row) {
//-------------------------------------------------------------------------
// make Row the new master of this CD.
// TDendiag = list< CRef< CDense_diag > >
//-------------------------------------------------------------------------
  TDendiag*  pDenDiagSet1;
  TDendiag*  pDenDiagSet2;
  list< CRef< CDense_diag > >::iterator  i, ii;
  CDense_diag::TIds::iterator  j, jj;
  CRef< CSeq_id >  pTempSeqId1(new CSeq_id);
  CRef< CSeq_id >  pTempSeqId2(new CSeq_id);
  list< TSeqPos >::iterator  k, kk;
  int  TempStart1, TempStart2;
  int  RowIndex, From, To, NewFrom, NewTo;
  list< CRef< CAlign_annot > >::iterator  m;
  list< CRef< CSeq_interval > >::iterator n;

  // get den-diags for current master row
  if (SetDenDiagSet(0, pDenDiagSet1)) {
    // get den-diags for new master row
    if (SetDenDiagSet(Row, pDenDiagSet2)) {
      // for each den-diag in the 2 sets
      ii = pDenDiagSet2->begin();
      for (i=pDenDiagSet1->begin(); i!=pDenDiagSet1->end(); i++) {
        // swap ids
        j = (*i)->SetIds().begin();
        jj = (*ii)->SetIds().begin();
        pTempSeqId1 = *j;
        pTempSeqId2 = *(++jj);
        (*i)->SetIds().front() = pTempSeqId2;
        (*ii)->SetIds().back() = pTempSeqId1;
        // swap starts
        k = (*i)->SetStarts().begin();
        kk = (*ii)->SetStarts().begin();
        TempStart1 = *k;
        TempStart2 = *(++kk);
        (*i)->SetStarts().front() = TempStart2;
        (*ii)->SetStarts().back() = TempStart1;
        ii++;
      }
    }
  }

  // get den-diags for master row
  if (SetDenDiagSet(0, pDenDiagSet1)) {
    // for each row except first 2
    for (RowIndex=2; RowIndex<GetNumRows(); RowIndex++) {
      // get den-diags for RowIndex row
      if (SetDenDiagSet(RowIndex, pDenDiagSet2)) {
        // for each den-diag in the 2 sets
        ii = pDenDiagSet2->begin();
        for (i=pDenDiagSet1->begin(); i!=pDenDiagSet1->end(); i++) {
          // replace id of master with new-master id
          j =  (*i)->SetIds().begin();
          (*ii)->SetIds().front() = *j;
          // replace start of master with new-master start
          k =  (*i)->SetStarts().begin();
          (*ii)->SetStarts().front() = *k;
          ii++;
        }
      }
    }
  }

  // if there's a master3d
  if (IsSetMaster3d()) {
    // get rid of it
    SetMaster3d().clear();
  }
  // if the new master has a pdb-id
  CRef<CSeq_id>  SeqID(new CSeq_id);
  if (GetSeqID(0, 0, SeqID)) {
    if (SeqID->IsPdb()) {
      // make it the master3d
      // (the ref-counter for SeqID should have been incremented in GetSeqID)
      SetMaster3d().push_back(SeqID);
    }
  }

  // get den-diag-set.  1st row is new master, 2nd row is old master.
  SetDenDiagSet(Row, pDenDiagSet1);
  // if there's an align-annot set
  if (IsSetAlignannot()) {
    // for each alignannot
    for (m=SetAlignannot().Set().begin(); m!=SetAlignannot().Set().end(); m++) {
      // if it's a from-to
      if ((*m)->SetLocation().IsInt()) {
        // update from and to with new master
        From = (*m)->SetLocation().GetInt().GetFrom();
        To = (*m)->SetLocation().GetInt().GetTo();
        NewFrom = GetSeqPosition(pDenDiagSet1, From, false);
        NewTo = GetSeqPosition(pDenDiagSet1, To, false);
        (*m)->SetLocation().SetInt().SetFrom(NewFrom);
        (*m)->SetLocation().SetInt().SetTo(NewTo);
        // erase old master-id, add new
//        (*m)->SetLocation().SetInt().ResetId();
        if (GetSeqID(0, 0, SeqID)) {
          (*m)->SetLocation().SetInt().SetId(*SeqID);
        }
      }
      // if it's a set of from-to's
      else if ((*m)->SetLocation().IsPacked_int()) {
        // for each from-to
        for (n=(*m)->SetLocation().SetPacked_int().Set().begin();
             n!=(*m)->SetLocation().SetPacked_int().Set().end(); n++) {
          // update from and to with new master
          From = (*n)->GetFrom();
          To = (*n)->GetTo();
          NewFrom = GetSeqPosition(pDenDiagSet1, From, false);
          NewTo = GetSeqPosition(pDenDiagSet1, To, false);
          (*n)->SetFrom(NewFrom);
          (*n)->SetTo(NewTo);
          // erase old master-id, add new
//          (*n)->ResetId();
          if (GetSeqID(0, 0, SeqID)) {
            (*n)->SetId(*SeqID);
          }
        }
      }
    }
  }


  return(true);
}


int CCdd::GetSeqPosition(const TDendiag* pDenDiagSet, int Position, bool OnMasterRow) {
//---------------------------------------------------------------------------
// if OnMasterRow is true, then get position on slave row that corresponds
// to Position on master row.  Otherwise, get position on master row that
// corresponds to Position on slave row.
//---------------------------------------------------------------------------
  list< CRef< CDense_diag > >::const_iterator  i;
  list< TSeqPos >::const_iterator  k;
  int  Start, Len, OtherStart;

  for (i=pDenDiagSet->begin(); i!=pDenDiagSet->end(); i++) {
    k = (*i)->GetStarts().begin();
    Len = (*i)->GetLen();
    Start = OnMasterRow ? *k : *(++k);
    k = (*i)->SetStarts().begin();
    OtherStart = OnMasterRow ? *(++k)  : *k;
    if ((Position >= Start) && (Position < (Start+Len))) {
      return(OtherStart + (Position-Start));
    }
  }
  return(-1);
}


bool CCdd::GetDenDiagSet(int Row, const TDendiag*& pDenDiagSet) {
//-------------------------------------------------------------------------
// basically the same as SetDenDiagSet, but insure that the returned
// den-diag-set is const.
//-------------------------------------------------------------------------
  TDendiag* pTempDenDiagSet;
  bool RetVal;
  RetVal = SetDenDiagSet(Row, pTempDenDiagSet);
  pDenDiagSet = pTempDenDiagSet;
  return(RetVal);
}


bool CCdd::IsSeqAligns() {
//-------------------------------------------------------------------------
// check if there are seq-aligns
//-------------------------------------------------------------------------
  list< CRef< CSeq_annot > >::iterator i;

  if (IsSetSeqannot()) {
    i = SetSeqannot().begin();
    if ((*i)->GetData().IsAlign()) {
      return(true);
    }
  }
  return(false);
}


const list< CRef< CSeq_align > >& CCdd::GetSeqAligns() {
//-------------------------------------------------------------------------
// get the seq-aligns.  Must know they're present.
//-------------------------------------------------------------------------
  list< CRef< CSeq_annot > >::iterator i;

  i = SetSeqannot().begin();
  return((*i)->GetData().GetAlign());
}


bool CCdd::SetDenDiagSet(int Row, TDendiag*& pDenDiagSet) {
//-------------------------------------------------------------------------
// get a set of dense-diag's.  this is dense-diag info for a row.
// for Row = 0, and Row = 1, return the same DenDiagSet.
//-------------------------------------------------------------------------
  TSeqannot::iterator i;
  list< CRef< CSeq_align > >::iterator j;

  if (IsSetSeqannot()) {
    // get the seq-annot
    i = SetSeqannot().begin();
    if ((*i)->GetData().IsAlign()) {
      // figure out which dense-diag set to get (based on Row)
      if (Row == 0) j = (*i)->SetData().SetAlign().begin();
      else {
        int Count = 0;
        for (j= (*i)->SetData().SetAlign().begin();
             j!= (*i)->SetData().SetAlign().end(); j++) {
          if (++Count == Row) break;
        }
      }
      if ((*j)->GetSegs().IsDendiag()) {
        // get the dense-diag set
        pDenDiagSet = &((*j)->SetSegs().SetDendiag());
        return(true);
      }
    }
  }
  return(false);
}


bool CCdd::GetDenDiag(int Row, bool First, CRef<CDense_diag>& DenDiag) {
//-------------------------------------------------------------------------
// get either the first or last dense-diag of Row
//-------------------------------------------------------------------------
  const TDendiag* pDenDiagSet;                     // (TDendiag = list<CRef<CDense_diag>>)
  list< CRef< CDense_diag > >::const_iterator k;

  if (GetDenDiagSet(Row, pDenDiagSet)) {
    if (First) {
      k = pDenDiagSet->begin();
    }
    else {
      k = pDenDiagSet->end();
      k--;
    }
    DenDiag = (*k);
    return(true);
  }
  return(false);
}


int CCdd::GetSeqIndex(CRef<CSeq_id>& SeqID) {
//-------------------------------------------------------------------------
//  get the sequence index with given SeqID
//-------------------------------------------------------------------------
  int  i, NumSequences = GetNumSequences();
  CRef<CSeq_id> TrialSeqID(new CSeq_id);

  for (i=0; i<NumSequences; i++) {
    GetSeqID(i, TrialSeqID);
    if (SeqIdsMatch(SeqID, TrialSeqID)) {
      return(i);
    }
  }
  return(-1);
}


bool CCdd::GetSeqIDs(int SeqIndex, list< CRef< CSeq_id > >& SeqIDs) {
//-------------------------------------------------------------------------
// get the list of SeqIDs for a sequence
//-------------------------------------------------------------------------
  list< CRef< CSeq_entry > >::const_iterator  i;
  int  SeqCount;

  if (IsSetSequences()) {
    if (GetSequences().IsSet()) {
      // count to the SeqIndex sequence
      SeqCount = 0;
      for (i=GetSequences().GetSet().GetSeq_set().begin();
           i!=GetSequences().GetSet().GetSeq_set().end(); i++) {
        if (SeqCount == SeqIndex) {
          if ((*i)->IsSeq()) {
            // return its set of ids
            SeqIDs = (*i)->GetSeq().GetId();
            return(true);
          }
        }
        SeqCount++;
        if (SeqCount > SeqIndex) break;
      }
    }
  }
  return(false);
}


bool CCdd::Get_GI_or_PDB_String_FromAlignment(int RowIndex, std::string& Str, bool Pad, int Len) {
//-------------------------------------------------------------------
// get seq-id string for RowIndex of alignment
//-------------------------------------------------------------------
  int  Pair = (RowIndex <= 1) ? 0 : RowIndex-1;
  int  DenDiagRow = (RowIndex == 0) ? 0 : 1;
  CRef<CSeq_id> SeqID;

  GetSeqID(Pair, DenDiagRow, SeqID);
  Make_GI_or_PDB_String(SeqID, Str, Pad, Len);
  return(true);
}


void CCdd::Make_GI_or_PDB_String(CRef<CSeq_id> SeqID, std::string& Str, bool Pad, int Len) {
//-------------------------------------------------------------------
// make a string for a seq-id
//-------------------------------------------------------------------
  int   GI;
  const CPDB_seq_id*  pPDB_ID;
  char  IDStr[256];
  char  Chain;

  if (SeqID->IsGi()) {
    GI = SeqID->GetGi();
    sprintf(IDStr, "%d", GI);
    Str += IDStr;
  }
  if (SeqID->IsPdb()) {
    pPDB_ID = &(SeqID->GetPdb());
    Str = pPDB_ID->GetMol().Get();
    Chain = pPDB_ID->GetChain();
    Str += " ";
    Str += Chain;
  }

  // pad with spaces to length of Len
  if (Pad) {
    if (Str.size() < Len) {
      Str.append(Len - Str.size(), ' ');
    }
  }
}


bool CCdd::GetSeqID(int SeqIndex, CRef<CSeq_id>& SeqID) {
//-------------------------------------------------------------------------
// get a SeqID from a list of sequences.
// each sequence can have multiple id's.
// if there's a pdb-id, return it.
// otherwise, if there's a gi, return it.
// otherwise, return false.
//-------------------------------------------------------------------------
  list< CRef< CSeq_entry > >::const_iterator  i;
  list< CRef< CSeq_id > >::const_iterator  j;
  int  SeqCount, IDCount, NumIDs;

  if (IsSetSequences()) {
    if (GetSequences().IsSet()) {
      // count to the SeqIndex sequence
      SeqCount = 0;
      for (i=GetSequences().GetSet().GetSeq_set().begin();
           i!=GetSequences().GetSet().GetSeq_set().end(); i++) {
        if (SeqCount == SeqIndex) {
          if ((*i)->IsSeq()) {
            // look through the IDs for a PDB id
            NumIDs = (*i)->GetSeq().GetId().size();
            IDCount = 0;
            for (j = (*i)->GetSeq().GetId().begin();
                 j != (*i)->GetSeq().GetId().end(); j++) {
              if ((*j)->IsPdb()) {
                SeqID = (*j);
                return(true);
              }
              IDCount++;
            }
            // look through IDs again for a gi
            IDCount = 0;
            for (j = (*i)->GetSeq().GetId().begin();
                 j != (*i)->GetSeq().GetId().end(); j++) {
              if ((*j)->IsGi()) {
                SeqID = (*j);
                return(true);
              }
              IDCount++;
            }
          }
        }
        SeqCount++;
        if (SeqCount > SeqIndex) break;
      }
    }
  }
  return(false);
}


bool CCdd::GetSeqID(int Pair, int DenDiagRow, CRef<CSeq_id>& SeqID) {
//-------------------------------------------------------------------------
// get a SeqID.
// first get the Pair'th DenDiag, then the DenDiagRow'th SeqID.
//-------------------------------------------------------------------------
  CRef< CDense_diag > DenDiag(new CDense_diag);
  CDense_diag::TIds IdsSet;
  CDense_diag::TIds::iterator i;
  int  Row;

  Row = (Pair == 0) ? DenDiagRow : Pair+1;
  GetDenDiag(Row, true, DenDiag);
  IdsSet = DenDiag->GetIds();
  // for Row=0, get the first id, otherwise get the 2nd id
  i = IdsSet.begin();
  if (DenDiagRow != 0) {
    i++;
  }
  SeqID = (*i);
  return(true);
}


bool CCdd::GetGI(int Row, int& GI) {
//-------------------------------------------------------------------------
// get the GI for Row
//-------------------------------------------------------------------------
  CRef< CSeq_id >  SeqID(new CSeq_id);
  int  Pair, DenDiagRow;

  Pair = (Row <= 1) ? 0 : Row-1;
  DenDiagRow = (Row == 0) ? 0 : 1;
  GetSeqID(Pair, DenDiagRow, SeqID);
  if (SeqID->IsGi()) {
    GI = SeqID->GetGi();
    return(true);
  }
  return(false);
}


bool CCdd::GetPDB(int Row, const CPDB_seq_id*& pPDB) {
//-------------------------------------------------------------------------
// get the PDB ID for Row
//-------------------------------------------------------------------------
  CRef< CSeq_id >  SeqID(new CSeq_id);
  int  Pair, DenDiagRow;

  Pair = (Row <= 1) ? 0 : Row-1;
  DenDiagRow = (Row == 0) ? 0 : 1;
  GetSeqID(Pair, DenDiagRow, SeqID);
  if (SeqID->IsPdb()) {
    pPDB = &(SeqID->GetPdb());
    return(true);
  }
  return(false);
}


int CCdd::GetLowerBound(int Row) {
//-------------------------------------------------------------------------
// get the lower alignment boundary for Row
//-------------------------------------------------------------------------
  CRef< CDense_diag > DenDiag(new CDense_diag);
  list< TSeqPos >::const_iterator  i;

  // get the first den-diag for row
  GetDenDiag(Row, true, DenDiag);
  i = DenDiag->GetStarts().begin();
  if (Row != 0) {
    i++;
  }
  return(*i);
}

int CCdd::GetUpperBound(int Row) {
//-------------------------------------------------------------------------
// get the upper alignment boundary for Row
//-------------------------------------------------------------------------
  CRef< CDense_diag > DenDiag(new CDense_diag);
  list< TSeqPos >::const_iterator  i;

  // get the last den-diag for row
  GetDenDiag(Row, false, DenDiag);
  i = DenDiag->GetStarts().begin();
  if (Row != 0) {
    i++;
  }
  return((*i + DenDiag->GetLen()) - 1);
}


int CCdd::ConvertSequences(std::deque< std::string >& ConvertedSequences) {
//------------------------------------------------------------------------------
// convert seq-data to common format (ncbieaa: extended ASCII 1 letter aa code)
// 
// return the index of the master sequence (in both the original sequences,
// and the converted sequences)
//------------------------------------------------------------------------------
  list< CRef< CSeq_entry > >::const_iterator  i;
  CRef< CSeq_id >  MasterSeqID(new CSeq_id);
  CRef< CSeq_id >  SeqID(new CSeq_id);
  std::string      String, err;
  int              RetVal=-1, SeqIndex=0;

  // get SeqID of the master row
  GetSeqIDFromAlignment(0, MasterSeqID);
  
  ConvertedSequences.clear();

  if (IsSetSequences()) {
    if (GetSequences().IsSet()) {
      // for each of the sequences
      for (i=GetSequences().GetSet().GetSeq_set().begin();
           i!=GetSequences().GetSet().GetSeq_set().end(); i++) {
        if ((*i)->IsSeq()) {
          // if the sequence is present
          if ((*i)->GetSeq().GetInst().IsSetSeq_data()) {
            // for iupacaa and ncbieaa, get sequence
            if ((*i)->GetSeq().GetInst().GetSeq_data().IsNcbieaa()) {
              String = (*i)->GetSeq().GetInst().GetSeq_data().GetNcbieaa().Get();
            }
            else if ((*i)->GetSeq().GetInst().GetSeq_data().IsIupacaa()) {
              String = (*i)->GetSeq().GetInst().GetSeq_data().GetIupacaa().Get();
            }
            // for ncbistdaa, convert the sequence to ncbieaa
            else if ((*i)->GetSeq().GetInst().GetSeq_data().IsNcbistdaa()) {
              StringFromStdaa((*i)->GetSeq().GetInst().GetSeq_data().GetNcbistdaa().Get(), &String);
            }
            else {
              throw runtime_error("Requested conversion not implemented");
            }
            ConvertedSequences.push_back(String);
          }
        }
        GetSeqID(SeqIndex, SeqID);
        if (SeqIdsMatch(MasterSeqID, SeqID)) RetVal = SeqIndex;
        SeqIndex++;
      }
    }
  }

  // return the SeqIndex of the master row
  return(RetVal);
}


int CCdd::GetPSSMLength() {
//-------------------------------------------------------------------------
// get number of residues in the master sequence, from the first
// aligned residue to the last aligned residue
//-------------------------------------------------------------------------
  return(GetUpperBound(0) - GetLowerBound(0) + 1);
}


int CCdd::GetAlignmentLength() {
//-------------------------------------------------------------------------
// get total number of aligned residues
// TDendiag = list< CRef< CDense_diag > >
//-------------------------------------------------------------------------
  TDendiag*  pDenDiagSet;
  list< CRef< CDense_diag > >::iterator  i;
  int  Len=0;

  // get den-diags for master row
  if (SetDenDiagSet(0, pDenDiagSet)) {
    // for each den-diag
    for (i=pDenDiagSet->begin(); i!=pDenDiagSet->end(); i++) {
      // sum lengths of aligned blocks
      Len += (*i)->GetLen();
    }
  }
  return(Len);
}


int CCdd::GetNumSequences() {
//-------------------------------------------------------------------------
// get number of sequences in CD
//-------------------------------------------------------------------------
  if (IsSetSequences()) {
    if (GetSequences().IsSet()) {
      return(GetSequences().GetSet().GetSeq_set().size());
    }
  }
  return(0);
}


int CCdd::GetNumRows() {
//-------------------------------------------------------------------------
// get number of rows in CD
//-------------------------------------------------------------------------
  TSeqannot::const_iterator i;

  if (IsSetSeqannot()) {
    for (i=GetSeqannot().begin(); i!=GetSeqannot().end(); i++) {
      if ((*i)->GetData().IsAlign()) {
        // number pairs + 1 == num rows
        return((*i)->GetData().GetAlign().size()+1);
      }
    }
  }
  return(0);
}


string CCdd::GetUpdateDate() {
//-------------------------------------------------------------------------
// get string indicating date of last change to CD
//-------------------------------------------------------------------------
  CCdd_descr_set::Tdata::const_iterator i;
  string  Str;

  if (IsSetDescription()) {
    for (i=GetDescription().Get().begin(); i!=GetDescription().Get().end(); i++) {
      if ((*i)->IsUpdate_date()) {
        (*i)->GetUpdate_date().GetDate(&Str);
        return(Str);
      }
    }
  }
  return(Str);
}


string CCdd::GetCurationStatus() {
//-------------------------------------------------------------------------
// get string indicating curation status of this CD
//-------------------------------------------------------------------------
  CCdd_descr_set::Tdata::const_iterator i;
  string  Str;

  if (IsSetDescription()) {
    for (i=GetDescription().Get().begin(); i!=GetDescription().Get().end(); i++) {
      if ((*i)->IsStatus()) {
        switch((*i)->GetStatus()) {
          case 0:   return("unassigned");
          case 1:   return("finished_ok");
          case 2:   return("pending_release");
          case 3:   return("other_asis");
          case 4:   return("matrix_only");
          case 5:   return("update_running");
          case 6:   return("auto_updated");
          case 7:   return("claimed");
          case 8:   return("curated_complete");
          default:  return("other");
        }
      }
    }
  }
  return(Str);
}


string CCdd::GetParentAccession(int& Version) {
//-------------------------------------------------------------------------
// get accession name and version of parent
//-------------------------------------------------------------------------
  string  Str;

  if (IsSetParent()) {
    if (GetParent().IsGid()) {
      if (GetParent().GetGid().IsSetVersion()) {
        Version = GetParent().GetGid().GetVersion();
      }
      else {
        Version = 1;
      }
      return(GetParent().GetGid().GetAccession());
    }
  }
  return(Str);
}


void CCdd::SetParentAccession(string Parent, int Version) {
//-------------------------------------------------------------------------
// set accession name and version of parent
//-------------------------------------------------------------------------
  ResetParent();

  CCdd_id* pID = new CCdd_id;
  CGlobal_id* pGID = new CGlobal_id;
  pGID->SetAccession(Parent);
  pGID->SetVersion(Version);
  pID->SetGid(*pGID);
  SetParent(*pID);
}


string CCdd::GetAccession(int& Version) {
//-------------------------------------------------------------------------
// get accession name of CD
//-------------------------------------------------------------------------
  CCdd_id_set::Tdata::const_iterator  i;
  string  Str;

  for (i=GetId().Get().begin(); i!=GetId().Get().end(); i++) {
    if ((*i)->IsGid()) {
      if ((*i)->GetGid().IsSetVersion()) {
        Version = (*i)->GetGid().GetVersion();
      }
      else {
        Version = 1;
      }
      return((*i)->GetGid().GetAccession());
    }
  }
  return(Str);
}


void CCdd::EraseUID() {
//-------------------------------------------------------------------------
// erase CD's uid
//-------------------------------------------------------------------------
  CCdd_id_set::Tdata::iterator  i;

  for (i=SetId().Set().begin(); i!=SetId().Set().end(); i++) {
    if ((*i)->IsUid()) {
      SetId().Set().erase(i);
      return;
    }
  }
}


void CCdd::SetAccession(string Accession, int Version) {
//-------------------------------------------------------------------------
// set accession name of CD
//-------------------------------------------------------------------------
  CCdd_id_set::Tdata::iterator  i;

  for (i=SetId().Set().begin(); i!=SetId().Set().end(); i++) {
    if ((*i)->IsGid()) {
      (*i)->SetGid().SetAccession(Accession);
      (*i)->SetGid().SetVersion(Version);
    }
  }
}


string CCdd::GetLongDescription() {
//-------------------------------------------------------------------------
// get descriptive comment about CD
//-------------------------------------------------------------------------
  CCdd_descr_set::Tdata::const_iterator  i;
  string  Str;

  if (IsSetDescription()) {
    for (i=GetDescription().Get().begin(); i!=GetDescription().Get().end(); i++) {
      if ((*i)->IsComment()) {
        return((*i)->GetComment());
      }
    }
  }
  return(Str);
}


END_objects_SCOPE // namespace ncbi::objects::

END_NCBI_SCOPE

/*
 * ===========================================================================
 * $Log$
 * Revision 1.18  2002/10/10 23:55:06  ucko
 * Replace <cstdio>, which does not exist on all our platforms, with good
 * old <stdio.h>.
 *
 * Revision 1.17  2002/10/10 20:56:12  hurwitz
 * fixed ugly code
 *
 * Revision 1.16  2002/10/09 21:22:49  hurwitz
 * small change to previous commit
 *
 * Revision 1.15  2002/10/09 20:59:50  hurwitz
 * added function for getting seq-id string for a row of the alignment
 *
 * Revision 1.14  2002/09/26 14:22:57  hurwitz
 * handle new case for curation status
 *
 * Revision 1.13  2002/09/20 18:35:01  hurwitz
 * added functions to support membership display
 *
 * Revision 1.12  2002/08/30 21:26:08  hurwitz
 * added function to re-arrange rows of alignment
 *
 * Revision 1.11  2002/08/23 14:33:05  hurwitz
 * prefer formal name over common name for taxonomy
 *
 * Revision 1.10  2002/08/02 18:57:19  hurwitz
 * fix STL inconsistencies
 *
 * Revision 1.9  2002/08/02 17:21:40  hurwitz
 * fix due to change in asn1 container class, plus bug fix
 *
 * Revision 1.8  2002/08/02 14:40:01  hurwitz
 * many new features
 *
 * Revision 1.7  2002/07/09 14:50:37  hurwitz
 * added function
 *
 * Revision 1.6  2002/07/05 13:27:42  ucko
 * Tweak to be less sensitive to ASN.1-based types' implementation-details.
 * Move CVS log to end per current practice.
 *
 * Revision 1.5  2002/06/20 14:08:01  hurwitz
 * fix header problem by getting rid of call to CopyASNObject
 *
 * Revision 1.4  2002/06/19 20:29:43  hurwitz
 * added more support functions for cdd access
 *
 * Revision 1.3  2002/06/10 21:05:05  hurwitz
 * added access function to parent field
 *
 * Revision 1.2  2002/06/07 18:35:48  hurwitz
 * fix 2 bugs for Solaris compilation
 *
 * Revision 1.1  2002/06/07 14:44:11  hurwitz
 * extra functions for cdd objects
 *
 *
 * ===========================================================================
 */

/* Original file checksum: lines: 61, chars: 1862, CRC32: 24714fb3 */
