/* $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author:  .......
 *
 * File Description:
 *   .......
 *
 * Remark:
 *   This code was originally generated by application DATATOOL
 *   using specifications from the ASN data definition file
 *   'general.asn'.
 *
 * ---------------------------------------------------------------------------
 */

// standard includes

// generated includes
#include <ncbi_pch.hpp>
#include <objects/general/Dbtag.hpp>
#include <objects/general/Object_id.hpp>
#include <corelib/ncbistd.hpp>

#include <util/static_map.hpp>

// generated classes

BEGIN_NCBI_SCOPE

BEGIN_objects_SCOPE // namespace ncbi::objects::

typedef pair<const char*, CDbtag::EDbtagType> TDbxrefPair;
static const TDbxrefPair kApprovedDbXrefs[] = {
    TDbxrefPair("ATCC", CDbtag::eDbtagType_ATCC),
    TDbxrefPair("ATCC(dna)", CDbtag::eDbtagType_ATCC_dna),
    TDbxrefPair("ATCC(in host)", CDbtag::eDbtagType_ATCC_in_host),
    TDbxrefPair("AceView/WormGenes", CDbtag::eDbtagType_AceView_WormGenes),
    TDbxrefPair("BDGP_EST", CDbtag::eDbtagType_BDGP_EST),
    TDbxrefPair("BDGP_INS", CDbtag::eDbtagType_BDGP_INS),
    TDbxrefPair("CDD", CDbtag::eDbtagType_CDD),
    TDbxrefPair("CK", CDbtag::eDbtagType_CK),
    TDbxrefPair("COG", CDbtag::eDbtagType_COG),
    TDbxrefPair("ENSEMBL", CDbtag::eDbtagType_ENSEMBL),
    TDbxrefPair("ESTLIB", CDbtag::eDbtagType_ESTLIB),
    TDbxrefPair("FANTOM_DB", CDbtag::eDbtagType_FANTOM_DB),
    TDbxrefPair("FLYBASE", CDbtag::eDbtagType_FLYBASE),
    TDbxrefPair("GABI", CDbtag::eDbtagType_GABI),
    TDbxrefPair("GDB", CDbtag::eDbtagType_GDB),
    TDbxrefPair("GI", CDbtag::eDbtagType_GI),
    TDbxrefPair("GO", CDbtag::eDbtagType_GO),
    TDbxrefPair("GOA", CDbtag::eDbtagType_GOA),
    TDbxrefPair("GeneDB", CDbtag::eDbtagType_GeneDB),
    TDbxrefPair("GeneID", CDbtag::eDbtagType_GeneID),
    TDbxrefPair("H-InvDB", CDbtag::eDbtagType_H_InvDB),
    TDbxrefPair("IFO", CDbtag::eDbtagType_IFO),
    TDbxrefPair("IMGT/HLA", CDbtag::eDbtagType_IMGT_HLA),
    TDbxrefPair("IMGT/LIGM", CDbtag::eDbtagType_IMGT_LIGM),
    TDbxrefPair("ISFinder", CDbtag::eDbtagType_ISFinder),
    TDbxrefPair("InterimID", CDbtag::eDbtagType_InterimID),
    TDbxrefPair("Interpro", CDbtag::eDbtagType_Interpro),
    TDbxrefPair("JCM", CDbtag::eDbtagType_JCM),
    TDbxrefPair("LocusID", CDbtag::eDbtagType_LocusID),
    TDbxrefPair("MGD", CDbtag::eDbtagType_MGD),
    TDbxrefPair("MGI", CDbtag::eDbtagType_MGI),
    TDbxrefPair("MIM", CDbtag::eDbtagType_MIM),
    TDbxrefPair("MaizeDB", CDbtag::eDbtagType_MaizeDB),
    TDbxrefPair("NextDB", CDbtag::eDbtagType_NextDB),
    TDbxrefPair("PID", CDbtag::eDbtagType_PID),
    TDbxrefPair("PIDd", CDbtag::eDbtagType_PIDd),
    TDbxrefPair("PIDe", CDbtag::eDbtagType_PIDe),
    TDbxrefPair("PIDg", CDbtag::eDbtagType_PIDg),
    TDbxrefPair("PIR", CDbtag::eDbtagType_PIR),
    TDbxrefPair("PSEUDO", CDbtag::eDbtagType_PSEUDO),
    TDbxrefPair("RATMAP", CDbtag::eDbtagType_RATMAP),
    TDbxrefPair("REMTREMBL", CDbtag::eDbtagType_REMTREMBL),
    TDbxrefPair("RGD", CDbtag::eDbtagType_RGD),
    TDbxrefPair("RZPD", CDbtag::eDbtagType_RZPD),
    TDbxrefPair("RiceGenes", CDbtag::eDbtagType_RiceGenes),
    TDbxrefPair("SGD", CDbtag::eDbtagType_SGD),
    TDbxrefPair("SoyBase", CDbtag::eDbtagType_SoyBase),
    TDbxrefPair("Swiss-Prot", CDbtag::eDbtagType_SWISS_PROT),
    TDbxrefPair("TrEMBL", CDbtag::eDbtagType_SPTREMBL),
    TDbxrefPair("UniGene", CDbtag::eDbtagType_UniGene),
    TDbxrefPair("UniSTS", CDbtag::eDbtagType_UniSTS),
    TDbxrefPair("WorfDB", CDbtag::eDbtagType_WorfDB),
    TDbxrefPair("WormBase", CDbtag::eDbtagType_WormBase),
    TDbxrefPair("ZFIN", CDbtag::eDbtagType_ZFIN),
    TDbxrefPair("dbEST", CDbtag::eDbtagType_dbEST),
    TDbxrefPair("dbSNP", CDbtag::eDbtagType_dbSNP),
    TDbxrefPair("dbSTS", CDbtag::eDbtagType_dbSTS),
    TDbxrefPair("niaEST", CDbtag::eDbtagType_niaEST),
    TDbxrefPair("taxon", CDbtag::eDbtagType_taxon)
};

static const TDbxrefPair kApprovedRefSeqDbXrefs[] = {
    TDbxrefPair("DDBJ", CDbtag::eDbtagType_DDBJ),
    TDbxrefPair("EMBL", CDbtag::eDbtagType_EMBL),
    TDbxrefPair("GenBank", CDbtag::eDbtagType_GenBank),
    TDbxrefPair("REBASE", CDbtag::eDbtagType_REBASE)
};

// case sensetive
typedef CStaticArrayMap<const char*, CDbtag::EDbtagType, PCase> TDbxrefTypeMap;
static const TDbxrefTypeMap sc_ApprovedDb(kApprovedDbXrefs,
                                          sizeof(kApprovedDbXrefs));
static const TDbxrefTypeMap sc_ApprovedRefSeqDb(kApprovedRefSeqDbXrefs,
                                                sizeof(kApprovedRefSeqDbXrefs));


// destructor
CDbtag::~CDbtag(void)
{
}

bool CDbtag::Match(const CDbtag& dbt2) const
{
	if (! PNocase().Equals(GetDb(), dbt2.GetDb()))
		return false;
	return ((GetTag()).Match((dbt2.GetTag())));
}


int CDbtag::Compare(const CDbtag& dbt2) const
{
    int ret = PNocase().Compare(GetDb(), dbt2.GetDb());
    if (ret == 0) {
        ret = GetTag().Compare(dbt2.GetTag());
    }
    return ret;
}


// Appends a label to "label" based on content of CDbtag 
void CDbtag::GetLabel(string* label) const
{
    const CObject_id& id = GetTag();
    switch (id.Which()) {
    case CObject_id::e_Str:
        *label += GetDb() + ": " + id.GetStr();
        break;
    case CObject_id::e_Id:
        *label += GetDb() + ": " + NStr::IntToString(id.GetId());
        break;
    default:
        *label += GetDb();
    }
}

// Test if CDbtag.db is in the approved databases list.
// NOTE: 'GenBank', 'EMBL', 'DDBJ' and 'REBASE' are approved only in 
//        the context of a RefSeq record.
bool CDbtag::IsApproved(bool refseq) const
{
    if ( !CanGetDb() ) {
        return false;
    }
    const string& db = GetDb();

    return sc_ApprovedDb.find(db.c_str()) != sc_ApprovedDb.end()  ||
        (refseq  &&  sc_ApprovedRefSeqDb.find(db.c_str()) != sc_ApprovedRefSeqDb.end());
}


const char* CDbtag::IsApprovedNoCase(bool refseq) const
{
    if ( !CanGetDb() ) {
        return false;
    }
    const string& db = GetDb();
    
    const char* retval = 0;
    ITERATE (TDbxrefTypeMap, it, sc_ApprovedDb) {
        if ( NStr::EqualNocase(db, it->first) ) {
            retval = it->first;
            break;
        }
    }
    if ( retval == 0  &&  refseq ) {
        ITERATE (TDbxrefTypeMap, it, sc_ApprovedRefSeqDb) {
            if ( NStr::EqualNocase(db, it->first) ) {
                retval = it->first;
                break;
            }
        }
    }

    return retval;
}


// Retrieve the enumerated type for the dbtag
CDbtag::EDbtagType CDbtag::GetType(void) const
{
    if (m_Type == eDbtagType_bad) {
        if ( !CanGetDb() ) {
            return m_Type;
        }

        const string& db = GetDb();

        TDbxrefTypeMap::const_iterator iter =
            sc_ApprovedDb.find(db.c_str());
        if ( iter != sc_ApprovedDb.end() ) {
            m_Type = iter->second;
        } else {
            iter = sc_ApprovedRefSeqDb.find(db.c_str());
            if ( iter != sc_ApprovedRefSeqDb.end() ) {
                m_Type = iter->second;
            }
        }
    }
    return m_Type;
}


// Force a refresh of the internal type
void CDbtag::InvalidateType(void)
{
    m_Type = eDbtagType_bad;
}


END_objects_SCOPE // namespace ncbi::objects::

END_NCBI_SCOPE

/*
 * ===========================================================================
 * $Log$
 * Revision 6.17  2004/08/30 13:24:23  shomrat
 * + eDbtagType_H_InvDB
 *
 * Revision 6.16  2004/05/28 20:09:44  johnson
 * Added Compare for seq-id type General (CDbtag)
 *
 * Revision 6.15  2004/05/19 17:21:39  gorelenk
 * Added include of PCH - ncbi_pch.hpp
 *
 * Revision 6.14  2004/04/23 16:56:00  shomrat
 * + IsApprovedNoCase
 *
 * Revision 6.13  2004/01/29 20:35:22  vasilche
 * Use CStaticArrayMap<>.
 *
 * Revision 6.12  2004/01/20 20:28:59  ucko
 * Fix calculation of kApprovedDbXrefs_size.
 *
 * Revision 6.11  2004/01/20 16:04:36  dicuccio
 * Implemented enumerated type interpretation of string-based database name
 *
 * Revision 6.10  2004/01/06 14:36:06  dicuccio
 * Removed unnecessary #include of ncbiapp.hpp and ncbireg.hpp.  Added <set>
 * where needed.
 *
 * Revision 6.9  2003/10/01 13:12:24  shomrat
 * REBASE is legal refseq dbxref
 *
 * Revision 6.8  2003/09/17 15:22:57  vasilche
 * Removed unnecessary array of strings and related memory leak.
 *
 * Revision 6.7  2003/07/22 16:34:39  shomrat
 * Added ZFIN to approved DB list
 *
 * Revision 6.6  2003/06/27 16:22:25  shomrat
 * Changed initialization of kApprovedDbXrefs
 *
 * Revision 6.5  2003/06/27 15:40:09  shomrat
 * Implemented IsApproved
 *
 * Revision 6.4  2002/01/10 19:45:57  clausen
 * Added GetLabel
 *
 * Revision 6.3  2001/12/07 18:52:04  grichenk
 * Updated "#include"-s and forward declarations to work with the
 * new datatool version.
 *
 * Revision 6.2  2000/12/15 19:22:10  ostell
 * made AsString do Upcase, and switched to using PNocase().Equals()
 *
 * Revision 6.1  2000/11/21 18:58:20  vasilche
 * Added Match() methods for CSeq_id, CObject_id and CDbtag.
 *
 *
 * ===========================================================================
 */
