/* $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author:  J. Chen
 *
 * File Description:
 *   Evaluate if a string and an object match to CString_constraint
 *
 * Remark:
 *   This code was originally generated by application DATATOOL
 *   using the following specifications:
 *   'macro.asn'.
 */

#include <ncbi_pch.hpp>
#include <objects/macro/String_constraint.hpp>
#include <objects/seqfeat/Seq_feat.hpp>
#include <objects/seqfeat/Imp_feat.hpp>

BEGIN_NCBI_SCOPE
BEGIN_objects_SCOPE // namespace ncbi::objects::

namespace
{
    static const char digit_str[] = "0123456789";
    static const char alpha_str[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

    static const CTempString s_weasels[] = {
        "candidate",
        "hypothetical",
        "novel",
        "possible",
        "potential",
        "predicted",
        "probable",
        "putative",
        "candidate",
        "uncharacterized",
        "unique"
    };

    CTempString::size_type x_SkipWeasel(const string& str)
    {
        if (str.empty()) {
            return 0;
        }

        bool found = false;

        string::size_type start;
        string::size_type word_end = 0;
        bool word_found;
        do
        {
            if ((start = str.find_first_not_of(' ', word_end)) == string::npos)
            {
                start = str.length();
                break;
            }

            if ((word_end = str.find(' ', start)) == string::npos)
                word_end = str.size();

            CTempString word(str, start, word_end - start);

            word_found = find(std::begin(s_weasels), std::end(s_weasels), word) != std::end(s_weasels);

            if (word_found)
                found = true;

        } while (word_found);

        if (found)
        {
            return start;
        }
        else
            return 0;
    }

    class T
    {
    public:
        T()
        {
            string r;
            r = x_SkipWeasel("check the word");
            r = x_SkipWeasel(" novel check the word");
            r = x_SkipWeasel("novel check the word");
            r = x_SkipWeasel("novel novel");
            r = x_SkipWeasel("novel novel ");
        };
    };

    T test;

    CTempString x_StripUnimportantCharacters(string& storage, const CTempString& str, bool strip_space, bool strip_punct)
    {
        if (str.empty()) {
            return kEmptyStr;
        }
        if (!strip_space && !strip_punct)
            return str;

        bool has_stripped = false;
        CTempString::size_type i = 0;
        const char* s = str.data();
        for (; i < str.size(); i++, s++)
        {
            if ((strip_space && isspace(*s)) || (strip_punct && ispunct(*s)))
            {
                if (!has_stripped) // first occurence
                {
                    storage.reserve(str.size()-1); // at least one symbol will be removed
                    storage.clear();
                    storage.append(str.data(), i);
                    has_stripped = true;
                }
            }
            else
            {
                if (has_stripped)
                   storage.push_back(*s);
            }
        }

        if (has_stripped)
            return storage;
        else
            return str;
    };

    inline
    bool x_DisallowCharacter(const char ch, bool disallow_slash)
    {
        if (isalpha(Uint1(ch)) || isdigit(Uint1(ch)) || ch == '_' || ch == '-') return true;
        else if (disallow_slash && ch == '/') return true;
        else return false;
    };

};

void CMatchString::x_GetNoweasel() const
{
    if (m_noweasel_start == CTempString::npos)
    {        
        m_noweasel_start = x_SkipWeasel(m_original.lowercase());
    }
}

CString_constraint::CString_constraint()
{
}

CString_constraint::~CString_constraint()
{
}

bool CString_constraint :: Empty() const
{
   if (GetIs_all_caps() ||
       GetIs_all_lower() ||
       GetIs_all_punct() ||
       GetIs_first_cap() ||
       GetIs_first_each_cap()) {
      return false;
   } else if (!CanGetMatch_text() || GetMatch_text().empty()) {
        return true;
   }

   return false;
}

bool CString_constraint::x_IsAllCaps(const CMatchString& str) const
{
    return x_GetCompareString(str, e_original) == x_GetCompareString(str, e_uppercase);
}

bool CString_constraint::x_IsAllLowerCase(const CMatchString& str) const
{
    return x_GetCompareString(str, e_original) == x_GetCompareString(str, e_lowercase);
}

bool CString_constraint::x_IsAllPunctuation(const CMatchString& str) const
{
   CTempString match = x_GetCompareString(str, e_original);
   for (unsigned i=0; i< match.size(); i++) {
     if (!ispunct(match[i])) return false;
   }
   return true;
}

bool CString_constraint::x_IsSkippable(const char ch) const
{
    if (ispunct(ch) && GetIgnore_punct()) {
        return true;
    } else if (isspace(ch) && GetIgnore_space()) {
        return true;
    } else {
        return false;
    }
}

bool CString_constraint::x_IsAllSkippable(const CTempString& match) const
{
    for (CTempString::size_type i = 0; i < match.size(); i++) {
        if (!x_IsSkippable(match[i])) {
            return false;
        }
    }
    return true;
}

bool CString_constraint::x_IsFirstCap(const CMatchString& s) const
{
    CTempString str = x_GetCompareString(s, e_original);
    // ignore punctuation and spaces at the beginning of the phrase
    CTempString::const_iterator it = str.begin();
    while (it != str.end() && !isalpha((unsigned char) (*it))) {
    if (isdigit( (unsigned char) (*it))) {
        return false;
    }
        ++it;
    }

    if (it != str.end()) {
        return isalpha((unsigned char) (*it)) && isupper((unsigned char) (*it));
    }
    return false;
}

bool CString_constraint::x_IsFirstEachCap(const CMatchString& s) const
{
    CTempString str = x_GetCompareString(s, e_original);
    bool first(true);
    bool rval(true);
    for (size_t i = 0; i < str.size() && rval; ++i) {
        if (isalpha( (unsigned char) str[i])) {
            if (first) {
                rval = rval && isupper( (unsigned char) str[i] );
                first = false;
            } 
        } else if ( str[i] == '-' ){
            // hyphenated words are considered as one composed word
            if ((i > 0 && !isalpha( (unsigned char) str[i - 1])) || 
                (i + 1 < str.size() && !isalpha( (unsigned char) str[i + 1] ))) 
                first = true;
        } else if (isdigit( (unsigned char) str[i])){
            if (i + 1 < str.size() && isalpha( (unsigned char) str[i + 1])) {
                rval = false;
            }
        } else {
            first = true;
        }
    }
    return rval;
}

bool CString_constraint :: x_IsWholeWordMatch(const CTempString& start, size_t found, size_t match_len, bool disallow_slash) const
{
  size_t after_idx;

  if (!match_len) return true;
  else if (start.empty() || found == string::npos) return false;
  else
  {
    if (found) {
      if (x_DisallowCharacter (start[found-1], disallow_slash)) {
         return false;
      }
    }
    after_idx = found + match_len;
    if ( after_idx < start.size()
              && x_DisallowCharacter(start[after_idx], disallow_slash)) {
       return false;
    }
  }
  return true;
};


bool CString_constraint :: x_PartialCompare(const string& str, const string& pattern, char prev_char, size_t & match_len) const
{
    // check for synonyms to skip
    if (IsSetIgnore_words()) {
        ITERATE(CWord_substitution_set::Tdata, word, GetIgnore_words().Get()) {
            vector<size_t> match_lens = (*word)->GetMatchLens(str, pattern, prev_char);
            if (match_lens.size() > 0) {
                size_t word_len = (*word)->GetWord().length();
                ITERATE(vector<size_t>, len, match_lens) {
                    size_t this_match = 0;
                    char this_prev_char = 0;
                    if (*len > 0) {
                        this_prev_char = str.c_str()[(*len) - 1];
                    } else {
                        this_prev_char = prev_char;
                    }
                    bool require_end = false;
                    if (GetMatch_location() == eString_location_equals || GetMatch_location() == eString_location_ends) {
                        require_end = true;
                    }
                    if (x_PartialCompare(str.substr(*len), pattern.substr(word_len), this_prev_char, this_match) &&
                        (!require_end || this_match == str.substr(*len).length())) {
                        match_len += *len;
                        match_len += this_match;                        
                        return true;
                    }
                }
            }
        }
    }

    if (pattern.length() == 0) {
        return true;
    }

    if (str.length() == 0) {
        if (x_IsAllSkippable(pattern)) {
            return true;
        }
        // special case: can continue if the next character is a space, might have words to ignore
        if (isspace(pattern[0])) {
            return x_PartialCompare(str, pattern.substr(1), ' ', match_len);
        } else {
            return false;
        }
    }
    if (GetIgnore_space()) {
        if (isspace(Uint1(str[0]))) {
            match_len++;
            return x_PartialCompare(str.substr(1), pattern, str[0], match_len);
        } else if (isspace(Uint1(pattern[0]))) {
            return x_PartialCompare(str, pattern.substr(1), prev_char, match_len);
        }
    }
    if (GetIgnore_punct()) {
        if (ispunct(Uint1(str[0]))) {
            match_len++;
            return x_PartialCompare(str.substr(1), pattern, str[0], match_len);
        } else if (ispunct(Uint1(pattern[0]))) {
            return x_PartialCompare(str, pattern.substr(1), prev_char, match_len);
        }
    }
    if (str[0] == pattern[0]) {
        match_len++;
        return x_PartialCompare(str.substr(1), pattern.substr(1), str[0], match_len);
    } else if ((!IsSetCase_sensitive() || !GetCase_sensitive()) &&
               tolower(Uint1(str[0])) == tolower(Uint1(pattern[0]))) {
        match_len++;
        return x_PartialCompare(str.substr(1), pattern.substr(1), str[0], match_len);
    }
        
    return false;
}


bool CString_constraint :: x_AdvancedStringCompare(const string& str, const string& str_match, const char prev_char, size_t * ini_target_match_len)  const
{
    bool rval = false;
    size_t match_len = 0;
    if (x_PartialCompare(str, str_match, prev_char, match_len)) {
        if (ini_target_match_len != NULL) {
            *ini_target_match_len = match_len;
        }
        rval = true;
    }

    return rval;
};

bool CString_constraint :: x_AdvancedStringMatch(const string& str, const string& tmp_match) const
{
  bool rval = false;
  string
    match_text = CanGetMatch_text() ? tmp_match : kEmptyStr;

  size_t match_len = 0;

  if (x_AdvancedStringCompare (str, match_text, 0, &match_len) &&
      (GetMatch_location() != eString_location_equals || match_len == str.length())) {
       return true;
  }
  else if (GetMatch_location() == eString_location_starts
                || GetMatch_location() == eString_location_equals) {
           return false;
  }
  else {
    size_t pos = 1;
    size_t len = str.size();
    while (!rval && pos < len) {
      if (GetWhole_word()) {
          while (pos < len && isalpha (Uint1(str[pos-1]))) pos++;
      }
      if (pos < len) {
        size_t sub_match_len = 0;
        if (x_AdvancedStringCompare (CTempString(str).substr(pos),
                                      match_text,
                                      0, &sub_match_len)) {
            if (sub_match_len < len - pos && GetMatch_location() == eString_location_ends) {
                pos++;
            } else {
                rval = true;
            }
        } else {
            pos++;
        }
      }
    }
  }
  return rval;
};

bool CString_constraint :: x_GetSpanFromHyphenInString(const string& str, size_t hyphen, string& first, string& second) const
{
   if (!hyphen) return false;

   /* find range start */
   size_t cp = str.substr(0, hyphen-1).find_last_not_of(' ');   
   if (cp != string::npos) {
      cp = str.substr(0, cp).find_last_not_of(" ,;"); 
   }
   if (cp == string::npos) {
     cp = 0;
   }

   size_t len = hyphen - cp;
   first = CTempString(str).substr(cp, len);
   NStr::TruncateSpacesInPlace(first);
 
   /* find range end */
   cp = str.find_first_not_of(' ', hyphen+1);
   if (cp != string::npos) {
      cp = str.find_first_not_of(" ,;");
   }
   if (cp == string::npos) {
      cp = str.size() -1;   
   }

   len = cp - hyphen;
   if (!isspace (Uint1(str[cp]))) {
     len--;
   }
   second = CTempString(str).substr(hyphen+1, len);
   NStr::TruncateSpacesInPlace(second);

   bool rval = true;
   if (first.empty() || second.empty()) {
      rval = false;
   }
   else if (!isdigit (Uint1(first[first.size() - 1])) 
                 || !isdigit (Uint1(second[second.size() - 1]))) {
      /* if this is a span, then neither end point can end with anything other than a number */
      rval = false;
   }
   if (!rval) {
      first = second = kEmptyStr;
   }
   return rval;
};

bool CString_constraint :: x_StringIsPositiveAllDigits(const string& str) const
{
   if (str.find_first_not_of(digit_str) != string::npos) {
      return false;
   }

   return true;
}

bool CString_constraint :: x_IsStringInSpan(const string& str, const string& first, const string& second) const
{
  string new_first, new_second, new_str;
  if (str.empty()) return false;
  else if (str == first || str == second) return true;
  else if (first.empty() || second.empty()) return false;

  int str_num, first_num, second_num;
  str_num = first_num = second_num = 0;
  bool rval = false;
  size_t prefix_len;
  string comp_str1, comp_str2;
  if (x_StringIsPositiveAllDigits (first)) {
    if (x_StringIsPositiveAllDigits (str) 
             && x_StringIsPositiveAllDigits (second)) {
      str_num = NStr::StringToUInt (str);
      first_num = NStr::StringToUInt (first);
      second_num = NStr::StringToUInt (second);
      if ( (str_num > first_num && str_num < second_num)
               || (str_num > second_num && str_num < first_num) ) {
          rval = true;
      }
    }
  } 
  else if (x_StringIsPositiveAllDigits(second)) {
    prefix_len = first.find_first_of(digit_str) + 1;

    new_str = CTempString(str).substr(prefix_len - 1);
    new_first = CTempString(first).substr(prefix_len - 1);
    comp_str1 = CTempString(str).substr(0, prefix_len);
    comp_str2 = CTempString(first).substr(0, prefix_len);
    if (comp_str1 == comp_str2
          && x_StringIsPositiveAllDigits (new_str)
          && x_StringIsPositiveAllDigits (new_first)) {
      first_num = NStr::StringToUInt(new_first);
      second_num = NStr::StringToUInt (second);
      str_num = NStr::StringToUInt (str);
      if ( (str_num > first_num && str_num < second_num)
               || (str_num > second_num && str_num < first_num) ) {
        rval = true;
      }
    }
  } 
  else {
    /* determine length of prefix */
    prefix_len = 0;
    while ( prefix_len < first.size() 
               && prefix_len < second.size() 
               && first[prefix_len] == second[prefix_len]) {
       prefix_len ++;
    }
    prefix_len ++;

    comp_str1 = CTempString(str).substr(0, prefix_len);
    comp_str2 = CTempString(first).substr(0, prefix_len);
    if (prefix_len <= first.size() 
           && prefix_len <= second.size()
           && isdigit (Uint1(first[prefix_len-1])) 
           && isdigit (Uint1(second[prefix_len-1]))
           && comp_str1 == comp_str2) {
      new_first = CTempString(first).substr(prefix_len);
      new_second = CTempString(second).substr(prefix_len);
      new_str = CTempString(str).substr(prefix_len);
      if (x_StringIsPositiveAllDigits (new_first) 
            && x_StringIsPositiveAllDigits (new_second) 
            && x_StringIsPositiveAllDigits (new_str)) {
        first_num = NStr::StringToUInt(new_first);
        second_num = NStr::StringToUInt (new_second);
        str_num = NStr::StringToUInt (new_str);
        if ( (str_num > first_num && str_num < second_num)
                || (str_num > second_num && str_num < first_num) ) {
          rval = true;
        }
      } else {
        /* determine whether there is a suffix */
        size_t idx1, idx2, idx_str;
        string suf1, suf2, sub_str;
        idx1 = first.find_first_not_of(digit_str);
        suf1 = CTempString(first).substr(prefix_len + idx1);
        idx2 = second.find_first_not_of(digit_str);
        suf2 = CTempString(second).substr(prefix_len + idx2);
        idx_str = str.find_first_not_of(digit_str);
        sub_str = CTempString(str).substr(prefix_len + idx_str);
        if (suf1 == suf2 && suf1 == sub_str) {
          /* suffixes match */
          first_num 
            = NStr::StringToUInt(CTempString(first).substr(prefix_len, idx1));
          second_num 
            =NStr::StringToUInt(CTempString(second).substr(prefix_len, idx2));
          str_num 
            =NStr::StringToUInt(CTempString(str).substr(prefix_len, idx_str));
          if ( (str_num > first_num && str_num < second_num)
                   || (str_num > second_num && str_num < first_num) ) {
            rval = true;
          }
        }
      }
    }
  }
  return rval;
};

bool CString_constraint :: x_IsStringInSpanInList (const string& str, const string& list) const
{
  if (list.empty() || str.empty()) {
      return false;
  }

  size_t idx = str.find_first_not_of(alpha_str);
  if (idx == string::npos) {
     return false;
  }

  idx = CTempString(str).substr(idx).find_first_not_of(digit_str);

  /* find ranges */
  size_t hyphen = list.find('-');
  bool rval = false;
  string range_start, range_end;
  while (hyphen != string::npos && !rval) {
    if (!hyphen) {
       hyphen = CTempString(list).substr(1).find('-');
    }
    else {
      if (x_GetSpanFromHyphenInString (list, hyphen, range_start, range_end)){
        if (x_IsStringInSpan (str, range_start, range_end)) rval = true;
      }
      hyphen = list.find('-', hyphen + 1);
    }
  }
  return rval;
};

CTempString CString_constraint::x_GetCompareString(const CMatchString& s, ECase e_case) const
{
    if (e_case == e_automatic)
    {
        if (GetCase_sensitive())
          e_case = e_original;
        else
          e_case = e_lowercase;
    }
    if (GetIgnore_weasel())
    {
        switch (e_case)
        {
        case e_automatic:
        case e_original:
            return s.GetNoweasel();
        case e_lowercase:
            return s.GetNoweaselLC();
        case e_uppercase:
            return s.GetNoweaselUC();
        }
    }
    else
    {
        switch (e_case)
        {
        case e_automatic:
        case e_original:
            return s.original().original();
        case e_lowercase:
            return s.original().lowercase();
        case e_uppercase:
            return s.original().uppercase();
        }
    }
}

bool CString_constraint::x_DoesSingleStringMatchConstraint(const CMatchString& str) const
{
    if (str.original().original().empty()) {
        return false;
    }

    bool rval(false);
    if (Empty()) {
        rval = true;
    }
    
    //const CAutoLowerCase& this_str = GetIgnore_weasel() ? str.noweasel() : str.original();
    //const CAutoLowerCase& this_str = str.original();

    if (GetIs_all_caps() && !x_IsAllCaps(str)) {
        rval = false;
    }
    else if (GetIs_all_lower() && !x_IsAllLowerCase(str)) {
        rval = false;
    }
    else if (GetIs_all_punct() && !x_IsAllPunctuation(str)) {
        rval = false;
    }
    else if (GetIs_first_cap() && !x_IsFirstCap(str)) {
        rval = false;
    }
    else if (GetIs_first_each_cap() && !x_IsFirstEachCap(str)) {
        rval = false;
    } else 
    {
        CTempString pattern = x_GetCompareString();
        CTempString search = x_GetCompareString(str);

        if (GetMatch_location() != eString_location_inlist && CanGetIgnore_words()){
            rval = x_AdvancedStringMatch(search, pattern);
        } else {
            string s_search, s_pattern;
            if ( GetMatch_location() != eString_location_inlist && (GetIgnore_space() || GetIgnore_punct())) {
              search = x_StripUnimportantCharacters(s_search, search, GetIgnore_space(), GetIgnore_punct());
              pattern = x_StripUnimportantCharacters(s_pattern, pattern, GetIgnore_space(), GetIgnore_punct());
            } 
            
            SIZE_TYPE pFound;
            if (pattern.empty()) {
                pFound = 0;
            } else {
                pFound = search.find(pattern); // NStr::Find(search, pattern, 0, NPOS, NStr::eFirst);
            }

            switch (GetMatch_location()) {
            case eString_location_contains:
                if (pFound == NPOS) {
                    rval = false;
                } else if (GetWhole_word()) {
                    rval = x_IsWholeWordMatch (search, pFound, pattern.size());
                    while (!rval && pFound != NPOS) {
                        pFound = search.find(pattern, pFound+1); // NStr::Find(search, pattern, pFound + 1, NPOS, NStr::eFirst);
                        rval = (pFound != NPOS) ? x_IsWholeWordMatch(search, pFound, pattern.size()) : false;
                    }
                } else {
                    rval = true;
                }
                break;
            case eString_location_starts:
                if (pFound == 0) {
                    rval = GetWhole_word() ? x_IsWholeWordMatch (search, pFound, pattern.size()) : true;
                }
                break;
            case eString_location_ends:
                while (pFound != NPOS && !rval) {
                    if ( (pFound + pattern.size()) == search.size()) {
                        rval = GetWhole_word() ? x_IsWholeWordMatch (search, pFound, pattern.size()) : true;
                        /* stop the search, we're at the end of the string */
                        pFound = NPOS;
                    } else {
                        pFound = search.find(pattern, pFound + 1); // NStr::Find(search, pattern, pFound + 1, NPOS, NStr::eFirst);
                    }
                }
                break;
            case eString_location_equals:
                rval = (search == pattern);
                break;
            case eString_location_inlist:
                pFound = NStr::Find(pattern, search, 0, NPOS, NStr::eFirst);
                if (pFound == NPOS) {
                    rval = false;
                } else {
                    rval = x_IsWholeWordMatch(pattern, pFound, search.size(), true);
                    while (!rval && pFound != NPOS) {
                        pFound = NStr::Find(pattern.substr(pFound + 1), search, 0, NPOS, NStr::eFirst);
                        if (pFound != NPOS) {
                            rval = x_IsWholeWordMatch(pattern, pFound, str.original().original().size(), true);
                        }
                    }
                }
                if (!rval) {
                /* look for spans */
                rval = x_IsStringInSpanInList (search, pattern);
                }
            break;
            }
        }
    }

    return rval;
}

bool CString_constraint::Match(const CMatchString& str) const
{
    bool rval = x_DoesSingleStringMatchConstraint (str);
    return GetNot_present() ? (!rval) : rval;
}

bool CString_constraint::x_ReplaceContains(string& val, const string& replace) const
{
    bool rval = false;

    size_t offset = 0;
    while (offset < val.length()) {
        size_t match_len = 0;
        if (x_AdvancedStringCompare(val.substr(offset), GetMatch_text(),
                                    offset == 0 ? 0 : val.c_str()[offset - 1],
                                    &match_len)) {
            val = val.substr(0, offset) + replace + val.substr(offset + match_len);
            rval = true;
            offset += replace.length();
        } else {
            offset++;
        }
    }
    return rval;
}


bool CString_constraint::ReplaceStringConstraintPortionInString(string& result, const CMatchString& str, const string& replace) const
{
    bool rval = false;
    
    const string& val = str;

    if (val.empty()) {
        if (Empty() || (IsSetNot_present() && GetNot_present())) {
            result = replace;
            rval = true;
        }
    } else if (Empty()) {
        result = replace;
        rval = true;
    } else {
        if (IsSetMatch_location()) {
            switch (GetMatch_location()) {
                case eString_location_inlist:
                case eString_location_equals:
                    result = replace;
                    rval = true;
                    break;
                case eString_location_starts:
                    {{
                       size_t match_len = 0;
                       if (x_AdvancedStringCompare(val, GetMatch_text(), 0, &match_len)) {
                           result = replace;
                           result.append(val.data()+match_len, val.length()-match_len);                           
                           rval = true;
                       }
                    }}
                    break;
                case eString_location_contains:
                    result = val;
                    rval = x_ReplaceContains(result, replace);
                    break;
                case eString_location_ends:
                    {{
                        size_t offset = 0;
                        while (!rval && offset < val.length()) {
                            size_t match_len = 0;
                            if (x_AdvancedStringCompare(val.substr(offset), 
                                                         GetMatch_text(),
                                                         (offset == 0 ? 0 : val.c_str()[offset - 1]), 
                                                          &match_len)
                                && offset + match_len == val.length()) {
                                result = val.substr(0, offset) + replace;
                                rval = true;
                            } else {
                                offset++;
                            }
                        }
                    }}
                    break;
            } 
        } else {
            result = val;
            rval = x_ReplaceContains(result, replace);                    
        }
    }
    return rval;
}

END_objects_SCOPE // namespace ncbi::objects::
END_NCBI_SCOPE
