/* $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author:  J. Chen
 *
 * File Description:
 *   suspect product name check against rule
 *
 * Remark:
 *   This code was originally generated by application DATATOOL
 *   using the following specifications:
 *   'macro.asn'.
 */

// standard includes
#include <ncbi_pch.hpp>

// generated includes
#include <objects/macro/Suspect_rule.hpp>
#include <objects/macro/Word_substitution.hpp>
#include <objects/macro/Word_substitution_set.hpp>
#include <serial/serial.hpp>
#include <serial/objostr.hpp>
#include <serial/objistr.hpp>
#include <corelib/ncbistre.hpp>

// generated classes

BEGIN_NCBI_SCOPE

BEGIN_objects_SCOPE // namespace ncbi::objects::

// destructor
CSuspect_rule::~CSuspect_rule(void)
{
}

bool CSuspect_rule :: StringMatchesSuspectProductRule(const string& str)
{
  CSearch_func& func = SetFind();
  func.SetSearchStr(str);
  if (!func.Empty() && !func.Match(str)) {
      return false;
  }
  else if (CanGetExcept()) {
     const CSearch_func& exc_func = GetExcept();
     if (!exc_func.Empty() && !exc_func.Match(str)) {
       return false;
     }
  }
  return true;
};





/*

bool CSuspect_rule :: x_DoesObjectMatchStringConstraint(const CBioSource& biosrc, const CString_constraint& str_cons) const
{
   vector <string> strs; 
   GetStringsFromObject(biosrc, strs);
   ITERATE (vector <string>, it, strs) {
      if (x_DoesSingleStringMatchConstraint(*it, &str_cons)) {
          strs.clear();
          return true;
      }
   }
   strs.clear();
   return false;
};

bool CSuspect_rule :: x_DoesObjectMatchStringConstraint(const CCGPSetData& cgp, const CString_constraint& str_cons) const
{
  * CDS-Gene-Prot set *
  bool all_match = true, any_match = false;
  vector <string> strs;
  if (cgp.gene) {
       m_bioseq_hl 
         = sequence:: GetBioseqFromSeqLoc(cgp.gene->GetLocation(), *m_scope);
       GetStringsFromObject(*cgp.gene, strs);
       if (x_DoesObjectMatchStringConstraint ( *cgp.gene, strs, str_cons)) {
          any_match = true;
       }
       else {
          any_match = false;
       }
       strs.clear();
  }
  if (cgp.cds && (!any_match || all_match)) {
      m_bioseq_hl 
        = sequence::GetBioseqFromSeqLoc(cgp.cds->GetLocation(), *m_scope);
      strs.clear();
      GetStringsFromObject(*cgp.cds, strs);
      if (x_DoesObjectMatchStringConstraint( *cgp.cds, strs, str_cons)) {
         any_match = true;
      }
      else {
         all_match = false;
      }
      strs.clear();
  }
  if (cgp.mrna && (!any_match || all_match)) {
      m_bioseq_hl 
        = sequence::GetBioseqFromSeqLoc(cgp.mrna->GetLocation(), *m_scope);
      strs.clear();
      GetStringsFromObject(*cgp.mrna, strs);
      if (x_DoesObjectMatchStringConstraint( *cgp.mrna, strs, str_cons)) {
         any_match = true;
      }
      else {
         all_match = false;
      }
      strs.clear();
  }
  if (cgp.prot  && (!any_match || all_match)) {
      m_bioseq_hl 
        = sequence::GetBioseqFromSeqLoc(cgp.prot->GetLocation(), *m_scope);
      strs.clear();
      GetStringsFromObject(*cgp.prot, strs);
      if (x_DoesObjectMatchStringConstraint( *cgp.prot, strs, str_cons)) {
         any_match = true;
      }
      else all_match = false;
      strs.clear();
  }
  if (!any_match || all_match) {
     ITERATE (vector <const CSeq_feat*>, it, cgp.mat_peptide_list) {
        m_bioseq_hl 
          = sequence :: GetBioseqFromSeqLoc((*it)->GetLocation(), *m_scope);
        strs.clear();
        GetStringsFromObject(**it, strs);
        if (x_DoesObjectMatchStringConstraint( **it, strs, str_cons)) {
           any_match = true;
        }
        else all_match = false;
        strs.clear();
        if (any_match && !all_match) {
            break;
        }
     }
  }

  if (str_cons.GetNot_present()) {
      return all_match;
  }
  else return any_match;
};

bool CSuspect_rule :: x_DoesObjectMatchStringConstraint(const CSeq_feat& feat, const vector <string>& strs, const CString_constraint& str_cons) const
{
   bool rval = false;
   ITERATE (vector <string>, it, strs) { 
       rval = x_DoesSingleStringMatchConstraint(*it, &str_cons); 
       if (rval) {
            break;
       }
   }
   if (!rval) {
     string str(kEmptyStr);
     switch (feat.GetData().Which()) {
       case CSeqFeatData::e_Cdregion: 
         {
            if (feat.CanGetProduct()) {
               CBioseq_Handle 
                  bioseq_hl = sequence :: GetBioseqFromSeqLoc(feat.GetProduct(),
                                                                 *m_scope);
               if (bioseq_hl) {
                  CFeat_CI ci(bioseq_hl, SAnnotSelector(CSeqFeatData::eSubtype_prot)); 
                  if (ci) {
                     vector <string> arr;
                     GetStringsFromObject(ci->GetOriginalFeature(), arr);
                     ITERATE (vector <string>, it, arr) {
                         rval = x_DoesSingleStringMatchConstraint(*it, &str_cons);
                         if (rval) break;
                     }
                     arr.clear();
                  }
               }
            }
            break;
         }
       case CSeqFeatData::e_Rna:
         {
           if (feat.GetData().GetSubtype() == CSeqFeatData::eSubtype_rRNA) {
             // try CTestAndRepData :: GetSeqFeatLabel(feat, str);
             feature::GetLabel(seq_feat, &str, fFGL_Content);
             rval = x_DoesSingleStringMatchConstraint(str, &str_cons);
             if (!rval) {
               str = "tRNA-" + str;
               rval = x_DoesSingleStringMatchConstraint(str, &str_cons);
             }
           }
           break;
         }
       case CSeqFeatData::e_Imp:
         rval 
           = x_DoesSingleStringMatchConstraint(feat.GetData().GetImp().GetKey(),
                                                &str_cons);
         break;
       default: break;
     }
   }
   if (str_cons.GetNot_present()) {
        rval = !rval;
   }
   return rval;
};

bool CSuspect_rule :: x_IsLocationConstraintEmpty(const CLocation_constraint& loc_cons) const
{
  if (loc_cons.GetStrand() != eStrand_constraint_any
          || loc_cons.GetSeq_type() != eSeqtype_constraint_any
          || loc_cons.GetPartial5() != ePartial_constraint_either
          || loc_cons.GetPartial3() != ePartial_constraint_either
          || loc_cons.GetLocation_type() != eLocation_type_constraint_any
          || (loc_cons.CanGetEnd5()
                && loc_cons.GetEnd5().Which() != CLocation_pos_constraint::e_not_set)
          || (loc_cons.CanGetEnd3()
                && loc_cons.GetEnd3().Which() != CLocation_pos_constraint::e_not_set)) {
    return false;
  }
  else return true;
};

bool CSuspect_rule :: x_DoesStrandMatchConstraint(const CSeq_loc& loc, const CLocation_constraint& loc_cons) const
{
  if (loc.Which() == CSeq_loc::e_not_set) {
     return false;
  }
  if (loc_cons.GetStrand() == eStrand_constraint_any) {
     return true;
  }

  if (loc.GetStrand() == eNa_strand_minus) {
      if (loc_cons.GetStrand() == eStrand_constraint_minus) {
         return true;
      }
      else return false;
  }
  else {
     if (loc_cons.GetStrand() == eStrand_constraint_plus) {
       return true;
     }
     else return false;
  }
};

bool CSuspect_rule :: x_DoesBioseqMatchSequenceType(const ESeqtype_constraint& seq_type) const
{
  if (seq_type == eSeqtype_constraint_any
        || (m_bioseq_hl.IsNa() && seq_type == eSeqtype_constraint_nuc)
        || (m_bioseq_hl.IsAa() && seq_type == eSeqtype_constraint_prot)) {
      return true;
  }
  else return false;
};

bool CSuspect_rule :: x_DoesLocationMatchPartialnessConstraint(const CSeq_loc& loc, const CLocation_constraint& loc_cons) const
{
  bool partial5 = loc.IsPartialStart(eExtreme_Biological);
  bool partial3 = loc.IsPartialStop(eExtreme_Biological);
  if ( (loc_cons.GetPartial5() == ePartial_constraint_partial && !partial5)
         || (loc_cons.GetPartial5() == ePartial_constraint_complete && partial5) 
         || (loc_cons.GetPartial3() == ePartial_constraint_partial && !partial3)
         || (loc_cons.GetPartial3() == ePartial_constraint_complete && partial3) ) {
       return false;
    }
    else return true;
};

bool CSuspect_rule :: x_DoesLocationMatchTypeConstraint(const CSeq_loc& seq_loc, const CLocation_constraint& loc_cons) const
{
  bool has_null = false;
  int  num_intervals = 0;

  if (loc_cons.GetLocation_type() == eLocation_type_constraint_any) {
      return true;
  }
  else
  {
    for (CSeq_loc_CI sl_ci(seq_loc); sl_ci; ++ sl_ci) {
       if (sl_ci.GetEmbeddingSeq_loc().Which() == CSeq_loc::e_Null) {
           has_null = true;
       }
       else if (!sl_ci.IsEmpty()) num_intervals ++;
    }

    if (loc_cons.GetLocation_type() == eLocation_type_constraint_single_interval)
    {
        if (num_intervals == 1) {
           return true;
        }
    }
    else if (loc_cons.GetLocation_type() == eLocation_type_constraint_joined) {
      if (num_intervals > 1 && !has_null) {
          return true;
      }
    }
    else if (loc_cons.GetLocation_type() == eLocation_type_constraint_ordered) {
       if (num_intervals > 1 && has_null) {
          return true;
       }
    }
  }
  return false;
}

bool CSuspect_rule :: x_DoesPositionMatchEndConstraint(int pos, const CLocation_pos_constraint& lp_cons) const
{
   switch (lp_cons.Which())
   {
      case CLocation_pos_constraint:: e_Dist_from_end:
            if (pos != lp_cons.GetDist_from_end()) {
               return false;
            }
            break;
      case CLocation_pos_constraint:: e_Max_dist_from_end:
            if (pos > lp_cons.GetMax_dist_from_end()) {
              return false;
            }
            break;
      case CLocation_pos_constraint:: e_Min_dist_from_end:
            if (pos < lp_cons.GetMin_dist_from_end()) {
               return false;
            }
            break;
      default: break;
   }
   return true;
};

bool CSuspect_rule :: x_DoesLocationMatchDistanceConstraint(const CSeq_loc& loc, const CLocation_constraint& loc_cons) const
{
  if (!loc_cons.CanGetEnd5() && !loc_cons.CanGetEnd3()) {
      return true;
  }

  unsigned pos = loc.GetStop(eExtreme_Positional);
  int pos2 = (m_bioseq_hl.IsSetInst_Length() ? m_bioseq_hl.GetInst_Length() : 0)
              - pos - 1;

  if (loc.GetStrand() == eNa_strand_minus) {
    if (loc_cons.CanGetEnd5()) {
      if (m_bioseq_hl.GetCompleteBioseq().Empty()) {
          return false;
      }
      else {
        if (!x_DoesPositionMatchEndConstraint(pos2, loc_cons.GetEnd5())) {
           return false;
        }
      }
    }
    if (loc_cons.CanGetEnd3()) {
       return x_DoesPositionMatchEndConstraint(pos, loc_cons.GetEnd3());
    }
  }
  else
  {
    if (loc_cons.CanGetEnd5()
           && !x_DoesPositionMatchEndConstraint(pos, loc_cons.GetEnd5())) {
        return false;
    }
    if (loc_cons.CanGetEnd3()) {
      if (m_bioseq_hl.GetCompleteBioseq().Empty()) {
         return false;
      }
      return x_DoesPositionMatchEndConstraint(pos2, loc_cons.GetEnd3());
    }
  }
  return true;
};

bool CSuspect_rule :: x_DoesFeatureMatchLocationConstraint(const CSeq_feat& feat, const CLocation_constraint& loc_cons) const 
{
  if (x_IsLocationConstraintEmpty (loc_cons)) {
     return true;
  }

  const CSeq_loc& feat_loc = feat.GetLocation();
  if (loc_cons.GetStrand() != eStrand_constraint_any) {
    if (!m_bioseq_hl) {
       return false;
    }
    else if (m_bioseq_hl.IsAa()) {
      const CSeq_feat* cds = sequence::GetCDSForProduct(m_bioseq_hl);
      if (!cds) {
         return false;
      }
      else if (!x_DoesStrandMatchConstraint (cds->GetLocation(), loc_cons)) {
        return false;
      }
    }
    else if (!DoesStrandMatchConstraint (feat_loc, loc_cons)) {
        return false;
    }
  }

  if (!x_DoesBioseqMatchSequenceType(loc_cons.GetSeq_type())) {
     return false;
  }

  if (!x_DoesLocationMatchPartialnessConstraint (feat_loc, loc_cons)) {
     return false;
  }

  if (!x_DoesLocationMatchTypeConstraint (feat_loc, loc_cons)) {
     return false;
  }

  if (!x_DoesLocationMatchDistanceConstraint(feat_loc, loc_cons)) {
     return false;
  }

  return true;
};

string CSuspect_rule :: GetSrcQualName(ESource_qual src_qual)
{
   string strtmp = ENUM_METHOD_NAME(ESource_qual)()->FindName(src_qual, true);
   if (strtmp == "bio-material-INST") {
      strtmp = "bio-material-inst";
   }
   else if (strtmp == "bio-material-COLL") {
      strtmp = "bio-material-coll";
   }
   else if (strtmp == "bio-material-SpecID") {
      strtmp = "bio-material-specid";
   }
   else if (strtmp == "common-name") {
      strtmp = "common name";
   }
   else if (strtmp == "culture-collection-INST") {
      strtmp = "culture-collection-inst";
   }
   else if (strtmp == "culture-collection-COLL") {
      strtmp = "culture-collection-coll";
   }
   else if (strtmp == "culture-collection-SpecID") {
      strtmp = "culture-collection-specid";
   }
   else if (strtmp == "orgmod-note") {
      strtmp = "note-orgmod";
   }
   else if (strtmp == "nat-host") {
      strtmp = "host";
   }
   else if (strtmp == "subsource-note") {
      strtmp = "sub-species";
   }
   else if (strtmp == "all-notes") {
      strtmp = "All Notes";
   }
   else if (strtmp == "all-quals") {
      strtmp = "All";
   }
   else if (strtmp == "all-primers") {
      strtmp = "All Primers";
   }

   return strtmp;
};

bool CSuspect_rule :: IsSubsrcQual(ESource_qual src_qual)
{
   switch (src_qual) {
     case eSource_qual_cell_line:
     case eSource_qual_cell_type:
     case eSource_qual_chromosome:
     case eSource_qual_clone:
     case eSource_qual_clone_lib:
     case eSource_qual_collected_by:
     case eSource_qual_collection_date:
     case eSource_qual_country:
     case eSource_qual_dev_stage:
     case eSource_qual_endogenous_virus_name:
     case eSource_qual_environmental_sample:
     case eSource_qual_frequency:
     case eSource_qual_fwd_primer_name:
     case eSource_qual_fwd_primer_seq:
     case eSource_qual_genotype:
     case eSource_qual_germline:
     case eSource_qual_haplotype:
     case eSource_qual_identified_by:
     case eSource_qual_insertion_seq_name:
     case eSource_qual_isolation_source:
     case eSource_qual_lab_host:
     case eSource_qual_lat_lon:
     case eSource_qual_map:
     case eSource_qual_metagenomic:
     case eSource_qual_plasmid_name:
     case eSource_qual_plastid_name:
     case eSource_qual_pop_variant:
     case eSource_qual_rearranged:
     case eSource_qual_rev_primer_name:
     case eSource_qual_rev_primer_seq:
     case eSource_qual_segment:
     case eSource_qual_sex:
     case eSource_qual_subclone:
     case eSource_qual_subsource_note:
     case eSource_qual_tissue_lib :
     case eSource_qual_tissue_type:
     case eSource_qual_transgenic:
     case eSource_qual_transposon_name:
     case eSource_qual_mating_type:
     case eSource_qual_linkage_group:
     case eSource_qual_haplogroup:
     case eSource_qual_altitude:
        return true;
     default: return false;
   }
};

string CSuspect_rule :: x_GetSrcQualValue4FieldType(const CBioSource& biosrc, const CSource_qual_choice& src_qual, const CString_constraint* str_cons) const
{
   string str(kEmptyStr);
   switch (src_qual.Which()) {
     case CSource_qual_choice::e_Textqual:
       {
          ESource_qual text_qual= src_qual.GetTextqual();
          string qual_name = GetSrcQualName(text_qual);
          bool is_subsrc = IsSubsrcQual(text_qual);
          str = CTestAndRepData :: GetSrcQualValue( biosrc, qual_name, is_subsrc, str_cons);
       }
       break;
     case CSource_qual_choice::e_not_set: break;
     default:
         str = GetNotTextqualSrcQualValue(biosrc, src_qual, str_cons);
   }
   return str;
};

bool CSuspect_rule :: x_DoesObjectMatchFieldConstraint(const CSeq_feat& data, const CField_constraint& field_cons) const 
{
  const CString_constraint& str_cons = field_cons.GetString_constraint();
  if (x_IsStringConstraintEmpty (&str_cons)) {
     return true;
  }

  bool rval = false;
  string str(kEmptyStr);
  const CField_type& field_type = field_cons.GetField();
  switch (field_type.Which()) {
    case CField_type::e_Source_qual:
      {
        const CBioSource* biosrc = sequence::GetBioSource(m_bioseq_hl);
        if (biosrc) {
          str = x_GetSrcQualValue4FieldType(*biosrc, 
                                      field_type.GetSource_qual(), &str_cons);
        }
        if (!str.empty()) rval = true;
      }
      break;
    case CField_type:: e_Feature_field:
      {
          const CFeature_field& feat_field = field_type.GetFeature_field();
          rval = DoesObjectMatchFeatureFieldConstraint(data, feat_field, str_cons);
      }
      break;
    case CField_type:: e_Rna_field:
      rval = DoesObjectMatchRnaQualConstraint (data, field_type.GetRna_field(), str_cons);
    case CField_type:: e_Cds_gene_prot:
      {
         CRef <CFeature_field> 
             feat_field = FeatureFieldFromCDSGeneProtField (field_type.GetCds_gene_prot());
         rval = DoesObjectMatchFeatureFieldConstraint (
                                    data, const_cast<CFeature_field&>(*feat_field), str_cons);
      }
      break;
    case CField_type:: e_Molinfo_field:
      if (m_bioseq_hl) {
        str = GetSequenceQualFromBioseq (field_type.GetMolinfo_field());
        if ( (str.empty() && str_cons.GetNot_present()) 
                || (!str.empty() && DoesStringMatchConstraint (str, &str_cons)) )
            rval = true;
      }
      break;
    case CField_type:: e_Misc:
    case CField_type:: e_Dblink:
      if (m_bioseq_hl) {
        str = GetFieldValueForObjectEx (field_type, str_cons);
        if (!str.empty()) rval = true;
      }
      break;

* TODO LATER * 
    case CField_type:: e_Pub:
      break;
    default: break;
  }
  return rval; 
};
bool CSuspect_rule :: x_DoesObjectMatchConstraint(const CSeq_feat& data, const vector <string>& strs, const CConstraint_choice& cons) const
{
  switch (cons.Which()) {
    case CConstraint_choice::e_String :
       return x_DoesObjectMatchStringConstraint (data, strs, cons.GetString());
    case CConstraint_choice::e_Location :
       return x_DoesFeatureMatchLocationConstraint (data, cons.GetLocation());
    case CConstraint_choice::e_Field :
       return x_DoesObjectMatchFieldConstraint (data, cons.GetField());
    case CConstraint_choice::e_Source :
       if (data.GetData().IsBiosrc()) {
          return x_DoesBiosourceMatchConstraint ( data.GetData().GetBiosrc(), 
                                                cons.GetSource());
       }
       else {
          CBioseq_Handle 
             seq_hl = sequence::GetBioseqFromSeqLoc(data.GetLocation(), 
                                                    *thisInfo.scope);
          const CBioSource* src = GetBioSource(seq_hl);
          if (src) {
            return x_DoesBiosourceMatchConstraint(*src, cons.GetSource());
          }
          else return false;
       }
       break;
    case CConstraint_choice::e_Cdsgeneprot_qual :
       return x_DoesFeatureMatchCGPQualConstraint (data, 
                                                 cons.GetCdsgeneprot_qual());
*
      if (choice == 0) {
        rval = DoesCGPSetMatchQualConstraint (data, cons->data.ptrvalue);
      } else if (choice == OBJ_SEQDESC) {
        rval = DoesSeqDescMatchCGPQualConstraint (data, cons->data.ptrvalue);
      } else if (choice == OBJ_SEQFEAT) {
        rval = DoesFeatureMatchCGPQualConstraint (data, cons->data.ptrvalue);
      } else if (choice == OBJ_BIOSEQ) {
        rval = DoesSequenceMatchCGPQualConstraint (data, cons->data.ptrvalue);
      } else {
        rval = FALSE;
      }
*
    case CConstraint_choice::e_Cdsgeneprot_pseudo :
       return x_DoesFeatureMatchCGPPseudoConstraint (data, cons.GetCdsgeneprot_pseudo());
*
      if (choice == 0) {
        rval = DoesCGPSetMatchPseudoConstraint (data, cons->data.ptrvalue);
      } else if (choice == OBJ_SEQFEAT) {
        rval = DoesFeatureMatchCGPPseudoConstraint (data, cons->data.ptrvalue);
      }
*
    case CConstraint_choice::e_Sequence :
      {
        if (m_bioseq_hl) { 
            return x_DoesSequenceMatchSequenceConstraint(cons.GetSequence());
        }
        break;
      }
    case CConstraint_choice::e_Pub:
      if (data.GetData().IsPub()) {
         return x_DoesPubMatchPublicationConstraint(data.GetData().GetPub(), cons.GetPub());
      }
      break;
    case CConstraint_choice::e_Molinfo:
       return x_DoesObjectMatchMolinfoFieldConstraint (data, cons.GetMolinfo()); // use bioseq_hl
    case CConstraint_choice::e_Field_missing:
     if (x_GetConstraintFieldFromObject(data, cons.GetField_missing()).empty()){
           return true; 
     }
     else return false;
    case CConstraint_choice::e_Translation:
     * must be coding region or protein feature *
      if (data.GetData().IsProt()) {
         const CSeq_feat* cds = sequence::GetCDSForProduct(m_bioseq_hl);
         if (cds) {
            return x_DoesCodingRegionMatchTranslationConstraint (
                              *cds, cons.GetTranslation());
         }
      }
      else if (data.GetData().IsCdregion()) {
         return x_DoesCodingRegionMatchTranslationConstraint(
                                             data, cons.GetTranslation());
      }
    default: break;
  }
  return true;
}

bool CSuspect_rule :: x_DoesObjectMatchConstraintChoiceSet(const CSeq_feat& feat, const CConstraint_choice_set& c_set) const
{
  vector <string> strs_in_feat;
  GetStringsFromObject(feat, strs_in_feat);
  ITERATE (list <CRef <CConstraint_choice> >, sit, c_set.Get()) {
     if (!x_DoesObjectMatchConstraint(feat, strs_in_feat, **sit)) {
           strs_in_feat.clear();
           return false;
     }
  }
  strs_in_feat.clear();
  return true;
};

*/
END_objects_SCOPE // namespace ncbi::objects::

END_NCBI_SCOPE

/* Original file checksum: lines: 57, chars: 1729, CRC32: 243f48c6 */
