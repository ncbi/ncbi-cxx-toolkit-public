#ifndef UTIL_COMPRESS__COMPRESS__HPP
#define UTIL_COMPRESS__COMPRESS__HPP

/*  $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author:  Vladimir Ivanov
 *
 * File Description:  The Compression API
 *
 */

#include <corelib/ncbistd.hpp>



BEGIN_NCBI_SCOPE


// Default input (get) compression stream buffer size
const streamsize kCompressionDefaultInBufSize = 16*1024;

// Default output (put) compression stream buffer size
const streamsize kCompressionDefaultOutBufSize = 16*1024;



/////////////////////////////////////////////////////////////////////////////
// CCompressionException
//
//  Exceptions generated by CCompression/CCompressionStream and derived classes
//

class NCBI_XUTIL_EXPORT CCompressionException : public CCoreException
{
public:
    enum EErrCode {
        eDeflate,       // Compression error
        eInflate,       // Decompression error
        eBusy,          // Compressor is already busy
        eSetBuf,        // streambuf::setbuf() not allowed
        eMemory,        // Memory allcation error
        eWrite          // Write to the underlying stream buffer failed
    };
    virtual const char* GetErrCodeString(void) const
    {
        switch (GetErrCode()) {
        case eDeflate : return "eDeflate";
        case eInflate : return "eInflate";
        case eBusy    : return "eBusy";
        case eSetBuf  : return "eSetBuf";
        case eMemory  : return "eMemory";
        case eWrite   : return "eWrite";
        default       : return CException::GetErrCodeString();
        }
    }
    NCBI_EXCEPTION_DEFAULT(CCompressionException,CCoreException);
};


// Forward declaration
class CCompressionIStreambuf;
class CCompressionOStreambuf;
class CDecompressionIStreambuf;
class CDecompressionOStreambuf;


//////////////////////////////////////////////////////////////////////////////
//
// CCompression -- base abstract class
//

class NCBI_XUTIL_EXPORT CCompression
{
public:
    // Compression level.
    // It is in range [0..9]. Increase of level might mean better compression
    // and usualy greater time of compression. Usualy 1 gives best speed,
    // 9 gives best compression, 0 gives no compression at all.
    // eDefault value requests a compromise between speed and compression
    // (according to developers of the corresponding compression algorithm).
    enum ELevel {
        eLevel_Default       = -1,  // default
        eLevel_NoCompression =  0,  // just store data
        eLevel_Lowest        =  1,
        eLevel_VeryLow       =  2,
        eLevel_Low           =  3,
        eLevel_MediumLow     =  4,
        eLevel_Medium        =  5,
        eLevel_MediumHigh    =  6,
        eLevel_High          =  7,
        eLevel_VeryHigh      =  8,
        eLevel_Best          =  9
    };

    // Type of the result of all basic functions
    enum EStatus {
        // Everything is fine, no errors occurred
        eStatus_Success,
        // Error has occured. The error code can be acquired by GetLastError() 
        eStatus_Error,
        // Output buffer overflow - not enough output space.
        // Buffer must be emptied and the last action repeated.
        eStatus_Overflow
    };

    // 'ctors
    CCompression(ELevel level = eLevel_Default);
    virtual ~CCompression(void);

    // Get/set compression level.
    // NOTE 1:  Changing compression level after compression has begun will
    //          be ignored.
    // NOTE 2:  If the level is not supported by the underlying algorithm, then
    //          it will be translated to the nearest supported value.
    void   SetLevel(ELevel level);
    virtual ELevel GetLevel(void) const;

    // Return the default compression level for current compression algorithm.
    virtual ELevel GetDefaultLevel(void) const = 0;

    // Get status/error of the last compressor action.
    int GetLastError(void) const;

    // Return compressor's busy flag. If returns value is true that
    // the current compression object already have being use in other
    // compression session.
    bool IsBusy(void);


    //------------------------------------------------------------------------
    //
    // Utility functions 
    //
    // All utility functions have default implementation, however for the best
    // performance they may be reimplemented in the derived classes with
    // using similar native functions of a compression algorithm.
    //
    //------------------------------------------------------------------------

    // Compress the source buffer into the destination buffer.
    // Return TRUE on success, FALSE on error.
    // The compressor error code can be acquired via GetLastError() call.
    // Notice that altogether the total size of the destination buffer must
    // be little more then size of the source buffer. 
    virtual 
    bool CompressBuffer(const char* src_buf, unsigned long  src_len,
                        char*       dst_buf, unsigned long  dst_size,
                        /* out */            unsigned long* dst_len);

    // Decompress data from buffer "src_buf", put result to buffer "dst_buf".
    // Return TRUE on success, FALSE on error.
    virtual
    bool DecompressBuffer(const char* src_buf, unsigned long  src_len,
                          char*       dst_buf, unsigned long  dst_size,
                          /* out */            unsigned long* dst_len);

protected:
    //------------------------------------------------------------------------
    //
    // Basic compression/decompression functions
    //
    // All this functions must be implemented in the derived classes
    //
    //------------------------------------------------------------------------

    //
    // Compression
    //

    // Initialize the internal stream state for compression
    // It does not perform any compression, this will be done by Deflate()
    virtual EStatus DeflateInit(void) = 0; 

    // Compress as much data as possible, and stops when the input buffer
    // becomes empty or the output buffer becomes full. It may introduce 
    // some output latency (reading input without producing any output).
    virtual EStatus Deflate
    (const char*    in_buf,      // [in]  input buffer 
     unsigned long  in_len,      // [in]  input data length
     char*          out_buf,     // [in]  output buffer
     unsigned long  out_size,    // [in]  output buffer size
     unsigned long* in_avail,    // [out] count unprocessed bytes in inp buffer
     unsigned long* out_avail    // [out] count bytes putted into out buffer
     ) = 0;

    // Flush compressed data from output buffer. 
    // Flushing may degrade compression for some compression algorithms
    // and so it should be used only when necessary.
    virtual EStatus DeflateFlush
    (char*          out_buf,     // [in]  output buffer
     unsigned long  out_size,    // [in]  output buffer size
     unsigned long* out_avail    // [out] count bytes putted into out buffer
     ) = 0;

    // Finish compression.
    // Process pending input, flush pending output.
    // This function partly like to DeflateFlush(), but it must be called only
    // at the end of compression process before DeflateEnd().
    virtual EStatus DeflateFinish
    (char*          out_buf,     // [in]  output buffer
     unsigned long  out_size,    // [in]  output buffer size
     unsigned long* out_avail    // [out] count bytes putted into out buffer
     ) = 0;

    // Free all dynamically allocated data structures.
    // This function discards any unprocessed input and does not flush
    // any pending output. 
    virtual EStatus DeflateEnd(void) = 0;


    //
    // Decompression
    //

    // Initialize the internal stream state for decompression.
    // It does not perform any decompression, this will be done by
    // Inflate(). 
    virtual EStatus InflateInit(void) = 0; 

    // Decompress as much data as possible, and stops when the input buffer
    // becomes empty or the output buffer becomes full. It may introduce
    // some output latency (reading input without producing any output).
    virtual EStatus Inflate
    (const char*    in_buf,      // [in]  input buffer 
     unsigned long  in_len,      // [in]  input data length
     char*          out_buf,     // [in]  output buffer
     unsigned long  out_size,    // [in]  output buffer size
     unsigned long* in_avail,    // [out] count unprocessed bytes in inp buffer
     unsigned long* out_avail    // [out] count bytes putted into out buffer
     ) = 0;

    // Free all dynamically allocated data structures.
    // This function discards any unprocessed input and does not flush
    // any pending output. 
    virtual EStatus InflateEnd(void) = 0;


protected:
    // Set last compressor's action error/status
    void SetLastError(int status);

    // Set/unset compressor busy flag
    void SetBusy(bool busy = true);

private:
    ELevel  m_Level;       // Compression level
    int     m_LastError;   // Last compressor action error/status
    bool    m_Busy;        // Is true if compressor is ready to begin
                           // next session

    // Friend classes
    friend class CCompressionIStreambuf;
    friend class CCompressionOStreambuf;
    friend class CDecompressionIStreambuf;
    friend class CDecompressionOStreambuf;
};

 
END_NCBI_SCOPE


/*
 * ===========================================================================
 * $Log$
 * Revision 1.3  2003/04/11 19:57:25  ivanov
 * Move streambuf.hpp from 'include/...' to 'src/...'
 *
 * Revision 1.2  2003/04/08 20:48:51  ivanov
 * Added class-key declaration for friend classes in the CCompression
 *
 * Revision 1.1  2003/04/07 20:42:11  ivanov
 * Initial revision
 *
 * ===========================================================================
 */

#endif  /* UTIL_COMPRESS__COMPRESS__HPP */
