#ifndef CORELIB___PLUGIN_MANAGER__HPP
#define CORELIB___PLUGIN_MANAGER__HPP

/* $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author:  Denis Vakatov, Anatoliy Kuznetsov
 *
 * File Description:  Plugin manager (using class factory paradigm)
 *
 */

/// @file plugin_manager.hpp
/// Plugin manager (using class factory paradigm).
///
/// Describe generic interface and provide basic functionality to advertise
/// and export a class factory. 
/// The class and class factory implementation code can be linked to
/// either statically (then, the class factory will need to be registered
/// explicitly by the user code) or dynamically (then, the DLL will be
/// searched for using plugin name, and the well-known DLL entry point
/// will be used to register the class factory, automagically).
/// 
/// - "class factory" -- An entity used to generate objects of the given class.
///                      One class factory can generate more than one version
///                      of the class.
/// 
/// - "interface"  -- Defines the implementation-independent API and expected
///                   behaviour of a class.
///                   Interface's name is provided by its class's factory,
///                   see IClassFactory::GetInterfaceName().
///                   Interfaces are versioned to track the compatibility.
/// 
/// - "driver"  -- A concrete implementation of the interface and its factory.
///                Each driver has its own name (do not confuse it with the
///                interface name!) and version.
/// 
/// - "host"    -- An entity (DLL or the EXEcutable itself) that contains
///                one or more drivers (or versions of the same driver),
///                which can implement one or more interfaces.
/// 
/// - "version" -- MAJOR (backward- and forward-incompatible changes in the
///                       interface and/or its expected behaviour);
///                MINOR (backward compatible changes in the driver code);
///                PATCH_LEVEL (100% compatible plugin or driver code changes).
/// 

#include <corelib/ncbimtx.hpp>
#include <corelib/version.hpp>
#include <corelib/ncbidll.hpp>

#include <set>


BEGIN_NCBI_SCOPE

/** @addtogroup PluginMgr
 *
 * @{
 */

/////////////////////////////////////////////////////////////////////////////
///
/// CPluginManagerException --
///
/// Exception generated by CPluginManager.

class NCBI_XNCBI_EXPORT CPluginManagerException : public CCoreException
{
public:
    /// Error types that CTime can generate.
    enum EErrCode {
        eResolveFailure       ///< Cannot resolve interface driver
    };

    /// Translate from the error code value to its string representation.
    virtual const char* GetErrCodeString(void) const
    {
        switch (GetErrCode()) {
        case eResolveFailure:   return "eResolveFailure";
        default:    return CException::GetErrCodeString();
        }
    }

    // Standard exception boilerplate code.
    NCBI_EXCEPTION_DEFAULT(CPluginManagerException, CCoreException);
};


/// CInterfaceVersion<> --
///
/// Current interface version.
///
/// It is just a boilerplate, to be hard-coded in the concrete interface header
/// @sa NCBI_PLUGIN_VERSION, CVersionInfo

template <class TClass>
class CInterfaceVersion
{
};


/// Macro to auto-setup the current interface name and version.
///
/// This macro must be "called" once per interface, usually in the
/// very header that describes that interface.
///
/// Example:
///    NCBI_INTERFACE_VERSION(IFooBar, "IFooBar", 1, 3, 8);
/// @sa CInterfaceVersion

#define NCBI_DECLARE_INTERFACE_VERSION(iface, iface_name, major, minor, patch_level) \
template<> \
class CInterfaceVersion<iface> \
{ \
public: \
    enum { \
        eMajor      = major, \
        eMinor      = minor, \
        ePatchLevel = patch_level \
    }; \
    static const char* GetName() { return iface_name; } \
}

/// Macro to contruct CVersionInfo class using interface name
/// (relies on CInterfaceVersion class)
/// @sa CVersionInfo
#define NCBI_INTERFACE_VERSION(iface) \
CVersionInfo(ncbi::CInterfaceVersion<iface>::eMajor, \
             ncbi::CInterfaceVersion<iface>::eMinor, \
             ncbi::CInterfaceVersion<iface>::ePatchLevel)



/// IClassFactory<> --
///
/// Class factory for the given interface.
///
/// IClassFactory should be implemented for collection of drivers
/// and exported by hosts

template <class TClass>
class IClassFactory
{
public:
    typedef TClass TInterface;

    struct SDriverInfo
    {
        string         name;        ///< Driver name
        CVersionInfo   version;     ///< Driver version

        SDriverInfo(const string&       driver_name,
                    const CVersionInfo& driver_version)
            : name(driver_name),
              version(driver_version)
        {}
    };

    typedef list<SDriverInfo>  TDriverList;


    /// Create driver's instance
    ///
    /// Function creates driver by its name and version.
    /// The requirements is the drivers version should match the interface
    /// up to the patch level.
    ///
    /// @param driver
    ///  Requested driver's name (not the name of the supported interface)
    /// @param version
    ///  Requested interface version (as understood by the caller).
    ///  By default it will be passed the version which is current from
    ///  the calling code's point of view.
    /// @return
    ///  NULL on any error (not found entry point, version mismatch, etc.)
    virtual TClass* CreateInstance
    (const string&  driver  = kEmptyStr,
     CVersionInfo   version = NCBI_INTERFACE_VERSION(TClass))
        const = 0;

    /// Versions of the interface exported by the factory
    virtual void GetDriverVersions(TDriverList& driver_list) const = 0;

    virtual ~IClassFactory(void) {}
};



class CPluginManager_DllResolver;



/// CPluginManager<> --
///
/// To register (either directly, or via an "entry point") class factories
/// for the given interface.
///
/// Then, to facilitate the process of instantiating the class given
/// the registered pool of drivers, and also taking into accont the driver name
/// and/or version as requested by the calling code.
///
/// Template class is protected by mutex and safe for use from diffrent threads

template <class TClass>
class CPluginManager
{
public:
    typedef IClassFactory<TClass> TClassFactory;

    /// Create class instance
    /// @return
    ///  Never returns NULL -- always throw exception on error.
    /// @sa GetFactory()
    TClass* CreateInstance
    (const string&       driver  = kEmptyStr,
     const CVersionInfo& version = NCBI_INTERFACE_VERSION(TClass))
    {
        TClassFactory* factory = GetFactory(driver, version);
        return factory->CreateInstance(driver, version);
    }


    /// Get class factory
    ///
    /// If more than one (of registered) class factory contain eligible
    /// driver candidates, then pick the class factory containing driver of
    /// the latest version.
    /// @param driver
    ///  Name of the driver. If passed empty, then -- any.
    /// @param version
    ///  Requested version. The returned driver can have a different (newer)
    ///  version (provided that the new implementation is backward-compatible
    ///  with the requested version.
    /// @return
    ///  Never return NULL -- always throw exception on error.
    TClassFactory* GetFactory
    (const string&       driver  = kEmptyStr,
     const CVersionInfo& version = NCBI_INTERFACE_VERSION(TClass));

    /// Information about a driver, with maybe a pointer to an instantiated
    /// class factory that contains the driver.
    /// @sa FNCBI_EntryPoint
    struct SDriverInfo {
        string         name;        ///< Driver name
        CVersionInfo   version;     ///< Driver version
        // It's the plugin manager's (and not SDriverInfo) responsibility to
        // keep and then destroy class factories.
        TClassFactory* factory;     ///< Class factory (can be NULL)

        SDriverInfo(const string&       driver_name,
                    const CVersionInfo& driver_version)
            : name(driver_name),
              version(driver_version),
              factory(0)
        {}
    };

    /// List of driver information.
    ///
    /// It is used to communicate using the entry points mechanism.
    /// @sa FNCBI_EntryPoint
    typedef list<SDriverInfo> TDriverInfoList;

    /// Register factory in the manager.
    ///  
    /// The registered factory will be owned by the manager.
    /// @sa UnregisterFactory()
    void RegisterFactory(TClassFactory& factory);

    /// Unregister and release (un-own)
    /// @sa RegisterFactory()
    bool UnregisterFactory(TClassFactory& factory);

    /// Actions performed by the entry point
    /// @sa FNCBI_EntryPoint
    enum EEntryPointRequest {
        /// Add info about all drivers exported through the entry point
        /// to the end of list.
        ///
        /// "SFactoryInfo::factory" in the added info should be assigned NULL.
        eGetFactoryInfo,

        /// Scan the driver info list passed to the entry point for the
        /// [name,version] pairs exported by the given entry point.
        ///
        /// For each pair found, if its "SDriverInfo::factory" is NULL,
        /// instantiate its class factory and assign it to the
        /// "SDriverInfo::factory".
        eInstantiateFactory
    };

    /// Entry point to get drivers' info, and (if requested) their class
    /// factori(es).
    ///
    /// This function is usually (but not necessarily) called by
    /// RegisterWithEntryPoint().
    ///
    /// Usually, it's called twice -- the first time to get the info
    /// about the drivers exported by the entry point, and then
    /// to instantiate selected factories.
    ///
    /// Caller is responsible for the proper destruction (deallocation)
    /// of the instantiated factories.
    typedef void (*FNCBI_EntryPoint)(TDriverInfoList&   info_list,
                                     EEntryPointRequest method);

    /// Register all factories exported by the plugin entry point.
    /// @sa RegisterFactory()
    void RegisterWithEntryPoint(FNCBI_EntryPoint plugin_entry_point);

    /// Attach DLL resolver to plugin manager 
    /// 
    /// Plugin mananger uses all attached resolvers to search for DLLs
    /// exporting drivers of this interface.
    ///
    /// @param resolver
    ///   DLL resolver. Plugin manager takes ownership of the resolver.
    void AddResolver(CPluginManager_DllResolver* resolver);

    /// Add path for the DLL lookup (for all resolvers)
    void AddDllSearchPath(const string& path);

    /// Scan DLLs for specified driver using attached resolvers
    void Resolve(const string&       driver  = kEmptyStr,
                 const CVersionInfo& version = NCBI_INTERFACE_VERSION(TClass));

    // ctors
    CPluginManager(void) {}
    virtual ~CPluginManager();

protected:
    TClassFactory* FindClassFactory(const string&  driver,
                                    const CVersionInfo& version);

    /// Protective mutex to syncronize the access to the plugin manager
    /// from different threads
    CFastMutex m_Mutex;

    typedef vector<CDllResolver::SResolvedEntry> TResolvedEntries;

private:
    /// List of factories presently registered with (and owned by)
    /// the plugin manager.
    set<TClassFactory*>                  m_Factories;
    /// DLL resolvers
    vector<CPluginManager_DllResolver*>  m_Resolvers;
    /// Paths used for DLL search
    vector<string>                       m_DllSearchPaths;
    /// DLL entries resolved and registered with dll resolver(s)
    TResolvedEntries                     m_RegisteredEntries;
};




/// Service class for DLLs resolution.
/// 
/// Class is used by CPluginManager to scan directories for DLLs, 
/// load and resolve entry points.
///
class NCBI_XNCBI_EXPORT CPluginManager_DllResolver
{
public:
    //
    CPluginManager_DllResolver(void);

    /// Construction
    ///
    /// @param interface_name
    ///   Target interface name
    /// @param plugin_name
    ///   Plugin family name (dbapi, xloader, etc)
    /// @param driver_name
    ///   Name of the driver (dblib, id1, etc)
    /// @param version
    ///   Interface version
    CPluginManager_DllResolver
    (const string&       interface_name,
     const string&       driver_name = kEmptyStr,
     const CVersionInfo& version     = CVersionInfo::kAny);

    //
    virtual ~CPluginManager_DllResolver(void);

    /// Search for plugin DLLs, resolve entry points.
    ///
    /// @param paths
    ///   List of directories to scan for DLLs
    /// @return
    ///   Reference on DLL resolver holding all entry points
    CDllResolver& Resolve(const vector<string>& paths);

    /// Search for plugin DLLs, resolve entry points.
    ///
    /// @param paths
    ///   Path to scan for DLLs
    /// @return
    ///   Reference on DLL resolver holding all entry points
    CDllResolver& Resolve(const string& path);

    /// Return dll file name. Name does not include path.
    ///
    /// Example:
    ///    "ncbi_plugin_dbapi_ftds_3_1_7".
    ///    "ncbi_pulgin_dbapi_ftds.so.3.1.7"
    /// In this case, the DLL will be searched for in the standard
    /// DLL search paths, with automatic addition of any platform-specific
    /// prefixes and suffixes.
    ///
    /// @param driver_name
    ///    Driver name ("id1", "lds", etc)
    /// @param version
    ///    Requested version of the driver
    virtual
    string GetDllName(const string&       interface_name,
                      const string&       driver_name  = kEmptyStr,
                      const CVersionInfo& version      = CVersionInfo::kAny)
        const;

    /// Return DLL name mask 
    ///
    /// DLL name mask is used for DLL file search.
    ///
    /// Example:
    ///    "ncbi_plugin_objmgr_*.dll"
    ///    "ncbi_plugin_dbapi_ftds.so.*"
    virtual
    string GetDllNameMask(const string&       interface_name,
                          const string&       driver_name = kEmptyStr,
                          const CVersionInfo& version     = CVersionInfo::kAny)
        const;

    /// Return DLL entry point name:
    ///
    /// Default name pattern is:
    ///  - "NCBI_EntryPoint_interface_driver"
    /// Alternative variants:
    ///  - "NCBI_EntryPoint"
    ///  - "NCBI_EntryPoint_interface"
    ///  - "NCBI_EntryPoint_driver"
    ///
    /// @sa GetEntryPointPrefix
    virtual
    string GetEntryPointName(const string& interface_name = kEmptyStr,
                             const string& driver_name    = kEmptyStr) const;


    /// Return DLL entry point prefix ("NCBI_EntryPoint")
    virtual string GetEntryPointPrefix() const;

    /// Return DLL file name prefix ("ncbi_plugin")
    virtual string GetDllNamePrefix() const;

    /// Set DLL file name prefix
    virtual void SetDllNamePrefix(const string& prefix);

    /// Return name of the driver
    const string& GetDriverName() const { return m_DriverName; }

protected:
    CDllResolver* GetCreateDllResolver();
    CDllResolver* CreateDllResolver() const;

protected:
    string          m_DllNamePrefix;
    string          m_EntryPointPrefix;
    string          m_InterfaceName;
    string          m_DriverName;
    CVersionInfo    m_Version;
    CDllResolver*   m_DllResolver;
};

/* @} */


/////////////////////////////////////////////////////////////////////////////
//  IMPLEMENTATION of INLINE functions
/////////////////////////////////////////////////////////////////////////////


template <class TClass>
typename CPluginManager<TClass>::TClassFactory* 
CPluginManager<TClass>::GetFactory(const string&       driver,
                                   const CVersionInfo& version)
{
    CFastMutexGuard guard(m_Mutex);

    TClassFactory* cf = 0;

    // Search among already registered factories
    cf = FindClassFactory(driver, version);
    if (cf) {
        return cf;
    }

    // Trying to resolve the driver's factory
    Resolve(driver, version);

    // Re-scanning factories...
    cf = FindClassFactory(driver, version);
    if (cf) {
        return cf;
    }

    NCBI_THROW(CPluginManagerException, eResolveFailure, 
               "Cannot resolve class factory");
}


template <class TClass>
typename CPluginManager<TClass>::TClassFactory* 
CPluginManager<TClass>::FindClassFactory(const string&  driver,
                                         const CVersionInfo& version)
{
    TClassFactory* best_factory = 0;
    int best_major = -1;
    int best_minor = -1;
    int best_patch_level = -1;

    NON_CONST_ITERATE(typename set<TClassFactory*>, it, m_Factories) {
        TClassFactory* cf = *it;

        typename IClassFactory<TClass>::TDriverList drv_list;

        if (!cf)
            continue;

        cf->GetDriverVersions(drv_list);

        NON_CONST_ITERATE(typename IClassFactory<TClass>::TDriverList, 
                          it2, 
                          drv_list) {
             typename IClassFactory<TClass>::SDriverInfo& drv_info = *it2;
             if (!driver.empty()) {
                if (driver != drv_info.name) {
                    continue;
                }
             }
             const CVersionInfo& vinfo = drv_info.version;
             if (IsBetterVersion(version, vinfo, 
                                 best_major, best_minor, best_patch_level))
             {
                best_factory = cf;
             }
        }
    }
    
    return best_factory;
}


template <class TClass>
void CPluginManager<TClass>::RegisterFactory(TClassFactory& factory)
{
    CFastMutexGuard guard(m_Mutex);

    m_Factories.insert(&factory);
}


template <class TClass>
bool CPluginManager<TClass>::UnregisterFactory(TClassFactory& factory)
{
    CFastMutexGuard guard(m_Mutex);

    typename set<TClassFactory*>::iterator it = m_Factories.find(&factory);
    if (it != m_Factories.end()) {
        delete *it;
        m_Factories.erase(it);
    }
}


template <class TClass>
void CPluginManager<TClass>::RegisterWithEntryPoint
(FNCBI_EntryPoint plugin_entry_point)
{
    TDriverInfoList drv_list;
    plugin_entry_point(drv_list, eGetFactoryInfo);

    if ( !drv_list.empty() ) {
        plugin_entry_point(drv_list, eInstantiateFactory);

        NON_CONST_ITERATE(typename TDriverInfoList, it, drv_list) {
            if (it->factory) {
                RegisterFactory(*(it->factory));
            }
        }
    }

}



template <class TClass>
void CPluginManager<TClass>::AddResolver(CPluginManager_DllResolver* resolver)
{
    _ASSERT(resolver);
    m_Resolvers.push_back(resolver);
}


template <class TClass>
void CPluginManager<TClass>::AddDllSearchPath(const string& path)
{
    m_DllSearchPaths.push_back(path);
}


template <class TClass>
void CPluginManager<TClass>::Resolve(const string&       /*driver*/,
                                     const CVersionInfo& /*version*/)
{
    vector<CDllResolver*> resolvers;

    // Run all resolvers to search for driver
    ITERATE(vector<CPluginManager_DllResolver*>, it, m_Resolvers) {
        CDllResolver& dll_resolver = (*it)->Resolve(m_DllSearchPaths);
        resolvers.push_back(&dll_resolver);
    }

    // Now choose the DLL entry point to register the class factory
    NON_CONST_ITERATE(vector<CDllResolver*>, it, resolvers) {
        CDllResolver::TEntries& entry_points = (*it)->GetResolvedEntries();

        NON_CONST_ITERATE(CDllResolver::TEntries, ite, entry_points) {
            CDllResolver::SResolvedEntry& entry = *ite;
            // TODO:
            // check if entry point provides the required interface-driver-version
            // and do not register otherwise...
            if (entry.entry_point) {
                FNCBI_EntryPoint ep;
                // What happens in the next couple of lines is basically:
                //  ep = (FNCBI_EntryPoint)entry.entry_point;
                // Some compilers(Workshop) rightfully consider 
                // (function*)() -> (void*) casts illegal.
                // But we know this unix style hack works on all our platforms.
                // (so this trick is well justified).
                union {
                    void*              void_ptr;
                    FNCBI_EntryPoint   func_ptr;
                } utmp;
                utmp.void_ptr = entry.entry_point;
                ep = utmp.func_ptr;
                
                RegisterWithEntryPoint(ep);
                m_RegisteredEntries.push_back(entry);
            }
        }
        entry_points.resize(0);
    }
}


template <class TClass>
CPluginManager<TClass>::~CPluginManager()
{
    {{
        typename set<TClassFactory*>::iterator it = m_Factories.begin();
        typename set<TClassFactory*>::iterator it_end = m_Factories.end();
        for (; it != it_end; ++it) {
            TClassFactory* f = *it;
            delete f;
        }

    }}

    {{
        typename vector<CPluginManager_DllResolver*>::iterator it =
            m_Resolvers.begin();
        typename vector<CPluginManager_DllResolver*>::iterator it_end = 
            m_Resolvers.end();
        for (; it != it_end; ++it) {
            CPluginManager_DllResolver* r = *it;
            delete r;
        }

    }}

    NON_CONST_ITERATE(TResolvedEntries, it, m_RegisteredEntries) {
        delete it->dll;
    }
}



END_NCBI_SCOPE



/*
 * ===========================================================================
 * $Log$
 * Revision 1.15  2003/11/19 13:48:20  kuznets
 * Helper classes migrated into a plugin_manager_impl.hpp
 *
 * Revision 1.14  2003/11/18 17:09:25  kuznets
 * Fixing compilation warnings
 *
 * Revision 1.13  2003/11/18 15:26:29  kuznets
 * Numerous fixes here and there as a result of testing and debugging.
 *
 * Revision 1.12  2003/11/17 17:04:11  kuznets
 * Cosmetic fixes
 *
 * Revision 1.11  2003/11/12 18:56:53  kuznets
 * Implemented dll resolution.
 *
 * Revision 1.10  2003/11/07 17:02:48  kuznets
 * Drafted CPluginManager_DllResolver.
 *
 * Revision 1.9  2003/11/03 20:08:01  kuznets
 * Fixing various compiler warnings
 *
 * Revision 1.8  2003/11/03 17:52:00  kuznets
 * Added CSimpleClassFactoryImpl template.
 * Helps quickly implement basic PM compatible class factory.
 *
 * Revision 1.7  2003/11/03 16:32:58  kuznets
 * Cleaning the code to be compatible with GCC, WorkShop 53 and MSVC at the
 * same time...
 *
 * Revision 1.6  2003/10/31 19:53:52  kuznets
 * +CHostEntryPointImpl
 *
 * Revision 1.5  2003/10/30 20:03:49  kuznets
 * Work in progress. Added implementations of CPluginManager<> methods.
 *
 * Revision 1.4  2003/10/29 23:35:46  vakatov
 * Just starting with CDllResolver...
 *
 * Revision 1.3  2003/10/29 19:34:43  vakatov
 * Comment out unfinished defined APIs (using "#if 0")
 *
 * Revision 1.2  2003/10/28 22:29:04  vakatov
 * Draft-done with:
 *   general terminology
 *   CInterfaceVersion<>
 *   NCBI_PLUGIN_VERSION()
 *   IClassFactory<>
 *   CPluginManager<>
 * TODO:
 *   Host-related API
 *   DLL resolution
 *
 * Revision 1.1  2003/10/28 00:12:23  vakatov
 * Initial revision
 *
 * Work-in-progress, totally unfinished.
 * Note: DLL resolution shall be split and partially moved to the NCBIDLL.
 *
 * ===========================================================================
 */

#endif  /* CORELIB___PLUGIN_MANAGER__HPP */
